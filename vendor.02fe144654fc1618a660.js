webpackJsonp([2],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	// Angular
	__webpack_require__(21);
	__webpack_require__(1);
	__webpack_require__(3);
	__webpack_require__(22);
	__webpack_require__(65);
	__webpack_require__(91);
	// RxJS
	__webpack_require__(701);
	// You can import js, ts, css, sass, ...
	__webpack_require__(973);
	// Other vendors for example jQuery, Lodash or Bootstrap
	__webpack_require__(68);
	__webpack_require__(67);
	__webpack_require__(146);
	__webpack_require__(205);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(2), __webpack_require__(3), __webpack_require__(21)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/compiler', '@angular/core', '@angular/platform-browser'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}),global.ng.compiler,global.ng.core,global.ng.platformBrowser));
	}(this, function (exports,_angular_compiler,_angular_core,_angular_platformBrowser) { 'use strict';

	    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = _angular_platformBrowser.__platform_browser_private__.INTERNAL_BROWSER_PLATFORM_PROVIDERS;

	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ResourceLoaderImpl = (function (_super) {
	        __extends(ResourceLoaderImpl, _super);
	        function ResourceLoaderImpl() {
	            _super.apply(this, arguments);
	        }
	        ResourceLoaderImpl.prototype.get = function (url) {
	            var resolve;
	            var reject;
	            var promise = new Promise(function (res, rej) {
	                resolve = res;
	                reject = rej;
	            });
	            var xhr = new XMLHttpRequest();
	            xhr.open('GET', url, true);
	            xhr.responseType = 'text';
	            xhr.onload = function () {
	                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                // response/responseType properties were introduced in ResourceLoader Level2 spec (supported
	                // by IE10)
	                var response = xhr.response || xhr.responseText;
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status = xhr.status === 1223 ? 204 : xhr.status;
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status === 0) {
	                    status = response ? 200 : 0;
	                }
	                if (200 <= status && status <= 300) {
	                    resolve(response);
	                }
	                else {
	                    reject("Failed to load " + url);
	                }
	            };
	            xhr.onerror = function () { reject("Failed to load " + url); };
	            xhr.send();
	            return promise;
	        };
	        ResourceLoaderImpl.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        ResourceLoaderImpl.ctorParameters = function () { return []; };
	        return ResourceLoaderImpl;
	    }(_angular_compiler.ResourceLoader));

	    var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [
	        INTERNAL_BROWSER_PLATFORM_PROVIDERS,
	        {
	            provide: _angular_core.COMPILER_OPTIONS,
	            useValue: { providers: [{ provide: _angular_compiler.ResourceLoader, useClass: ResourceLoaderImpl }] },
	            multi: true
	        },
	    ];

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = self;
	        }
	        else {
	            globalScope = global;
	        }
	    }
	    else {
	        globalScope = window;
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var _global = globalScope;
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    _global.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * An implementation of ResourceLoader that uses a template cache to avoid doing an actual
	     * ResourceLoader.
	     *
	     * The template cache needs to be built and loaded into window.$templateCache
	     * via a separate mechanism.
	     */
	    var CachedResourceLoader = (function (_super) {
	        __extends$1(CachedResourceLoader, _super);
	        function CachedResourceLoader() {
	            _super.call(this);
	            this._cache = _global.$templateCache;
	            if (this._cache == null) {
	                throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');
	            }
	        }
	        CachedResourceLoader.prototype.get = function (url) {
	            if (this._cache.hasOwnProperty(url)) {
	                return Promise.resolve(this._cache[url]);
	            }
	            else {
	                return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);
	            }
	        };
	        return CachedResourceLoader;
	    }(_angular_compiler.ResourceLoader));

	    var __platform_browser_dynamic_private__ = {
	        INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS,
	        ResourceLoaderImpl: ResourceLoaderImpl
	    };

	    /**
	     * @stable
	     */
	    var VERSION = new _angular_core.Version('2.4.10');

	    /**
	     * @experimental
	     */
	    var RESOURCE_CACHE_PROVIDER = [{ provide: _angular_compiler.ResourceLoader, useClass: CachedResourceLoader }];
	    /**
	     * @stable
	     */
	    var platformBrowserDynamic = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);

	    exports.RESOURCE_CACHE_PROVIDER = RESOURCE_CACHE_PROVIDER;
	    exports.platformBrowserDynamic = platformBrowserDynamic;
	    exports.VERSION = VERSION;
	    exports.__platform_browser_dynamic_private__ = __platform_browser_dynamic_private__;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}),global.ng.core));
	}(this, function (exports,_angular_core) { 'use strict';

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.10');

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * A segment of text within the template.
	     */
	    var TextAst = (function () {
	        /**
	         * @param {?} value
	         * @param {?} ngContentIndex
	         * @param {?} sourceSpan
	         */
	        function TextAst(value, ngContentIndex, sourceSpan) {
	            this.value = value;
	            this.ngContentIndex = ngContentIndex;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
	        return TextAst;
	    }());
	    /**
	     * A bound expression within the text of a template.
	     */
	    var BoundTextAst = (function () {
	        /**
	         * @param {?} value
	         * @param {?} ngContentIndex
	         * @param {?} sourceSpan
	         */
	        function BoundTextAst(value, ngContentIndex, sourceSpan) {
	            this.value = value;
	            this.ngContentIndex = ngContentIndex;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        BoundTextAst.prototype.visit = function (visitor, context) {
	            return visitor.visitBoundText(this, context);
	        };
	        return BoundTextAst;
	    }());
	    /**
	     * A plain attribute on an element.
	     */
	    var AttrAst = (function () {
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function AttrAst(name, value, sourceSpan) {
	            this.name = name;
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
	        return AttrAst;
	    }());
	    /**
	     * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
	     * `[\@trigger]="stateExp"`)
	     */
	    var BoundElementPropertyAst = (function () {
	        /**
	         * @param {?} name
	         * @param {?} type
	         * @param {?} securityContext
	         * @param {?} needsRuntimeSecurityContext
	         * @param {?} value
	         * @param {?} unit
	         * @param {?} sourceSpan
	         */
	        function BoundElementPropertyAst(name, type, securityContext, needsRuntimeSecurityContext, value, unit, sourceSpan) {
	            this.name = name;
	            this.type = type;
	            this.securityContext = securityContext;
	            this.needsRuntimeSecurityContext = needsRuntimeSecurityContext;
	            this.value = value;
	            this.unit = unit;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        BoundElementPropertyAst.prototype.visit = function (visitor, context) {
	            return visitor.visitElementProperty(this, context);
	        };
	        Object.defineProperty(BoundElementPropertyAst.prototype, "isAnimation", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.type === PropertyBindingType.Animation; },
	            enumerable: true,
	            configurable: true
	        });
	        return BoundElementPropertyAst;
	    }());
	    /**
	     * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
	     * `(\@trigger.phase)="callback($event)"`).
	     */
	    var BoundEventAst = (function () {
	        /**
	         * @param {?} name
	         * @param {?} target
	         * @param {?} phase
	         * @param {?} handler
	         * @param {?} sourceSpan
	         */
	        function BoundEventAst(name, target, phase, handler, sourceSpan) {
	            this.name = name;
	            this.target = target;
	            this.phase = phase;
	            this.handler = handler;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} name
	         * @param {?} target
	         * @param {?} phase
	         * @return {?}
	         */
	        BoundEventAst.calcFullName = function (name, target, phase) {
	            if (target) {
	                return target + ":" + name;
	            }
	            else if (phase) {
	                return "@" + name + "." + phase;
	            }
	            else {
	                return name;
	            }
	        };
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        BoundEventAst.prototype.visit = function (visitor, context) {
	            return visitor.visitEvent(this, context);
	        };
	        Object.defineProperty(BoundEventAst.prototype, "fullName", {
	            /**
	             * @return {?}
	             */
	            get: function () { return BoundEventAst.calcFullName(this.name, this.target, this.phase); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BoundEventAst.prototype, "isAnimation", {
	            /**
	             * @return {?}
	             */
	            get: function () { return !!this.phase; },
	            enumerable: true,
	            configurable: true
	        });
	        return BoundEventAst;
	    }());
	    /**
	     * A reference declaration on an element (e.g. `let someName="expression"`).
	     */
	    var ReferenceAst = (function () {
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function ReferenceAst(name, value, sourceSpan) {
	            this.name = name;
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ReferenceAst.prototype.visit = function (visitor, context) {
	            return visitor.visitReference(this, context);
	        };
	        return ReferenceAst;
	    }());
	    /**
	     * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
	     */
	    var VariableAst = (function () {
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function VariableAst(name, value, sourceSpan) {
	            this.name = name;
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        VariableAst.prototype.visit = function (visitor, context) {
	            return visitor.visitVariable(this, context);
	        };
	        return VariableAst;
	    }());
	    /**
	     * An element declaration in a template.
	     */
	    var ElementAst = (function () {
	        /**
	         * @param {?} name
	         * @param {?} attrs
	         * @param {?} inputs
	         * @param {?} outputs
	         * @param {?} references
	         * @param {?} directives
	         * @param {?} providers
	         * @param {?} hasViewContainer
	         * @param {?} children
	         * @param {?} ngContentIndex
	         * @param {?} sourceSpan
	         * @param {?} endSourceSpan
	         */
	        function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan, endSourceSpan) {
	            this.name = name;
	            this.attrs = attrs;
	            this.inputs = inputs;
	            this.outputs = outputs;
	            this.references = references;
	            this.directives = directives;
	            this.providers = providers;
	            this.hasViewContainer = hasViewContainer;
	            this.children = children;
	            this.ngContentIndex = ngContentIndex;
	            this.sourceSpan = sourceSpan;
	            this.endSourceSpan = endSourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ElementAst.prototype.visit = function (visitor, context) {
	            return visitor.visitElement(this, context);
	        };
	        return ElementAst;
	    }());
	    /**
	     * A `<template>` element included in an Angular template.
	     */
	    var EmbeddedTemplateAst = (function () {
	        /**
	         * @param {?} attrs
	         * @param {?} outputs
	         * @param {?} references
	         * @param {?} variables
	         * @param {?} directives
	         * @param {?} providers
	         * @param {?} hasViewContainer
	         * @param {?} children
	         * @param {?} ngContentIndex
	         * @param {?} sourceSpan
	         */
	        function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
	            this.attrs = attrs;
	            this.outputs = outputs;
	            this.references = references;
	            this.variables = variables;
	            this.directives = directives;
	            this.providers = providers;
	            this.hasViewContainer = hasViewContainer;
	            this.children = children;
	            this.ngContentIndex = ngContentIndex;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
	            return visitor.visitEmbeddedTemplate(this, context);
	        };
	        return EmbeddedTemplateAst;
	    }());
	    /**
	     * A directive property with a bound value (e.g. `*ngIf="condition").
	     */
	    var BoundDirectivePropertyAst = (function () {
	        /**
	         * @param {?} directiveName
	         * @param {?} templateName
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
	            this.directiveName = directiveName;
	            this.templateName = templateName;
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
	            return visitor.visitDirectiveProperty(this, context);
	        };
	        return BoundDirectivePropertyAst;
	    }());
	    /**
	     * A directive declared on an element.
	     */
	    var DirectiveAst = (function () {
	        /**
	         * @param {?} directive
	         * @param {?} inputs
	         * @param {?} hostProperties
	         * @param {?} hostEvents
	         * @param {?} sourceSpan
	         */
	        function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
	            this.directive = directive;
	            this.inputs = inputs;
	            this.hostProperties = hostProperties;
	            this.hostEvents = hostEvents;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        DirectiveAst.prototype.visit = function (visitor, context) {
	            return visitor.visitDirective(this, context);
	        };
	        return DirectiveAst;
	    }());
	    /**
	     * A provider declared on an element
	     */
	    var ProviderAst = (function () {
	        /**
	         * @param {?} token
	         * @param {?} multiProvider
	         * @param {?} eager
	         * @param {?} providers
	         * @param {?} providerType
	         * @param {?} lifecycleHooks
	         * @param {?} sourceSpan
	         */
	        function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {
	            this.token = token;
	            this.multiProvider = multiProvider;
	            this.eager = eager;
	            this.providers = providers;
	            this.providerType = providerType;
	            this.lifecycleHooks = lifecycleHooks;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ProviderAst.prototype.visit = function (visitor, context) {
	            // No visit method in the visitor for now...
	            return null;
	        };
	        return ProviderAst;
	    }());
	    var ProviderAstType = {};
	    ProviderAstType.PublicService = 0;
	    ProviderAstType.PrivateService = 1;
	    ProviderAstType.Component = 2;
	    ProviderAstType.Directive = 3;
	    ProviderAstType.Builtin = 4;
	    ProviderAstType[ProviderAstType.PublicService] = "PublicService";
	    ProviderAstType[ProviderAstType.PrivateService] = "PrivateService";
	    ProviderAstType[ProviderAstType.Component] = "Component";
	    ProviderAstType[ProviderAstType.Directive] = "Directive";
	    ProviderAstType[ProviderAstType.Builtin] = "Builtin";
	    /**
	     * Position where content is to be projected (instance of `<ng-content>` in a template).
	     */
	    var NgContentAst = (function () {
	        /**
	         * @param {?} index
	         * @param {?} ngContentIndex
	         * @param {?} sourceSpan
	         */
	        function NgContentAst(index, ngContentIndex, sourceSpan) {
	            this.index = index;
	            this.ngContentIndex = ngContentIndex;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        NgContentAst.prototype.visit = function (visitor, context) {
	            return visitor.visitNgContent(this, context);
	        };
	        return NgContentAst;
	    }());
	    var PropertyBindingType = {};
	    PropertyBindingType.Property = 0;
	    PropertyBindingType.Attribute = 1;
	    PropertyBindingType.Class = 2;
	    PropertyBindingType.Style = 3;
	    PropertyBindingType.Animation = 4;
	    PropertyBindingType[PropertyBindingType.Property] = "Property";
	    PropertyBindingType[PropertyBindingType.Attribute] = "Attribute";
	    PropertyBindingType[PropertyBindingType.Class] = "Class";
	    PropertyBindingType[PropertyBindingType.Style] = "Style";
	    PropertyBindingType[PropertyBindingType.Animation] = "Animation";
	    /**
	     * Visit every node in a list of {\@link TemplateAst}s with the given {\@link TemplateAstVisitor}.
	     * @param {?} visitor
	     * @param {?} asts
	     * @param {?=} context
	     * @return {?}
	     */
	    function templateVisitAll(visitor, asts, context) {
	        if (context === void 0) { context = null; }
	        var /** @type {?} */ result = [];
	        var /** @type {?} */ visit = visitor.visit ?
	            function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :
	            function (ast) { return ast.visit(visitor, context); };
	        asts.forEach(function (ast) {
	            var /** @type {?} */ astResult = visit(ast);
	            if (astResult) {
	                result.push(astResult);
	            }
	        });
	        return result;
	    }

	    /**
	     * A token representing the a reference to a static type.
	     *
	     * This token is unique for a filePath and name and can be used as a hash table key.
	     */
	    var StaticSymbol = (function () {
	        /**
	         * @param {?} filePath
	         * @param {?} name
	         * @param {?=} members
	         */
	        function StaticSymbol(filePath, name, members) {
	            this.filePath = filePath;
	            this.name = name;
	            this.members = members;
	        }
	        return StaticSymbol;
	    }());
	    /**
	     * A cache of static symbol used by the StaticReflector to return the same symbol for the
	     * same symbol values.
	     */
	    var StaticSymbolCache = (function () {
	        function StaticSymbolCache() {
	            this.cache = new Map();
	        }
	        /**
	         * @param {?} declarationFile
	         * @param {?} name
	         * @param {?=} members
	         * @return {?}
	         */
	        StaticSymbolCache.prototype.get = function (declarationFile, name, members) {
	            members = members || [];
	            var /** @type {?} */ memberSuffix = members.length ? "." + members.join('.') : '';
	            var /** @type {?} */ key = "\"" + declarationFile + "\"." + name + memberSuffix;
	            var /** @type {?} */ result = this.cache.get(key);
	            if (!result) {
	                result = new StaticSymbol(declarationFile, name, members);
	                this.cache.set(key, result);
	            }
	            return result;
	        };
	        return StaticSymbolCache;
	    }());

	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    var /** @type {?} */ STRING_MAP_PROTO = Object.getPrototypeOf({});
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isStrictStringMap(obj) {
	        return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    var NumberWrapper = (function () {
	        function NumberWrapper() {
	        }
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        NumberWrapper.parseIntAutoRadix = function (text) {
	            var /** @type {?} */ result = parseInt(text);
	            if (isNaN(result)) {
	                throw new Error('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	        return NumberWrapper;
	    }());
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }
	    /**
	     * @param {?} s
	     * @return {?}
	     */
	    function escapeRegExp(s) {
	        return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	    }

	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} condition
	         * @return {?}
	         */
	        ListWrapper.findLast = function (arr, condition) {
	            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
	                if (condition(arr[i])) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} list
	         * @param {?} items
	         * @return {?}
	         */
	        ListWrapper.removeAll = function (list, items) {
	            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
	                var /** @type {?} */ index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        /**
	         * @param {?} list
	         * @param {?} el
	         * @return {?}
	         */
	        ListWrapper.remove = function (list, el) {
	            var /** @type {?} */ index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} a
	         * @param {?} b
	         * @return {?}
	         */
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        /**
	         * @param {?} list
	         * @return {?}
	         */
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return ((flat)).concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());

	    var /** @type {?} */ isDefaultChangeDetectionStrategy = _angular_core.__core_private__.isDefaultChangeDetectionStrategy;
	    var /** @type {?} */ ChangeDetectorStatus = _angular_core.__core_private__.ChangeDetectorStatus;
	    var /** @type {?} */ LifecycleHooks = _angular_core.__core_private__.LifecycleHooks;
	    var /** @type {?} */ LIFECYCLE_HOOKS_VALUES = _angular_core.__core_private__.LIFECYCLE_HOOKS_VALUES;
	    var /** @type {?} */ ReflectorReader = _angular_core.__core_private__.ReflectorReader;
	    var /** @type {?} */ ViewContainer = _angular_core.__core_private__.ViewContainer;
	    var /** @type {?} */ CodegenComponentFactoryResolver = _angular_core.__core_private__.CodegenComponentFactoryResolver;
	    var /** @type {?} */ ComponentRef_ = _angular_core.__core_private__.ComponentRef_;
	    var /** @type {?} */ AppView = _angular_core.__core_private__.AppView;
	    var /** @type {?} */ DebugAppView = _angular_core.__core_private__.DebugAppView;
	    var /** @type {?} */ NgModuleInjector = _angular_core.__core_private__.NgModuleInjector;
	    var /** @type {?} */ registerModuleFactory = _angular_core.__core_private__.registerModuleFactory;
	    var /** @type {?} */ ViewType = _angular_core.__core_private__.ViewType;
	    var /** @type {?} */ view_utils = _angular_core.__core_private__.view_utils;
	    var /** @type {?} */ DebugContext = _angular_core.__core_private__.DebugContext;
	    var /** @type {?} */ StaticNodeDebugInfo = _angular_core.__core_private__.StaticNodeDebugInfo;
	    var /** @type {?} */ devModeEqual = _angular_core.__core_private__.devModeEqual;
	    var /** @type {?} */ UNINITIALIZED = _angular_core.__core_private__.UNINITIALIZED;
	    var /** @type {?} */ ValueUnwrapper = _angular_core.__core_private__.ValueUnwrapper;
	    var /** @type {?} */ TemplateRef_ = _angular_core.__core_private__.TemplateRef_;
	    var /** @type {?} */ Console = _angular_core.__core_private__.Console;
	    var /** @type {?} */ reflector = _angular_core.__core_private__.reflector;
	    var /** @type {?} */ Reflector = _angular_core.__core_private__.Reflector;
	    var /** @type {?} */ ReflectionCapabilities = _angular_core.__core_private__.ReflectionCapabilities;
	    var /** @type {?} */ NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;
	    var /** @type {?} */ AnimationSequencePlayer = _angular_core.__core_private__.AnimationSequencePlayer;
	    var /** @type {?} */ AnimationGroupPlayer = _angular_core.__core_private__.AnimationGroupPlayer;
	    var /** @type {?} */ AnimationKeyframe = _angular_core.__core_private__.AnimationKeyframe;
	    var /** @type {?} */ AnimationStyles = _angular_core.__core_private__.AnimationStyles;
	    var /** @type {?} */ ANY_STATE = _angular_core.__core_private__.ANY_STATE;
	    var /** @type {?} */ DEFAULT_STATE = _angular_core.__core_private__.DEFAULT_STATE;
	    var /** @type {?} */ EMPTY_STATE = _angular_core.__core_private__.EMPTY_STATE;
	    var /** @type {?} */ FILL_STYLE_FLAG = _angular_core.__core_private__.FILL_STYLE_FLAG;
	    var /** @type {?} */ prepareFinalAnimationStyles = _angular_core.__core_private__.prepareFinalAnimationStyles;
	    var /** @type {?} */ balanceAnimationKeyframes = _angular_core.__core_private__.balanceAnimationKeyframes;
	    var /** @type {?} */ clearStyles = _angular_core.__core_private__.clearStyles;
	    var /** @type {?} */ collectAndResolveStyles = _angular_core.__core_private__.collectAndResolveStyles;
	    var /** @type {?} */ renderStyles = _angular_core.__core_private__.renderStyles;
	    var /** @type {?} */ ComponentStillLoadingError = _angular_core.__core_private__.ComponentStillLoadingError;
	    var /** @type {?} */ AnimationTransition = _angular_core.__core_private__.AnimationTransition;

	    var TagContentType = {};
	    TagContentType.RAW_TEXT = 0;
	    TagContentType.ESCAPABLE_RAW_TEXT = 1;
	    TagContentType.PARSABLE_DATA = 2;
	    TagContentType[TagContentType.RAW_TEXT] = "RAW_TEXT";
	    TagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = "ESCAPABLE_RAW_TEXT";
	    TagContentType[TagContentType.PARSABLE_DATA] = "PARSABLE_DATA";
	    /**
	     * @param {?} elementName
	     * @return {?}
	     */
	    function splitNsName(elementName) {
	        if (elementName[0] != ':') {
	            return [null, elementName];
	        }
	        var /** @type {?} */ colonIndex = elementName.indexOf(':', 1);
	        if (colonIndex == -1) {
	            throw new Error("Unsupported format \"" + elementName + "\" expecting \":namespace:name\"");
	        }
	        return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
	    }
	    /**
	     * @param {?} fullName
	     * @return {?}
	     */
	    function getNsPrefix(fullName) {
	        return fullName === null ? null : splitNsName(fullName)[0];
	    }
	    /**
	     * @param {?} prefix
	     * @param {?} localName
	     * @return {?}
	     */
	    function mergeNsAndName(prefix, localName) {
	        return prefix ? ":" + prefix + ":" + localName : localName;
	    }
	    // see http://www.w3.org/TR/html51/syntax.html#named-character-references
	    // see https://html.spec.whatwg.org/multipage/entities.json
	    // This list is not exhaustive to keep the compiler footprint low.
	    // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.
	    var /** @type {?} */ NAMED_ENTITIES = {
	        'Aacute': '\u00C1',
	        'aacute': '\u00E1',
	        'Acirc': '\u00C2',
	        'acirc': '\u00E2',
	        'acute': '\u00B4',
	        'AElig': '\u00C6',
	        'aelig': '\u00E6',
	        'Agrave': '\u00C0',
	        'agrave': '\u00E0',
	        'alefsym': '\u2135',
	        'Alpha': '\u0391',
	        'alpha': '\u03B1',
	        'amp': '&',
	        'and': '\u2227',
	        'ang': '\u2220',
	        'apos': '\u0027',
	        'Aring': '\u00C5',
	        'aring': '\u00E5',
	        'asymp': '\u2248',
	        'Atilde': '\u00C3',
	        'atilde': '\u00E3',
	        'Auml': '\u00C4',
	        'auml': '\u00E4',
	        'bdquo': '\u201E',
	        'Beta': '\u0392',
	        'beta': '\u03B2',
	        'brvbar': '\u00A6',
	        'bull': '\u2022',
	        'cap': '\u2229',
	        'Ccedil': '\u00C7',
	        'ccedil': '\u00E7',
	        'cedil': '\u00B8',
	        'cent': '\u00A2',
	        'Chi': '\u03A7',
	        'chi': '\u03C7',
	        'circ': '\u02C6',
	        'clubs': '\u2663',
	        'cong': '\u2245',
	        'copy': '\u00A9',
	        'crarr': '\u21B5',
	        'cup': '\u222A',
	        'curren': '\u00A4',
	        'dagger': '\u2020',
	        'Dagger': '\u2021',
	        'darr': '\u2193',
	        'dArr': '\u21D3',
	        'deg': '\u00B0',
	        'Delta': '\u0394',
	        'delta': '\u03B4',
	        'diams': '\u2666',
	        'divide': '\u00F7',
	        'Eacute': '\u00C9',
	        'eacute': '\u00E9',
	        'Ecirc': '\u00CA',
	        'ecirc': '\u00EA',
	        'Egrave': '\u00C8',
	        'egrave': '\u00E8',
	        'empty': '\u2205',
	        'emsp': '\u2003',
	        'ensp': '\u2002',
	        'Epsilon': '\u0395',
	        'epsilon': '\u03B5',
	        'equiv': '\u2261',
	        'Eta': '\u0397',
	        'eta': '\u03B7',
	        'ETH': '\u00D0',
	        'eth': '\u00F0',
	        'Euml': '\u00CB',
	        'euml': '\u00EB',
	        'euro': '\u20AC',
	        'exist': '\u2203',
	        'fnof': '\u0192',
	        'forall': '\u2200',
	        'frac12': '\u00BD',
	        'frac14': '\u00BC',
	        'frac34': '\u00BE',
	        'frasl': '\u2044',
	        'Gamma': '\u0393',
	        'gamma': '\u03B3',
	        'ge': '\u2265',
	        'gt': '>',
	        'harr': '\u2194',
	        'hArr': '\u21D4',
	        'hearts': '\u2665',
	        'hellip': '\u2026',
	        'Iacute': '\u00CD',
	        'iacute': '\u00ED',
	        'Icirc': '\u00CE',
	        'icirc': '\u00EE',
	        'iexcl': '\u00A1',
	        'Igrave': '\u00CC',
	        'igrave': '\u00EC',
	        'image': '\u2111',
	        'infin': '\u221E',
	        'int': '\u222B',
	        'Iota': '\u0399',
	        'iota': '\u03B9',
	        'iquest': '\u00BF',
	        'isin': '\u2208',
	        'Iuml': '\u00CF',
	        'iuml': '\u00EF',
	        'Kappa': '\u039A',
	        'kappa': '\u03BA',
	        'Lambda': '\u039B',
	        'lambda': '\u03BB',
	        'lang': '\u27E8',
	        'laquo': '\u00AB',
	        'larr': '\u2190',
	        'lArr': '\u21D0',
	        'lceil': '\u2308',
	        'ldquo': '\u201C',
	        'le': '\u2264',
	        'lfloor': '\u230A',
	        'lowast': '\u2217',
	        'loz': '\u25CA',
	        'lrm': '\u200E',
	        'lsaquo': '\u2039',
	        'lsquo': '\u2018',
	        'lt': '<',
	        'macr': '\u00AF',
	        'mdash': '\u2014',
	        'micro': '\u00B5',
	        'middot': '\u00B7',
	        'minus': '\u2212',
	        'Mu': '\u039C',
	        'mu': '\u03BC',
	        'nabla': '\u2207',
	        'nbsp': '\u00A0',
	        'ndash': '\u2013',
	        'ne': '\u2260',
	        'ni': '\u220B',
	        'not': '\u00AC',
	        'notin': '\u2209',
	        'nsub': '\u2284',
	        'Ntilde': '\u00D1',
	        'ntilde': '\u00F1',
	        'Nu': '\u039D',
	        'nu': '\u03BD',
	        'Oacute': '\u00D3',
	        'oacute': '\u00F3',
	        'Ocirc': '\u00D4',
	        'ocirc': '\u00F4',
	        'OElig': '\u0152',
	        'oelig': '\u0153',
	        'Ograve': '\u00D2',
	        'ograve': '\u00F2',
	        'oline': '\u203E',
	        'Omega': '\u03A9',
	        'omega': '\u03C9',
	        'Omicron': '\u039F',
	        'omicron': '\u03BF',
	        'oplus': '\u2295',
	        'or': '\u2228',
	        'ordf': '\u00AA',
	        'ordm': '\u00BA',
	        'Oslash': '\u00D8',
	        'oslash': '\u00F8',
	        'Otilde': '\u00D5',
	        'otilde': '\u00F5',
	        'otimes': '\u2297',
	        'Ouml': '\u00D6',
	        'ouml': '\u00F6',
	        'para': '\u00B6',
	        'permil': '\u2030',
	        'perp': '\u22A5',
	        'Phi': '\u03A6',
	        'phi': '\u03C6',
	        'Pi': '\u03A0',
	        'pi': '\u03C0',
	        'piv': '\u03D6',
	        'plusmn': '\u00B1',
	        'pound': '\u00A3',
	        'prime': '\u2032',
	        'Prime': '\u2033',
	        'prod': '\u220F',
	        'prop': '\u221D',
	        'Psi': '\u03A8',
	        'psi': '\u03C8',
	        'quot': '\u0022',
	        'radic': '\u221A',
	        'rang': '\u27E9',
	        'raquo': '\u00BB',
	        'rarr': '\u2192',
	        'rArr': '\u21D2',
	        'rceil': '\u2309',
	        'rdquo': '\u201D',
	        'real': '\u211C',
	        'reg': '\u00AE',
	        'rfloor': '\u230B',
	        'Rho': '\u03A1',
	        'rho': '\u03C1',
	        'rlm': '\u200F',
	        'rsaquo': '\u203A',
	        'rsquo': '\u2019',
	        'sbquo': '\u201A',
	        'Scaron': '\u0160',
	        'scaron': '\u0161',
	        'sdot': '\u22C5',
	        'sect': '\u00A7',
	        'shy': '\u00AD',
	        'Sigma': '\u03A3',
	        'sigma': '\u03C3',
	        'sigmaf': '\u03C2',
	        'sim': '\u223C',
	        'spades': '\u2660',
	        'sub': '\u2282',
	        'sube': '\u2286',
	        'sum': '\u2211',
	        'sup': '\u2283',
	        'sup1': '\u00B9',
	        'sup2': '\u00B2',
	        'sup3': '\u00B3',
	        'supe': '\u2287',
	        'szlig': '\u00DF',
	        'Tau': '\u03A4',
	        'tau': '\u03C4',
	        'there4': '\u2234',
	        'Theta': '\u0398',
	        'theta': '\u03B8',
	        'thetasym': '\u03D1',
	        'thinsp': '\u2009',
	        'THORN': '\u00DE',
	        'thorn': '\u00FE',
	        'tilde': '\u02DC',
	        'times': '\u00D7',
	        'trade': '\u2122',
	        'Uacute': '\u00DA',
	        'uacute': '\u00FA',
	        'uarr': '\u2191',
	        'uArr': '\u21D1',
	        'Ucirc': '\u00DB',
	        'ucirc': '\u00FB',
	        'Ugrave': '\u00D9',
	        'ugrave': '\u00F9',
	        'uml': '\u00A8',
	        'upsih': '\u03D2',
	        'Upsilon': '\u03A5',
	        'upsilon': '\u03C5',
	        'Uuml': '\u00DC',
	        'uuml': '\u00FC',
	        'weierp': '\u2118',
	        'Xi': '\u039E',
	        'xi': '\u03BE',
	        'Yacute': '\u00DD',
	        'yacute': '\u00FD',
	        'yen': '\u00A5',
	        'yuml': '\u00FF',
	        'Yuml': '\u0178',
	        'Zeta': '\u0396',
	        'zeta': '\u03B6',
	        'zwj': '\u200D',
	        'zwnj': '\u200C',
	    };

	    var HtmlTagDefinition = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function HtmlTagDefinition(_a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;
	            this.closedByChildren = {};
	            this.closedByParent = false;
	            this.canSelfClose = false;
	            if (closedByChildren && closedByChildren.length > 0) {
	                closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });
	            }
	            this.isVoid = isVoid;
	            this.closedByParent = closedByParent || isVoid;
	            if (requiredParents && requiredParents.length > 0) {
	                this.requiredParents = {};
	                // The first parent is the list is automatically when none of the listed parents are present
	                this.parentToAdd = requiredParents[0];
	                requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });
	            }
	            this.implicitNamespacePrefix = implicitNamespacePrefix;
	            this.contentType = contentType;
	            this.ignoreFirstLf = ignoreFirstLf;
	        }
	        /**
	         * @param {?} currentParent
	         * @return {?}
	         */
	        HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {
	            if (!this.requiredParents) {
	                return false;
	            }
	            if (!currentParent) {
	                return true;
	            }
	            var /** @type {?} */ lcParent = currentParent.toLowerCase();
	            return this.requiredParents[lcParent] != true && lcParent != 'template';
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        HtmlTagDefinition.prototype.isClosedByChild = function (name) {
	            return this.isVoid || name.toLowerCase() in this.closedByChildren;
	        };
	        return HtmlTagDefinition;
	    }());
	    // see http://www.w3.org/TR/html51/syntax.html#optional-tags
	    // This implementation does not fully conform to the HTML5 spec.
	    var /** @type {?} */ TAG_DEFINITIONS = {
	        'base': new HtmlTagDefinition({ isVoid: true }),
	        'meta': new HtmlTagDefinition({ isVoid: true }),
	        'area': new HtmlTagDefinition({ isVoid: true }),
	        'embed': new HtmlTagDefinition({ isVoid: true }),
	        'link': new HtmlTagDefinition({ isVoid: true }),
	        'img': new HtmlTagDefinition({ isVoid: true }),
	        'input': new HtmlTagDefinition({ isVoid: true }),
	        'param': new HtmlTagDefinition({ isVoid: true }),
	        'hr': new HtmlTagDefinition({ isVoid: true }),
	        'br': new HtmlTagDefinition({ isVoid: true }),
	        'source': new HtmlTagDefinition({ isVoid: true }),
	        'track': new HtmlTagDefinition({ isVoid: true }),
	        'wbr': new HtmlTagDefinition({ isVoid: true }),
	        'p': new HtmlTagDefinition({
	            closedByChildren: [
	                'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',
	                'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',
	                'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'
	            ],
	            closedByParent: true
	        }),
	        'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
	        'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
	        'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
	        'tr': new HtmlTagDefinition({
	            closedByChildren: ['tr'],
	            requiredParents: ['tbody', 'tfoot', 'thead'],
	            closedByParent: true
	        }),
	        'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
	        'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
	        'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
	        'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
	        'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
	        'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
	        'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
	        'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
	        'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	        'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	        'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
	        'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	        'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
	        'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
	        'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
	        'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
	        'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
	        'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
	        'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),
	        'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
	    };
	    var /** @type {?} */ _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
	    /**
	     * @param {?} tagName
	     * @return {?}
	     */
	    function getHtmlTagDefinition(tagName) {
	        return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
	    }

	    var /** @type {?} */ _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' +
	        '([-\\w]+)|' +
	        '(?:\\.([-\\w]+))|' +
	        // "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
	        '(?:\\[([-.\\w*]+)(?:=([^\\]]*))?\\])|' +
	        '(\\))|' +
	        '(\\s*,\\s*)', // ","
	    'g');
	    /**
	     * A css selector contains an element name,
	     * css classes and attribute/value pairs with the purpose
	     * of selecting subsets out of them.
	     */
	    var CssSelector = (function () {
	        function CssSelector() {
	            this.element = null;
	            this.classNames = [];
	            this.attrs = [];
	            this.notSelectors = [];
	        }
	        /**
	         * @param {?} selector
	         * @return {?}
	         */
	        CssSelector.parse = function (selector) {
	            var /** @type {?} */ results = [];
	            var /** @type {?} */ _addResult = function (res, cssSel) {
	                if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
	                    cssSel.attrs.length == 0) {
	                    cssSel.element = '*';
	                }
	                res.push(cssSel);
	            };
	            var /** @type {?} */ cssSelector = new CssSelector();
	            var /** @type {?} */ match;
	            var /** @type {?} */ current = cssSelector;
	            var /** @type {?} */ inNot = false;
	            _SELECTOR_REGEXP.lastIndex = 0;
	            while (match = _SELECTOR_REGEXP.exec(selector)) {
	                if (match[1]) {
	                    if (inNot) {
	                        throw new Error('Nesting :not is not allowed in a selector');
	                    }
	                    inNot = true;
	                    current = new CssSelector();
	                    cssSelector.notSelectors.push(current);
	                }
	                if (match[2]) {
	                    current.setElement(match[2]);
	                }
	                if (match[3]) {
	                    current.addClassName(match[3]);
	                }
	                if (match[4]) {
	                    current.addAttribute(match[4], match[5]);
	                }
	                if (match[6]) {
	                    inNot = false;
	                    current = cssSelector;
	                }
	                if (match[7]) {
	                    if (inNot) {
	                        throw new Error('Multiple selectors in :not are not supported');
	                    }
	                    _addResult(results, cssSelector);
	                    cssSelector = current = new CssSelector();
	                }
	            }
	            _addResult(results, cssSelector);
	            return results;
	        };
	        /**
	         * @return {?}
	         */
	        CssSelector.prototype.isElementSelector = function () {
	            return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
	                this.notSelectors.length === 0;
	        };
	        /**
	         * @return {?}
	         */
	        CssSelector.prototype.hasElementSelector = function () { return !!this.element; };
	        /**
	         * @param {?=} element
	         * @return {?}
	         */
	        CssSelector.prototype.setElement = function (element) {
	            if (element === void 0) { element = null; }
	            this.element = element;
	        };
	        /**
	         * Gets a template string for an element that matches the selector.
	         * @return {?}
	         */
	        CssSelector.prototype.getMatchingElementTemplate = function () {
	            var /** @type {?} */ tagName = this.element || 'div';
	            var /** @type {?} */ classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
	            var /** @type {?} */ attrs = '';
	            for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {
	                var /** @type {?} */ attrName = this.attrs[i];
	                var /** @type {?} */ attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
	                attrs += " " + attrName + attrValue;
	            }
	            return getHtmlTagDefinition(tagName).isVoid ? "<" + tagName + classAttr + attrs + "/>" :
	                "<" + tagName + classAttr + attrs + "></" + tagName + ">";
	        };
	        /**
	         * @param {?} name
	         * @param {?=} value
	         * @return {?}
	         */
	        CssSelector.prototype.addAttribute = function (name, value) {
	            if (value === void 0) { value = ''; }
	            this.attrs.push(name, value && value.toLowerCase() || '');
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
	        /**
	         * @return {?}
	         */
	        CssSelector.prototype.toString = function () {
	            var /** @type {?} */ res = this.element || '';
	            if (this.classNames) {
	                this.classNames.forEach(function (klass) { return res += "." + klass; });
	            }
	            if (this.attrs) {
	                for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {
	                    var /** @type {?} */ name_1 = this.attrs[i];
	                    var /** @type {?} */ value = this.attrs[i + 1];
	                    res += "[" + name_1 + (value ? '=' + value : '') + "]";
	                }
	            }
	            this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
	            return res;
	        };
	        return CssSelector;
	    }());
	    /**
	     * Reads a list of CssSelectors and allows to calculate which ones
	     * are contained in a given CssSelector.
	     */
	    var SelectorMatcher = (function () {
	        function SelectorMatcher() {
	            this._elementMap = new Map();
	            this._elementPartialMap = new Map();
	            this._classMap = new Map();
	            this._classPartialMap = new Map();
	            this._attrValueMap = new Map();
	            this._attrValuePartialMap = new Map();
	            this._listContexts = [];
	        }
	        /**
	         * @param {?} notSelectors
	         * @return {?}
	         */
	        SelectorMatcher.createNotMatcher = function (notSelectors) {
	            var /** @type {?} */ notMatcher = new SelectorMatcher();
	            notMatcher.addSelectables(notSelectors, null);
	            return notMatcher;
	        };
	        /**
	         * @param {?} cssSelectors
	         * @param {?=} callbackCtxt
	         * @return {?}
	         */
	        SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
	            var /** @type {?} */ listContext = null;
	            if (cssSelectors.length > 1) {
	                listContext = new SelectorListContext(cssSelectors);
	                this._listContexts.push(listContext);
	            }
	            for (var /** @type {?} */ i = 0; i < cssSelectors.length; i++) {
	                this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
	            }
	        };
	        /**
	         * Add an object that can be found later on by calling `match`.
	         * @param {?} cssSelector A css selector
	         * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function
	         * @param {?} listContext
	         * @return {?}
	         */
	        SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
	            var /** @type {?} */ matcher = this;
	            var /** @type {?} */ element = cssSelector.element;
	            var /** @type {?} */ classNames = cssSelector.classNames;
	            var /** @type {?} */ attrs = cssSelector.attrs;
	            var /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
	            if (element) {
	                var /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;
	                if (isTerminal) {
	                    this._addTerminal(matcher._elementMap, element, selectable);
	                }
	                else {
	                    matcher = this._addPartial(matcher._elementPartialMap, element);
	                }
	            }
	            if (classNames) {
	                for (var /** @type {?} */ i = 0; i < classNames.length; i++) {
	                    var /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;
	                    var /** @type {?} */ className = classNames[i];
	                    if (isTerminal) {
	                        this._addTerminal(matcher._classMap, className, selectable);
	                    }
	                    else {
	                        matcher = this._addPartial(matcher._classPartialMap, className);
	                    }
	                }
	            }
	            if (attrs) {
	                for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
	                    var /** @type {?} */ isTerminal = i === attrs.length - 2;
	                    var /** @type {?} */ name_2 = attrs[i];
	                    var /** @type {?} */ value = attrs[i + 1];
	                    if (isTerminal) {
	                        var /** @type {?} */ terminalMap = matcher._attrValueMap;
	                        var /** @type {?} */ terminalValuesMap = terminalMap.get(name_2);
	                        if (!terminalValuesMap) {
	                            terminalValuesMap = new Map();
	                            terminalMap.set(name_2, terminalValuesMap);
	                        }
	                        this._addTerminal(terminalValuesMap, value, selectable);
	                    }
	                    else {
	                        var /** @type {?} */ partialMap = matcher._attrValuePartialMap;
	                        var /** @type {?} */ partialValuesMap = partialMap.get(name_2);
	                        if (!partialValuesMap) {
	                            partialValuesMap = new Map();
	                            partialMap.set(name_2, partialValuesMap);
	                        }
	                        matcher = this._addPartial(partialValuesMap, value);
	                    }
	                }
	            }
	        };
	        /**
	         * @param {?} map
	         * @param {?} name
	         * @param {?} selectable
	         * @return {?}
	         */
	        SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
	            var /** @type {?} */ terminalList = map.get(name);
	            if (!terminalList) {
	                terminalList = [];
	                map.set(name, terminalList);
	            }
	            terminalList.push(selectable);
	        };
	        /**
	         * @param {?} map
	         * @param {?} name
	         * @return {?}
	         */
	        SelectorMatcher.prototype._addPartial = function (map, name) {
	            var /** @type {?} */ matcher = map.get(name);
	            if (!matcher) {
	                matcher = new SelectorMatcher();
	                map.set(name, matcher);
	            }
	            return matcher;
	        };
	        /**
	         * Find the objects that have been added via `addSelectable`
	         * whose css selector is contained in the given css selector.
	         * @param {?} cssSelector A css selector
	         * @param {?} matchedCallback This callback will be called with the object handed into `addSelectable`
	         * @return {?} boolean true if a match was found
	         */
	        SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
	            var /** @type {?} */ result = false;
	            var /** @type {?} */ element = cssSelector.element;
	            var /** @type {?} */ classNames = cssSelector.classNames;
	            var /** @type {?} */ attrs = cssSelector.attrs;
	            for (var /** @type {?} */ i = 0; i < this._listContexts.length; i++) {
	                this._listContexts[i].alreadyMatched = false;
	            }
	            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
	            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
	                result;
	            if (classNames) {
	                for (var /** @type {?} */ i = 0; i < classNames.length; i++) {
	                    var /** @type {?} */ className = classNames[i];
	                    result =
	                        this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
	                    result =
	                        this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
	                            result;
	                }
	            }
	            if (attrs) {
	                for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
	                    var /** @type {?} */ name_3 = attrs[i];
	                    var /** @type {?} */ value = attrs[i + 1];
	                    var /** @type {?} */ terminalValuesMap = this._attrValueMap.get(name_3);
	                    if (value) {
	                        result =
	                            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
	                    }
	                    result =
	                        this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
	                    var /** @type {?} */ partialValuesMap = this._attrValuePartialMap.get(name_3);
	                    if (value) {
	                        result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
	                    }
	                    result =
	                        this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
	                }
	            }
	            return result;
	        };
	        /**
	         * \@internal
	         * @param {?} map
	         * @param {?} name
	         * @param {?} cssSelector
	         * @param {?} matchedCallback
	         * @return {?}
	         */
	        SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
	            if (!map || typeof name !== 'string') {
	                return false;
	            }
	            var /** @type {?} */ selectables = map.get(name) || [];
	            var /** @type {?} */ starSelectables = map.get('*');
	            if (starSelectables) {
	                selectables = selectables.concat(starSelectables);
	            }
	            if (selectables.length === 0) {
	                return false;
	            }
	            var /** @type {?} */ selectable;
	            var /** @type {?} */ result = false;
	            for (var /** @type {?} */ i = 0; i < selectables.length; i++) {
	                selectable = selectables[i];
	                result = selectable.finalize(cssSelector, matchedCallback) || result;
	            }
	            return result;
	        };
	        /**
	         * \@internal
	         * @param {?} map
	         * @param {?} name
	         * @param {?} cssSelector
	         * @param {?} matchedCallback
	         * @return {?}
	         */
	        SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {
	            if (!map || typeof name !== 'string') {
	                return false;
	            }
	            var /** @type {?} */ nestedSelector = map.get(name);
	            if (!nestedSelector) {
	                return false;
	            }
	            // TODO(perf): get rid of recursion and measure again
	            // TODO(perf): don't pass the whole selector into the recursion,
	            // but only the not processed parts
	            return nestedSelector.match(cssSelector, matchedCallback);
	        };
	        return SelectorMatcher;
	    }());
	    var SelectorListContext = (function () {
	        /**
	         * @param {?} selectors
	         */
	        function SelectorListContext(selectors) {
	            this.selectors = selectors;
	            this.alreadyMatched = false;
	        }
	        return SelectorListContext;
	    }());
	    var SelectorContext = (function () {
	        /**
	         * @param {?} selector
	         * @param {?} cbContext
	         * @param {?} listContext
	         */
	        function SelectorContext(selector, cbContext, listContext) {
	            this.selector = selector;
	            this.cbContext = cbContext;
	            this.listContext = listContext;
	            this.notSelectors = selector.notSelectors;
	        }
	        /**
	         * @param {?} cssSelector
	         * @param {?} callback
	         * @return {?}
	         */
	        SelectorContext.prototype.finalize = function (cssSelector, callback) {
	            var /** @type {?} */ result = true;
	            if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
	                var /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
	                result = !notMatcher.match(cssSelector, null);
	            }
	            if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
	                if (this.listContext) {
	                    this.listContext.alreadyMatched = true;
	                }
	                callback(this.selector, this.cbContext);
	            }
	            return result;
	        };
	        return SelectorContext;
	    }());

	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     */
	    var BaseError = (function (_super) {
	        __extends$3(BaseError, _super);
	        /**
	         * @param {?} message
	         */
	        function BaseError(message) {
	            _super.call(this, message);
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            // TODO(bradfordcsmith): Remove this hack when
	            //     google/closure-compiler/issues/2102 is fixed.
	            var nativeError = new Error(message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.message; },
	            /**
	             * @param {?} message
	             * @return {?}
	             */
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () { return ((this._nativeError)).stack; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { ((this._nativeError)).stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * \@stable
	     */
	    var WrappedError = (function (_super) {
	        __extends$3(WrappedError, _super);
	        /**
	         * @param {?} message
	         * @param {?} error
	         */
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (((this.originalError instanceof Error ? this.originalError : this._nativeError)))
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ MODULE_SUFFIX = '';
	    var /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function dashCaseToCamelCase(input) {
	        return input.replace(DASH_CASE_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            return m[1].toUpperCase();
	        });
	    }
	    /**
	     * @param {?} input
	     * @param {?} defaultValues
	     * @return {?}
	     */
	    function splitAtColon(input, defaultValues) {
	        return _splitAt(input, ':', defaultValues);
	    }
	    /**
	     * @param {?} input
	     * @param {?} defaultValues
	     * @return {?}
	     */
	    function splitAtPeriod(input, defaultValues) {
	        return _splitAt(input, '.', defaultValues);
	    }
	    /**
	     * @param {?} input
	     * @param {?} character
	     * @param {?} defaultValues
	     * @return {?}
	     */
	    function _splitAt(input, character, defaultValues) {
	        var /** @type {?} */ characterIndex = input.indexOf(character);
	        if (characterIndex == -1)
	            return defaultValues;
	        return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
	    }
	    /**
	     * @param {?} value
	     * @param {?} visitor
	     * @param {?} context
	     * @return {?}
	     */
	    function visitValue(value, visitor, context) {
	        if (Array.isArray(value)) {
	            return visitor.visitArray(/** @type {?} */ (value), context);
	        }
	        if (isStrictStringMap(value)) {
	            return visitor.visitStringMap(/** @type {?} */ (value), context);
	        }
	        if (value == null || isPrimitive(value)) {
	            return visitor.visitPrimitive(value, context);
	        }
	        return visitor.visitOther(value, context);
	    }
	    var ValueTransformer = (function () {
	        function ValueTransformer() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} context
	         * @return {?}
	         */
	        ValueTransformer.prototype.visitArray = function (arr, context) {
	            var _this = this;
	            return arr.map(function (value) { return visitValue(value, _this, context); });
	        };
	        /**
	         * @param {?} map
	         * @param {?} context
	         * @return {?}
	         */
	        ValueTransformer.prototype.visitStringMap = function (map, context) {
	            var _this = this;
	            var /** @type {?} */ result = {};
	            Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });
	            return result;
	        };
	        /**
	         * @param {?} value
	         * @param {?} context
	         * @return {?}
	         */
	        ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };
	        /**
	         * @param {?} value
	         * @param {?} context
	         * @return {?}
	         */
	        ValueTransformer.prototype.visitOther = function (value, context) { return value; };
	        return ValueTransformer;
	    }());
	    var SyncAsyncResult = (function () {
	        /**
	         * @param {?} syncResult
	         * @param {?=} asyncResult
	         */
	        function SyncAsyncResult(syncResult, asyncResult) {
	            if (asyncResult === void 0) { asyncResult = null; }
	            this.syncResult = syncResult;
	            this.asyncResult = asyncResult;
	            if (!asyncResult) {
	                this.asyncResult = Promise.resolve(syncResult);
	            }
	        }
	        return SyncAsyncResult;
	    }());
	    var SyntaxError = (function (_super) {
	        __extends$2(SyntaxError, _super);
	        function SyntaxError() {
	            _super.apply(this, arguments);
	        }
	        return SyntaxError;
	    }(BaseError));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    // group 0: "[prop] or (event) or @trigger"
	    // group 1: "prop" from "[prop]"
	    // group 2: "event" from "(event)"
	    // group 3: "@trigger" from "@trigger"
	    var /** @type {?} */ HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
	    var CompileAnimationEntryMetadata = (function () {
	        /**
	         * @param {?=} name
	         * @param {?=} definitions
	         */
	        function CompileAnimationEntryMetadata(name, definitions) {
	            if (name === void 0) { name = null; }
	            if (definitions === void 0) { definitions = null; }
	            this.name = name;
	            this.definitions = definitions;
	        }
	        return CompileAnimationEntryMetadata;
	    }());
	    /**
	     * @abstract
	     */
	    var CompileAnimationStateMetadata = (function () {
	        function CompileAnimationStateMetadata() {
	        }
	        return CompileAnimationStateMetadata;
	    }());
	    var CompileAnimationStateDeclarationMetadata = (function (_super) {
	        __extends$1(CompileAnimationStateDeclarationMetadata, _super);
	        /**
	         * @param {?} stateNameExpr
	         * @param {?} styles
	         */
	        function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
	            _super.call(this);
	            this.stateNameExpr = stateNameExpr;
	            this.styles = styles;
	        }
	        return CompileAnimationStateDeclarationMetadata;
	    }(CompileAnimationStateMetadata));
	    var CompileAnimationStateTransitionMetadata = (function (_super) {
	        __extends$1(CompileAnimationStateTransitionMetadata, _super);
	        /**
	         * @param {?} stateChangeExpr
	         * @param {?} steps
	         */
	        function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
	            _super.call(this);
	            this.stateChangeExpr = stateChangeExpr;
	            this.steps = steps;
	        }
	        return CompileAnimationStateTransitionMetadata;
	    }(CompileAnimationStateMetadata));
	    /**
	     * @abstract
	     */
	    var CompileAnimationMetadata = (function () {
	        function CompileAnimationMetadata() {
	        }
	        return CompileAnimationMetadata;
	    }());
	    var CompileAnimationKeyframesSequenceMetadata = (function (_super) {
	        __extends$1(CompileAnimationKeyframesSequenceMetadata, _super);
	        /**
	         * @param {?=} steps
	         */
	        function CompileAnimationKeyframesSequenceMetadata(steps) {
	            if (steps === void 0) { steps = []; }
	            _super.call(this);
	            this.steps = steps;
	        }
	        return CompileAnimationKeyframesSequenceMetadata;
	    }(CompileAnimationMetadata));
	    var CompileAnimationStyleMetadata = (function (_super) {
	        __extends$1(CompileAnimationStyleMetadata, _super);
	        /**
	         * @param {?} offset
	         * @param {?=} styles
	         */
	        function CompileAnimationStyleMetadata(offset, styles) {
	            if (styles === void 0) { styles = null; }
	            _super.call(this);
	            this.offset = offset;
	            this.styles = styles;
	        }
	        return CompileAnimationStyleMetadata;
	    }(CompileAnimationMetadata));
	    var CompileAnimationAnimateMetadata = (function (_super) {
	        __extends$1(CompileAnimationAnimateMetadata, _super);
	        /**
	         * @param {?=} timings
	         * @param {?=} styles
	         */
	        function CompileAnimationAnimateMetadata(timings, styles) {
	            if (timings === void 0) { timings = 0; }
	            if (styles === void 0) { styles = null; }
	            _super.call(this);
	            this.timings = timings;
	            this.styles = styles;
	        }
	        return CompileAnimationAnimateMetadata;
	    }(CompileAnimationMetadata));
	    /**
	     * @abstract
	     */
	    var CompileAnimationWithStepsMetadata = (function (_super) {
	        __extends$1(CompileAnimationWithStepsMetadata, _super);
	        /**
	         * @param {?=} steps
	         */
	        function CompileAnimationWithStepsMetadata(steps) {
	            if (steps === void 0) { steps = null; }
	            _super.call(this);
	            this.steps = steps;
	        }
	        return CompileAnimationWithStepsMetadata;
	    }(CompileAnimationMetadata));
	    var CompileAnimationSequenceMetadata = (function (_super) {
	        __extends$1(CompileAnimationSequenceMetadata, _super);
	        /**
	         * @param {?=} steps
	         */
	        function CompileAnimationSequenceMetadata(steps) {
	            if (steps === void 0) { steps = null; }
	            _super.call(this, steps);
	        }
	        return CompileAnimationSequenceMetadata;
	    }(CompileAnimationWithStepsMetadata));
	    var CompileAnimationGroupMetadata = (function (_super) {
	        __extends$1(CompileAnimationGroupMetadata, _super);
	        /**
	         * @param {?=} steps
	         */
	        function CompileAnimationGroupMetadata(steps) {
	            if (steps === void 0) { steps = null; }
	            _super.call(this, steps);
	        }
	        return CompileAnimationGroupMetadata;
	    }(CompileAnimationWithStepsMetadata));
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function _sanitizeIdentifier(name) {
	        return name.replace(/\W/g, '_');
	    }
	    var /** @type {?} */ _anonymousTypeIndex = 0;
	    /**
	     * @param {?} compileIdentifier
	     * @return {?}
	     */
	    function identifierName(compileIdentifier) {
	        if (!compileIdentifier || !compileIdentifier.reference) {
	            return null;
	        }
	        var /** @type {?} */ ref = compileIdentifier.reference;
	        if (ref instanceof StaticSymbol) {
	            return ref.name;
	        }
	        if (ref['__anonymousType']) {
	            return ref['__anonymousType'];
	        }
	        var /** @type {?} */ identifier = stringify(ref);
	        if (identifier.indexOf('(') >= 0) {
	            // case: anonymous functions!
	            identifier = "anonymous_" + _anonymousTypeIndex++;
	            ref['__anonymousType'] = identifier;
	        }
	        else {
	            identifier = _sanitizeIdentifier(identifier);
	        }
	        return identifier;
	    }
	    /**
	     * @param {?} compileIdentifier
	     * @return {?}
	     */
	    function identifierModuleUrl(compileIdentifier) {
	        var /** @type {?} */ ref = compileIdentifier.reference;
	        if (ref instanceof StaticSymbol) {
	            return ref.filePath;
	        }
	        return reflector.importUri(ref);
	    }
	    var CompileSummaryKind = {};
	    CompileSummaryKind.Pipe = 0;
	    CompileSummaryKind.Directive = 1;
	    CompileSummaryKind.NgModule = 2;
	    CompileSummaryKind.Injectable = 3;
	    CompileSummaryKind[CompileSummaryKind.Pipe] = "Pipe";
	    CompileSummaryKind[CompileSummaryKind.Directive] = "Directive";
	    CompileSummaryKind[CompileSummaryKind.NgModule] = "NgModule";
	    CompileSummaryKind[CompileSummaryKind.Injectable] = "Injectable";
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function tokenName(token) {
	        return isPresent(token.value) ? _sanitizeIdentifier(token.value) :
	            identifierName(token.identifier);
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function tokenReference(token) {
	        if (isPresent(token.identifier)) {
	            return token.identifier.reference;
	        }
	        else {
	            return token.value;
	        }
	    }
	    /**
	     * Metadata about a stylesheet
	     */
	    var CompileStylesheetMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function CompileStylesheetMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;
	            this.moduleUrl = moduleUrl;
	            this.styles = _normalizeArray(styles);
	            this.styleUrls = _normalizeArray(styleUrls);
	        }
	        return CompileStylesheetMetadata;
	    }());
	    /**
	     * Metadata regarding compilation of a template.
	     */
	    var CompileTemplateMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function CompileTemplateMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation;
	            this.encapsulation = encapsulation;
	            this.template = template;
	            this.templateUrl = templateUrl;
	            this.styles = _normalizeArray(styles);
	            this.styleUrls = _normalizeArray(styleUrls);
	            this.externalStylesheets = _normalizeArray(externalStylesheets);
	            this.animations = animations ? ListWrapper.flatten(animations) : [];
	            this.ngContentSelectors = ngContentSelectors || [];
	            if (interpolation && interpolation.length != 2) {
	                throw new Error("'interpolation' should have a start and an end symbol.");
	            }
	            this.interpolation = interpolation;
	        }
	        /**
	         * @return {?}
	         */
	        CompileTemplateMetadata.prototype.toSummary = function () {
	            return {
	                animations: this.animations.map(function (anim) { return anim.name; }),
	                ngContentSelectors: this.ngContentSelectors,
	                encapsulation: this.encapsulation
	            };
	        };
	        return CompileTemplateMetadata;
	    }());
	    /**
	     * Metadata regarding compilation of a directive.
	     */
	    var CompileDirectiveMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function CompileDirectiveMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, isHost = _b.isHost, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
	            this.isHost = !!isHost;
	            this.type = type;
	            this.isComponent = isComponent;
	            this.selector = selector;
	            this.exportAs = exportAs;
	            this.changeDetection = changeDetection;
	            this.inputs = inputs;
	            this.outputs = outputs;
	            this.hostListeners = hostListeners;
	            this.hostProperties = hostProperties;
	            this.hostAttributes = hostAttributes;
	            this.providers = _normalizeArray(providers);
	            this.viewProviders = _normalizeArray(viewProviders);
	            this.queries = _normalizeArray(queries);
	            this.viewQueries = _normalizeArray(viewQueries);
	            this.entryComponents = _normalizeArray(entryComponents);
	            this.template = template;
	        }
	        /**
	         * @param {?=} __0
	         * @return {?}
	         */
	        CompileDirectiveMetadata.create = function (_a) {
	            var _b = _a === void 0 ? {} : _a, isHost = _b.isHost, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
	            var /** @type {?} */ hostListeners = {};
	            var /** @type {?} */ hostProperties = {};
	            var /** @type {?} */ hostAttributes = {};
	            if (isPresent(host)) {
	                Object.keys(host).forEach(function (key) {
	                    var /** @type {?} */ value = host[key];
	                    var /** @type {?} */ matches = key.match(HOST_REG_EXP);
	                    if (matches === null) {
	                        hostAttributes[key] = value;
	                    }
	                    else if (isPresent(matches[1])) {
	                        hostProperties[matches[1]] = value;
	                    }
	                    else if (isPresent(matches[2])) {
	                        hostListeners[matches[2]] = value;
	                    }
	                });
	            }
	            var /** @type {?} */ inputsMap = {};
	            if (isPresent(inputs)) {
	                inputs.forEach(function (bindConfig) {
	                    // canonical syntax: `dirProp: elProp`
	                    // if there is no `:`, use dirProp = elProp
	                    var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
	                    inputsMap[parts[0]] = parts[1];
	                });
	            }
	            var /** @type {?} */ outputsMap = {};
	            if (isPresent(outputs)) {
	                outputs.forEach(function (bindConfig) {
	                    // canonical syntax: `dirProp: elProp`
	                    // if there is no `:`, use dirProp = elProp
	                    var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
	                    outputsMap[parts[0]] = parts[1];
	                });
	            }
	            return new CompileDirectiveMetadata({
	                isHost: isHost,
	                type: type,
	                isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,
	                inputs: inputsMap,
	                outputs: outputsMap,
	                hostListeners: hostListeners,
	                hostProperties: hostProperties,
	                hostAttributes: hostAttributes,
	                providers: providers,
	                viewProviders: viewProviders,
	                queries: queries,
	                viewQueries: viewQueries,
	                entryComponents: entryComponents,
	                template: template,
	            });
	        };
	        /**
	         * @return {?}
	         */
	        CompileDirectiveMetadata.prototype.toSummary = function () {
	            return {
	                summaryKind: CompileSummaryKind.Directive,
	                type: this.type,
	                isComponent: this.isComponent,
	                selector: this.selector,
	                exportAs: this.exportAs,
	                inputs: this.inputs,
	                outputs: this.outputs,
	                hostListeners: this.hostListeners,
	                hostProperties: this.hostProperties,
	                hostAttributes: this.hostAttributes,
	                providers: this.providers,
	                viewProviders: this.viewProviders,
	                queries: this.queries,
	                entryComponents: this.entryComponents,
	                changeDetection: this.changeDetection,
	                template: this.template && this.template.toSummary()
	            };
	        };
	        return CompileDirectiveMetadata;
	    }());
	    /**
	     * Construct {\@link CompileDirectiveMetadata} from {\@link ComponentTypeMetadata} and a selector.
	     * @param {?} typeReference
	     * @param {?} compMeta
	     * @return {?}
	     */
	    function createHostComponentMeta(typeReference, compMeta) {
	        var /** @type {?} */ template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
	        return CompileDirectiveMetadata.create({
	            isHost: true,
	            type: { reference: typeReference, diDeps: [], lifecycleHooks: [] },
	            template: new CompileTemplateMetadata({
	                encapsulation: _angular_core.ViewEncapsulation.None,
	                template: template,
	                templateUrl: '',
	                styles: [],
	                styleUrls: [],
	                ngContentSelectors: [],
	                animations: []
	            }),
	            changeDetection: _angular_core.ChangeDetectionStrategy.Default,
	            inputs: [],
	            outputs: [],
	            host: {},
	            isComponent: true,
	            selector: '*',
	            providers: [],
	            viewProviders: [],
	            queries: [],
	            viewQueries: []
	        });
	    }
	    var CompilePipeMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function CompilePipeMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;
	            this.type = type;
	            this.name = name;
	            this.pure = !!pure;
	        }
	        /**
	         * @return {?}
	         */
	        CompilePipeMetadata.prototype.toSummary = function () {
	            return {
	                summaryKind: CompileSummaryKind.Pipe,
	                type: this.type,
	                name: this.name,
	                pure: this.pure
	            };
	        };
	        return CompilePipeMetadata;
	    }());
	    /**
	     * Metadata regarding compilation of a module.
	     */
	    var CompileNgModuleMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function CompileNgModuleMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;
	            this.type = type;
	            this.declaredDirectives = _normalizeArray(declaredDirectives);
	            this.exportedDirectives = _normalizeArray(exportedDirectives);
	            this.declaredPipes = _normalizeArray(declaredPipes);
	            this.exportedPipes = _normalizeArray(exportedPipes);
	            this.providers = _normalizeArray(providers);
	            this.entryComponents = _normalizeArray(entryComponents);
	            this.bootstrapComponents = _normalizeArray(bootstrapComponents);
	            this.importedModules = _normalizeArray(importedModules);
	            this.exportedModules = _normalizeArray(exportedModules);
	            this.schemas = _normalizeArray(schemas);
	            this.id = id;
	            this.transitiveModule = transitiveModule;
	        }
	        /**
	         * @return {?}
	         */
	        CompileNgModuleMetadata.prototype.toSummary = function () {
	            return {
	                summaryKind: CompileSummaryKind.NgModule,
	                type: this.type,
	                entryComponents: this.transitiveModule.entryComponents,
	                providers: this.transitiveModule.providers,
	                modules: this.transitiveModule.modules,
	                exportedDirectives: this.transitiveModule.exportedDirectives,
	                exportedPipes: this.transitiveModule.exportedPipes
	            };
	        };
	        return CompileNgModuleMetadata;
	    }());
	    var TransitiveCompileNgModuleMetadata = (function () {
	        function TransitiveCompileNgModuleMetadata() {
	            this.directivesSet = new Set();
	            this.directives = [];
	            this.exportedDirectivesSet = new Set();
	            this.exportedDirectives = [];
	            this.pipesSet = new Set();
	            this.pipes = [];
	            this.exportedPipesSet = new Set();
	            this.exportedPipes = [];
	            this.modulesSet = new Set();
	            this.modules = [];
	            this.entryComponentsSet = new Set();
	            this.entryComponents = [];
	            this.providers = [];
	        }
	        /**
	         * @param {?} provider
	         * @param {?} module
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {
	            this.providers.push({ provider: provider, module: module });
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {
	            if (!this.directivesSet.has(id.reference)) {
	                this.directivesSet.add(id.reference);
	                this.directives.push(id);
	            }
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {
	            if (!this.exportedDirectivesSet.has(id.reference)) {
	                this.exportedDirectivesSet.add(id.reference);
	                this.exportedDirectives.push(id);
	            }
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {
	            if (!this.pipesSet.has(id.reference)) {
	                this.pipesSet.add(id.reference);
	                this.pipes.push(id);
	            }
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {
	            if (!this.exportedPipesSet.has(id.reference)) {
	                this.exportedPipesSet.add(id.reference);
	                this.exportedPipes.push(id);
	            }
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {
	            if (!this.modulesSet.has(id.reference)) {
	                this.modulesSet.add(id.reference);
	                this.modules.push(id);
	            }
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (id) {
	            if (!this.entryComponentsSet.has(id.reference)) {
	                this.entryComponentsSet.add(id.reference);
	                this.entryComponents.push(id);
	            }
	        };
	        return TransitiveCompileNgModuleMetadata;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function _normalizeArray(obj) {
	        return obj || [];
	    }
	    var ProviderMeta = (function () {
	        /**
	         * @param {?} token
	         * @param {?} __1
	         */
	        function ProviderMeta(token, _a) {
	            var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	            this.token = token;
	            this.useClass = useClass;
	            this.useValue = useValue;
	            this.useExisting = useExisting;
	            this.useFactory = useFactory;
	            this.dependencies = deps;
	            this.multi = !!multi;
	        }
	        return ProviderMeta;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ $EOF = 0;
	    var /** @type {?} */ $TAB = 9;
	    var /** @type {?} */ $LF = 10;
	    var /** @type {?} */ $VTAB = 11;
	    var /** @type {?} */ $FF = 12;
	    var /** @type {?} */ $CR = 13;
	    var /** @type {?} */ $SPACE = 32;
	    var /** @type {?} */ $BANG = 33;
	    var /** @type {?} */ $DQ = 34;
	    var /** @type {?} */ $HASH = 35;
	    var /** @type {?} */ $$ = 36;
	    var /** @type {?} */ $PERCENT = 37;
	    var /** @type {?} */ $AMPERSAND = 38;
	    var /** @type {?} */ $SQ = 39;
	    var /** @type {?} */ $LPAREN = 40;
	    var /** @type {?} */ $RPAREN = 41;
	    var /** @type {?} */ $STAR = 42;
	    var /** @type {?} */ $PLUS = 43;
	    var /** @type {?} */ $COMMA = 44;
	    var /** @type {?} */ $MINUS = 45;
	    var /** @type {?} */ $PERIOD = 46;
	    var /** @type {?} */ $SLASH = 47;
	    var /** @type {?} */ $COLON = 58;
	    var /** @type {?} */ $SEMICOLON = 59;
	    var /** @type {?} */ $LT = 60;
	    var /** @type {?} */ $EQ = 61;
	    var /** @type {?} */ $GT = 62;
	    var /** @type {?} */ $QUESTION = 63;
	    var /** @type {?} */ $0 = 48;
	    var /** @type {?} */ $9 = 57;
	    var /** @type {?} */ $A = 65;
	    var /** @type {?} */ $E = 69;
	    var /** @type {?} */ $F = 70;
	    var /** @type {?} */ $X = 88;
	    var /** @type {?} */ $Z = 90;
	    var /** @type {?} */ $LBRACKET = 91;
	    var /** @type {?} */ $BACKSLASH = 92;
	    var /** @type {?} */ $RBRACKET = 93;
	    var /** @type {?} */ $CARET = 94;
	    var /** @type {?} */ $_ = 95;
	    var /** @type {?} */ $a = 97;
	    var /** @type {?} */ $e = 101;
	    var /** @type {?} */ $f = 102;
	    var /** @type {?} */ $n = 110;
	    var /** @type {?} */ $r = 114;
	    var /** @type {?} */ $t = 116;
	    var /** @type {?} */ $u = 117;
	    var /** @type {?} */ $v = 118;
	    var /** @type {?} */ $x = 120;
	    var /** @type {?} */ $z = 122;
	    var /** @type {?} */ $LBRACE = 123;
	    var /** @type {?} */ $BAR = 124;
	    var /** @type {?} */ $RBRACE = 125;
	    var /** @type {?} */ $NBSP = 160;
	    var /** @type {?} */ $BT = 96;
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isWhitespace(code) {
	        return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isDigit(code) {
	        return $0 <= code && code <= $9;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isAsciiLetter(code) {
	        return code >= $a && code <= $z || code >= $A && code <= $Z;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isAsciiHexDigit(code) {
	        return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
	    }

	    /**
	     * A replacement for \@Injectable to be used in the compiler, so that
	     * we don't try to evaluate the metadata in the compiler during AoT.
	     * This decorator is enough to make the compiler work with the ReflectiveInjector though.
	     * @return {?}
	     */
	    function CompilerInjectable() {
	        return function (x) { return x; };
	    }

	    /**
	     * @param {?} identifier
	     * @param {?} value
	     * @return {?}
	     */
	    function assertArrayOfStrings(identifier, value) {
	        if (!_angular_core.isDevMode() || isBlank(value)) {
	            return;
	        }
	        if (!Array.isArray(value)) {
	            throw new Error("Expected '" + identifier + "' to be an array of strings.");
	        }
	        for (var /** @type {?} */ i = 0; i < value.length; i += 1) {
	            if (typeof value[i] !== 'string') {
	                throw new Error("Expected '" + identifier + "' to be an array of strings.");
	            }
	        }
	    }
	    var /** @type {?} */ INTERPOLATION_BLACKLIST_REGEXPS = [
	        /^\s*$/,
	        /[<>]/,
	        /^[{}]$/,
	        /&(#|[a-z])/i,
	        /^\/\//,
	    ];
	    /**
	     * @param {?} identifier
	     * @param {?} value
	     * @return {?}
	     */
	    function assertInterpolationSymbols(identifier, value) {
	        if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {
	            throw new Error("Expected '" + identifier + "' to be an array, [start, end].");
	        }
	        else if (_angular_core.isDevMode() && !isBlank(value)) {
	            var /** @type {?} */ start_1 = (value[0]);
	            var /** @type {?} */ end_1 = (value[1]);
	            // black list checking
	            INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {
	                if (regexp.test(start_1) || regexp.test(end_1)) {
	                    throw new Error("['" + start_1 + "', '" + end_1 + "'] contains unusable interpolation symbol.");
	                }
	            });
	        }
	    }

	    var InterpolationConfig = (function () {
	        /**
	         * @param {?} start
	         * @param {?} end
	         */
	        function InterpolationConfig(start, end) {
	            this.start = start;
	            this.end = end;
	        }
	        /**
	         * @param {?} markers
	         * @return {?}
	         */
	        InterpolationConfig.fromArray = function (markers) {
	            if (!markers) {
	                return DEFAULT_INTERPOLATION_CONFIG;
	            }
	            assertInterpolationSymbols('interpolation', markers);
	            return new InterpolationConfig(markers[0], markers[1]);
	        };
	        ;
	        return InterpolationConfig;
	    }());
	    var /** @type {?} */ DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ParserError = (function () {
	        /**
	         * @param {?} message
	         * @param {?} input
	         * @param {?} errLocation
	         * @param {?=} ctxLocation
	         */
	        function ParserError(message, input, errLocation, ctxLocation) {
	            this.input = input;
	            this.errLocation = errLocation;
	            this.ctxLocation = ctxLocation;
	            this.message = "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation;
	        }
	        return ParserError;
	    }());
	    var ParseSpan = (function () {
	        /**
	         * @param {?} start
	         * @param {?} end
	         */
	        function ParseSpan(start, end) {
	            this.start = start;
	            this.end = end;
	        }
	        return ParseSpan;
	    }());
	    var AST = (function () {
	        /**
	         * @param {?} span
	         */
	        function AST(span) {
	            this.span = span;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        AST.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return null;
	        };
	        /**
	         * @return {?}
	         */
	        AST.prototype.toString = function () { return 'AST'; };
	        return AST;
	    }());
	    /**
	     * Represents a quoted expression of the form:
	     *
	     * quote = prefix `:` uninterpretedExpression
	     * prefix = identifier
	     * uninterpretedExpression = arbitrary string
	     *
	     * A quoted expression is meant to be pre-processed by an AST transformer that
	     * converts it into another AST that no longer contains quoted expressions.
	     * It is meant to allow third-party developers to extend Angular template
	     * expression language. The `uninterpretedExpression` part of the quote is
	     * therefore not interpreted by the Angular's own expression parser.
	     */
	    var Quote = (function (_super) {
	        __extends$4(Quote, _super);
	        /**
	         * @param {?} span
	         * @param {?} prefix
	         * @param {?} uninterpretedExpression
	         * @param {?} location
	         */
	        function Quote(span, prefix, uninterpretedExpression, location) {
	            _super.call(this, span);
	            this.prefix = prefix;
	            this.uninterpretedExpression = uninterpretedExpression;
	            this.location = location;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Quote.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitQuote(this, context);
	        };
	        /**
	         * @return {?}
	         */
	        Quote.prototype.toString = function () { return 'Quote'; };
	        return Quote;
	    }(AST));
	    var EmptyExpr = (function (_super) {
	        __extends$4(EmptyExpr, _super);
	        function EmptyExpr() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        EmptyExpr.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            // do nothing
	        };
	        return EmptyExpr;
	    }(AST));
	    var ImplicitReceiver = (function (_super) {
	        __extends$4(ImplicitReceiver, _super);
	        function ImplicitReceiver() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        ImplicitReceiver.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitImplicitReceiver(this, context);
	        };
	        return ImplicitReceiver;
	    }(AST));
	    /**
	     * Multiple expressions separated by a semicolon.
	     */
	    var Chain = (function (_super) {
	        __extends$4(Chain, _super);
	        /**
	         * @param {?} span
	         * @param {?} expressions
	         */
	        function Chain(span, expressions) {
	            _super.call(this, span);
	            this.expressions = expressions;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Chain.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitChain(this, context);
	        };
	        return Chain;
	    }(AST));
	    var Conditional = (function (_super) {
	        __extends$4(Conditional, _super);
	        /**
	         * @param {?} span
	         * @param {?} condition
	         * @param {?} trueExp
	         * @param {?} falseExp
	         */
	        function Conditional(span, condition, trueExp, falseExp) {
	            _super.call(this, span);
	            this.condition = condition;
	            this.trueExp = trueExp;
	            this.falseExp = falseExp;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Conditional.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitConditional(this, context);
	        };
	        return Conditional;
	    }(AST));
	    var PropertyRead = (function (_super) {
	        __extends$4(PropertyRead, _super);
	        /**
	         * @param {?} span
	         * @param {?} receiver
	         * @param {?} name
	         */
	        function PropertyRead(span, receiver, name) {
	            _super.call(this, span);
	            this.receiver = receiver;
	            this.name = name;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        PropertyRead.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitPropertyRead(this, context);
	        };
	        return PropertyRead;
	    }(AST));
	    var PropertyWrite = (function (_super) {
	        __extends$4(PropertyWrite, _super);
	        /**
	         * @param {?} span
	         * @param {?} receiver
	         * @param {?} name
	         * @param {?} value
	         */
	        function PropertyWrite(span, receiver, name, value) {
	            _super.call(this, span);
	            this.receiver = receiver;
	            this.name = name;
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        PropertyWrite.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitPropertyWrite(this, context);
	        };
	        return PropertyWrite;
	    }(AST));
	    var SafePropertyRead = (function (_super) {
	        __extends$4(SafePropertyRead, _super);
	        /**
	         * @param {?} span
	         * @param {?} receiver
	         * @param {?} name
	         */
	        function SafePropertyRead(span, receiver, name) {
	            _super.call(this, span);
	            this.receiver = receiver;
	            this.name = name;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        SafePropertyRead.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitSafePropertyRead(this, context);
	        };
	        return SafePropertyRead;
	    }(AST));
	    var KeyedRead = (function (_super) {
	        __extends$4(KeyedRead, _super);
	        /**
	         * @param {?} span
	         * @param {?} obj
	         * @param {?} key
	         */
	        function KeyedRead(span, obj, key) {
	            _super.call(this, span);
	            this.obj = obj;
	            this.key = key;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        KeyedRead.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitKeyedRead(this, context);
	        };
	        return KeyedRead;
	    }(AST));
	    var KeyedWrite = (function (_super) {
	        __extends$4(KeyedWrite, _super);
	        /**
	         * @param {?} span
	         * @param {?} obj
	         * @param {?} key
	         * @param {?} value
	         */
	        function KeyedWrite(span, obj, key, value) {
	            _super.call(this, span);
	            this.obj = obj;
	            this.key = key;
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        KeyedWrite.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitKeyedWrite(this, context);
	        };
	        return KeyedWrite;
	    }(AST));
	    var BindingPipe = (function (_super) {
	        __extends$4(BindingPipe, _super);
	        /**
	         * @param {?} span
	         * @param {?} exp
	         * @param {?} name
	         * @param {?} args
	         */
	        function BindingPipe(span, exp, name, args) {
	            _super.call(this, span);
	            this.exp = exp;
	            this.name = name;
	            this.args = args;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        BindingPipe.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitPipe(this, context);
	        };
	        return BindingPipe;
	    }(AST));
	    var LiteralPrimitive = (function (_super) {
	        __extends$4(LiteralPrimitive, _super);
	        /**
	         * @param {?} span
	         * @param {?} value
	         */
	        function LiteralPrimitive(span, value) {
	            _super.call(this, span);
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        LiteralPrimitive.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitLiteralPrimitive(this, context);
	        };
	        return LiteralPrimitive;
	    }(AST));
	    var LiteralArray = (function (_super) {
	        __extends$4(LiteralArray, _super);
	        /**
	         * @param {?} span
	         * @param {?} expressions
	         */
	        function LiteralArray(span, expressions) {
	            _super.call(this, span);
	            this.expressions = expressions;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        LiteralArray.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitLiteralArray(this, context);
	        };
	        return LiteralArray;
	    }(AST));
	    var LiteralMap = (function (_super) {
	        __extends$4(LiteralMap, _super);
	        /**
	         * @param {?} span
	         * @param {?} keys
	         * @param {?} values
	         */
	        function LiteralMap(span, keys, values) {
	            _super.call(this, span);
	            this.keys = keys;
	            this.values = values;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        LiteralMap.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitLiteralMap(this, context);
	        };
	        return LiteralMap;
	    }(AST));
	    var Interpolation = (function (_super) {
	        __extends$4(Interpolation, _super);
	        /**
	         * @param {?} span
	         * @param {?} strings
	         * @param {?} expressions
	         */
	        function Interpolation(span, strings, expressions) {
	            _super.call(this, span);
	            this.strings = strings;
	            this.expressions = expressions;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Interpolation.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitInterpolation(this, context);
	        };
	        return Interpolation;
	    }(AST));
	    var Binary = (function (_super) {
	        __extends$4(Binary, _super);
	        /**
	         * @param {?} span
	         * @param {?} operation
	         * @param {?} left
	         * @param {?} right
	         */
	        function Binary(span, operation, left, right) {
	            _super.call(this, span);
	            this.operation = operation;
	            this.left = left;
	            this.right = right;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Binary.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitBinary(this, context);
	        };
	        return Binary;
	    }(AST));
	    var PrefixNot = (function (_super) {
	        __extends$4(PrefixNot, _super);
	        /**
	         * @param {?} span
	         * @param {?} expression
	         */
	        function PrefixNot(span, expression) {
	            _super.call(this, span);
	            this.expression = expression;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        PrefixNot.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitPrefixNot(this, context);
	        };
	        return PrefixNot;
	    }(AST));
	    var MethodCall = (function (_super) {
	        __extends$4(MethodCall, _super);
	        /**
	         * @param {?} span
	         * @param {?} receiver
	         * @param {?} name
	         * @param {?} args
	         */
	        function MethodCall(span, receiver, name, args) {
	            _super.call(this, span);
	            this.receiver = receiver;
	            this.name = name;
	            this.args = args;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        MethodCall.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitMethodCall(this, context);
	        };
	        return MethodCall;
	    }(AST));
	    var SafeMethodCall = (function (_super) {
	        __extends$4(SafeMethodCall, _super);
	        /**
	         * @param {?} span
	         * @param {?} receiver
	         * @param {?} name
	         * @param {?} args
	         */
	        function SafeMethodCall(span, receiver, name, args) {
	            _super.call(this, span);
	            this.receiver = receiver;
	            this.name = name;
	            this.args = args;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        SafeMethodCall.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitSafeMethodCall(this, context);
	        };
	        return SafeMethodCall;
	    }(AST));
	    var FunctionCall = (function (_super) {
	        __extends$4(FunctionCall, _super);
	        /**
	         * @param {?} span
	         * @param {?} target
	         * @param {?} args
	         */
	        function FunctionCall(span, target, args) {
	            _super.call(this, span);
	            this.target = target;
	            this.args = args;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        FunctionCall.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return visitor.visitFunctionCall(this, context);
	        };
	        return FunctionCall;
	    }(AST));
	    var ASTWithSource = (function (_super) {
	        __extends$4(ASTWithSource, _super);
	        /**
	         * @param {?} ast
	         * @param {?} source
	         * @param {?} location
	         * @param {?} errors
	         */
	        function ASTWithSource(ast, source, location, errors) {
	            _super.call(this, new ParseSpan(0, isBlank(source) ? 0 : source.length));
	            this.ast = ast;
	            this.source = source;
	            this.location = location;
	            this.errors = errors;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        ASTWithSource.prototype.visit = function (visitor, context) {
	            if (context === void 0) { context = null; }
	            return this.ast.visit(visitor, context);
	        };
	        /**
	         * @return {?}
	         */
	        ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
	        return ASTWithSource;
	    }(AST));
	    var TemplateBinding = (function () {
	        /**
	         * @param {?} span
	         * @param {?} key
	         * @param {?} keyIsVar
	         * @param {?} name
	         * @param {?} expression
	         */
	        function TemplateBinding(span, key, keyIsVar, name, expression) {
	            this.span = span;
	            this.key = key;
	            this.keyIsVar = keyIsVar;
	            this.name = name;
	            this.expression = expression;
	        }
	        return TemplateBinding;
	    }());
	    var RecursiveAstVisitor = (function () {
	        function RecursiveAstVisitor() {
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {
	            ast.left.visit(this);
	            ast.right.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {
	            ast.condition.visit(this);
	            ast.trueExp.visit(this);
	            ast.falseExp.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {
	            ast.exp.visit(this);
	            this.visitAll(ast.args, context);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {
	            ast.target.visit(this);
	            this.visitAll(ast.args, context);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {
	            return this.visitAll(ast.expressions, context);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {
	            ast.obj.visit(this);
	            ast.key.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {
	            ast.obj.visit(this);
	            ast.key.visit(this);
	            ast.value.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {
	            return this.visitAll(ast.expressions, context);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {
	            ast.receiver.visit(this);
	            return this.visitAll(ast.args, context);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {
	            ast.expression.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {
	            ast.receiver.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {
	            ast.receiver.visit(this);
	            ast.value.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {
	            ast.receiver.visit(this);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {
	            ast.receiver.visit(this);
	            return this.visitAll(ast.args, context);
	        };
	        /**
	         * @param {?} asts
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitAll = function (asts, context) {
	            var _this = this;
	            asts.forEach(function (ast) { return ast.visit(_this, context); });
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };
	        return RecursiveAstVisitor;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$2 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var TokenType = {};
	    TokenType.Character = 0;
	    TokenType.Identifier = 1;
	    TokenType.Keyword = 2;
	    TokenType.String = 3;
	    TokenType.Operator = 4;
	    TokenType.Number = 5;
	    TokenType.Error = 6;
	    TokenType[TokenType.Character] = "Character";
	    TokenType[TokenType.Identifier] = "Identifier";
	    TokenType[TokenType.Keyword] = "Keyword";
	    TokenType[TokenType.String] = "String";
	    TokenType[TokenType.Operator] = "Operator";
	    TokenType[TokenType.Number] = "Number";
	    TokenType[TokenType.Error] = "Error";
	    var /** @type {?} */ KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
	    var Lexer = (function () {
	        function Lexer() {
	        }
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        Lexer.prototype.tokenize = function (text) {
	            var /** @type {?} */ scanner = new _Scanner(text);
	            var /** @type {?} */ tokens = [];
	            var /** @type {?} */ token = scanner.scanToken();
	            while (token != null) {
	                tokens.push(token);
	                token = scanner.scanToken();
	            }
	            return tokens;
	        };
	        Lexer = __decorate$2([
	            CompilerInjectable(), 
	            __metadata$2('design:paramtypes', [])
	        ], Lexer);
	        return Lexer;
	    }());
	    var Token = (function () {
	        /**
	         * @param {?} index
	         * @param {?} type
	         * @param {?} numValue
	         * @param {?} strValue
	         */
	        function Token(index, type, numValue, strValue) {
	            this.index = index;
	            this.type = type;
	            this.numValue = numValue;
	            this.strValue = strValue;
	        }
	        /**
	         * @param {?} code
	         * @return {?}
	         */
	        Token.prototype.isCharacter = function (code) {
	            return this.type == TokenType.Character && this.numValue == code;
	        };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isNumber = function () { return this.type == TokenType.Number; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isString = function () { return this.type == TokenType.String; };
	        /**
	         * @param {?} operater
	         * @return {?}
	         */
	        Token.prototype.isOperator = function (operater) {
	            return this.type == TokenType.Operator && this.strValue == operater;
	        };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isIdentifier = function () { return this.type == TokenType.Identifier; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeyword = function () { return this.type == TokenType.Keyword; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeywordLet = function () { return this.type == TokenType.Keyword && this.strValue == 'let'; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeywordNull = function () { return this.type == TokenType.Keyword && this.strValue == 'null'; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeywordUndefined = function () {
	            return this.type == TokenType.Keyword && this.strValue == 'undefined';
	        };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeywordTrue = function () { return this.type == TokenType.Keyword && this.strValue == 'true'; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeywordFalse = function () { return this.type == TokenType.Keyword && this.strValue == 'false'; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isKeywordThis = function () { return this.type == TokenType.Keyword && this.strValue == 'this'; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.isError = function () { return this.type == TokenType.Error; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.toNumber = function () { return this.type == TokenType.Number ? this.numValue : -1; };
	        /**
	         * @return {?}
	         */
	        Token.prototype.toString = function () {
	            switch (this.type) {
	                case TokenType.Character:
	                case TokenType.Identifier:
	                case TokenType.Keyword:
	                case TokenType.Operator:
	                case TokenType.String:
	                case TokenType.Error:
	                    return this.strValue;
	                case TokenType.Number:
	                    return this.numValue.toString();
	                default:
	                    return null;
	            }
	        };
	        return Token;
	    }());
	    /**
	     * @param {?} index
	     * @param {?} code
	     * @return {?}
	     */
	    function newCharacterToken(index, code) {
	        return new Token(index, TokenType.Character, code, String.fromCharCode(code));
	    }
	    /**
	     * @param {?} index
	     * @param {?} text
	     * @return {?}
	     */
	    function newIdentifierToken(index, text) {
	        return new Token(index, TokenType.Identifier, 0, text);
	    }
	    /**
	     * @param {?} index
	     * @param {?} text
	     * @return {?}
	     */
	    function newKeywordToken(index, text) {
	        return new Token(index, TokenType.Keyword, 0, text);
	    }
	    /**
	     * @param {?} index
	     * @param {?} text
	     * @return {?}
	     */
	    function newOperatorToken(index, text) {
	        return new Token(index, TokenType.Operator, 0, text);
	    }
	    /**
	     * @param {?} index
	     * @param {?} text
	     * @return {?}
	     */
	    function newStringToken(index, text) {
	        return new Token(index, TokenType.String, 0, text);
	    }
	    /**
	     * @param {?} index
	     * @param {?} n
	     * @return {?}
	     */
	    function newNumberToken(index, n) {
	        return new Token(index, TokenType.Number, n, '');
	    }
	    /**
	     * @param {?} index
	     * @param {?} message
	     * @return {?}
	     */
	    function newErrorToken(index, message) {
	        return new Token(index, TokenType.Error, 0, message);
	    }
	    var /** @type {?} */ EOF = new Token(-1, TokenType.Character, 0, '');
	    var _Scanner = (function () {
	        /**
	         * @param {?} input
	         */
	        function _Scanner(input) {
	            this.input = input;
	            this.peek = 0;
	            this.index = -1;
	            this.length = input.length;
	            this.advance();
	        }
	        /**
	         * @return {?}
	         */
	        _Scanner.prototype.advance = function () {
	            this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
	        };
	        /**
	         * @return {?}
	         */
	        _Scanner.prototype.scanToken = function () {
	            var /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;
	            var /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;
	            // Skip whitespace.
	            while (peek <= $SPACE) {
	                if (++index >= length) {
	                    peek = $EOF;
	                    break;
	                }
	                else {
	                    peek = input.charCodeAt(index);
	                }
	            }
	            this.peek = peek;
	            this.index = index;
	            if (index >= length) {
	                return null;
	            }
	            // Handle identifiers and numbers.
	            if (isIdentifierStart(peek))
	                return this.scanIdentifier();
	            if (isDigit(peek))
	                return this.scanNumber(index);
	            var /** @type {?} */ start = index;
	            switch (peek) {
	                case $PERIOD:
	                    this.advance();
	                    return isDigit(this.peek) ? this.scanNumber(start) :
	                        newCharacterToken(start, $PERIOD);
	                case $LPAREN:
	                case $RPAREN:
	                case $LBRACE:
	                case $RBRACE:
	                case $LBRACKET:
	                case $RBRACKET:
	                case $COMMA:
	                case $COLON:
	                case $SEMICOLON:
	                    return this.scanCharacter(start, peek);
	                case $SQ:
	                case $DQ:
	                    return this.scanString();
	                case $HASH:
	                case $PLUS:
	                case $MINUS:
	                case $STAR:
	                case $SLASH:
	                case $PERCENT:
	                case $CARET:
	                    return this.scanOperator(start, String.fromCharCode(peek));
	                case $QUESTION:
	                    return this.scanComplexOperator(start, '?', $PERIOD, '.');
	                case $LT:
	                case $GT:
	                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
	                case $BANG:
	                case $EQ:
	                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
	                case $AMPERSAND:
	                    return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
	                case $BAR:
	                    return this.scanComplexOperator(start, '|', $BAR, '|');
	                case $NBSP:
	                    while (isWhitespace(this.peek))
	                        this.advance();
	                    return this.scanToken();
	            }
	            this.advance();
	            return this.error("Unexpected character [" + String.fromCharCode(peek) + "]", 0);
	        };
	        /**
	         * @param {?} start
	         * @param {?} code
	         * @return {?}
	         */
	        _Scanner.prototype.scanCharacter = function (start, code) {
	            this.advance();
	            return newCharacterToken(start, code);
	        };
	        /**
	         * @param {?} start
	         * @param {?} str
	         * @return {?}
	         */
	        _Scanner.prototype.scanOperator = function (start, str) {
	            this.advance();
	            return newOperatorToken(start, str);
	        };
	        /**
	         * Tokenize a 2/3 char long operator
	         *
	         * @param {?} start start index in the expression
	         * @param {?} one first symbol (always part of the operator)
	         * @param {?} twoCode code point for the second symbol
	         * @param {?} two second symbol (part of the operator when the second code point matches)
	         * @param {?=} threeCode code point for the third symbol
	         * @param {?=} three third symbol (part of the operator when provided and matches source expression)
	         * @return {?}
	         */
	        _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
	            this.advance();
	            var /** @type {?} */ str = one;
	            if (this.peek == twoCode) {
	                this.advance();
	                str += two;
	            }
	            if (threeCode != null && this.peek == threeCode) {
	                this.advance();
	                str += three;
	            }
	            return newOperatorToken(start, str);
	        };
	        /**
	         * @return {?}
	         */
	        _Scanner.prototype.scanIdentifier = function () {
	            var /** @type {?} */ start = this.index;
	            this.advance();
	            while (isIdentifierPart(this.peek))
	                this.advance();
	            var /** @type {?} */ str = this.input.substring(start, this.index);
	            return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :
	                newIdentifierToken(start, str);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Scanner.prototype.scanNumber = function (start) {
	            var /** @type {?} */ simple = (this.index === start);
	            this.advance(); // Skip initial digit.
	            while (true) {
	                if (isDigit(this.peek)) {
	                }
	                else if (this.peek == $PERIOD) {
	                    simple = false;
	                }
	                else if (isExponentStart(this.peek)) {
	                    this.advance();
	                    if (isExponentSign(this.peek))
	                        this.advance();
	                    if (!isDigit(this.peek))
	                        return this.error('Invalid exponent', -1);
	                    simple = false;
	                }
	                else {
	                    break;
	                }
	                this.advance();
	            }
	            var /** @type {?} */ str = this.input.substring(start, this.index);
	            var /** @type {?} */ value = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);
	            return newNumberToken(start, value);
	        };
	        /**
	         * @return {?}
	         */
	        _Scanner.prototype.scanString = function () {
	            var /** @type {?} */ start = this.index;
	            var /** @type {?} */ quote = this.peek;
	            this.advance(); // Skip initial quote.
	            var /** @type {?} */ buffer = '';
	            var /** @type {?} */ marker = this.index;
	            var /** @type {?} */ input = this.input;
	            while (this.peek != quote) {
	                if (this.peek == $BACKSLASH) {
	                    buffer += input.substring(marker, this.index);
	                    this.advance();
	                    var /** @type {?} */ unescapedCode = void 0;
	                    if (this.peek == $u) {
	                        // 4 character hex code for unicode character.
	                        var /** @type {?} */ hex = input.substring(this.index + 1, this.index + 5);
	                        if (/^[0-9a-f]+$/i.test(hex)) {
	                            unescapedCode = parseInt(hex, 16);
	                        }
	                        else {
	                            return this.error("Invalid unicode escape [\\u" + hex + "]", 0);
	                        }
	                        for (var /** @type {?} */ i = 0; i < 5; i++) {
	                            this.advance();
	                        }
	                    }
	                    else {
	                        unescapedCode = unescape(this.peek);
	                        this.advance();
	                    }
	                    buffer += String.fromCharCode(unescapedCode);
	                    marker = this.index;
	                }
	                else if (this.peek == $EOF) {
	                    return this.error('Unterminated quote', 0);
	                }
	                else {
	                    this.advance();
	                }
	            }
	            var /** @type {?} */ last = input.substring(marker, this.index);
	            this.advance(); // Skip terminating quote.
	            return newStringToken(start, buffer + last);
	        };
	        /**
	         * @param {?} message
	         * @param {?} offset
	         * @return {?}
	         */
	        _Scanner.prototype.error = function (message, offset) {
	            var /** @type {?} */ position = this.index + offset;
	            return newErrorToken(position, "Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
	        };
	        return _Scanner;
	    }());
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isIdentifierStart(code) {
	        return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
	            (code == $_) || (code == $$);
	    }
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function isIdentifier(input) {
	        if (input.length == 0)
	            return false;
	        var /** @type {?} */ scanner = new _Scanner(input);
	        if (!isIdentifierStart(scanner.peek))
	            return false;
	        scanner.advance();
	        while (scanner.peek !== $EOF) {
	            if (!isIdentifierPart(scanner.peek))
	                return false;
	            scanner.advance();
	        }
	        return true;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isIdentifierPart(code) {
	        return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
	            (code == $$);
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isExponentStart(code) {
	        return code == $e || code == $E;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isExponentSign(code) {
	        return code == $MINUS || code == $PLUS;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isQuote(code) {
	        return code === $SQ || code === $DQ || code === $BT;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function unescape(code) {
	        switch (code) {
	            case $n:
	                return $LF;
	            case $f:
	                return $FF;
	            case $r:
	                return $CR;
	            case $t:
	                return $TAB;
	            case $v:
	                return $VTAB;
	            default:
	                return code;
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$1 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var SplitInterpolation = (function () {
	        /**
	         * @param {?} strings
	         * @param {?} expressions
	         * @param {?} offsets
	         */
	        function SplitInterpolation(strings, expressions, offsets) {
	            this.strings = strings;
	            this.expressions = expressions;
	            this.offsets = offsets;
	        }
	        return SplitInterpolation;
	    }());
	    var TemplateBindingParseResult = (function () {
	        /**
	         * @param {?} templateBindings
	         * @param {?} warnings
	         * @param {?} errors
	         */
	        function TemplateBindingParseResult(templateBindings, warnings, errors) {
	            this.templateBindings = templateBindings;
	            this.warnings = warnings;
	            this.errors = errors;
	        }
	        return TemplateBindingParseResult;
	    }());
	    /**
	     * @param {?} config
	     * @return {?}
	     */
	    function _createInterpolateRegExp(config) {
	        var /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
	        return new RegExp(pattern, 'g');
	    }
	    var Parser = (function () {
	        /**
	         * @param {?} _lexer
	         */
	        function Parser(_lexer) {
	            this._lexer = _lexer;
	            this.errors = [];
	        }
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype.parseAction = function (input, location, interpolationConfig) {
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            this._checkNoInterpolation(input, location, interpolationConfig);
	            var /** @type {?} */ sourceToLex = this._stripComments(input);
	            var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));
	            var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
	                .parseChain();
	            return new ASTWithSource(ast, input, location, this.errors);
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype.parseBinding = function (input, location, interpolationConfig) {
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);
	            return new ASTWithSource(ast, input, location, this.errors);
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);
	            var /** @type {?} */ errors = SimpleExpressionChecker.check(ast);
	            if (errors.length > 0) {
	                this._reportError("Host binding expression cannot contain " + errors.join(' '), input, location);
	            }
	            return new ASTWithSource(ast, input, location, this.errors);
	        };
	        /**
	         * @param {?} message
	         * @param {?} input
	         * @param {?} errLocation
	         * @param {?=} ctxLocation
	         * @return {?}
	         */
	        Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {
	            this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {
	            // Quotes expressions use 3rd-party expression language. We don't want to use
	            // our lexer or parser for that, so we check for that ahead of time.
	            var /** @type {?} */ quote = this._parseQuote(input, location);
	            if (isPresent(quote)) {
	                return quote;
	            }
	            this._checkNoInterpolation(input, location, interpolationConfig);
	            var /** @type {?} */ sourceToLex = this._stripComments(input);
	            var /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);
	            return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
	                .parseChain();
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @return {?}
	         */
	        Parser.prototype._parseQuote = function (input, location) {
	            if (isBlank(input))
	                return null;
	            var /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');
	            if (prefixSeparatorIndex == -1)
	                return null;
	            var /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();
	            if (!isIdentifier(prefix))
	                return null;
	            var /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
	            return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
	        };
	        /**
	         * @param {?} prefixToken
	         * @param {?} input
	         * @param {?} location
	         * @return {?}
	         */
	        Parser.prototype.parseTemplateBindings = function (prefixToken, input, location) {
	            var /** @type {?} */ tokens = this._lexer.tokenize(input);
	            if (prefixToken) {
	                // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).
	                var /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(function (t) {
	                    t.index = 0;
	                    return t;
	                });
	                tokens.unshift.apply(tokens, prefixTokens);
	            }
	            return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)
	                .parseTemplateBindings();
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            var /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);
	            if (split == null)
	                return null;
	            var /** @type {?} */ expressions = [];
	            for (var /** @type {?} */ i = 0; i < split.expressions.length; ++i) {
	                var /** @type {?} */ expressionText = split.expressions[i];
	                var /** @type {?} */ sourceToLex = this._stripComments(expressionText);
	                var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
	                var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))
	                    .parseChain();
	                expressions.push(ast);
	            }
	            return new ASTWithSource(new Interpolation(new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions), input, location, this.errors);
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);
	            var /** @type {?} */ parts = input.split(regexp);
	            if (parts.length <= 1) {
	                return null;
	            }
	            var /** @type {?} */ strings = [];
	            var /** @type {?} */ expressions = [];
	            var /** @type {?} */ offsets = [];
	            var /** @type {?} */ offset = 0;
	            for (var /** @type {?} */ i = 0; i < parts.length; i++) {
	                var /** @type {?} */ part = parts[i];
	                if (i % 2 === 0) {
	                    // fixed string
	                    strings.push(part);
	                    offset += part.length;
	                }
	                else if (part.trim().length > 0) {
	                    offset += interpolationConfig.start.length;
	                    expressions.push(part);
	                    offsets.push(offset);
	                    offset += part.length + interpolationConfig.end.length;
	                }
	                else {
	                    this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + " in", location);
	                    expressions.push('$implict');
	                    offsets.push(offset);
	                }
	            }
	            return new SplitInterpolation(strings, expressions, offsets);
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @return {?}
	         */
	        Parser.prototype.wrapLiteralPrimitive = function (input, location) {
	            return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input, location, this.errors);
	        };
	        /**
	         * @param {?} input
	         * @return {?}
	         */
	        Parser.prototype._stripComments = function (input) {
	            var /** @type {?} */ i = this._commentStart(input);
	            return isPresent(i) ? input.substring(0, i).trim() : input;
	        };
	        /**
	         * @param {?} input
	         * @return {?}
	         */
	        Parser.prototype._commentStart = function (input) {
	            var /** @type {?} */ outerQuote = null;
	            for (var /** @type {?} */ i = 0; i < input.length - 1; i++) {
	                var /** @type {?} */ char = input.charCodeAt(i);
	                var /** @type {?} */ nextChar = input.charCodeAt(i + 1);
	                if (char === $SLASH && nextChar == $SLASH && isBlank(outerQuote))
	                    return i;
	                if (outerQuote === char) {
	                    outerQuote = null;
	                }
	                else if (isBlank(outerQuote) && isQuote(char)) {
	                    outerQuote = char;
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {
	            var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);
	            var /** @type {?} */ parts = input.split(regexp);
	            if (parts.length > 1) {
	                this._reportError("Got interpolation (" + interpolationConfig.start + interpolationConfig.end + ") where expression was expected", input, "at column " + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + " in", location);
	            }
	        };
	        /**
	         * @param {?} parts
	         * @param {?} partInErrIdx
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {
	            var /** @type {?} */ errLocation = '';
	            for (var /** @type {?} */ j = 0; j < partInErrIdx; j++) {
	                errLocation += j % 2 === 0 ?
	                    parts[j] :
	                    "" + interpolationConfig.start + parts[j] + interpolationConfig.end;
	            }
	            return errLocation.length;
	        };
	        Parser = __decorate$1([
	            CompilerInjectable(), 
	            __metadata$1('design:paramtypes', [Lexer])
	        ], Parser);
	        return Parser;
	    }());
	    var _ParseAST = (function () {
	        /**
	         * @param {?} input
	         * @param {?} location
	         * @param {?} tokens
	         * @param {?} inputLength
	         * @param {?} parseAction
	         * @param {?} errors
	         * @param {?} offset
	         */
	        function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {
	            this.input = input;
	            this.location = location;
	            this.tokens = tokens;
	            this.inputLength = inputLength;
	            this.parseAction = parseAction;
	            this.errors = errors;
	            this.offset = offset;
	            this.rparensExpected = 0;
	            this.rbracketsExpected = 0;
	            this.rbracesExpected = 0;
	            this.index = 0;
	        }
	        /**
	         * @param {?} offset
	         * @return {?}
	         */
	        _ParseAST.prototype.peek = function (offset) {
	            var /** @type {?} */ i = this.index + offset;
	            return i < this.tokens.length ? this.tokens[i] : EOF;
	        };
	        Object.defineProperty(_ParseAST.prototype, "next", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.peek(0); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(_ParseAST.prototype, "inputIndex", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (this.index < this.tokens.length) ? this.next.index + this.offset :
	                    this.inputLength + this.offset;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.advance = function () { this.index++; };
	        /**
	         * @param {?} code
	         * @return {?}
	         */
	        _ParseAST.prototype.optionalCharacter = function (code) {
	            if (this.next.isCharacter(code)) {
	                this.advance();
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };
	        /**
	         * @param {?} code
	         * @return {?}
	         */
	        _ParseAST.prototype.expectCharacter = function (code) {
	            if (this.optionalCharacter(code))
	                return;
	            this.error("Missing expected " + String.fromCharCode(code));
	        };
	        /**
	         * @param {?} op
	         * @return {?}
	         */
	        _ParseAST.prototype.optionalOperator = function (op) {
	            if (this.next.isOperator(op)) {
	                this.advance();
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        /**
	         * @param {?} operator
	         * @return {?}
	         */
	        _ParseAST.prototype.expectOperator = function (operator) {
	            if (this.optionalOperator(operator))
	                return;
	            this.error("Missing expected operator " + operator);
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.expectIdentifierOrKeyword = function () {
	            var /** @type {?} */ n = this.next;
	            if (!n.isIdentifier() && !n.isKeyword()) {
	                this.error("Unexpected token " + n + ", expected identifier or keyword");
	                return '';
	            }
	            this.advance();
	            return n.toString();
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
	            var /** @type {?} */ n = this.next;
	            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
	                this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
	                return '';
	            }
	            this.advance();
	            return n.toString();
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseChain = function () {
	            var /** @type {?} */ exprs = [];
	            var /** @type {?} */ start = this.inputIndex;
	            while (this.index < this.tokens.length) {
	                var /** @type {?} */ expr = this.parsePipe();
	                exprs.push(expr);
	                if (this.optionalCharacter($SEMICOLON)) {
	                    if (!this.parseAction) {
	                        this.error('Binding expression cannot contain chained expression');
	                    }
	                    while (this.optionalCharacter($SEMICOLON)) {
	                    } // read all semicolons
	                }
	                else if (this.index < this.tokens.length) {
	                    this.error("Unexpected token '" + this.next + "'");
	                }
	            }
	            if (exprs.length == 0)
	                return new EmptyExpr(this.span(start));
	            if (exprs.length == 1)
	                return exprs[0];
	            return new Chain(this.span(start), exprs);
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parsePipe = function () {
	            var /** @type {?} */ result = this.parseExpression();
	            if (this.optionalOperator('|')) {
	                if (this.parseAction) {
	                    this.error('Cannot have a pipe in an action expression');
	                }
	                do {
	                    var /** @type {?} */ name_1 = this.expectIdentifierOrKeyword();
	                    var /** @type {?} */ args = [];
	                    while (this.optionalCharacter($COLON)) {
	                        args.push(this.parseExpression());
	                    }
	                    result = new BindingPipe(this.span(result.span.start), result, name_1, args);
	                } while (this.optionalOperator('|'));
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseConditional = function () {
	            var /** @type {?} */ start = this.inputIndex;
	            var /** @type {?} */ result = this.parseLogicalOr();
	            if (this.optionalOperator('?')) {
	                var /** @type {?} */ yes = this.parsePipe();
	                var /** @type {?} */ no = void 0;
	                if (!this.optionalCharacter($COLON)) {
	                    var /** @type {?} */ end = this.inputIndex;
	                    var /** @type {?} */ expression = this.input.substring(start, end);
	                    this.error("Conditional expression " + expression + " requires all 3 expressions");
	                    no = new EmptyExpr(this.span(start));
	                }
	                else {
	                    no = this.parsePipe();
	                }
	                return new Conditional(this.span(start), result, yes, no);
	            }
	            else {
	                return result;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseLogicalOr = function () {
	            // '||'
	            var /** @type {?} */ result = this.parseLogicalAnd();
	            while (this.optionalOperator('||')) {
	                var /** @type {?} */ right = this.parseLogicalAnd();
	                result = new Binary(this.span(result.span.start), '||', result, right);
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseLogicalAnd = function () {
	            // '&&'
	            var /** @type {?} */ result = this.parseEquality();
	            while (this.optionalOperator('&&')) {
	                var /** @type {?} */ right = this.parseEquality();
	                result = new Binary(this.span(result.span.start), '&&', result, right);
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseEquality = function () {
	            // '==','!=','===','!=='
	            var /** @type {?} */ result = this.parseRelational();
	            while (this.next.type == TokenType.Operator) {
	                var /** @type {?} */ operator = this.next.strValue;
	                switch (operator) {
	                    case '==':
	                    case '===':
	                    case '!=':
	                    case '!==':
	                        this.advance();
	                        var /** @type {?} */ right = this.parseRelational();
	                        result = new Binary(this.span(result.span.start), operator, result, right);
	                        continue;
	                }
	                break;
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseRelational = function () {
	            // '<', '>', '<=', '>='
	            var /** @type {?} */ result = this.parseAdditive();
	            while (this.next.type == TokenType.Operator) {
	                var /** @type {?} */ operator = this.next.strValue;
	                switch (operator) {
	                    case '<':
	                    case '>':
	                    case '<=':
	                    case '>=':
	                        this.advance();
	                        var /** @type {?} */ right = this.parseAdditive();
	                        result = new Binary(this.span(result.span.start), operator, result, right);
	                        continue;
	                }
	                break;
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseAdditive = function () {
	            // '+', '-'
	            var /** @type {?} */ result = this.parseMultiplicative();
	            while (this.next.type == TokenType.Operator) {
	                var /** @type {?} */ operator = this.next.strValue;
	                switch (operator) {
	                    case '+':
	                    case '-':
	                        this.advance();
	                        var /** @type {?} */ right = this.parseMultiplicative();
	                        result = new Binary(this.span(result.span.start), operator, result, right);
	                        continue;
	                }
	                break;
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseMultiplicative = function () {
	            // '*', '%', '/'
	            var /** @type {?} */ result = this.parsePrefix();
	            while (this.next.type == TokenType.Operator) {
	                var /** @type {?} */ operator = this.next.strValue;
	                switch (operator) {
	                    case '*':
	                    case '%':
	                    case '/':
	                        this.advance();
	                        var /** @type {?} */ right = this.parsePrefix();
	                        result = new Binary(this.span(result.span.start), operator, result, right);
	                        continue;
	                }
	                break;
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parsePrefix = function () {
	            if (this.next.type == TokenType.Operator) {
	                var /** @type {?} */ start = this.inputIndex;
	                var /** @type {?} */ operator = this.next.strValue;
	                var /** @type {?} */ result = void 0;
	                switch (operator) {
	                    case '+':
	                        this.advance();
	                        return this.parsePrefix();
	                    case '-':
	                        this.advance();
	                        result = this.parsePrefix();
	                        return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);
	                    case '!':
	                        this.advance();
	                        result = this.parsePrefix();
	                        return new PrefixNot(this.span(start), result);
	                }
	            }
	            return this.parseCallChain();
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseCallChain = function () {
	            var /** @type {?} */ result = this.parsePrimary();
	            while (true) {
	                if (this.optionalCharacter($PERIOD)) {
	                    result = this.parseAccessMemberOrMethodCall(result, false);
	                }
	                else if (this.optionalOperator('?.')) {
	                    result = this.parseAccessMemberOrMethodCall(result, true);
	                }
	                else if (this.optionalCharacter($LBRACKET)) {
	                    this.rbracketsExpected++;
	                    var /** @type {?} */ key = this.parsePipe();
	                    this.rbracketsExpected--;
	                    this.expectCharacter($RBRACKET);
	                    if (this.optionalOperator('=')) {
	                        var /** @type {?} */ value = this.parseConditional();
	                        result = new KeyedWrite(this.span(result.span.start), result, key, value);
	                    }
	                    else {
	                        result = new KeyedRead(this.span(result.span.start), result, key);
	                    }
	                }
	                else if (this.optionalCharacter($LPAREN)) {
	                    this.rparensExpected++;
	                    var /** @type {?} */ args = this.parseCallArguments();
	                    this.rparensExpected--;
	                    this.expectCharacter($RPAREN);
	                    result = new FunctionCall(this.span(result.span.start), result, args);
	                }
	                else {
	                    return result;
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parsePrimary = function () {
	            var /** @type {?} */ start = this.inputIndex;
	            if (this.optionalCharacter($LPAREN)) {
	                this.rparensExpected++;
	                var /** @type {?} */ result = this.parsePipe();
	                this.rparensExpected--;
	                this.expectCharacter($RPAREN);
	                return result;
	            }
	            else if (this.next.isKeywordNull()) {
	                this.advance();
	                return new LiteralPrimitive(this.span(start), null);
	            }
	            else if (this.next.isKeywordUndefined()) {
	                this.advance();
	                return new LiteralPrimitive(this.span(start), void 0);
	            }
	            else if (this.next.isKeywordTrue()) {
	                this.advance();
	                return new LiteralPrimitive(this.span(start), true);
	            }
	            else if (this.next.isKeywordFalse()) {
	                this.advance();
	                return new LiteralPrimitive(this.span(start), false);
	            }
	            else if (this.next.isKeywordThis()) {
	                this.advance();
	                return new ImplicitReceiver(this.span(start));
	            }
	            else if (this.optionalCharacter($LBRACKET)) {
	                this.rbracketsExpected++;
	                var /** @type {?} */ elements = this.parseExpressionList($RBRACKET);
	                this.rbracketsExpected--;
	                this.expectCharacter($RBRACKET);
	                return new LiteralArray(this.span(start), elements);
	            }
	            else if (this.next.isCharacter($LBRACE)) {
	                return this.parseLiteralMap();
	            }
	            else if (this.next.isIdentifier()) {
	                return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);
	            }
	            else if (this.next.isNumber()) {
	                var /** @type {?} */ value = this.next.toNumber();
	                this.advance();
	                return new LiteralPrimitive(this.span(start), value);
	            }
	            else if (this.next.isString()) {
	                var /** @type {?} */ literalValue = this.next.toString();
	                this.advance();
	                return new LiteralPrimitive(this.span(start), literalValue);
	            }
	            else if (this.index >= this.tokens.length) {
	                this.error("Unexpected end of expression: " + this.input);
	                return new EmptyExpr(this.span(start));
	            }
	            else {
	                this.error("Unexpected token " + this.next);
	                return new EmptyExpr(this.span(start));
	            }
	        };
	        /**
	         * @param {?} terminator
	         * @return {?}
	         */
	        _ParseAST.prototype.parseExpressionList = function (terminator) {
	            var /** @type {?} */ result = [];
	            if (!this.next.isCharacter(terminator)) {
	                do {
	                    result.push(this.parsePipe());
	                } while (this.optionalCharacter($COMMA));
	            }
	            return result;
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseLiteralMap = function () {
	            var /** @type {?} */ keys = [];
	            var /** @type {?} */ values = [];
	            var /** @type {?} */ start = this.inputIndex;
	            this.expectCharacter($LBRACE);
	            if (!this.optionalCharacter($RBRACE)) {
	                this.rbracesExpected++;
	                do {
	                    var /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();
	                    keys.push(key);
	                    this.expectCharacter($COLON);
	                    values.push(this.parsePipe());
	                } while (this.optionalCharacter($COMMA));
	                this.rbracesExpected--;
	                this.expectCharacter($RBRACE);
	            }
	            return new LiteralMap(this.span(start), keys, values);
	        };
	        /**
	         * @param {?} receiver
	         * @param {?=} isSafe
	         * @return {?}
	         */
	        _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
	            if (isSafe === void 0) { isSafe = false; }
	            var /** @type {?} */ start = receiver.span.start;
	            var /** @type {?} */ id = this.expectIdentifierOrKeyword();
	            if (this.optionalCharacter($LPAREN)) {
	                this.rparensExpected++;
	                var /** @type {?} */ args = this.parseCallArguments();
	                this.expectCharacter($RPAREN);
	                this.rparensExpected--;
	                var /** @type {?} */ span = this.span(start);
	                return isSafe ? new SafeMethodCall(span, receiver, id, args) :
	                    new MethodCall(span, receiver, id, args);
	            }
	            else {
	                if (isSafe) {
	                    if (this.optionalOperator('=')) {
	                        this.error('The \'?.\' operator cannot be used in the assignment');
	                        return new EmptyExpr(this.span(start));
	                    }
	                    else {
	                        return new SafePropertyRead(this.span(start), receiver, id);
	                    }
	                }
	                else {
	                    if (this.optionalOperator('=')) {
	                        if (!this.parseAction) {
	                            this.error('Bindings cannot contain assignments');
	                            return new EmptyExpr(this.span(start));
	                        }
	                        var /** @type {?} */ value = this.parseConditional();
	                        return new PropertyWrite(this.span(start), receiver, id, value);
	                    }
	                    else {
	                        return new PropertyRead(this.span(start), receiver, id);
	                    }
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseCallArguments = function () {
	            if (this.next.isCharacter($RPAREN))
	                return [];
	            var /** @type {?} */ positionals = [];
	            do {
	                positionals.push(this.parsePipe());
	            } while (this.optionalCharacter($COMMA));
	            return (positionals);
	        };
	        /**
	         * An identifier, a keyword, a string with an optional `-` inbetween.
	         * @return {?}
	         */
	        _ParseAST.prototype.expectTemplateBindingKey = function () {
	            var /** @type {?} */ result = '';
	            var /** @type {?} */ operatorFound = false;
	            do {
	                result += this.expectIdentifierOrKeywordOrString();
	                operatorFound = this.optionalOperator('-');
	                if (operatorFound) {
	                    result += '-';
	                }
	            } while (operatorFound);
	            return result.toString();
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.parseTemplateBindings = function () {
	            var /** @type {?} */ bindings = [];
	            var /** @type {?} */ prefix = null;
	            var /** @type {?} */ warnings = [];
	            while (this.index < this.tokens.length) {
	                var /** @type {?} */ start = this.inputIndex;
	                var /** @type {?} */ keyIsVar = this.peekKeywordLet();
	                if (keyIsVar) {
	                    this.advance();
	                }
	                var /** @type {?} */ key = this.expectTemplateBindingKey();
	                if (!keyIsVar) {
	                    if (prefix == null) {
	                        prefix = key;
	                    }
	                    else {
	                        key = prefix + key[0].toUpperCase() + key.substring(1);
	                    }
	                }
	                this.optionalCharacter($COLON);
	                var /** @type {?} */ name_2 = null;
	                var /** @type {?} */ expression = null;
	                if (keyIsVar) {
	                    if (this.optionalOperator('=')) {
	                        name_2 = this.expectTemplateBindingKey();
	                    }
	                    else {
	                        name_2 = '\$implicit';
	                    }
	                }
	                else if (this.next !== EOF && !this.peekKeywordLet()) {
	                    var /** @type {?} */ start_1 = this.inputIndex;
	                    var /** @type {?} */ ast = this.parsePipe();
	                    var /** @type {?} */ source = this.input.substring(start_1 - this.offset, this.inputIndex - this.offset);
	                    expression = new ASTWithSource(ast, source, this.location, this.errors);
	                }
	                bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name_2, expression));
	                if (!this.optionalCharacter($SEMICOLON)) {
	                    this.optionalCharacter($COMMA);
	                }
	            }
	            return new TemplateBindingParseResult(bindings, warnings, this.errors);
	        };
	        /**
	         * @param {?} message
	         * @param {?=} index
	         * @return {?}
	         */
	        _ParseAST.prototype.error = function (message, index) {
	            if (index === void 0) { index = null; }
	            this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
	            this.skip();
	        };
	        /**
	         * @param {?=} index
	         * @return {?}
	         */
	        _ParseAST.prototype.locationText = function (index) {
	            if (index === void 0) { index = null; }
	            if (isBlank(index))
	                index = this.index;
	            return (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
	                "at the end of the expression";
	        };
	        /**
	         * @return {?}
	         */
	        _ParseAST.prototype.skip = function () {
	            var /** @type {?} */ n = this.next;
	            while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
	                (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
	                (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
	                (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
	                if (this.next.isError()) {
	                    this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
	                }
	                this.advance();
	                n = this.next;
	            }
	        };
	        return _ParseAST;
	    }());
	    var SimpleExpressionChecker = (function () {
	        function SimpleExpressionChecker() {
	            this.errors = [];
	        }
	        /**
	         * @param {?} ast
	         * @return {?}
	         */
	        SimpleExpressionChecker.check = function (ast) {
	            var /** @type {?} */ s = new SimpleExpressionChecker();
	            ast.visit(s);
	            return s.errors;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };
	        /**
	         * @param {?} asts
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitAll = function (asts) {
	            var _this = this;
	            return asts.map(function (node) { return node.visit(_this); });
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };
	        return SimpleExpressionChecker;
	    }());

	    var ParseLocation = (function () {
	        /**
	         * @param {?} file
	         * @param {?} offset
	         * @param {?} line
	         * @param {?} col
	         */
	        function ParseLocation(file, offset, line, col) {
	            this.file = file;
	            this.offset = offset;
	            this.line = line;
	            this.col = col;
	        }
	        /**
	         * @return {?}
	         */
	        ParseLocation.prototype.toString = function () {
	            return isPresent(this.offset) ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
	        };
	        /**
	         * @param {?} delta
	         * @return {?}
	         */
	        ParseLocation.prototype.moveBy = function (delta) {
	            var /** @type {?} */ source = this.file.content;
	            var /** @type {?} */ len = source.length;
	            var /** @type {?} */ offset = this.offset;
	            var /** @type {?} */ line = this.line;
	            var /** @type {?} */ col = this.col;
	            while (offset > 0 && delta < 0) {
	                offset--;
	                delta++;
	                var /** @type {?} */ ch = source.charCodeAt(offset);
	                if (ch == $LF) {
	                    line--;
	                    var /** @type {?} */ priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
	                    col = priorLine > 0 ? offset - priorLine : offset;
	                }
	                else {
	                    col--;
	                }
	            }
	            while (offset < len && delta > 0) {
	                var /** @type {?} */ ch = source.charCodeAt(offset);
	                offset++;
	                delta--;
	                if (ch == $LF) {
	                    line++;
	                    col = 0;
	                }
	                else {
	                    col++;
	                }
	            }
	            return new ParseLocation(this.file, offset, line, col);
	        };
	        /**
	         * @param {?} maxChars
	         * @param {?} maxLines
	         * @return {?}
	         */
	        ParseLocation.prototype.getContext = function (maxChars, maxLines) {
	            var /** @type {?} */ content = this.file.content;
	            var /** @type {?} */ startOffset = this.offset;
	            if (isPresent(startOffset)) {
	                if (startOffset > content.length - 1) {
	                    startOffset = content.length - 1;
	                }
	                var /** @type {?} */ endOffset = startOffset;
	                var /** @type {?} */ ctxChars = 0;
	                var /** @type {?} */ ctxLines = 0;
	                while (ctxChars < maxChars && startOffset > 0) {
	                    startOffset--;
	                    ctxChars++;
	                    if (content[startOffset] == '\n') {
	                        if (++ctxLines == maxLines) {
	                            break;
	                        }
	                    }
	                }
	                ctxChars = 0;
	                ctxLines = 0;
	                while (ctxChars < maxChars && endOffset < content.length - 1) {
	                    endOffset++;
	                    ctxChars++;
	                    if (content[endOffset] == '\n') {
	                        if (++ctxLines == maxLines) {
	                            break;
	                        }
	                    }
	                }
	                return {
	                    before: content.substring(startOffset, this.offset),
	                    after: content.substring(this.offset, endOffset + 1),
	                };
	            }
	            return null;
	        };
	        return ParseLocation;
	    }());
	    var ParseSourceFile = (function () {
	        /**
	         * @param {?} content
	         * @param {?} url
	         */
	        function ParseSourceFile(content, url) {
	            this.content = content;
	            this.url = url;
	        }
	        return ParseSourceFile;
	    }());
	    var ParseSourceSpan = (function () {
	        /**
	         * @param {?} start
	         * @param {?} end
	         * @param {?=} details
	         */
	        function ParseSourceSpan(start, end, details) {
	            if (details === void 0) { details = null; }
	            this.start = start;
	            this.end = end;
	            this.details = details;
	        }
	        /**
	         * @return {?}
	         */
	        ParseSourceSpan.prototype.toString = function () {
	            return this.start.file.content.substring(this.start.offset, this.end.offset);
	        };
	        return ParseSourceSpan;
	    }());
	    var ParseErrorLevel = {};
	    ParseErrorLevel.WARNING = 0;
	    ParseErrorLevel.FATAL = 1;
	    ParseErrorLevel[ParseErrorLevel.WARNING] = "WARNING";
	    ParseErrorLevel[ParseErrorLevel.FATAL] = "FATAL";
	    var ParseError = (function () {
	        /**
	         * @param {?} span
	         * @param {?} msg
	         * @param {?=} level
	         */
	        function ParseError(span, msg, level) {
	            if (level === void 0) { level = ParseErrorLevel.FATAL; }
	            this.span = span;
	            this.msg = msg;
	            this.level = level;
	        }
	        /**
	         * @return {?}
	         */
	        ParseError.prototype.toString = function () {
	            var /** @type {?} */ ctx = this.span.start.getContext(100, 3);
	            var /** @type {?} */ contextStr = ctx ? " (\"" + ctx.before + "[ERROR ->]" + ctx.after + "\")" : '';
	            var /** @type {?} */ details = this.span.details ? ", " + this.span.details : '';
	            return "" + this.msg + contextStr + ": " + this.span.start + details;
	        };
	        return ParseError;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var Text = (function () {
	        /**
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function Text(value, sourceSpan) {
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
	        return Text;
	    }());
	    var Expansion = (function () {
	        /**
	         * @param {?} switchValue
	         * @param {?} type
	         * @param {?} cases
	         * @param {?} sourceSpan
	         * @param {?} switchValueSourceSpan
	         */
	        function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
	            this.switchValue = switchValue;
	            this.type = type;
	            this.cases = cases;
	            this.sourceSpan = sourceSpan;
	            this.switchValueSourceSpan = switchValueSourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };
	        return Expansion;
	    }());
	    var ExpansionCase = (function () {
	        /**
	         * @param {?} value
	         * @param {?} expression
	         * @param {?} sourceSpan
	         * @param {?} valueSourceSpan
	         * @param {?} expSourceSpan
	         */
	        function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
	            this.value = value;
	            this.expression = expression;
	            this.sourceSpan = sourceSpan;
	            this.valueSourceSpan = valueSourceSpan;
	            this.expSourceSpan = expSourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };
	        return ExpansionCase;
	    }());
	    var Attribute$1 = (function () {
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @param {?=} valueSpan
	         */
	        function Attribute(name, value, sourceSpan, valueSpan) {
	            this.name = name;
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	            this.valueSpan = valueSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Attribute.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };
	        return Attribute;
	    }());
	    var Element = (function () {
	        /**
	         * @param {?} name
	         * @param {?} attrs
	         * @param {?} children
	         * @param {?} sourceSpan
	         * @param {?} startSourceSpan
	         * @param {?} endSourceSpan
	         */
	        function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
	            this.name = name;
	            this.attrs = attrs;
	            this.children = children;
	            this.sourceSpan = sourceSpan;
	            this.startSourceSpan = startSourceSpan;
	            this.endSourceSpan = endSourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
	        return Element;
	    }());
	    var Comment = (function () {
	        /**
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function Comment(value, sourceSpan) {
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };
	        return Comment;
	    }());
	    /**
	     * @param {?} visitor
	     * @param {?} nodes
	     * @param {?=} context
	     * @return {?}
	     */
	    function visitAll(visitor, nodes, context) {
	        if (context === void 0) { context = null; }
	        var /** @type {?} */ result = [];
	        var /** @type {?} */ visit = visitor.visit ?
	            function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :
	            function (ast) { return ast.visit(visitor, context); };
	        nodes.forEach(function (ast) {
	            var /** @type {?} */ astResult = visit(ast);
	            if (astResult) {
	                result.push(astResult);
	            }
	        });
	        return result;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var TokenType$1 = {};
	    TokenType$1.TAG_OPEN_START = 0;
	    TokenType$1.TAG_OPEN_END = 1;
	    TokenType$1.TAG_OPEN_END_VOID = 2;
	    TokenType$1.TAG_CLOSE = 3;
	    TokenType$1.TEXT = 4;
	    TokenType$1.ESCAPABLE_RAW_TEXT = 5;
	    TokenType$1.RAW_TEXT = 6;
	    TokenType$1.COMMENT_START = 7;
	    TokenType$1.COMMENT_END = 8;
	    TokenType$1.CDATA_START = 9;
	    TokenType$1.CDATA_END = 10;
	    TokenType$1.ATTR_NAME = 11;
	    TokenType$1.ATTR_VALUE = 12;
	    TokenType$1.DOC_TYPE = 13;
	    TokenType$1.EXPANSION_FORM_START = 14;
	    TokenType$1.EXPANSION_CASE_VALUE = 15;
	    TokenType$1.EXPANSION_CASE_EXP_START = 16;
	    TokenType$1.EXPANSION_CASE_EXP_END = 17;
	    TokenType$1.EXPANSION_FORM_END = 18;
	    TokenType$1.EOF = 19;
	    TokenType$1[TokenType$1.TAG_OPEN_START] = "TAG_OPEN_START";
	    TokenType$1[TokenType$1.TAG_OPEN_END] = "TAG_OPEN_END";
	    TokenType$1[TokenType$1.TAG_OPEN_END_VOID] = "TAG_OPEN_END_VOID";
	    TokenType$1[TokenType$1.TAG_CLOSE] = "TAG_CLOSE";
	    TokenType$1[TokenType$1.TEXT] = "TEXT";
	    TokenType$1[TokenType$1.ESCAPABLE_RAW_TEXT] = "ESCAPABLE_RAW_TEXT";
	    TokenType$1[TokenType$1.RAW_TEXT] = "RAW_TEXT";
	    TokenType$1[TokenType$1.COMMENT_START] = "COMMENT_START";
	    TokenType$1[TokenType$1.COMMENT_END] = "COMMENT_END";
	    TokenType$1[TokenType$1.CDATA_START] = "CDATA_START";
	    TokenType$1[TokenType$1.CDATA_END] = "CDATA_END";
	    TokenType$1[TokenType$1.ATTR_NAME] = "ATTR_NAME";
	    TokenType$1[TokenType$1.ATTR_VALUE] = "ATTR_VALUE";
	    TokenType$1[TokenType$1.DOC_TYPE] = "DOC_TYPE";
	    TokenType$1[TokenType$1.EXPANSION_FORM_START] = "EXPANSION_FORM_START";
	    TokenType$1[TokenType$1.EXPANSION_CASE_VALUE] = "EXPANSION_CASE_VALUE";
	    TokenType$1[TokenType$1.EXPANSION_CASE_EXP_START] = "EXPANSION_CASE_EXP_START";
	    TokenType$1[TokenType$1.EXPANSION_CASE_EXP_END] = "EXPANSION_CASE_EXP_END";
	    TokenType$1[TokenType$1.EXPANSION_FORM_END] = "EXPANSION_FORM_END";
	    TokenType$1[TokenType$1.EOF] = "EOF";
	    var Token$1 = (function () {
	        /**
	         * @param {?} type
	         * @param {?} parts
	         * @param {?} sourceSpan
	         */
	        function Token(type, parts, sourceSpan) {
	            this.type = type;
	            this.parts = parts;
	            this.sourceSpan = sourceSpan;
	        }
	        return Token;
	    }());
	    var TokenError = (function (_super) {
	        __extends$6(TokenError, _super);
	        /**
	         * @param {?} errorMsg
	         * @param {?} tokenType
	         * @param {?} span
	         */
	        function TokenError(errorMsg, tokenType, span) {
	            _super.call(this, span, errorMsg);
	            this.tokenType = tokenType;
	        }
	        return TokenError;
	    }(ParseError));
	    var TokenizeResult = (function () {
	        /**
	         * @param {?} tokens
	         * @param {?} errors
	         */
	        function TokenizeResult(tokens, errors) {
	            this.tokens = tokens;
	            this.errors = errors;
	        }
	        return TokenizeResult;
	    }());
	    /**
	     * @param {?} source
	     * @param {?} url
	     * @param {?} getTagDefinition
	     * @param {?=} tokenizeExpansionForms
	     * @param {?=} interpolationConfig
	     * @return {?}
	     */
	    function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {
	        if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }
	        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	        return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)
	            .tokenize();
	    }
	    var /** @type {?} */ _CR_OR_CRLF_REGEXP = /\r\n?/g;
	    /**
	     * @param {?} charCode
	     * @return {?}
	     */
	    function _unexpectedCharacterErrorMsg(charCode) {
	        var /** @type {?} */ char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
	        return "Unexpected character \"" + char + "\"";
	    }
	    /**
	     * @param {?} entitySrc
	     * @return {?}
	     */
	    function _unknownEntityErrorMsg(entitySrc) {
	        return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
	    }
	    var _ControlFlowError = (function () {
	        /**
	         * @param {?} error
	         */
	        function _ControlFlowError(error) {
	            this.error = error;
	        }
	        return _ControlFlowError;
	    }());
	    var _Tokenizer = (function () {
	        /**
	         * @param {?} _file The html source
	         * @param {?} _getTagDefinition
	         * @param {?} _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)
	         * @param {?=} _interpolationConfig
	         */
	        function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {
	            if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            this._file = _file;
	            this._getTagDefinition = _getTagDefinition;
	            this._tokenizeIcu = _tokenizeIcu;
	            this._interpolationConfig = _interpolationConfig;
	            this._peek = -1;
	            this._nextPeek = -1;
	            this._index = -1;
	            this._line = 0;
	            this._column = -1;
	            this._expansionCaseStack = [];
	            this._inInterpolation = false;
	            this.tokens = [];
	            this.errors = [];
	            this._input = _file.content;
	            this._length = _file.content.length;
	            this._advance();
	        }
	        /**
	         * @param {?} content
	         * @return {?}
	         */
	        _Tokenizer.prototype._processCarriageReturns = function (content) {
	            // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
	            // In order to keep the original position in the source, we can not
	            // pre-process it.
	            // Instead CRs are processed right before instantiating the tokens.
	            return content.replace(_CR_OR_CRLF_REGEXP, '\n');
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype.tokenize = function () {
	            while (this._peek !== $EOF) {
	                var /** @type {?} */ start = this._getLocation();
	                try {
	                    if (this._attemptCharCode($LT)) {
	                        if (this._attemptCharCode($BANG)) {
	                            if (this._attemptCharCode($LBRACKET)) {
	                                this._consumeCdata(start);
	                            }
	                            else if (this._attemptCharCode($MINUS)) {
	                                this._consumeComment(start);
	                            }
	                            else {
	                                this._consumeDocType(start);
	                            }
	                        }
	                        else if (this._attemptCharCode($SLASH)) {
	                            this._consumeTagClose(start);
	                        }
	                        else {
	                            this._consumeTagOpen(start);
	                        }
	                    }
	                    else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
	                        this._consumeText();
	                    }
	                }
	                catch (e) {
	                    if (e instanceof _ControlFlowError) {
	                        this.errors.push(e.error);
	                    }
	                    else {
	                        throw e;
	                    }
	                }
	            }
	            this._beginToken(TokenType$1.EOF);
	            this._endToken([]);
	            return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        _Tokenizer.prototype._tokenizeExpansionForm = function () {
	            if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
	                this._consumeExpansionFormStart();
	                return true;
	            }
	            if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
	                this._consumeExpansionCaseStart();
	                return true;
	            }
	            if (this._peek === $RBRACE) {
	                if (this._isInExpansionCase()) {
	                    this._consumeExpansionCaseEnd();
	                    return true;
	                }
	                if (this._isInExpansionForm()) {
	                    this._consumeExpansionFormEnd();
	                    return true;
	                }
	            }
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._getLocation = function () {
	            return new ParseLocation(this._file, this._index, this._line, this._column);
	        };
	        /**
	         * @param {?=} start
	         * @param {?=} end
	         * @return {?}
	         */
	        _Tokenizer.prototype._getSpan = function (start, end) {
	            if (start === void 0) { start = this._getLocation(); }
	            if (end === void 0) { end = this._getLocation(); }
	            return new ParseSourceSpan(start, end);
	        };
	        /**
	         * @param {?} type
	         * @param {?=} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._beginToken = function (type, start) {
	            if (start === void 0) { start = this._getLocation(); }
	            this._currentTokenStart = start;
	            this._currentTokenType = type;
	        };
	        /**
	         * @param {?} parts
	         * @param {?=} end
	         * @return {?}
	         */
	        _Tokenizer.prototype._endToken = function (parts, end) {
	            if (end === void 0) { end = this._getLocation(); }
	            var /** @type {?} */ token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
	            this.tokens.push(token);
	            this._currentTokenStart = null;
	            this._currentTokenType = null;
	            return token;
	        };
	        /**
	         * @param {?} msg
	         * @param {?} span
	         * @return {?}
	         */
	        _Tokenizer.prototype._createError = function (msg, span) {
	            if (this._isInExpansionForm()) {
	                msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
	            }
	            var /** @type {?} */ error = new TokenError(msg, this._currentTokenType, span);
	            this._currentTokenStart = null;
	            this._currentTokenType = null;
	            return new _ControlFlowError(error);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._advance = function () {
	            if (this._index >= this._length) {
	                throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());
	            }
	            if (this._peek === $LF) {
	                this._line++;
	                this._column = 0;
	            }
	            else if (this._peek !== $LF && this._peek !== $CR) {
	                this._column++;
	            }
	            this._index++;
	            this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);
	            this._nextPeek =
	                this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);
	        };
	        /**
	         * @param {?} charCode
	         * @return {?}
	         */
	        _Tokenizer.prototype._attemptCharCode = function (charCode) {
	            if (this._peek === charCode) {
	                this._advance();
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} charCode
	         * @return {?}
	         */
	        _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {
	            if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
	                this._advance();
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} charCode
	         * @return {?}
	         */
	        _Tokenizer.prototype._requireCharCode = function (charCode) {
	            var /** @type {?} */ location = this._getLocation();
	            if (!this._attemptCharCode(charCode)) {
	                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
	            }
	        };
	        /**
	         * @param {?} chars
	         * @return {?}
	         */
	        _Tokenizer.prototype._attemptStr = function (chars) {
	            var /** @type {?} */ len = chars.length;
	            if (this._index + len > this._length) {
	                return false;
	            }
	            var /** @type {?} */ initialPosition = this._savePosition();
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                if (!this._attemptCharCode(chars.charCodeAt(i))) {
	                    // If attempting to parse the string fails, we want to reset the parser
	                    // to where it was before the attempt
	                    this._restorePosition(initialPosition);
	                    return false;
	                }
	            }
	            return true;
	        };
	        /**
	         * @param {?} chars
	         * @return {?}
	         */
	        _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {
	            for (var /** @type {?} */ i = 0; i < chars.length; i++) {
	                if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        /**
	         * @param {?} chars
	         * @return {?}
	         */
	        _Tokenizer.prototype._requireStr = function (chars) {
	            var /** @type {?} */ location = this._getLocation();
	            if (!this._attemptStr(chars)) {
	                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
	            }
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {
	            while (!predicate(this._peek)) {
	                this._advance();
	            }
	        };
	        /**
	         * @param {?} predicate
	         * @param {?} len
	         * @return {?}
	         */
	        _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {
	            var /** @type {?} */ start = this._getLocation();
	            this._attemptCharCodeUntilFn(predicate);
	            if (this._index - start.offset < len) {
	                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
	            }
	        };
	        /**
	         * @param {?} char
	         * @return {?}
	         */
	        _Tokenizer.prototype._attemptUntilChar = function (char) {
	            while (this._peek !== char) {
	                this._advance();
	            }
	        };
	        /**
	         * @param {?} decodeEntities
	         * @return {?}
	         */
	        _Tokenizer.prototype._readChar = function (decodeEntities) {
	            if (decodeEntities && this._peek === $AMPERSAND) {
	                return this._decodeEntity();
	            }
	            else {
	                var /** @type {?} */ index = this._index;
	                this._advance();
	                return this._input[index];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._decodeEntity = function () {
	            var /** @type {?} */ start = this._getLocation();
	            this._advance();
	            if (this._attemptCharCode($HASH)) {
	                var /** @type {?} */ isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
	                var /** @type {?} */ numberStart = this._getLocation().offset;
	                this._attemptCharCodeUntilFn(isDigitEntityEnd);
	                if (this._peek != $SEMICOLON) {
	                    throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
	                }
	                this._advance();
	                var /** @type {?} */ strNum = this._input.substring(numberStart, this._index - 1);
	                try {
	                    var /** @type {?} */ charCode = parseInt(strNum, isHex ? 16 : 10);
	                    return String.fromCharCode(charCode);
	                }
	                catch (e) {
	                    var /** @type {?} */ entity = this._input.substring(start.offset + 1, this._index - 1);
	                    throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
	                }
	            }
	            else {
	                var /** @type {?} */ startPosition = this._savePosition();
	                this._attemptCharCodeUntilFn(isNamedEntityEnd);
	                if (this._peek != $SEMICOLON) {
	                    this._restorePosition(startPosition);
	                    return '&';
	                }
	                this._advance();
	                var /** @type {?} */ name_1 = this._input.substring(start.offset + 1, this._index - 1);
	                var /** @type {?} */ char = NAMED_ENTITIES[name_1];
	                if (!char) {
	                    throw this._createError(_unknownEntityErrorMsg(name_1), this._getSpan(start));
	                }
	                return char;
	            }
	        };
	        /**
	         * @param {?} decodeEntities
	         * @param {?} firstCharOfEnd
	         * @param {?} attemptEndRest
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {
	            var /** @type {?} */ tagCloseStart;
	            var /** @type {?} */ textStart = this._getLocation();
	            this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);
	            var /** @type {?} */ parts = [];
	            while (true) {
	                tagCloseStart = this._getLocation();
	                if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
	                    break;
	                }
	                if (this._index > tagCloseStart.offset) {
	                    // add the characters consumed by the previous if statement to the output
	                    parts.push(this._input.substring(tagCloseStart.offset, this._index));
	                }
	                while (this._peek !== firstCharOfEnd) {
	                    parts.push(this._readChar(decodeEntities));
	                }
	            }
	            return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeComment = function (start) {
	            var _this = this;
	            this._beginToken(TokenType$1.COMMENT_START, start);
	            this._requireCharCode($MINUS);
	            this._endToken([]);
	            var /** @type {?} */ textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });
	            this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);
	            this._endToken([]);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeCdata = function (start) {
	            var _this = this;
	            this._beginToken(TokenType$1.CDATA_START, start);
	            this._requireStr('CDATA[');
	            this._endToken([]);
	            var /** @type {?} */ textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });
	            this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);
	            this._endToken([]);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeDocType = function (start) {
	            this._beginToken(TokenType$1.DOC_TYPE, start);
	            this._attemptUntilChar($GT);
	            this._advance();
	            this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumePrefixAndName = function () {
	            var /** @type {?} */ nameOrPrefixStart = this._index;
	            var /** @type {?} */ prefix = null;
	            while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
	                this._advance();
	            }
	            var /** @type {?} */ nameStart;
	            if (this._peek === $COLON) {
	                this._advance();
	                prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
	                nameStart = this._index;
	            }
	            else {
	                nameStart = nameOrPrefixStart;
	            }
	            this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
	            var /** @type {?} */ name = this._input.substring(nameStart, this._index);
	            return [prefix, name];
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeTagOpen = function (start) {
	            var /** @type {?} */ savedPos = this._savePosition();
	            var /** @type {?} */ tagName;
	            var /** @type {?} */ lowercaseTagName;
	            try {
	                if (!isAsciiLetter(this._peek)) {
	                    throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
	                }
	                var /** @type {?} */ nameStart = this._index;
	                this._consumeTagOpenStart(start);
	                tagName = this._input.substring(nameStart, this._index);
	                lowercaseTagName = tagName.toLowerCase();
	                this._attemptCharCodeUntilFn(isNotWhitespace);
	                while (this._peek !== $SLASH && this._peek !== $GT) {
	                    this._consumeAttributeName();
	                    this._attemptCharCodeUntilFn(isNotWhitespace);
	                    if (this._attemptCharCode($EQ)) {
	                        this._attemptCharCodeUntilFn(isNotWhitespace);
	                        this._consumeAttributeValue();
	                    }
	                    this._attemptCharCodeUntilFn(isNotWhitespace);
	                }
	                this._consumeTagOpenEnd();
	            }
	            catch (e) {
	                if (e instanceof _ControlFlowError) {
	                    // When the start tag is invalid, assume we want a "<"
	                    this._restorePosition(savedPos);
	                    // Back to back text tokens are merged at the end
	                    this._beginToken(TokenType$1.TEXT, start);
	                    this._endToken(['<']);
	                    return;
	                }
	                throw e;
	            }
	            var /** @type {?} */ contentTokenType = this._getTagDefinition(tagName).contentType;
	            if (contentTokenType === TagContentType.RAW_TEXT) {
	                this._consumeRawTextWithTagClose(lowercaseTagName, false);
	            }
	            else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
	                this._consumeRawTextWithTagClose(lowercaseTagName, true);
	            }
	        };
	        /**
	         * @param {?} lowercaseTagName
	         * @param {?} decodeEntities
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {
	            var _this = this;
	            var /** @type {?} */ textToken = this._consumeRawText(decodeEntities, $LT, function () {
	                if (!_this._attemptCharCode($SLASH))
	                    return false;
	                _this._attemptCharCodeUntilFn(isNotWhitespace);
	                if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
	                    return false;
	                _this._attemptCharCodeUntilFn(isNotWhitespace);
	                return _this._attemptCharCode($GT);
	            });
	            this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);
	            this._endToken([null, lowercaseTagName]);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeTagOpenStart = function (start) {
	            this._beginToken(TokenType$1.TAG_OPEN_START, start);
	            var /** @type {?} */ parts = this._consumePrefixAndName();
	            this._endToken(parts);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeAttributeName = function () {
	            this._beginToken(TokenType$1.ATTR_NAME);
	            var /** @type {?} */ prefixAndName = this._consumePrefixAndName();
	            this._endToken(prefixAndName);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeAttributeValue = function () {
	            this._beginToken(TokenType$1.ATTR_VALUE);
	            var /** @type {?} */ value;
	            if (this._peek === $SQ || this._peek === $DQ) {
	                var /** @type {?} */ quoteChar = this._peek;
	                this._advance();
	                var /** @type {?} */ parts = [];
	                while (this._peek !== quoteChar) {
	                    parts.push(this._readChar(true));
	                }
	                value = parts.join('');
	                this._advance();
	            }
	            else {
	                var /** @type {?} */ valueStart = this._index;
	                this._requireCharCodeUntilFn(isNameEnd, 1);
	                value = this._input.substring(valueStart, this._index);
	            }
	            this._endToken([this._processCarriageReturns(value)]);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeTagOpenEnd = function () {
	            var /** @type {?} */ tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;
	            this._beginToken(tokenType);
	            this._requireCharCode($GT);
	            this._endToken([]);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeTagClose = function (start) {
	            this._beginToken(TokenType$1.TAG_CLOSE, start);
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            var /** @type {?} */ prefixAndName = this._consumePrefixAndName();
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._requireCharCode($GT);
	            this._endToken(prefixAndName);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeExpansionFormStart = function () {
	            this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());
	            this._requireCharCode($LBRACE);
	            this._endToken([]);
	            this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);
	            this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
	            var /** @type {?} */ condition = this._readUntil($COMMA);
	            this._endToken([condition], this._getLocation());
	            this._requireCharCode($COMMA);
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
	            var /** @type {?} */ type = this._readUntil($COMMA);
	            this._endToken([type], this._getLocation());
	            this._requireCharCode($COMMA);
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeExpansionCaseStart = function () {
	            this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());
	            var /** @type {?} */ value = this._readUntil($LBRACE).trim();
	            this._endToken([value], this._getLocation());
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());
	            this._requireCharCode($LBRACE);
	            this._endToken([], this._getLocation());
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeExpansionCaseEnd = function () {
	            this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());
	            this._requireCharCode($RBRACE);
	            this._endToken([], this._getLocation());
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._expansionCaseStack.pop();
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeExpansionFormEnd = function () {
	            this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());
	            this._requireCharCode($RBRACE);
	            this._endToken([]);
	            this._expansionCaseStack.pop();
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._consumeText = function () {
	            var /** @type {?} */ start = this._getLocation();
	            this._beginToken(TokenType$1.TEXT, start);
	            var /** @type {?} */ parts = [];
	            do {
	                if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
	                    parts.push(this._interpolationConfig.start);
	                    this._inInterpolation = true;
	                }
	                else if (this._interpolationConfig && this._inInterpolation &&
	                    this._attemptStr(this._interpolationConfig.end)) {
	                    parts.push(this._interpolationConfig.end);
	                    this._inInterpolation = false;
	                }
	                else {
	                    parts.push(this._readChar(true));
	                }
	            } while (!this._isTextEnd());
	            this._endToken([this._processCarriageReturns(parts.join(''))]);
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._isTextEnd = function () {
	            if (this._peek === $LT || this._peek === $EOF) {
	                return true;
	            }
	            if (this._tokenizeIcu && !this._inInterpolation) {
	                if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
	                    // start of an expansion form
	                    return true;
	                }
	                if (this._peek === $RBRACE && this._isInExpansionCase()) {
	                    // end of and expansion case
	                    return true;
	                }
	            }
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._savePosition = function () {
	            return [this._peek, this._index, this._column, this._line, this.tokens.length];
	        };
	        /**
	         * @param {?} char
	         * @return {?}
	         */
	        _Tokenizer.prototype._readUntil = function (char) {
	            var /** @type {?} */ start = this._index;
	            this._attemptUntilChar(char);
	            return this._input.substring(start, this._index);
	        };
	        /**
	         * @param {?} position
	         * @return {?}
	         */
	        _Tokenizer.prototype._restorePosition = function (position) {
	            this._peek = position[0];
	            this._index = position[1];
	            this._column = position[2];
	            this._line = position[3];
	            var /** @type {?} */ nbTokens = position[4];
	            if (nbTokens < this.tokens.length) {
	                // remove any extra tokens
	                this.tokens = this.tokens.slice(0, nbTokens);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._isInExpansionCase = function () {
	            return this._expansionCaseStack.length > 0 &&
	                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
	                    TokenType$1.EXPANSION_CASE_EXP_START;
	        };
	        /**
	         * @return {?}
	         */
	        _Tokenizer.prototype._isInExpansionForm = function () {
	            return this._expansionCaseStack.length > 0 &&
	                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
	                    TokenType$1.EXPANSION_FORM_START;
	        };
	        return _Tokenizer;
	    }());
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isNotWhitespace(code) {
	        return !isWhitespace(code) || code === $EOF;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isNameEnd(code) {
	        return isWhitespace(code) || code === $GT || code === $SLASH ||
	            code === $SQ || code === $DQ || code === $EQ;
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isPrefixEnd(code) {
	        return (code < $a || $z < code) && (code < $A || $Z < code) &&
	            (code < $0 || code > $9);
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isDigitEntityEnd(code) {
	        return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function isNamedEntityEnd(code) {
	        return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
	    }
	    /**
	     * @param {?} input
	     * @param {?} offset
	     * @param {?} interpolationConfig
	     * @return {?}
	     */
	    function isExpansionFormStart(input, offset, interpolationConfig) {
	        var /** @type {?} */ isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
	        return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;
	    }
	    /**
	     * @param {?} peek
	     * @return {?}
	     */
	    function isExpansionCaseStart(peek) {
	        return peek === $EQ || isAsciiLetter(peek);
	    }
	    /**
	     * @param {?} code1
	     * @param {?} code2
	     * @return {?}
	     */
	    function compareCharCodeCaseInsensitive(code1, code2) {
	        return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
	    }
	    /**
	     * @param {?} code
	     * @return {?}
	     */
	    function toUpperCaseCharCode(code) {
	        return code >= $a && code <= $z ? code - $a + $A : code;
	    }
	    /**
	     * @param {?} srcTokens
	     * @return {?}
	     */
	    function mergeTextTokens(srcTokens) {
	        var /** @type {?} */ dstTokens = [];
	        var /** @type {?} */ lastDstToken;
	        for (var /** @type {?} */ i = 0; i < srcTokens.length; i++) {
	            var /** @type {?} */ token = srcTokens[i];
	            if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {
	                lastDstToken.parts[0] += token.parts[0];
	                lastDstToken.sourceSpan.end = token.sourceSpan.end;
	            }
	            else {
	                lastDstToken = token;
	                dstTokens.push(lastDstToken);
	            }
	        }
	        return dstTokens;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var TreeError = (function (_super) {
	        __extends$5(TreeError, _super);
	        /**
	         * @param {?} elementName
	         * @param {?} span
	         * @param {?} msg
	         */
	        function TreeError(elementName, span, msg) {
	            _super.call(this, span, msg);
	            this.elementName = elementName;
	        }
	        /**
	         * @param {?} elementName
	         * @param {?} span
	         * @param {?} msg
	         * @return {?}
	         */
	        TreeError.create = function (elementName, span, msg) {
	            return new TreeError(elementName, span, msg);
	        };
	        return TreeError;
	    }(ParseError));
	    var ParseTreeResult = (function () {
	        /**
	         * @param {?} rootNodes
	         * @param {?} errors
	         */
	        function ParseTreeResult(rootNodes, errors) {
	            this.rootNodes = rootNodes;
	            this.errors = errors;
	        }
	        return ParseTreeResult;
	    }());
	    var Parser$1 = (function () {
	        /**
	         * @param {?} getTagDefinition
	         */
	        function Parser(getTagDefinition) {
	            this.getTagDefinition = getTagDefinition;
	        }
	        /**
	         * @param {?} source
	         * @param {?} url
	         * @param {?=} parseExpansionForms
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        Parser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
	            if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            var /** @type {?} */ tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);
	            var /** @type {?} */ treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
	            return new ParseTreeResult(treeAndErrors.rootNodes, ((tokensAndErrors.errors)).concat(treeAndErrors.errors));
	        };
	        return Parser;
	    }());
	    var _TreeBuilder = (function () {
	        /**
	         * @param {?} tokens
	         * @param {?} getTagDefinition
	         */
	        function _TreeBuilder(tokens, getTagDefinition) {
	            this.tokens = tokens;
	            this.getTagDefinition = getTagDefinition;
	            this._index = -1;
	            this._rootNodes = [];
	            this._errors = [];
	            this._elementStack = [];
	            this._advance();
	        }
	        /**
	         * @return {?}
	         */
	        _TreeBuilder.prototype.build = function () {
	            while (this._peek.type !== TokenType$1.EOF) {
	                if (this._peek.type === TokenType$1.TAG_OPEN_START) {
	                    this._consumeStartTag(this._advance());
	                }
	                else if (this._peek.type === TokenType$1.TAG_CLOSE) {
	                    this._consumeEndTag(this._advance());
	                }
	                else if (this._peek.type === TokenType$1.CDATA_START) {
	                    this._closeVoidElement();
	                    this._consumeCdata(this._advance());
	                }
	                else if (this._peek.type === TokenType$1.COMMENT_START) {
	                    this._closeVoidElement();
	                    this._consumeComment(this._advance());
	                }
	                else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||
	                    this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {
	                    this._closeVoidElement();
	                    this._consumeText(this._advance());
	                }
	                else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {
	                    this._consumeExpansion(this._advance());
	                }
	                else {
	                    // Skip all other tokens...
	                    this._advance();
	                }
	            }
	            return new ParseTreeResult(this._rootNodes, this._errors);
	        };
	        /**
	         * @return {?}
	         */
	        _TreeBuilder.prototype._advance = function () {
	            var /** @type {?} */ prev = this._peek;
	            if (this._index < this.tokens.length - 1) {
	                // Note: there is always an EOF token at the end
	                this._index++;
	            }
	            this._peek = this.tokens[this._index];
	            return prev;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        _TreeBuilder.prototype._advanceIf = function (type) {
	            if (this._peek.type === type) {
	                return this._advance();
	            }
	            return null;
	        };
	        /**
	         * @param {?} startToken
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeCdata = function (startToken) {
	            this._consumeText(this._advance());
	            this._advanceIf(TokenType$1.CDATA_END);
	        };
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeComment = function (token) {
	            var /** @type {?} */ text = this._advanceIf(TokenType$1.RAW_TEXT);
	            this._advanceIf(TokenType$1.COMMENT_END);
	            var /** @type {?} */ value = isPresent(text) ? text.parts[0].trim() : null;
	            this._addToParent(new Comment(value, token.sourceSpan));
	        };
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeExpansion = function (token) {
	            var /** @type {?} */ switchValue = this._advance();
	            var /** @type {?} */ type = this._advance();
	            var /** @type {?} */ cases = [];
	            // read =
	            while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {
	                var /** @type {?} */ expCase = this._parseExpansionCase();
	                if (!expCase)
	                    return; // error
	                cases.push(expCase);
	            }
	            // read the final }
	            if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {
	                this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
	                return;
	            }
	            var /** @type {?} */ sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
	            this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
	            this._advance();
	        };
	        /**
	         * @return {?}
	         */
	        _TreeBuilder.prototype._parseExpansionCase = function () {
	            var /** @type {?} */ value = this._advance();
	            // read {
	            if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {
	                this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
	                return null;
	            }
	            // read until }
	            var /** @type {?} */ start = this._advance();
	            var /** @type {?} */ exp = this._collectExpansionExpTokens(start);
	            if (!exp)
	                return null;
	            var /** @type {?} */ end = this._advance();
	            exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));
	            // parse everything in between { and }
	            var /** @type {?} */ parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
	            if (parsedExp.errors.length > 0) {
	                this._errors = this._errors.concat(/** @type {?} */ (parsedExp.errors));
	                return null;
	            }
	            var /** @type {?} */ sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
	            var /** @type {?} */ expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
	            return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
	        };
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {
	            var /** @type {?} */ exp = [];
	            var /** @type {?} */ expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];
	            while (true) {
	                if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||
	                    this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {
	                    expansionFormStack.push(this._peek.type);
	                }
	                if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {
	                    if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {
	                        expansionFormStack.pop();
	                        if (expansionFormStack.length == 0)
	                            return exp;
	                    }
	                    else {
	                        this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
	                        return null;
	                    }
	                }
	                if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {
	                    if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {
	                        expansionFormStack.pop();
	                    }
	                    else {
	                        this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
	                        return null;
	                    }
	                }
	                if (this._peek.type === TokenType$1.EOF) {
	                    this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
	                    return null;
	                }
	                exp.push(this._advance());
	            }
	        };
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeText = function (token) {
	            var /** @type {?} */ text = token.parts[0];
	            if (text.length > 0 && text[0] == '\n') {
	                var /** @type {?} */ parent_1 = this._getParentElement();
	                if (isPresent(parent_1) && parent_1.children.length == 0 &&
	                    this.getTagDefinition(parent_1.name).ignoreFirstLf) {
	                    text = text.substring(1);
	                }
	            }
	            if (text.length > 0) {
	                this._addToParent(new Text(text, token.sourceSpan));
	            }
	        };
	        /**
	         * @return {?}
	         */
	        _TreeBuilder.prototype._closeVoidElement = function () {
	            if (this._elementStack.length > 0) {
	                var /** @type {?} */ el = this._elementStack[this._elementStack.length - 1];
	                if (this.getTagDefinition(el.name).isVoid) {
	                    this._elementStack.pop();
	                }
	            }
	        };
	        /**
	         * @param {?} startTagToken
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {
	            var /** @type {?} */ prefix = startTagToken.parts[0];
	            var /** @type {?} */ name = startTagToken.parts[1];
	            var /** @type {?} */ attrs = [];
	            while (this._peek.type === TokenType$1.ATTR_NAME) {
	                attrs.push(this._consumeAttr(this._advance()));
	            }
	            var /** @type {?} */ fullName = this._getElementFullName(prefix, name, this._getParentElement());
	            var /** @type {?} */ selfClosing = false;
	            // Note: There could have been a tokenizer error
	            // so that we don't get a token for the end tag...
	            if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {
	                this._advance();
	                selfClosing = true;
	                var /** @type {?} */ tagDef = this.getTagDefinition(fullName);
	                if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
	                    this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
	                }
	            }
	            else if (this._peek.type === TokenType$1.TAG_OPEN_END) {
	                this._advance();
	                selfClosing = false;
	            }
	            var /** @type {?} */ end = this._peek.sourceSpan.start;
	            var /** @type {?} */ span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
	            var /** @type {?} */ el = new Element(fullName, attrs, [], span, span, null);
	            this._pushElement(el);
	            if (selfClosing) {
	                this._popElement(fullName);
	                el.endSourceSpan = span;
	            }
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        _TreeBuilder.prototype._pushElement = function (el) {
	            if (this._elementStack.length > 0) {
	                var /** @type {?} */ parentEl = this._elementStack[this._elementStack.length - 1];
	                if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
	                    this._elementStack.pop();
	                }
	            }
	            var /** @type {?} */ tagDef = this.getTagDefinition(el.name);
	            var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;
	            if (parent && tagDef.requireExtraParent(parent.name)) {
	                var /** @type {?} */ newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
	                this._insertBeforeContainer(parent, container, newParent);
	            }
	            this._addToParent(el);
	            this._elementStack.push(el);
	        };
	        /**
	         * @param {?} endTagToken
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {
	            var /** @type {?} */ fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
	            if (this._getParentElement()) {
	                this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
	            }
	            if (this.getTagDefinition(fullName).isVoid) {
	                this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
	            }
	            else if (!this._popElement(fullName)) {
	                this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
	            }
	        };
	        /**
	         * @param {?} fullName
	         * @return {?}
	         */
	        _TreeBuilder.prototype._popElement = function (fullName) {
	            for (var /** @type {?} */ stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
	                var /** @type {?} */ el = this._elementStack[stackIndex];
	                if (el.name == fullName) {
	                    this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
	                    return true;
	                }
	                if (!this.getTagDefinition(el.name).closedByParent) {
	                    return false;
	                }
	            }
	            return false;
	        };
	        /**
	         * @param {?} attrName
	         * @return {?}
	         */
	        _TreeBuilder.prototype._consumeAttr = function (attrName) {
	            var /** @type {?} */ fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
	            var /** @type {?} */ end = attrName.sourceSpan.end;
	            var /** @type {?} */ value = '';
	            var /** @type {?} */ valueSpan;
	            if (this._peek.type === TokenType$1.ATTR_VALUE) {
	                var /** @type {?} */ valueToken = this._advance();
	                value = valueToken.parts[0];
	                end = valueToken.sourceSpan.end;
	                valueSpan = valueToken.sourceSpan;
	            }
	            return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
	        };
	        /**
	         * @return {?}
	         */
	        _TreeBuilder.prototype._getParentElement = function () {
	            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
	        };
	        /**
	         * Returns the parent in the DOM and the container.
	         *
	         * `<ng-container>` elements are skipped as they are not rendered as DOM element.
	         * @return {?}
	         */
	        _TreeBuilder.prototype._getParentElementSkippingContainers = function () {
	            var /** @type {?} */ container = null;
	            for (var /** @type {?} */ i = this._elementStack.length - 1; i >= 0; i--) {
	                if (this._elementStack[i].name !== 'ng-container') {
	                    return { parent: this._elementStack[i], container: container };
	                }
	                container = this._elementStack[i];
	            }
	            return { parent: this._elementStack[this._elementStack.length - 1], container: container };
	        };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        _TreeBuilder.prototype._addToParent = function (node) {
	            var /** @type {?} */ parent = this._getParentElement();
	            if (isPresent(parent)) {
	                parent.children.push(node);
	            }
	            else {
	                this._rootNodes.push(node);
	            }
	        };
	        /**
	         * Insert a node between the parent and the container.
	         * When no container is given, the node is appended as a child of the parent.
	         * Also updates the element stack accordingly.
	         *
	         * \@internal
	         * @param {?} parent
	         * @param {?} container
	         * @param {?} node
	         * @return {?}
	         */
	        _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {
	            if (!container) {
	                this._addToParent(node);
	                this._elementStack.push(node);
	            }
	            else {
	                if (parent) {
	                    // replace the container with the new node in the children
	                    var /** @type {?} */ index = parent.children.indexOf(container);
	                    parent.children[index] = node;
	                }
	                else {
	                    this._rootNodes.push(node);
	                }
	                node.children.push(container);
	                this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
	            }
	        };
	        /**
	         * @param {?} prefix
	         * @param {?} localName
	         * @param {?} parentElement
	         * @return {?}
	         */
	        _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {
	            if (isBlank(prefix)) {
	                prefix = this.getTagDefinition(localName).implicitNamespacePrefix;
	                if (isBlank(prefix) && isPresent(parentElement)) {
	                    prefix = getNsPrefix(parentElement.name);
	                }
	            }
	            return mergeNsAndName(prefix, localName);
	        };
	        return _TreeBuilder;
	    }());
	    /**
	     * @param {?} stack
	     * @param {?} element
	     * @return {?}
	     */
	    function lastOnStack(stack, element) {
	        return stack.length > 0 && stack[stack.length - 1] === element;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var Message = (function () {
	        /**
	         * @param {?} nodes message AST
	         * @param {?} placeholders maps placeholder names to static content
	         * @param {?} placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
	         * @param {?} meaning
	         * @param {?} description
	         */
	        function Message(nodes, placeholders, placeholderToMessage, meaning, description) {
	            this.nodes = nodes;
	            this.placeholders = placeholders;
	            this.placeholderToMessage = placeholderToMessage;
	            this.meaning = meaning;
	            this.description = description;
	        }
	        return Message;
	    }());
	    var Text$1 = (function () {
	        /**
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function Text(value, sourceSpan) {
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
	        return Text;
	    }());
	    var Container = (function () {
	        /**
	         * @param {?} children
	         * @param {?} sourceSpan
	         */
	        function Container(children, sourceSpan) {
	            this.children = children;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };
	        return Container;
	    }());
	    var Icu = (function () {
	        /**
	         * @param {?} expression
	         * @param {?} type
	         * @param {?} cases
	         * @param {?} sourceSpan
	         */
	        function Icu(expression, type, cases, sourceSpan) {
	            this.expression = expression;
	            this.type = type;
	            this.cases = cases;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };
	        return Icu;
	    }());
	    var TagPlaceholder = (function () {
	        /**
	         * @param {?} tag
	         * @param {?} attrs
	         * @param {?} startName
	         * @param {?} closeName
	         * @param {?} children
	         * @param {?} isVoid
	         * @param {?} sourceSpan
	         */
	        function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
	            this.tag = tag;
	            this.attrs = attrs;
	            this.startName = startName;
	            this.closeName = closeName;
	            this.children = children;
	            this.isVoid = isVoid;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };
	        return TagPlaceholder;
	    }());
	    var Placeholder = (function () {
	        /**
	         * @param {?} value
	         * @param {?} name
	         * @param {?} sourceSpan
	         */
	        function Placeholder(value, name, sourceSpan) {
	            this.value = value;
	            this.name = name;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };
	        return Placeholder;
	    }());
	    var IcuPlaceholder = (function () {
	        /**
	         * @param {?} value
	         * @param {?} name
	         * @param {?} sourceSpan
	         */
	        function IcuPlaceholder(value, name, sourceSpan) {
	            this.value = value;
	            this.name = name;
	            this.sourceSpan = sourceSpan;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?=} context
	         * @return {?}
	         */
	        IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };
	        return IcuPlaceholder;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ TAG_TO_PLACEHOLDER_NAMES = {
	        'A': 'LINK',
	        'B': 'BOLD_TEXT',
	        'BR': 'LINE_BREAK',
	        'EM': 'EMPHASISED_TEXT',
	        'H1': 'HEADING_LEVEL1',
	        'H2': 'HEADING_LEVEL2',
	        'H3': 'HEADING_LEVEL3',
	        'H4': 'HEADING_LEVEL4',
	        'H5': 'HEADING_LEVEL5',
	        'H6': 'HEADING_LEVEL6',
	        'HR': 'HORIZONTAL_RULE',
	        'I': 'ITALIC_TEXT',
	        'LI': 'LIST_ITEM',
	        'LINK': 'MEDIA_LINK',
	        'OL': 'ORDERED_LIST',
	        'P': 'PARAGRAPH',
	        'Q': 'QUOTATION',
	        'S': 'STRIKETHROUGH_TEXT',
	        'SMALL': 'SMALL_TEXT',
	        'SUB': 'SUBSTRIPT',
	        'SUP': 'SUPERSCRIPT',
	        'TBODY': 'TABLE_BODY',
	        'TD': 'TABLE_CELL',
	        'TFOOT': 'TABLE_FOOTER',
	        'TH': 'TABLE_HEADER_CELL',
	        'THEAD': 'TABLE_HEADER',
	        'TR': 'TABLE_ROW',
	        'TT': 'MONOSPACED_TEXT',
	        'U': 'UNDERLINED_TEXT',
	        'UL': 'UNORDERED_LIST',
	    };
	    /**
	     * Creates unique names for placeholder with different content.
	     *
	     * Returns the same placeholder name when the content is identical.
	     *
	     * \@internal
	     */
	    var PlaceholderRegistry = (function () {
	        function PlaceholderRegistry() {
	            this._placeHolderNameCounts = {};
	            this._signatureToName = {};
	        }
	        /**
	         * @param {?} tag
	         * @param {?} attrs
	         * @param {?} isVoid
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {
	            var /** @type {?} */ signature = this._hashTag(tag, attrs, isVoid);
	            if (this._signatureToName[signature]) {
	                return this._signatureToName[signature];
	            }
	            var /** @type {?} */ upperTag = tag.toUpperCase();
	            var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
	            var /** @type {?} */ name = this._generateUniqueName(isVoid ? baseName : "START_" + baseName);
	            this._signatureToName[signature] = name;
	            return name;
	        };
	        /**
	         * @param {?} tag
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {
	            var /** @type {?} */ signature = this._hashClosingTag(tag);
	            if (this._signatureToName[signature]) {
	                return this._signatureToName[signature];
	            }
	            var /** @type {?} */ upperTag = tag.toUpperCase();
	            var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
	            var /** @type {?} */ name = this._generateUniqueName("CLOSE_" + baseName);
	            this._signatureToName[signature] = name;
	            return name;
	        };
	        /**
	         * @param {?} name
	         * @param {?} content
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {
	            var /** @type {?} */ upperName = name.toUpperCase();
	            var /** @type {?} */ signature = "PH: " + upperName + "=" + content;
	            if (this._signatureToName[signature]) {
	                return this._signatureToName[signature];
	            }
	            var /** @type {?} */ uniqueName = this._generateUniqueName(upperName);
	            this._signatureToName[signature] = uniqueName;
	            return uniqueName;
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {
	            return this._generateUniqueName(name.toUpperCase());
	        };
	        /**
	         * @param {?} tag
	         * @param {?} attrs
	         * @param {?} isVoid
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {
	            var /** @type {?} */ start = "<" + tag;
	            var /** @type {?} */ strAttrs = Object.keys(attrs).sort().map(function (name) { return (" " + name + "=" + attrs[name]); }).join('');
	            var /** @type {?} */ end = isVoid ? '/>' : "></" + tag + ">";
	            return start + strAttrs + end;
	        };
	        /**
	         * @param {?} tag
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag("/" + tag, {}, false); };
	        /**
	         * @param {?} base
	         * @return {?}
	         */
	        PlaceholderRegistry.prototype._generateUniqueName = function (base) {
	            var /** @type {?} */ seen = this._placeHolderNameCounts.hasOwnProperty(base);
	            if (!seen) {
	                this._placeHolderNameCounts[base] = 1;
	                return base;
	            }
	            var /** @type {?} */ id = this._placeHolderNameCounts[base];
	            this._placeHolderNameCounts[base] = id + 1;
	            return base + "_" + id;
	        };
	        return PlaceholderRegistry;
	    }());

	    var /** @type {?} */ _expParser = new Parser(new Lexer());
	    /**
	     * Returns a function converting html nodes to an i18n Message given an interpolationConfig
	     * @param {?} interpolationConfig
	     * @return {?}
	     */
	    function createI18nMessageFactory(interpolationConfig) {
	        var /** @type {?} */ visitor = new _I18nVisitor(_expParser, interpolationConfig);
	        return function (nodes, meaning, description) {
	            return visitor.toI18nMessage(nodes, meaning, description);
	        };
	    }
	    var _I18nVisitor = (function () {
	        /**
	         * @param {?} _expressionParser
	         * @param {?} _interpolationConfig
	         */
	        function _I18nVisitor(_expressionParser, _interpolationConfig) {
	            this._expressionParser = _expressionParser;
	            this._interpolationConfig = _interpolationConfig;
	        }
	        /**
	         * @param {?} nodes
	         * @param {?} meaning
	         * @param {?} description
	         * @return {?}
	         */
	        _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description) {
	            this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;
	            this._icuDepth = 0;
	            this._placeholderRegistry = new PlaceholderRegistry();
	            this._placeholderToContent = {};
	            this._placeholderToMessage = {};
	            var /** @type {?} */ i18nodes = visitAll(this, nodes, {});
	            return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description);
	        };
	        /**
	         * @param {?} el
	         * @param {?} context
	         * @return {?}
	         */
	        _I18nVisitor.prototype.visitElement = function (el, context) {
	            var /** @type {?} */ children = visitAll(this, el.children);
	            var /** @type {?} */ attrs = {};
	            el.attrs.forEach(function (attr) {
	                // Do not visit the attributes, translatable ones are top-level ASTs
	                attrs[attr.name] = attr.value;
	            });
	            var /** @type {?} */ isVoid = getHtmlTagDefinition(el.name).isVoid;
	            var /** @type {?} */ startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
	            this._placeholderToContent[startPhName] = el.sourceSpan.toString();
	            var /** @type {?} */ closePhName = '';
	            if (!isVoid) {
	                closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
	                this._placeholderToContent[closePhName] = "</" + el.name + ">";
	            }
	            return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
	        };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        _I18nVisitor.prototype.visitAttribute = function (attribute, context) {
	            return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
	        };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        _I18nVisitor.prototype.visitText = function (text, context) {
	            return this._visitTextWithInterpolation(text.value, text.sourceSpan);
	        };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        _I18nVisitor.prototype.visitExpansion = function (icu, context) {
	            var _this = this;
	            this._icuDepth++;
	            var /** @type {?} */ i18nIcuCases = {};
	            var /** @type {?} */ i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
	            icu.cases.forEach(function (caze) {
	                i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);
	            });
	            this._icuDepth--;
	            if (this._isIcu || this._icuDepth > 0) {
	                // Returns an ICU node when:
	                // - the message (vs a part of the message) is an ICU message, or
	                // - the ICU message is nested.
	                var /** @type {?} */ expPh = this._placeholderRegistry.getUniquePlaceholder("VAR_" + icu.type);
	                i18nIcu.expressionPlaceholder = expPh;
	                this._placeholderToContent[expPh] = icu.switchValue;
	                return i18nIcu;
	            }
	            // Else returns a placeholder
	            // ICU placeholders should not be replaced with their original content but with the their
	            // translations. We need to create a new visitor (they are not re-entrant) to compute the
	            // message id.
	            // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
	            var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
	            var /** @type {?} */ visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);
	            this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '');
	            return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
	        };
	        /**
	         * @param {?} icuCase
	         * @param {?} context
	         * @return {?}
	         */
	        _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {
	            throw new Error('Unreachable code');
	        };
	        /**
	         * @param {?} text
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {
	            var /** @type {?} */ splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
	            if (!splitInterpolation) {
	                // No expression, return a single text
	                return new Text$1(text, sourceSpan);
	            }
	            // Return a group of text + expressions
	            var /** @type {?} */ nodes = [];
	            var /** @type {?} */ container = new Container(nodes, sourceSpan);
	            var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;
	            for (var /** @type {?} */ i = 0; i < splitInterpolation.strings.length - 1; i++) {
	                var /** @type {?} */ expression = splitInterpolation.expressions[i];
	                var /** @type {?} */ baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
	                var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
	                if (splitInterpolation.strings[i].length) {
	                    // No need to add empty strings
	                    nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
	                }
	                nodes.push(new Placeholder(expression, phName, sourceSpan));
	                this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
	            }
	            // The last index contains no expression
	            var /** @type {?} */ lastStringIdx = splitInterpolation.strings.length - 1;
	            if (splitInterpolation.strings[lastStringIdx].length) {
	                nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
	            }
	            return container;
	        };
	        return _I18nVisitor;
	    }());
	    var /** @type {?} */ _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*"([\s\S]*?)"[\s\S]*\)/g;
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function _extractPlaceholderName(input) {
	        return input.split(_CUSTOM_PH_EXP)[1];
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * An i18n error.
	     */
	    var I18nError = (function (_super) {
	        __extends$7(I18nError, _super);
	        /**
	         * @param {?} span
	         * @param {?} msg
	         */
	        function I18nError(span, msg) {
	            _super.call(this, span, msg);
	        }
	        return I18nError;
	    }(ParseError));

	    var /** @type {?} */ _I18N_ATTR = 'i18n';
	    var /** @type {?} */ _I18N_ATTR_PREFIX = 'i18n-';
	    var /** @type {?} */ _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
	    /**
	     * Extract translatable messages from an html AST
	     * @param {?} nodes
	     * @param {?} interpolationConfig
	     * @param {?} implicitTags
	     * @param {?} implicitAttrs
	     * @return {?}
	     */
	    function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
	        var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);
	        return visitor.extract(nodes, interpolationConfig);
	    }
	    /**
	     * @param {?} nodes
	     * @param {?} translations
	     * @param {?} interpolationConfig
	     * @param {?} implicitTags
	     * @param {?} implicitAttrs
	     * @return {?}
	     */
	    function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
	        var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);
	        return visitor.merge(nodes, translations, interpolationConfig);
	    }
	    var ExtractionResult = (function () {
	        /**
	         * @param {?} messages
	         * @param {?} errors
	         */
	        function ExtractionResult(messages, errors) {
	            this.messages = messages;
	            this.errors = errors;
	        }
	        return ExtractionResult;
	    }());
	    var _VisitorMode = {};
	    _VisitorMode.Extract = 0;
	    _VisitorMode.Merge = 1;
	    _VisitorMode[_VisitorMode.Extract] = "Extract";
	    _VisitorMode[_VisitorMode.Merge] = "Merge";
	    /**
	     * This Visitor is used:
	     * 1. to extract all the translatable strings from an html AST (see `extract()`),
	     * 2. to replace the translatable strings with the actual translations (see `merge()`)
	     *
	     * \@internal
	     */
	    var _Visitor = (function () {
	        /**
	         * @param {?} _implicitTags
	         * @param {?} _implicitAttrs
	         */
	        function _Visitor(_implicitTags, _implicitAttrs) {
	            this._implicitTags = _implicitTags;
	            this._implicitAttrs = _implicitAttrs;
	        }
	        /**
	         * Extracts the messages from the tree
	         * @param {?} nodes
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        _Visitor.prototype.extract = function (nodes, interpolationConfig) {
	            var _this = this;
	            this._init(_VisitorMode.Extract, interpolationConfig);
	            nodes.forEach(function (node) { return node.visit(_this, null); });
	            if (this._inI18nBlock) {
	                this._reportError(nodes[nodes.length - 1], 'Unclosed block');
	            }
	            return new ExtractionResult(this._messages, this._errors);
	        };
	        /**
	         * Returns a tree where all translatable nodes are translated
	         * @param {?} nodes
	         * @param {?} translations
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {
	            this._init(_VisitorMode.Merge, interpolationConfig);
	            this._translations = translations;
	            // Construct a single fake root element
	            var /** @type {?} */ wrapper = new Element('wrapper', [], nodes, null, null, null);
	            var /** @type {?} */ translatedNode = wrapper.visit(this, null);
	            if (this._inI18nBlock) {
	                this._reportError(nodes[nodes.length - 1], 'Unclosed block');
	            }
	            return new ParseTreeResult(translatedNode.children, this._errors);
	        };
	        /**
	         * @param {?} icuCase
	         * @param {?} context
	         * @return {?}
	         */
	        _Visitor.prototype.visitExpansionCase = function (icuCase, context) {
	            // Parse cases for translatable html attributes
	            var /** @type {?} */ expression = visitAll(this, icuCase.expression, context);
	            if (this._mode === _VisitorMode.Merge) {
	                return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
	            }
	        };
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        _Visitor.prototype.visitExpansion = function (icu, context) {
	            this._mayBeAddBlockChildren(icu);
	            var /** @type {?} */ wasInIcu = this._inIcu;
	            if (!this._inIcu) {
	                // nested ICU messages should not be extracted but top-level translated as a whole
	                if (this._isInTranslatableSection) {
	                    this._addMessage([icu]);
	                }
	                this._inIcu = true;
	            }
	            var /** @type {?} */ cases = visitAll(this, icu.cases, context);
	            if (this._mode === _VisitorMode.Merge) {
	                icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
	            }
	            this._inIcu = wasInIcu;
	            return icu;
	        };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        _Visitor.prototype.visitComment = function (comment, context) {
	            var /** @type {?} */ isOpening = _isOpeningComment(comment);
	            if (isOpening && this._isInTranslatableSection) {
	                this._reportError(comment, 'Could not start a block inside a translatable section');
	                return;
	            }
	            var /** @type {?} */ isClosing = _isClosingComment(comment);
	            if (isClosing && !this._inI18nBlock) {
	                this._reportError(comment, 'Trying to close an unopened block');
	                return;
	            }
	            if (!this._inI18nNode && !this._inIcu) {
	                if (!this._inI18nBlock) {
	                    if (isOpening) {
	                        this._inI18nBlock = true;
	                        this._blockStartDepth = this._depth;
	                        this._blockChildren = [];
	                        this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
	                        this._openTranslatableSection(comment);
	                    }
	                }
	                else {
	                    if (isClosing) {
	                        if (this._depth == this._blockStartDepth) {
	                            this._closeTranslatableSection(comment, this._blockChildren);
	                            this._inI18nBlock = false;
	                            var /** @type {?} */ message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
	                            // merge attributes in sections
	                            var /** @type {?} */ nodes = this._translateMessage(comment, message);
	                            return visitAll(this, nodes);
	                        }
	                        else {
	                            this._reportError(comment, 'I18N blocks should not cross element boundaries');
	                            return;
	                        }
	                    }
	                }
	            }
	        };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        _Visitor.prototype.visitText = function (text, context) {
	            if (this._isInTranslatableSection) {
	                this._mayBeAddBlockChildren(text);
	            }
	            return text;
	        };
	        /**
	         * @param {?} el
	         * @param {?} context
	         * @return {?}
	         */
	        _Visitor.prototype.visitElement = function (el, context) {
	            var _this = this;
	            this._mayBeAddBlockChildren(el);
	            this._depth++;
	            var /** @type {?} */ wasInI18nNode = this._inI18nNode;
	            var /** @type {?} */ wasInImplicitNode = this._inImplicitNode;
	            var /** @type {?} */ childNodes = [];
	            var /** @type {?} */ translatedChildNodes;
	            // Extract:
	            // - top level nodes with the (implicit) "i18n" attribute if not already in a section
	            // - ICU messages
	            var /** @type {?} */ i18nAttr = _getI18nAttr(el);
	            var /** @type {?} */ i18nMeta = i18nAttr ? i18nAttr.value : '';
	            var /** @type {?} */ isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&
	                !this._isInTranslatableSection;
	            var /** @type {?} */ isTopLevelImplicit = !wasInImplicitNode && isImplicit;
	            this._inImplicitNode = wasInImplicitNode || isImplicit;
	            if (!this._isInTranslatableSection && !this._inIcu) {
	                if (i18nAttr || isTopLevelImplicit) {
	                    this._inI18nNode = true;
	                    var /** @type {?} */ message = this._addMessage(el.children, i18nMeta);
	                    translatedChildNodes = this._translateMessage(el, message);
	                }
	                if (this._mode == _VisitorMode.Extract) {
	                    var /** @type {?} */ isTranslatable = i18nAttr || isTopLevelImplicit;
	                    if (isTranslatable)
	                        this._openTranslatableSection(el);
	                    visitAll(this, el.children);
	                    if (isTranslatable)
	                        this._closeTranslatableSection(el, el.children);
	                }
	            }
	            else {
	                if (i18nAttr || isTopLevelImplicit) {
	                    this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
	                }
	                if (this._mode == _VisitorMode.Extract) {
	                    // Descend into child nodes for extraction
	                    visitAll(this, el.children);
	                }
	            }
	            if (this._mode === _VisitorMode.Merge) {
	                var /** @type {?} */ visitNodes = translatedChildNodes || el.children;
	                visitNodes.forEach(function (child) {
	                    var /** @type {?} */ visited = child.visit(_this, context);
	                    if (visited && !_this._isInTranslatableSection) {
	                        // Do not add the children from translatable sections (= i18n blocks here)
	                        // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)
	                        childNodes = childNodes.concat(visited);
	                    }
	                });
	            }
	            this._visitAttributesOf(el);
	            this._depth--;
	            this._inI18nNode = wasInI18nNode;
	            this._inImplicitNode = wasInImplicitNode;
	            if (this._mode === _VisitorMode.Merge) {
	                var /** @type {?} */ translatedAttrs = this._translateAttributes(el);
	                return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
	            }
	        };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        _Visitor.prototype.visitAttribute = function (attribute, context) {
	            throw new Error('unreachable code');
	        };
	        /**
	         * @param {?} mode
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        _Visitor.prototype._init = function (mode, interpolationConfig) {
	            this._mode = mode;
	            this._inI18nBlock = false;
	            this._inI18nNode = false;
	            this._depth = 0;
	            this._inIcu = false;
	            this._msgCountAtSectionStart = void 0;
	            this._errors = [];
	            this._messages = [];
	            this._inImplicitNode = false;
	            this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        _Visitor.prototype._visitAttributesOf = function (el) {
	            var _this = this;
	            var /** @type {?} */ explicitAttrNameToValue = {};
	            var /** @type {?} */ implicitAttrNames = this._implicitAttrs[el.name] || [];
	            el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })
	                .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
	                attr.value; });
	            el.attrs.forEach(function (attr) {
	                if (attr.name in explicitAttrNameToValue) {
	                    _this._addMessage([attr], explicitAttrNameToValue[attr.name]);
	                }
	                else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {
	                    _this._addMessage([attr]);
	                }
	            });
	        };
	        /**
	         * @param {?} ast
	         * @param {?=} meaningAndDesc
	         * @return {?}
	         */
	        _Visitor.prototype._addMessage = function (ast, meaningAndDesc) {
	            if (ast.length == 0 ||
	                ast.length == 1 && ast[0] instanceof Attribute$1 && !((ast[0])).value) {
	                // Do not create empty messages
	                return;
	            }
	            var _a = _splitMeaningAndDesc(meaningAndDesc), meaning = _a[0], description = _a[1];
	            var /** @type {?} */ message = this._createI18nMessage(ast, meaning, description);
	            this._messages.push(message);
	            return message;
	        };
	        /**
	         * @param {?} el
	         * @param {?} message
	         * @return {?}
	         */
	        _Visitor.prototype._translateMessage = function (el, message) {
	            if (message && this._mode === _VisitorMode.Merge) {
	                var /** @type {?} */ nodes = this._translations.get(message);
	                if (nodes) {
	                    return nodes;
	                }
	                this._reportError(el, "Translation unavailable for message id=\"" + this._translations.digest(message) + "\"");
	            }
	            return [];
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        _Visitor.prototype._translateAttributes = function (el) {
	            var _this = this;
	            var /** @type {?} */ attributes = el.attrs;
	            var /** @type {?} */ i18nAttributeMeanings = {};
	            attributes.forEach(function (attr) {
	                if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
	                    i18nAttributeMeanings[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
	                        _splitMeaningAndDesc(attr.value)[0];
	                }
	            });
	            var /** @type {?} */ translatedAttributes = [];
	            attributes.forEach(function (attr) {
	                if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
	                    // strip i18n specific attributes
	                    return;
	                }
	                if (attr.value && attr.value != '' && i18nAttributeMeanings.hasOwnProperty(attr.name)) {
	                    var /** @type {?} */ meaning = i18nAttributeMeanings[attr.name];
	                    var /** @type {?} */ message = _this._createI18nMessage([attr], meaning, '');
	                    var /** @type {?} */ nodes = _this._translations.get(message);
	                    if (nodes) {
	                        if (nodes.length == 0) {
	                            translatedAttributes.push(new Attribute$1(attr.name, '', attr.sourceSpan));
	                        }
	                        else if (nodes[0] instanceof Text) {
	                            var /** @type {?} */ value = ((nodes[0])).value;
	                            translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));
	                        }
	                        else {
	                            _this._reportError(el, "Unexpected translation for attribute \"" + attr.name + "\" (id=\"" + _this._translations.digest(message) + "\")");
	                        }
	                    }
	                    else {
	                        _this._reportError(el, "Translation unavailable for attribute \"" + attr.name + "\" (id=\"" + _this._translations.digest(message) + "\")");
	                    }
	                }
	                else {
	                    translatedAttributes.push(attr);
	                }
	            });
	            return translatedAttributes;
	        };
	        /**
	         * Add the node as a child of the block when:
	         * - we are in a block,
	         * - we are not inside a ICU message (those are handled separately),
	         * - the node is a "direct child" of the block
	         * @param {?} node
	         * @return {?}
	         */
	        _Visitor.prototype._mayBeAddBlockChildren = function (node) {
	            if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
	                this._blockChildren.push(node);
	            }
	        };
	        /**
	         * Marks the start of a section, see `_closeTranslatableSection`
	         * @param {?} node
	         * @return {?}
	         */
	        _Visitor.prototype._openTranslatableSection = function (node) {
	            if (this._isInTranslatableSection) {
	                this._reportError(node, 'Unexpected section start');
	            }
	            else {
	                this._msgCountAtSectionStart = this._messages.length;
	            }
	        };
	        Object.defineProperty(_Visitor.prototype, "_isInTranslatableSection", {
	            /**
	             * A translatable section could be:
	             * - the content of translatable element,
	             * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
	             * @return {?}
	             */
	            get: function () {
	                return this._msgCountAtSectionStart !== void 0;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Terminates a section.
	         *
	         * If a section has only one significant children (comments not significant) then we should not
	         * keep the message from this children:
	         *
	         * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
	         * - one for the <p> content with meaning and description,
	         * - another one for the ICU message.
	         *
	         * In this case the last message is discarded as it contains less information (the AST is
	         * otherwise identical).
	         *
	         * Note that we should still keep messages extracted from attributes inside the section (ie in the
	         * ICU message here)
	         * @param {?} node
	         * @param {?} directChildren
	         * @return {?}
	         */
	        _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {
	            if (!this._isInTranslatableSection) {
	                this._reportError(node, 'Unexpected section end');
	                return;
	            }
	            var /** @type {?} */ startIndex = this._msgCountAtSectionStart;
	            var /** @type {?} */ significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);
	            if (significantChildren == 1) {
	                for (var /** @type {?} */ i = this._messages.length - 1; i >= startIndex; i--) {
	                    var /** @type {?} */ ast = this._messages[i].nodes;
	                    if (!(ast.length == 1 && ast[0] instanceof Text$1)) {
	                        this._messages.splice(i, 1);
	                        break;
	                    }
	                }
	            }
	            this._msgCountAtSectionStart = void 0;
	        };
	        /**
	         * @param {?} node
	         * @param {?} msg
	         * @return {?}
	         */
	        _Visitor.prototype._reportError = function (node, msg) {
	            this._errors.push(new I18nError(node.sourceSpan, msg));
	        };
	        return _Visitor;
	    }());
	    /**
	     * @param {?} n
	     * @return {?}
	     */
	    function _isOpeningComment(n) {
	        return n instanceof Comment && n.value && n.value.startsWith('i18n');
	    }
	    /**
	     * @param {?} n
	     * @return {?}
	     */
	    function _isClosingComment(n) {
	        return n instanceof Comment && n.value && n.value === '/i18n';
	    }
	    /**
	     * @param {?} p
	     * @return {?}
	     */
	    function _getI18nAttr(p) {
	        return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;
	    }
	    /**
	     * @param {?} i18n
	     * @return {?}
	     */
	    function _splitMeaningAndDesc(i18n) {
	        if (!i18n)
	            return ['', ''];
	        var /** @type {?} */ pipeIndex = i18n.indexOf('|');
	        return pipeIndex == -1 ? ['', i18n] : [i18n.slice(0, pipeIndex), i18n.slice(pipeIndex + 1)];
	    }

	    var XmlTagDefinition = (function () {
	        function XmlTagDefinition() {
	            this.closedByParent = false;
	            this.contentType = TagContentType.PARSABLE_DATA;
	            this.isVoid = false;
	            this.ignoreFirstLf = false;
	            this.canSelfClose = true;
	        }
	        /**
	         * @param {?} currentParent
	         * @return {?}
	         */
	        XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };
	        return XmlTagDefinition;
	    }());
	    var /** @type {?} */ _TAG_DEFINITION = new XmlTagDefinition();
	    /**
	     * @param {?} tagName
	     * @return {?}
	     */
	    function getXmlTagDefinition(tagName) {
	        return _TAG_DEFINITION;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var XmlParser = (function (_super) {
	        __extends$9(XmlParser, _super);
	        function XmlParser() {
	            _super.call(this, getXmlTagDefinition);
	        }
	        /**
	         * @param {?} source
	         * @param {?} url
	         * @param {?=} parseExpansionForms
	         * @return {?}
	         */
	        XmlParser.prototype.parse = function (source, url, parseExpansionForms) {
	            if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	            return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);
	        };
	        return XmlParser;
	    }(Parser$1));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    function digest(message) {
	        return sha1(serializeNodes(message.nodes).join('') + ("[" + message.meaning + "]"));
	    }
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    function decimalDigest(message) {
	        var /** @type {?} */ visitor = new _SerializerIgnoreIcuExpVisitor();
	        var /** @type {?} */ parts = message.nodes.map(function (a) { return a.visit(visitor, null); });
	        return computeMsgId(parts.join(''), message.meaning);
	    }
	    /**
	     * Serialize the i18n ast to something xml-like in order to generate an UID.
	     *
	     * The visitor is also used in the i18n parser tests
	     *
	     * \@internal
	     */
	    var _SerializerVisitor = (function () {
	        function _SerializerVisitor() {
	        }
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };
	        /**
	         * @param {?} container
	         * @param {?} context
	         * @return {?}
	         */
	        _SerializerVisitor.prototype.visitContainer = function (container, context) {
	            var _this = this;
	            return "[" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + "]";
	        };
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        _SerializerVisitor.prototype.visitIcu = function (icu, context) {
	            var _this = this;
	            var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return (k + " {" + icu.cases[k].visit(_this) + "}"); });
	            return "{" + icu.expression + ", " + icu.type + ", " + strCases.join(', ') + "}";
	        };
	        /**
	         * @param {?} ph
	         * @param {?} context
	         * @return {?}
	         */
	        _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {
	            var _this = this;
	            return ph.isVoid ?
	                "<ph tag name=\"" + ph.startName + "\"/>" :
	                "<ph tag name=\"" + ph.startName + "\">" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + "</ph name=\"" + ph.closeName + "\">";
	        };
	        /**
	         * @param {?} ph
	         * @param {?} context
	         * @return {?}
	         */
	        _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {
	            return ph.value ? "<ph name=\"" + ph.name + "\">" + ph.value + "</ph>" : "<ph name=\"" + ph.name + "\"/>";
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
	            return "<ph icu name=\"" + ph.name + "\">" + ph.value.visit(this) + "</ph>";
	        };
	        return _SerializerVisitor;
	    }());
	    var /** @type {?} */ serializerVisitor = new _SerializerVisitor();
	    /**
	     * @param {?} nodes
	     * @return {?}
	     */
	    function serializeNodes(nodes) {
	        return nodes.map(function (a) { return a.visit(serializerVisitor, null); });
	    }
	    /**
	     * Serialize the i18n ast to something xml-like in order to generate an UID.
	     *
	     * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
	     *
	     * \@internal
	     */
	    var _SerializerIgnoreIcuExpVisitor = (function (_super) {
	        __extends$10(_SerializerIgnoreIcuExpVisitor, _super);
	        function _SerializerIgnoreIcuExpVisitor() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {
	            var _this = this;
	            var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return (k + " {" + icu.cases[k].visit(_this) + "}"); });
	            // Do not take the expression into account
	            return "{" + icu.type + ", " + strCases.join(', ') + "}";
	        };
	        return _SerializerIgnoreIcuExpVisitor;
	    }(_SerializerVisitor));
	    /**
	     * Compute the SHA1 of the given string
	     *
	     * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
	     *
	     * WARNING: this function has not been designed not tested with security in mind.
	     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
	     * @param {?} str
	     * @return {?}
	     */
	    function sha1(str) {
	        var /** @type {?} */ utf8 = utf8Encode(str);
	        var /** @type {?} */ words32 = stringToWords32(utf8, Endian.Big);
	        var /** @type {?} */ len = utf8.length * 8;
	        var /** @type {?} */ w = new Array(80);
	        var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];
	        words32[len >> 5] |= 0x80 << (24 - len % 32);
	        words32[((len + 64 >> 9) << 4) + 15] = len;
	        for (var /** @type {?} */ i = 0; i < words32.length; i += 16) {
	            var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];
	            for (var /** @type {?} */ j = 0; j < 80; j++) {
	                if (j < 16) {
	                    w[j] = words32[i + j];
	                }
	                else {
	                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
	                }
	                var _c = fk(j, b, c, d), f = _c[0], k = _c[1];
	                var /** @type {?} */ temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
	                _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];
	            }
	            _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];
	        }
	        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
	        var _d, _e;
	    }
	    /**
	     * @param {?} index
	     * @param {?} b
	     * @param {?} c
	     * @param {?} d
	     * @return {?}
	     */
	    function fk(index, b, c, d) {
	        if (index < 20) {
	            return [(b & c) | (~b & d), 0x5a827999];
	        }
	        if (index < 40) {
	            return [b ^ c ^ d, 0x6ed9eba1];
	        }
	        if (index < 60) {
	            return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
	        }
	        return [b ^ c ^ d, 0xca62c1d6];
	    }
	    /**
	     * Compute the fingerprint of the given string
	     *
	     * The output is 64 bit number encoded as a decimal string
	     *
	     * based on:
	     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
	     * @param {?} str
	     * @return {?}
	     */
	    function fingerprint(str) {
	        var /** @type {?} */ utf8 = utf8Encode(str);
	        var _a = [hash32(utf8, 0), hash32(utf8, 102072)], hi = _a[0], lo = _a[1];
	        if (hi == 0 && (lo == 0 || lo == 1)) {
	            hi = hi ^ 0x130f9bef;
	            lo = lo ^ -0x6b5f56d8;
	        }
	        return [hi, lo];
	    }
	    /**
	     * @param {?} msg
	     * @param {?} meaning
	     * @return {?}
	     */
	    function computeMsgId(msg, meaning) {
	        var _a = fingerprint(msg), hi = _a[0], lo = _a[1];
	        if (meaning) {
	            var _b = fingerprint(meaning), him = _b[0], lom = _b[1];
	            _c = add64(rol64([hi, lo], 1), [him, lom]), hi = _c[0], lo = _c[1];
	        }
	        return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));
	        var _c;
	    }
	    /**
	     * @param {?} str
	     * @param {?} c
	     * @return {?}
	     */
	    function hash32(str, c) {
	        var _a = [0x9e3779b9, 0x9e3779b9], a = _a[0], b = _a[1];
	        var /** @type {?} */ i;
	        var /** @type {?} */ len = str.length;
	        for (i = 0; i + 12 <= len; i += 12) {
	            a = add32(a, wordAt(str, i, Endian.Little));
	            b = add32(b, wordAt(str, i + 4, Endian.Little));
	            c = add32(c, wordAt(str, i + 8, Endian.Little));
	            _b = mix([a, b, c]), a = _b[0], b = _b[1], c = _b[2];
	        }
	        a = add32(a, wordAt(str, i, Endian.Little));
	        b = add32(b, wordAt(str, i + 4, Endian.Little));
	        // the first byte of c is reserved for the length
	        c = add32(c, len);
	        c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);
	        return mix([a, b, c])[2];
	        var _b;
	    }
	    /**
	     * @param {?} __0
	     * @return {?}
	     */
	    function mix(_a) {
	        var a = _a[0], b = _a[1], c = _a[2];
	        a = sub32(a, b);
	        a = sub32(a, c);
	        a ^= c >>> 13;
	        b = sub32(b, c);
	        b = sub32(b, a);
	        b ^= a << 8;
	        c = sub32(c, a);
	        c = sub32(c, b);
	        c ^= b >>> 13;
	        a = sub32(a, b);
	        a = sub32(a, c);
	        a ^= c >>> 12;
	        b = sub32(b, c);
	        b = sub32(b, a);
	        b ^= a << 16;
	        c = sub32(c, a);
	        c = sub32(c, b);
	        c ^= b >>> 5;
	        a = sub32(a, b);
	        a = sub32(a, c);
	        a ^= c >>> 3;
	        b = sub32(b, c);
	        b = sub32(b, a);
	        b ^= a << 10;
	        c = sub32(c, a);
	        c = sub32(c, b);
	        c ^= b >>> 15;
	        return [a, b, c];
	    }
	    var Endian = {};
	    Endian.Little = 0;
	    Endian.Big = 1;
	    Endian[Endian.Little] = "Little";
	    Endian[Endian.Big] = "Big";
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function utf8Encode(str) {
	        var /** @type {?} */ encoded = '';
	        for (var /** @type {?} */ index = 0; index < str.length; index++) {
	            var /** @type {?} */ codePoint = str.charCodeAt(index);
	            // decode surrogate
	            // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	            if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {
	                var /** @type {?} */ low = str.charCodeAt(index + 1);
	                if (low >= 0xdc00 && low <= 0xdfff) {
	                    index++;
	                    codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;
	                }
	            }
	            if (codePoint <= 0x7f) {
	                encoded += String.fromCharCode(codePoint);
	            }
	            else if (codePoint <= 0x7ff) {
	                encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);
	            }
	            else if (codePoint <= 0xffff) {
	                encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
	            }
	            else if (codePoint <= 0x1fffff) {
	                encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
	            }
	        }
	        return encoded;
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function add32(a, b) {
	        return add32to64(a, b)[1];
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function add32to64(a, b) {
	        var /** @type {?} */ low = (a & 0xffff) + (b & 0xffff);
	        var /** @type {?} */ high = (a >>> 16) + (b >>> 16) + (low >>> 16);
	        return [high >>> 16, (high << 16) | (low & 0xffff)];
	    }
	    /**
	     * @param {?} __0
	     * @param {?} __1
	     * @return {?}
	     */
	    function add64(_a, _b) {
	        var ah = _a[0], al = _a[1];
	        var bh = _b[0], bl = _b[1];
	        var _c = add32to64(al, bl), carry = _c[0], l = _c[1];
	        var /** @type {?} */ h = add32(add32(ah, bh), carry);
	        return [h, l];
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function sub32(a, b) {
	        var /** @type {?} */ low = (a & 0xffff) - (b & 0xffff);
	        var /** @type {?} */ high = (a >> 16) - (b >> 16) + (low >> 16);
	        return (high << 16) | (low & 0xffff);
	    }
	    /**
	     * @param {?} a
	     * @param {?} count
	     * @return {?}
	     */
	    function rol32(a, count) {
	        return (a << count) | (a >>> (32 - count));
	    }
	    /**
	     * @param {?} __0
	     * @param {?} count
	     * @return {?}
	     */
	    function rol64(_a, count) {
	        var hi = _a[0], lo = _a[1];
	        var /** @type {?} */ h = (hi << count) | (lo >>> (32 - count));
	        var /** @type {?} */ l = (lo << count) | (hi >>> (32 - count));
	        return [h, l];
	    }
	    /**
	     * @param {?} str
	     * @param {?} endian
	     * @return {?}
	     */
	    function stringToWords32(str, endian) {
	        var /** @type {?} */ words32 = Array((str.length + 3) >>> 2);
	        for (var /** @type {?} */ i = 0; i < words32.length; i++) {
	            words32[i] = wordAt(str, i * 4, endian);
	        }
	        return words32;
	    }
	    /**
	     * @param {?} str
	     * @param {?} index
	     * @return {?}
	     */
	    function byteAt(str, index) {
	        return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;
	    }
	    /**
	     * @param {?} str
	     * @param {?} index
	     * @param {?} endian
	     * @return {?}
	     */
	    function wordAt(str, index, endian) {
	        var /** @type {?} */ word = 0;
	        if (endian === Endian.Big) {
	            for (var /** @type {?} */ i = 0; i < 4; i++) {
	                word += byteAt(str, index + i) << (24 - 8 * i);
	            }
	        }
	        else {
	            for (var /** @type {?} */ i = 0; i < 4; i++) {
	                word += byteAt(str, index + i) << 8 * i;
	            }
	        }
	        return word;
	    }
	    /**
	     * @param {?} words32
	     * @return {?}
	     */
	    function words32ToByteString(words32) {
	        return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');
	    }
	    /**
	     * @param {?} word
	     * @return {?}
	     */
	    function word32ToByteString(word) {
	        var /** @type {?} */ str = '';
	        for (var /** @type {?} */ i = 0; i < 4; i++) {
	            str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);
	        }
	        return str;
	    }
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function byteStringToHexString(str) {
	        var /** @type {?} */ hex = '';
	        for (var /** @type {?} */ i = 0; i < str.length; i++) {
	            var /** @type {?} */ b = byteAt(str, i);
	            hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
	        }
	        return hex.toLowerCase();
	    }
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function byteStringToDecString(str) {
	        var /** @type {?} */ decimal = '';
	        var /** @type {?} */ toThePower = '1';
	        for (var /** @type {?} */ i = str.length - 1; i >= 0; i--) {
	            decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));
	            toThePower = numberTimesBigInt(256, toThePower);
	        }
	        return decimal.split('').reverse().join('');
	    }
	    /**
	     * @param {?} x
	     * @param {?} y
	     * @return {?}
	     */
	    function addBigInt(x, y) {
	        var /** @type {?} */ sum = '';
	        var /** @type {?} */ len = Math.max(x.length, y.length);
	        for (var /** @type {?} */ i = 0, /** @type {?} */ carry = 0; i < len || carry; i++) {
	            var /** @type {?} */ tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);
	            if (tmpSum >= 10) {
	                carry = 1;
	                sum += tmpSum - 10;
	            }
	            else {
	                carry = 0;
	                sum += tmpSum;
	            }
	        }
	        return sum;
	    }
	    /**
	     * @param {?} num
	     * @param {?} b
	     * @return {?}
	     */
	    function numberTimesBigInt(num, b) {
	        var /** @type {?} */ product = '';
	        var /** @type {?} */ bToThePower = b;
	        for (; num !== 0; num = num >>> 1) {
	            if (num & 1)
	                product = addBigInt(product, bToThePower);
	            bToThePower = addBigInt(bToThePower, bToThePower);
	        }
	        return product;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @abstract
	     */
	    var Serializer = (function () {
	        function Serializer() {
	        }
	        /**
	         * @abstract
	         * @param {?} messages
	         * @return {?}
	         */
	        Serializer.prototype.write = function (messages) { };
	        /**
	         * @abstract
	         * @param {?} content
	         * @param {?} url
	         * @return {?}
	         */
	        Serializer.prototype.load = function (content, url) { };
	        /**
	         * @abstract
	         * @param {?} message
	         * @return {?}
	         */
	        Serializer.prototype.digest = function (message) { };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Serializer.prototype.createNameMapper = function (message) { return null; };
	        return Serializer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var _Visitor$1 = (function () {
	        function _Visitor() {
	        }
	        /**
	         * @param {?} tag
	         * @return {?}
	         */
	        _Visitor.prototype.visitTag = function (tag) {
	            var _this = this;
	            var /** @type {?} */ strAttrs = this._serializeAttributes(tag.attrs);
	            if (tag.children.length == 0) {
	                return "<" + tag.name + strAttrs + "/>";
	            }
	            var /** @type {?} */ strChildren = tag.children.map(function (node) { return node.visit(_this); });
	            return "<" + tag.name + strAttrs + ">" + strChildren.join('') + "</" + tag.name + ">";
	        };
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        _Visitor.prototype.visitText = function (text) { return text.value; };
	        /**
	         * @param {?} decl
	         * @return {?}
	         */
	        _Visitor.prototype.visitDeclaration = function (decl) {
	            return "<?xml" + this._serializeAttributes(decl.attrs) + " ?>";
	        };
	        /**
	         * @param {?} attrs
	         * @return {?}
	         */
	        _Visitor.prototype._serializeAttributes = function (attrs) {
	            var /** @type {?} */ strAttrs = Object.keys(attrs).map(function (name) { return (name + "=\"" + attrs[name] + "\""); }).join(' ');
	            return strAttrs.length > 0 ? ' ' + strAttrs : '';
	        };
	        /**
	         * @param {?} doctype
	         * @return {?}
	         */
	        _Visitor.prototype.visitDoctype = function (doctype) {
	            return "<!DOCTYPE " + doctype.rootTag + " [\n" + doctype.dtd + "\n]>";
	        };
	        return _Visitor;
	    }());
	    var /** @type {?} */ _visitor = new _Visitor$1();
	    /**
	     * @param {?} nodes
	     * @return {?}
	     */
	    function serialize(nodes) {
	        return nodes.map(function (node) { return node.visit(_visitor); }).join('');
	    }
	    var Declaration = (function () {
	        /**
	         * @param {?} unescapedAttrs
	         */
	        function Declaration(unescapedAttrs) {
	            var _this = this;
	            this.attrs = {};
	            Object.keys(unescapedAttrs).forEach(function (k) {
	                _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
	            });
	        }
	        /**
	         * @param {?} visitor
	         * @return {?}
	         */
	        Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };
	        return Declaration;
	    }());
	    var Doctype = (function () {
	        /**
	         * @param {?} rootTag
	         * @param {?} dtd
	         */
	        function Doctype(rootTag, dtd) {
	            this.rootTag = rootTag;
	            this.dtd = dtd;
	        }
	        ;
	        /**
	         * @param {?} visitor
	         * @return {?}
	         */
	        Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };
	        return Doctype;
	    }());
	    var Tag = (function () {
	        /**
	         * @param {?} name
	         * @param {?=} unescapedAttrs
	         * @param {?=} children
	         */
	        function Tag(name, unescapedAttrs, children) {
	            var _this = this;
	            if (unescapedAttrs === void 0) { unescapedAttrs = {}; }
	            if (children === void 0) { children = []; }
	            this.name = name;
	            this.children = children;
	            this.attrs = {};
	            Object.keys(unescapedAttrs).forEach(function (k) {
	                _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
	            });
	        }
	        /**
	         * @param {?} visitor
	         * @return {?}
	         */
	        Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };
	        return Tag;
	    }());
	    var Text$2 = (function () {
	        /**
	         * @param {?} unescapedValue
	         */
	        function Text(unescapedValue) {
	            this.value = _escapeXml(unescapedValue);
	        }
	        ;
	        /**
	         * @param {?} visitor
	         * @return {?}
	         */
	        Text.prototype.visit = function (visitor) { return visitor.visitText(this); };
	        return Text;
	    }());
	    var CR = (function (_super) {
	        __extends$11(CR, _super);
	        /**
	         * @param {?=} ws
	         */
	        function CR(ws) {
	            if (ws === void 0) { ws = 0; }
	            _super.call(this, "\n" + new Array(ws + 1).join(' '));
	        }
	        return CR;
	    }(Text$2));
	    var /** @type {?} */ _ESCAPED_CHARS = [
	        [/&/g, '&amp;'],
	        [/"/g, '&quot;'],
	        [/'/g, '&apos;'],
	        [/</g, '&lt;'],
	        [/>/g, '&gt;'],
	    ];
	    /**
	     * @param {?} text
	     * @return {?}
	     */
	    function _escapeXml(text) {
	        return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _VERSION = '1.2';
	    var /** @type {?} */ _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';
	    // TODO(vicb): make this a param (s/_/-/)
	    var /** @type {?} */ _SOURCE_LANG = 'en';
	    var /** @type {?} */ _PLACEHOLDER_TAG = 'x';
	    var /** @type {?} */ _SOURCE_TAG = 'source';
	    var /** @type {?} */ _TARGET_TAG = 'target';
	    var /** @type {?} */ _UNIT_TAG = 'trans-unit';
	    var Xliff = (function (_super) {
	        __extends$8(Xliff, _super);
	        function Xliff() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} messages
	         * @return {?}
	         */
	        Xliff.prototype.write = function (messages) {
	            var _this = this;
	            var /** @type {?} */ visitor = new _WriteVisitor();
	            var /** @type {?} */ visited = {};
	            var /** @type {?} */ transUnits = [];
	            messages.forEach(function (message) {
	                var /** @type {?} */ id = _this.digest(message);
	                // deduplicate messages
	                if (visited[id])
	                    return;
	                visited[id] = true;
	                var /** @type {?} */ transUnit = new Tag(_UNIT_TAG, { id: id, datatype: 'html' });
	                transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));
	                if (message.description) {
	                    transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));
	                }
	                if (message.meaning) {
	                    transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));
	                }
	                transUnit.children.push(new CR(6));
	                transUnits.push(new CR(6), transUnit);
	            });
	            var /** @type {?} */ body = new Tag('body', {}, transUnits.concat([new CR(4)]));
	            var /** @type {?} */ file = new Tag('file', { 'source-language': _SOURCE_LANG, datatype: 'plaintext', original: 'ng2.template' }, [new CR(4), body, new CR(2)]);
	            var /** @type {?} */ xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);
	            return serialize([
	                new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()
	            ]);
	        };
	        /**
	         * @param {?} content
	         * @param {?} url
	         * @return {?}
	         */
	        Xliff.prototype.load = function (content, url) {
	            // xliff to xml nodes
	            var /** @type {?} */ xliffParser = new XliffParser();
	            var _a = xliffParser.parse(content, url), mlNodesByMsgId = _a.mlNodesByMsgId, errors = _a.errors;
	            // xml nodes to i18n nodes
	            var /** @type {?} */ i18nNodesByMsgId = {};
	            var /** @type {?} */ converter = new XmlToI18n();
	            Object.keys(mlNodesByMsgId).forEach(function (msgId) {
	                var _a = converter.convert(mlNodesByMsgId[msgId]), i18nNodes = _a.i18nNodes, e = _a.errors;
	                errors.push.apply(errors, e);
	                i18nNodesByMsgId[msgId] = i18nNodes;
	            });
	            if (errors.length) {
	                throw new Error("xliff parse errors:\n" + errors.join('\n'));
	            }
	            return i18nNodesByMsgId;
	        };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Xliff.prototype.digest = function (message) { return digest(message); };
	        return Xliff;
	    }(Serializer));
	    var _WriteVisitor = (function () {
	        function _WriteVisitor() {
	        }
	        /**
	         * @param {?} text
	         * @param {?=} context
	         * @return {?}
	         */
	        _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
	        /**
	         * @param {?} container
	         * @param {?=} context
	         * @return {?}
	         */
	        _WriteVisitor.prototype.visitContainer = function (container, context) {
	            var _this = this;
	            var /** @type {?} */ nodes = [];
	            container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
	            return nodes;
	        };
	        /**
	         * @param {?} icu
	         * @param {?=} context
	         * @return {?}
	         */
	        _WriteVisitor.prototype.visitIcu = function (icu, context) {
	            if (this._isInIcu) {
	                // nested ICU is not supported
	                throw new Error('xliff does not support nested ICU messages');
	            }
	            this._isInIcu = true;
	            // TODO(vicb): support ICU messages
	            // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html
	            // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html
	            var /** @type {?} */ nodes = [];
	            this._isInIcu = false;
	            return nodes;
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {
	            var /** @type {?} */ ctype = getCtypeForTag(ph.tag);
	            var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });
	            if (ph.isVoid) {
	                // void tags have no children nor closing tags
	                return [startTagPh];
	            }
	            var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });
	            return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {
	            return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
	            return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
	        };
	        /**
	         * @param {?} nodes
	         * @return {?}
	         */
	        _WriteVisitor.prototype.serialize = function (nodes) {
	            var _this = this;
	            this._isInIcu = false;
	            return (_a = []).concat.apply(_a, nodes.map(function (node) { return node.visit(_this); }));
	            var _a;
	        };
	        return _WriteVisitor;
	    }());
	    var XliffParser = (function () {
	        function XliffParser() {
	        }
	        /**
	         * @param {?} xliff
	         * @param {?} url
	         * @return {?}
	         */
	        XliffParser.prototype.parse = function (xliff, url) {
	            this._unitMlNodes = [];
	            this._mlNodesByMsgId = {};
	            var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);
	            this._errors = xml.errors;
	            visitAll(this, xml.rootNodes, null);
	            return {
	                mlNodesByMsgId: this._mlNodesByMsgId,
	                errors: this._errors,
	            };
	        };
	        /**
	         * @param {?} element
	         * @param {?} context
	         * @return {?}
	         */
	        XliffParser.prototype.visitElement = function (element, context) {
	            switch (element.name) {
	                case _UNIT_TAG:
	                    this._unitMlNodes = null;
	                    var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
	                    if (!idAttr) {
	                        this._addError(element, "<" + _UNIT_TAG + "> misses the \"id\" attribute");
	                    }
	                    else {
	                        var /** @type {?} */ id = idAttr.value;
	                        if (this._mlNodesByMsgId.hasOwnProperty(id)) {
	                            this._addError(element, "Duplicated translations for msg " + id);
	                        }
	                        else {
	                            visitAll(this, element.children, null);
	                            if (this._unitMlNodes) {
	                                this._mlNodesByMsgId[id] = this._unitMlNodes;
	                            }
	                            else {
	                                this._addError(element, "Message " + id + " misses a translation");
	                            }
	                        }
	                    }
	                    break;
	                case _SOURCE_TAG:
	                    // ignore source message
	                    break;
	                case _TARGET_TAG:
	                    this._unitMlNodes = element.children;
	                    break;
	                default:
	                    // TODO(vicb): assert file structure, xliff version
	                    // For now only recurse on unhandled nodes
	                    visitAll(this, element.children, null);
	            }
	        };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        XliffParser.prototype.visitAttribute = function (attribute, context) { };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        XliffParser.prototype.visitText = function (text, context) { };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        XliffParser.prototype.visitComment = function (comment, context) { };
	        /**
	         * @param {?} expansion
	         * @param {?} context
	         * @return {?}
	         */
	        XliffParser.prototype.visitExpansion = function (expansion, context) { };
	        /**
	         * @param {?} expansionCase
	         * @param {?} context
	         * @return {?}
	         */
	        XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };
	        /**
	         * @param {?} node
	         * @param {?} message
	         * @return {?}
	         */
	        XliffParser.prototype._addError = function (node, message) {
	            this._errors.push(new I18nError(node.sourceSpan, message));
	        };
	        return XliffParser;
	    }());
	    var XmlToI18n = (function () {
	        function XmlToI18n() {
	        }
	        /**
	         * @param {?} nodes
	         * @return {?}
	         */
	        XmlToI18n.prototype.convert = function (nodes) {
	            this._errors = [];
	            return {
	                i18nNodes: visitAll(this, nodes),
	                errors: this._errors,
	            };
	        };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };
	        /**
	         * @param {?} el
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitElement = function (el, context) {
	            if (el.name === _PLACEHOLDER_TAG) {
	                var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });
	                if (nameAttr) {
	                    return new Placeholder('', nameAttr.value, el.sourceSpan);
	                }
	                this._addError(el, "<" + _PLACEHOLDER_TAG + "> misses the \"id\" attribute");
	            }
	            else {
	                this._addError(el, "Unexpected tag");
	            }
	        };
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitExpansion = function (icu, context) { };
	        /**
	         * @param {?} icuCase
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) { };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitComment = function (comment, context) { };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitAttribute = function (attribute, context) { };
	        /**
	         * @param {?} node
	         * @param {?} message
	         * @return {?}
	         */
	        XmlToI18n.prototype._addError = function (node, message) {
	            this._errors.push(new I18nError(node.sourceSpan, message));
	        };
	        return XmlToI18n;
	    }());
	    /**
	     * @param {?} tag
	     * @return {?}
	     */
	    function getCtypeForTag(tag) {
	        switch (tag.toLowerCase()) {
	            case 'br':
	                return 'lb';
	            case 'img':
	                return 'image';
	            default:
	                return "x-" + tag;
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _MESSAGES_TAG = 'messagebundle';
	    var /** @type {?} */ _MESSAGE_TAG = 'msg';
	    var /** @type {?} */ _PLACEHOLDER_TAG$1 = 'ph';
	    var /** @type {?} */ _EXEMPLE_TAG = 'ex';
	    var /** @type {?} */ _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
	    var Xmb = (function (_super) {
	        __extends$12(Xmb, _super);
	        function Xmb() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} messages
	         * @return {?}
	         */
	        Xmb.prototype.write = function (messages) {
	            var _this = this;
	            var /** @type {?} */ exampleVisitor = new ExampleVisitor();
	            var /** @type {?} */ visitor = new _Visitor$2();
	            var /** @type {?} */ visited = {};
	            var /** @type {?} */ rootNode = new Tag(_MESSAGES_TAG);
	            messages.forEach(function (message) {
	                var /** @type {?} */ id = _this.digest(message);
	                // deduplicate messages
	                if (visited[id])
	                    return;
	                visited[id] = true;
	                var /** @type {?} */ mapper = _this.createNameMapper(message);
	                var /** @type {?} */ attrs = { id: id };
	                if (message.description) {
	                    attrs['desc'] = message.description;
	                }
	                if (message.meaning) {
	                    attrs['meaning'] = message.meaning;
	                }
	                rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes, { mapper: mapper })));
	            });
	            rootNode.children.push(new CR());
	            return serialize([
	                new Declaration({ version: '1.0', encoding: 'UTF-8' }),
	                new CR(),
	                new Doctype(_MESSAGES_TAG, _DOCTYPE),
	                new CR(),
	                exampleVisitor.addDefaultExamples(rootNode),
	                new CR(),
	            ]);
	        };
	        /**
	         * @param {?} content
	         * @param {?} url
	         * @return {?}
	         */
	        Xmb.prototype.load = function (content, url) {
	            throw new Error('Unsupported');
	        };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Xmb.prototype.digest = function (message) { return digest$1(message); };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Xmb.prototype.createNameMapper = function (message) {
	            return new XmbPlaceholderMapper(message);
	        };
	        return Xmb;
	    }(Serializer));
	    var _Visitor$2 = (function () {
	        function _Visitor() {
	        }
	        /**
	         * @param {?} text
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.visitText = function (text, ctx) {
	            return [new Text$2(text.value)];
	        };
	        /**
	         * @param {?} container
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.visitContainer = function (container, ctx) {
	            var _this = this;
	            var /** @type {?} */ nodes = [];
	            container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this, ctx)); });
	            return nodes;
	        };
	        /**
	         * @param {?} icu
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.visitIcu = function (icu, ctx) {
	            var _this = this;
	            var /** @type {?} */ nodes = [new Text$2("{" + icu.expressionPlaceholder + ", " + icu.type + ", ")];
	            Object.keys(icu.cases).forEach(function (c) {
	                nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this, ctx), [new Text$2("} ")]));
	            });
	            nodes.push(new Text$2("}"));
	            return nodes;
	        };
	        /**
	         * @param {?} ph
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.visitTagPlaceholder = function (ph, ctx) {
	            var /** @type {?} */ startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("<" + ph.tag + ">")]);
	            var /** @type {?} */ name = ctx.mapper.toPublicName(ph.startName);
	            var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: name }, [startEx]);
	            if (ph.isVoid) {
	                // void tags have no children nor closing tags
	                return [startTagPh];
	            }
	            var /** @type {?} */ closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("</" + ph.tag + ">")]);
	            name = ctx.mapper.toPublicName(ph.closeName);
	            var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: name }, [closeEx]);
	            return [startTagPh].concat(this.serialize(ph.children, ctx), [closeTagPh]);
	        };
	        /**
	         * @param {?} ph
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.visitPlaceholder = function (ph, ctx) {
	            var /** @type {?} */ name = ctx.mapper.toPublicName(ph.name);
	            return [new Tag(_PLACEHOLDER_TAG$1, { name: name })];
	        };
	        /**
	         * @param {?} ph
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.visitIcuPlaceholder = function (ph, ctx) {
	            var /** @type {?} */ name = ctx.mapper.toPublicName(ph.name);
	            return [new Tag(_PLACEHOLDER_TAG$1, { name: name })];
	        };
	        /**
	         * @param {?} nodes
	         * @param {?} ctx
	         * @return {?}
	         */
	        _Visitor.prototype.serialize = function (nodes, ctx) {
	            var _this = this;
	            return (_a = []).concat.apply(_a, nodes.map(function (node) { return node.visit(_this, ctx); }));
	            var _a;
	        };
	        return _Visitor;
	    }());
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    function digest$1(message) {
	        return decimalDigest(message);
	    }
	    var ExampleVisitor = (function () {
	        function ExampleVisitor() {
	        }
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        ExampleVisitor.prototype.addDefaultExamples = function (node) {
	            node.visit(this);
	            return node;
	        };
	        /**
	         * @param {?} tag
	         * @return {?}
	         */
	        ExampleVisitor.prototype.visitTag = function (tag) {
	            var _this = this;
	            if (tag.name === _PLACEHOLDER_TAG$1) {
	                if (!tag.children || tag.children.length == 0) {
	                    var /** @type {?} */ exText = new Text$2(tag.attrs['name'] || '...');
	                    tag.children = [new Tag(_EXEMPLE_TAG, {}, [exText])];
	                }
	            }
	            else if (tag.children) {
	                tag.children.forEach(function (node) { return node.visit(_this); });
	            }
	        };
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        ExampleVisitor.prototype.visitText = function (text) { };
	        /**
	         * @param {?} decl
	         * @return {?}
	         */
	        ExampleVisitor.prototype.visitDeclaration = function (decl) { };
	        /**
	         * @param {?} doctype
	         * @return {?}
	         */
	        ExampleVisitor.prototype.visitDoctype = function (doctype) { };
	        return ExampleVisitor;
	    }());
	    /**
	     * XMB/XTB placeholders can only contain A-Z, 0-9 and _
	     *
	     * Because such restrictions do not exist on placeholder names generated locally, the
	     * `PlaceholderMapper` is used to convert internal names to XMB names when the XMB file is
	     * serialized and back from XTB to internal names when an XTB is loaded.
	     */
	    var XmbPlaceholderMapper = (function () {
	        /**
	         * @param {?} message
	         */
	        function XmbPlaceholderMapper(message) {
	            var _this = this;
	            this.internalToXmb = {};
	            this.xmbToNextId = {};
	            this.xmbToInternal = {};
	            message.nodes.forEach(function (node) { return node.visit(_this); });
	        }
	        /**
	         * @param {?} internalName
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.toPublicName = function (internalName) {
	            return this.internalToXmb.hasOwnProperty(internalName) ? this.internalToXmb[internalName] :
	                null;
	        };
	        /**
	         * @param {?} publicName
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.toInternalName = function (publicName) {
	            return this.xmbToInternal.hasOwnProperty(publicName) ? this.xmbToInternal[publicName] : null;
	        };
	        /**
	         * @param {?} text
	         * @param {?=} ctx
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.visitText = function (text, ctx) { return null; };
	        /**
	         * @param {?} container
	         * @param {?=} ctx
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.visitContainer = function (container, ctx) {
	            var _this = this;
	            container.children.forEach(function (child) { return child.visit(_this); });
	        };
	        /**
	         * @param {?} icu
	         * @param {?=} ctx
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.visitIcu = function (icu, ctx) {
	            var _this = this;
	            Object.keys(icu.cases).forEach(function (k) { icu.cases[k].visit(_this); });
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} ctx
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.visitTagPlaceholder = function (ph, ctx) {
	            var _this = this;
	            this.addPlaceholder(ph.startName);
	            ph.children.forEach(function (child) { return child.visit(_this); });
	            this.addPlaceholder(ph.closeName);
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} ctx
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.visitPlaceholder = function (ph, ctx) { this.addPlaceholder(ph.name); };
	        /**
	         * @param {?} ph
	         * @param {?=} ctx
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, ctx) { this.addPlaceholder(ph.name); };
	        /**
	         * @param {?} internalName
	         * @return {?}
	         */
	        XmbPlaceholderMapper.prototype.addPlaceholder = function (internalName) {
	            if (!internalName || this.internalToXmb.hasOwnProperty(internalName)) {
	                return;
	            }
	            var /** @type {?} */ xmbName = internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
	            if (this.xmbToInternal.hasOwnProperty(xmbName)) {
	                // Create a new XMB when it has already been used
	                var /** @type {?} */ nextId = this.xmbToNextId[xmbName];
	                this.xmbToNextId[xmbName] = nextId + 1;
	                xmbName = xmbName + "_" + nextId;
	            }
	            else {
	                this.xmbToNextId[xmbName] = 1;
	            }
	            this.internalToXmb[internalName] = xmbName;
	            this.xmbToInternal[xmbName] = internalName;
	        };
	        return XmbPlaceholderMapper;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _TRANSLATIONS_TAG = 'translationbundle';
	    var /** @type {?} */ _TRANSLATION_TAG = 'translation';
	    var /** @type {?} */ _PLACEHOLDER_TAG$2 = 'ph';
	    var Xtb = (function (_super) {
	        __extends$13(Xtb, _super);
	        function Xtb() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} messages
	         * @return {?}
	         */
	        Xtb.prototype.write = function (messages) { throw new Error('Unsupported'); };
	        /**
	         * @param {?} content
	         * @param {?} url
	         * @return {?}
	         */
	        Xtb.prototype.load = function (content, url) {
	            // xtb to xml nodes
	            var /** @type {?} */ xtbParser = new XtbParser();
	            var _a = xtbParser.parse(content, url), mlNodesByMsgId = _a.mlNodesByMsgId, errors = _a.errors;
	            // xml nodes to i18n nodes
	            var /** @type {?} */ i18nNodesByMsgId = {};
	            var /** @type {?} */ converter = new XmlToI18n$1();
	            Object.keys(mlNodesByMsgId).forEach(function (msgId) {
	                var _a = converter.convert(mlNodesByMsgId[msgId]), i18nNodes = _a.i18nNodes, e = _a.errors;
	                errors.push.apply(errors, e);
	                i18nNodesByMsgId[msgId] = i18nNodes;
	            });
	            if (errors.length) {
	                throw new Error("xtb parse errors:\n" + errors.join('\n'));
	            }
	            return i18nNodesByMsgId;
	        };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Xtb.prototype.digest = function (message) { return digest$1(message); };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Xtb.prototype.createNameMapper = function (message) {
	            return new XmbPlaceholderMapper(message);
	        };
	        return Xtb;
	    }(Serializer));
	    var XtbParser = (function () {
	        function XtbParser() {
	        }
	        /**
	         * @param {?} xtb
	         * @param {?} url
	         * @return {?}
	         */
	        XtbParser.prototype.parse = function (xtb, url) {
	            this._bundleDepth = 0;
	            this._mlNodesByMsgId = {};
	            var /** @type {?} */ xml = new XmlParser().parse(xtb, url, true);
	            this._errors = xml.errors;
	            visitAll(this, xml.rootNodes);
	            return {
	                mlNodesByMsgId: this._mlNodesByMsgId,
	                errors: this._errors,
	            };
	        };
	        /**
	         * @param {?} element
	         * @param {?} context
	         * @return {?}
	         */
	        XtbParser.prototype.visitElement = function (element, context) {
	            switch (element.name) {
	                case _TRANSLATIONS_TAG:
	                    this._bundleDepth++;
	                    if (this._bundleDepth > 1) {
	                        this._addError(element, "<" + _TRANSLATIONS_TAG + "> elements can not be nested");
	                    }
	                    visitAll(this, element.children, null);
	                    this._bundleDepth--;
	                    break;
	                case _TRANSLATION_TAG:
	                    var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
	                    if (!idAttr) {
	                        this._addError(element, "<" + _TRANSLATION_TAG + "> misses the \"id\" attribute");
	                    }
	                    else {
	                        var /** @type {?} */ id = idAttr.value;
	                        if (this._mlNodesByMsgId.hasOwnProperty(id)) {
	                            this._addError(element, "Duplicated translations for msg " + id);
	                        }
	                        else {
	                            this._mlNodesByMsgId[id] = element.children;
	                        }
	                    }
	                    break;
	                default:
	                    this._addError(element, 'Unexpected tag');
	            }
	        };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        XtbParser.prototype.visitAttribute = function (attribute, context) { };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        XtbParser.prototype.visitText = function (text, context) { };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        XtbParser.prototype.visitComment = function (comment, context) { };
	        /**
	         * @param {?} expansion
	         * @param {?} context
	         * @return {?}
	         */
	        XtbParser.prototype.visitExpansion = function (expansion, context) { };
	        /**
	         * @param {?} expansionCase
	         * @param {?} context
	         * @return {?}
	         */
	        XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };
	        /**
	         * @param {?} node
	         * @param {?} message
	         * @return {?}
	         */
	        XtbParser.prototype._addError = function (node, message) {
	            this._errors.push(new I18nError(node.sourceSpan, message));
	        };
	        return XtbParser;
	    }());
	    var XmlToI18n$1 = (function () {
	        function XmlToI18n() {
	        }
	        /**
	         * @param {?} nodes
	         * @return {?}
	         */
	        XmlToI18n.prototype.convert = function (nodes) {
	            this._errors = [];
	            return {
	                i18nNodes: visitAll(this, nodes),
	                errors: this._errors,
	            };
	        };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitExpansion = function (icu, context) {
	            var /** @type {?} */ caseMap = {};
	            visitAll(this, icu.cases).forEach(function (c) {
	                caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
	            });
	            return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
	        };
	        /**
	         * @param {?} icuCase
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {
	            return {
	                value: icuCase.value,
	                nodes: visitAll(this, icuCase.expression),
	            };
	        };
	        /**
	         * @param {?} el
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitElement = function (el, context) {
	            if (el.name === _PLACEHOLDER_TAG$2) {
	                var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });
	                if (nameAttr) {
	                    return new Placeholder('', nameAttr.value, el.sourceSpan);
	                }
	                this._addError(el, "<" + _PLACEHOLDER_TAG$2 + "> misses the \"name\" attribute");
	            }
	            else {
	                this._addError(el, "Unexpected tag");
	            }
	        };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitComment = function (comment, context) { };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        XmlToI18n.prototype.visitAttribute = function (attribute, context) { };
	        /**
	         * @param {?} node
	         * @param {?} message
	         * @return {?}
	         */
	        XmlToI18n.prototype._addError = function (node, message) {
	            this._errors.push(new I18nError(node.sourceSpan, message));
	        };
	        return XmlToI18n;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$14 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$3 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var HtmlParser = (function (_super) {
	        __extends$14(HtmlParser, _super);
	        function HtmlParser() {
	            _super.call(this, getHtmlTagDefinition);
	        }
	        /**
	         * @param {?} source
	         * @param {?} url
	         * @param {?=} parseExpansionForms
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
	            if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);
	        };
	        HtmlParser = __decorate$3([
	            CompilerInjectable(), 
	            __metadata$3('design:paramtypes', [])
	        ], HtmlParser);
	        return HtmlParser;
	    }(Parser$1));

	    /**
	     * A container for translated messages
	     */
	    var TranslationBundle = (function () {
	        /**
	         * @param {?=} _i18nNodesByMsgId
	         * @param {?} digest
	         * @param {?=} mapperFactory
	         */
	        function TranslationBundle(_i18nNodesByMsgId, digest, mapperFactory) {
	            if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }
	            this._i18nNodesByMsgId = _i18nNodesByMsgId;
	            this.digest = digest;
	            this.mapperFactory = mapperFactory;
	            this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, digest, mapperFactory);
	        }
	        /**
	         * @param {?} content
	         * @param {?} url
	         * @param {?} serializer
	         * @return {?}
	         */
	        TranslationBundle.load = function (content, url, serializer) {
	            var /** @type {?} */ i18nNodesByMsgId = serializer.load(content, url);
	            var /** @type {?} */ digestFn = function (m) { return serializer.digest(m); };
	            var /** @type {?} */ mapperFactory = function (m) { return serializer.createNameMapper(m); };
	            return new TranslationBundle(i18nNodesByMsgId, digestFn, mapperFactory);
	        };
	        /**
	         * @param {?} srcMsg
	         * @return {?}
	         */
	        TranslationBundle.prototype.get = function (srcMsg) {
	            var /** @type {?} */ html = this._i18nToHtml.convert(srcMsg);
	            if (html.errors.length) {
	                throw new Error(html.errors.join('\n'));
	            }
	            return html.nodes;
	        };
	        /**
	         * @param {?} srcMsg
	         * @return {?}
	         */
	        TranslationBundle.prototype.has = function (srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; };
	        return TranslationBundle;
	    }());
	    var I18nToHtmlVisitor = (function () {
	        /**
	         * @param {?=} _i18nNodesByMsgId
	         * @param {?} _digest
	         * @param {?} _mapperFactory
	         */
	        function I18nToHtmlVisitor(_i18nNodesByMsgId, _digest, _mapperFactory) {
	            if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }
	            this._i18nNodesByMsgId = _i18nNodesByMsgId;
	            this._digest = _digest;
	            this._mapperFactory = _mapperFactory;
	            this._contextStack = [];
	            this._errors = [];
	        }
	        /**
	         * @param {?} srcMsg
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.convert = function (srcMsg) {
	            this._contextStack.length = 0;
	            this._errors.length = 0;
	            // i18n to text
	            var /** @type {?} */ text = this._convertToText(srcMsg);
	            // text to html
	            var /** @type {?} */ url = srcMsg.nodes[0].sourceSpan.start.file.url;
	            var /** @type {?} */ html = new HtmlParser().parse(text, url, true);
	            return {
	                nodes: html.rootNodes,
	                errors: this._errors.concat(html.errors),
	            };
	        };
	        /**
	         * @param {?} text
	         * @param {?=} context
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.visitText = function (text, context) { return text.value; };
	        /**
	         * @param {?} container
	         * @param {?=} context
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {
	            var _this = this;
	            return container.children.map(function (n) { return n.visit(_this); }).join('');
	        };
	        /**
	         * @param {?} icu
	         * @param {?=} context
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {
	            var _this = this;
	            var /** @type {?} */ cases = Object.keys(icu.cases).map(function (k) { return (k + " {" + icu.cases[k].visit(_this) + "}"); });
	            // TODO(vicb): Once all format switch to using expression placeholders
	            // we should throw when the placeholder is not in the source message
	            var /** @type {?} */ exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?
	                this._srcMsg.placeholders[icu.expression] :
	                icu.expression;
	            return "{" + exp + ", " + icu.type + ", " + cases.join(' ') + "}";
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {
	            var /** @type {?} */ phName = this._mapper(ph.name);
	            if (this._srcMsg.placeholders.hasOwnProperty(phName)) {
	                return this._srcMsg.placeholders[phName];
	            }
	            if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {
	                return this._convertToText(this._srcMsg.placeholderToMessage[phName]);
	            }
	            this._addError(ph, "Unknown placeholder");
	            return '';
	        };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) { throw 'unreachable code'; };
	        /**
	         * @param {?} ph
	         * @param {?=} context
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) { throw 'unreachable code'; };
	        /**
	         * Convert a source message to a translated text string:
	         * - text nodes are replaced with their translation,
	         * - placeholders are replaced with their content,
	         * - ICU nodes are converted to ICU expressions.
	         * @param {?} srcMsg
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {
	            var _this = this;
	            var /** @type {?} */ digest = this._digest(srcMsg);
	            var /** @type {?} */ mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;
	            if (this._i18nNodesByMsgId.hasOwnProperty(digest)) {
	                this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });
	                this._srcMsg = srcMsg;
	                this._mapper = function (name) { return mapper ? mapper.toInternalName(name) : name; };
	                var /** @type {?} */ nodes = this._i18nNodesByMsgId[digest];
	                var /** @type {?} */ text = nodes.map(function (node) { return node.visit(_this); }).join('');
	                var /** @type {?} */ context = this._contextStack.pop();
	                this._srcMsg = context.msg;
	                this._mapper = context.mapper;
	                return text;
	            }
	            this._addError(srcMsg.nodes[0], "Missing translation for message " + digest);
	            return '';
	        };
	        /**
	         * @param {?} el
	         * @param {?} msg
	         * @return {?}
	         */
	        I18nToHtmlVisitor.prototype._addError = function (el, msg) {
	            this._errors.push(new I18nError(el.sourceSpan, msg));
	        };
	        return I18nToHtmlVisitor;
	    }());

	    var I18NHtmlParser = (function () {
	        /**
	         * @param {?} _htmlParser
	         * @param {?=} _translations
	         * @param {?=} _translationsFormat
	         */
	        function I18NHtmlParser(_htmlParser, _translations, _translationsFormat) {
	            this._htmlParser = _htmlParser;
	            this._translations = _translations;
	            this._translationsFormat = _translationsFormat;
	        }
	        /**
	         * @param {?} source
	         * @param {?} url
	         * @param {?=} parseExpansionForms
	         * @param {?=} interpolationConfig
	         * @return {?}
	         */
	        I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
	            if (parseExpansionForms === void 0) { parseExpansionForms = false; }
	            if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
	            var /** @type {?} */ parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);
	            if (!this._translations || this._translations === '') {
	                // Do not enable i18n when no translation bundle is provided
	                return parseResult;
	            }
	            // TODO(vicb): add support for implicit tags / attributes
	            if (parseResult.errors.length) {
	                return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);
	            }
	            var /** @type {?} */ serializer = this._createSerializer();
	            var /** @type {?} */ translationBundle = TranslationBundle.load(this._translations, url, serializer);
	            return mergeTranslations(parseResult.rootNodes, translationBundle, interpolationConfig, [], {});
	        };
	        /**
	         * @return {?}
	         */
	        I18NHtmlParser.prototype._createSerializer = function () {
	            var /** @type {?} */ format = (this._translationsFormat || 'xlf').toLowerCase();
	            switch (format) {
	                case 'xmb':
	                    return new Xmb();
	                case 'xtb':
	                    return new Xtb();
	                case 'xliff':
	                case 'xlf':
	                default:
	                    return new Xliff();
	            }
	        };
	        return I18NHtmlParser;
	    }());

	    var /** @type {?} */ APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');
	    var /** @type {?} */ VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');
	    var /** @type {?} */ CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');
	    var /** @type {?} */ ANIMATION_STYLE_UTIL_ASSET_URL = assetUrl('core', 'animation/animation_style_util');
	    var Identifiers = (function () {
	        function Identifiers() {
	        }
	        Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
	            name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
	            moduleUrl: assetUrl('core', 'metadata/di'),
	            runtime: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS
	        };
	        Identifiers.ViewUtils = {
	            name: 'ViewUtils',
	            moduleUrl: assetUrl('core', 'linker/view_utils'),
	            runtime: view_utils.ViewUtils
	        };
	        Identifiers.AppView = { name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: AppView };
	        Identifiers.DebugAppView = {
	            name: 'DebugAppView',
	            moduleUrl: APP_VIEW_MODULE_URL,
	            runtime: DebugAppView
	        };
	        Identifiers.ViewContainer = {
	            name: 'ViewContainer',
	            moduleUrl: assetUrl('core', 'linker/view_container'),
	            runtime: ViewContainer
	        };
	        Identifiers.ElementRef = {
	            name: 'ElementRef',
	            moduleUrl: assetUrl('core', 'linker/element_ref'),
	            runtime: _angular_core.ElementRef
	        };
	        Identifiers.ViewContainerRef = {
	            name: 'ViewContainerRef',
	            moduleUrl: assetUrl('core', 'linker/view_container_ref'),
	            runtime: _angular_core.ViewContainerRef
	        };
	        Identifiers.ChangeDetectorRef = {
	            name: 'ChangeDetectorRef',
	            moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),
	            runtime: _angular_core.ChangeDetectorRef
	        };
	        Identifiers.RenderComponentType = {
	            name: 'RenderComponentType',
	            moduleUrl: assetUrl('core', 'render/api'),
	            runtime: _angular_core.RenderComponentType
	        };
	        Identifiers.QueryList = {
	            name: 'QueryList',
	            moduleUrl: assetUrl('core', 'linker/query_list'),
	            runtime: _angular_core.QueryList
	        };
	        Identifiers.TemplateRef = {
	            name: 'TemplateRef',
	            moduleUrl: assetUrl('core', 'linker/template_ref'),
	            runtime: _angular_core.TemplateRef
	        };
	        Identifiers.TemplateRef_ = {
	            name: 'TemplateRef_',
	            moduleUrl: assetUrl('core', 'linker/template_ref'),
	            runtime: TemplateRef_
	        };
	        Identifiers.CodegenComponentFactoryResolver = {
	            name: 'CodegenComponentFactoryResolver',
	            moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
	            runtime: CodegenComponentFactoryResolver
	        };
	        Identifiers.ComponentFactoryResolver = {
	            name: 'ComponentFactoryResolver',
	            moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
	            runtime: _angular_core.ComponentFactoryResolver
	        };
	        Identifiers.ComponentFactory = {
	            name: 'ComponentFactory',
	            runtime: _angular_core.ComponentFactory,
	            moduleUrl: assetUrl('core', 'linker/component_factory')
	        };
	        Identifiers.ComponentRef_ = {
	            name: 'ComponentRef_',
	            runtime: ComponentRef_,
	            moduleUrl: assetUrl('core', 'linker/component_factory')
	        };
	        Identifiers.ComponentRef = {
	            name: 'ComponentRef',
	            runtime: _angular_core.ComponentRef,
	            moduleUrl: assetUrl('core', 'linker/component_factory')
	        };
	        Identifiers.NgModuleFactory = {
	            name: 'NgModuleFactory',
	            runtime: _angular_core.NgModuleFactory,
	            moduleUrl: assetUrl('core', 'linker/ng_module_factory')
	        };
	        Identifiers.NgModuleInjector = {
	            name: 'NgModuleInjector',
	            runtime: NgModuleInjector,
	            moduleUrl: assetUrl('core', 'linker/ng_module_factory')
	        };
	        Identifiers.RegisterModuleFactoryFn = {
	            name: 'registerModuleFactory',
	            runtime: registerModuleFactory,
	            moduleUrl: assetUrl('core', 'linker/ng_module_factory_loader')
	        };
	        Identifiers.ValueUnwrapper = { name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: ValueUnwrapper };
	        Identifiers.Injector = {
	            name: 'Injector',
	            moduleUrl: assetUrl('core', 'di/injector'),
	            runtime: _angular_core.Injector
	        };
	        Identifiers.ViewEncapsulation = {
	            name: 'ViewEncapsulation',
	            moduleUrl: assetUrl('core', 'metadata/view'),
	            runtime: _angular_core.ViewEncapsulation
	        };
	        Identifiers.ViewType = {
	            name: 'ViewType',
	            moduleUrl: assetUrl('core', 'linker/view_type'),
	            runtime: ViewType
	        };
	        Identifiers.ChangeDetectionStrategy = {
	            name: 'ChangeDetectionStrategy',
	            moduleUrl: CD_MODULE_URL,
	            runtime: _angular_core.ChangeDetectionStrategy
	        };
	        Identifiers.StaticNodeDebugInfo = {
	            name: 'StaticNodeDebugInfo',
	            moduleUrl: assetUrl('core', 'linker/debug_context'),
	            runtime: StaticNodeDebugInfo
	        };
	        Identifiers.DebugContext = {
	            name: 'DebugContext',
	            moduleUrl: assetUrl('core', 'linker/debug_context'),
	            runtime: DebugContext
	        };
	        Identifiers.Renderer = {
	            name: 'Renderer',
	            moduleUrl: assetUrl('core', 'render/api'),
	            runtime: _angular_core.Renderer
	        };
	        Identifiers.SimpleChange = { name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: _angular_core.SimpleChange };
	        Identifiers.UNINITIALIZED = { name: 'UNINITIALIZED', moduleUrl: CD_MODULE_URL, runtime: UNINITIALIZED };
	        Identifiers.ChangeDetectorStatus = {
	            name: 'ChangeDetectorStatus',
	            moduleUrl: CD_MODULE_URL,
	            runtime: ChangeDetectorStatus
	        };
	        Identifiers.checkBinding = {
	            name: 'checkBinding',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.checkBinding
	        };
	        Identifiers.devModeEqual = { name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: devModeEqual };
	        Identifiers.inlineInterpolate = {
	            name: 'inlineInterpolate',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.inlineInterpolate
	        };
	        Identifiers.interpolate = {
	            name: 'interpolate',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.interpolate
	        };
	        Identifiers.castByValue = {
	            name: 'castByValue',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.castByValue
	        };
	        Identifiers.EMPTY_ARRAY = {
	            name: 'EMPTY_ARRAY',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.EMPTY_ARRAY
	        };
	        Identifiers.EMPTY_MAP = {
	            name: 'EMPTY_MAP',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.EMPTY_MAP
	        };
	        Identifiers.createRenderElement = {
	            name: 'createRenderElement',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.createRenderElement
	        };
	        Identifiers.selectOrCreateRenderHostElement = {
	            name: 'selectOrCreateRenderHostElement',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.selectOrCreateRenderHostElement
	        };
	        Identifiers.pureProxies = [
	            null,
	            { name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy1 },
	            { name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy2 },
	            { name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy3 },
	            { name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy4 },
	            { name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy5 },
	            { name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy6 },
	            { name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy7 },
	            { name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy8 },
	            { name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy9 },
	            { name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy10 },
	        ];
	        Identifiers.SecurityContext = {
	            name: 'SecurityContext',
	            moduleUrl: assetUrl('core', 'security'),
	            runtime: _angular_core.SecurityContext,
	        };
	        Identifiers.AnimationKeyframe = {
	            name: 'AnimationKeyframe',
	            moduleUrl: assetUrl('core', 'animation/animation_keyframe'),
	            runtime: AnimationKeyframe
	        };
	        Identifiers.AnimationStyles = {
	            name: 'AnimationStyles',
	            moduleUrl: assetUrl('core', 'animation/animation_styles'),
	            runtime: AnimationStyles
	        };
	        Identifiers.NoOpAnimationPlayer = {
	            name: 'NoOpAnimationPlayer',
	            moduleUrl: assetUrl('core', 'animation/animation_player'),
	            runtime: NoOpAnimationPlayer
	        };
	        Identifiers.AnimationGroupPlayer = {
	            name: 'AnimationGroupPlayer',
	            moduleUrl: assetUrl('core', 'animation/animation_group_player'),
	            runtime: AnimationGroupPlayer
	        };
	        Identifiers.AnimationSequencePlayer = {
	            name: 'AnimationSequencePlayer',
	            moduleUrl: assetUrl('core', 'animation/animation_sequence_player'),
	            runtime: AnimationSequencePlayer
	        };
	        Identifiers.prepareFinalAnimationStyles = {
	            name: 'prepareFinalAnimationStyles',
	            moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	            runtime: prepareFinalAnimationStyles
	        };
	        Identifiers.balanceAnimationKeyframes = {
	            name: 'balanceAnimationKeyframes',
	            moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	            runtime: balanceAnimationKeyframes
	        };
	        Identifiers.clearStyles = {
	            name: 'clearStyles',
	            moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	            runtime: clearStyles
	        };
	        Identifiers.renderStyles = {
	            name: 'renderStyles',
	            moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	            runtime: renderStyles
	        };
	        Identifiers.collectAndResolveStyles = {
	            name: 'collectAndResolveStyles',
	            moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	            runtime: collectAndResolveStyles
	        };
	        Identifiers.LOCALE_ID = {
	            name: 'LOCALE_ID',
	            moduleUrl: assetUrl('core', 'i18n/tokens'),
	            runtime: _angular_core.LOCALE_ID
	        };
	        Identifiers.TRANSLATIONS_FORMAT = {
	            name: 'TRANSLATIONS_FORMAT',
	            moduleUrl: assetUrl('core', 'i18n/tokens'),
	            runtime: _angular_core.TRANSLATIONS_FORMAT
	        };
	        Identifiers.setBindingDebugInfo = {
	            name: 'setBindingDebugInfo',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.setBindingDebugInfo
	        };
	        Identifiers.setBindingDebugInfoForChanges = {
	            name: 'setBindingDebugInfoForChanges',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.setBindingDebugInfoForChanges
	        };
	        Identifiers.AnimationTransition = {
	            name: 'AnimationTransition',
	            moduleUrl: assetUrl('core', 'animation/animation_transition'),
	            runtime: AnimationTransition
	        };
	        // This is just the interface!
	        Identifiers.InlineArray = { name: 'InlineArray', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: null };
	        Identifiers.inlineArrays = [
	            { name: 'InlineArray2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray2 },
	            { name: 'InlineArray2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray2 },
	            { name: 'InlineArray4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray4 },
	            { name: 'InlineArray8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray8 },
	            { name: 'InlineArray16', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray16 },
	        ];
	        Identifiers.EMPTY_INLINE_ARRAY = {
	            name: 'EMPTY_INLINE_ARRAY',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.EMPTY_INLINE_ARRAY
	        };
	        Identifiers.InlineArrayDynamic = {
	            name: 'InlineArrayDynamic',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.InlineArrayDynamic
	        };
	        Identifiers.subscribeToRenderElement = {
	            name: 'subscribeToRenderElement',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.subscribeToRenderElement
	        };
	        Identifiers.createRenderComponentType = {
	            name: 'createRenderComponentType',
	            moduleUrl: VIEW_UTILS_MODULE_URL,
	            runtime: view_utils.createRenderComponentType
	        };
	        Identifiers.noop = { name: 'noop', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.noop };
	        return Identifiers;
	    }());
	    /**
	     * @param {?} pkg
	     * @param {?=} path
	     * @param {?=} type
	     * @return {?}
	     */
	    function assetUrl(pkg, path, type) {
	        if (path === void 0) { path = null; }
	        if (type === void 0) { type = 'src'; }
	        if (path == null) {
	            return "@angular/" + pkg + "/index";
	        }
	        else {
	            return "@angular/" + pkg + "/" + type + "/" + path;
	        }
	    }
	    /**
	     * @param {?} identifier
	     * @return {?}
	     */
	    function resolveIdentifier(identifier) {
	        return reflector.resolveIdentifier(identifier.name, identifier.moduleUrl, identifier.runtime);
	    }
	    /**
	     * @param {?} identifier
	     * @return {?}
	     */
	    function createIdentifier(identifier) {
	        var /** @type {?} */ reference = reflector.resolveIdentifier(identifier.name, identifier.moduleUrl, identifier.runtime);
	        return { reference: reference };
	    }
	    /**
	     * @param {?} identifier
	     * @return {?}
	     */
	    function identifierToken(identifier) {
	        return { identifier: identifier };
	    }
	    /**
	     * @param {?} identifier
	     * @return {?}
	     */
	    function createIdentifierToken(identifier) {
	        return identifierToken(createIdentifier(identifier));
	    }
	    /**
	     * @param {?} enumType
	     * @param {?} name
	     * @return {?}
	     */
	    function createEnumIdentifier(enumType, name) {
	        var /** @type {?} */ resolvedEnum = reflector.resolveEnum(resolveIdentifier(enumType), name);
	        return { reference: resolvedEnum };
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$15 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    // http://cldr.unicode.org/index/cldr-spec/plural-rules
	    var /** @type {?} */ PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
	    /**
	     * Expands special forms into elements.
	     *
	     * For example,
	     *
	     * ```
	     * { messages.length, plural,
	     *   =0 {zero}
	     *   =1 {one}
	     *   other {more than one}
	     * }
	     * ```
	     *
	     * will be expanded into
	     *
	     * ```
	     * <ng-container [ngPlural]="messages.length">
	     *   <template ngPluralCase="=0">zero</template>
	     *   <template ngPluralCase="=1">one</template>
	     *   <template ngPluralCase="other">more than one</template>
	     * </ng-container>
	     * ```
	     * @param {?} nodes
	     * @return {?}
	     */
	    function expandNodes(nodes) {
	        var /** @type {?} */ expander = new _Expander();
	        return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);
	    }
	    var ExpansionResult = (function () {
	        /**
	         * @param {?} nodes
	         * @param {?} expanded
	         * @param {?} errors
	         */
	        function ExpansionResult(nodes, expanded, errors) {
	            this.nodes = nodes;
	            this.expanded = expanded;
	            this.errors = errors;
	        }
	        return ExpansionResult;
	    }());
	    var ExpansionError = (function (_super) {
	        __extends$15(ExpansionError, _super);
	        /**
	         * @param {?} span
	         * @param {?} errorMsg
	         */
	        function ExpansionError(span, errorMsg) {
	            _super.call(this, span, errorMsg);
	        }
	        return ExpansionError;
	    }(ParseError));
	    /**
	     * Expand expansion forms (plural, select) to directives
	     *
	     * \@internal
	     */
	    var _Expander = (function () {
	        function _Expander() {
	            this.isExpanded = false;
	            this.errors = [];
	        }
	        /**
	         * @param {?} element
	         * @param {?} context
	         * @return {?}
	         */
	        _Expander.prototype.visitElement = function (element, context) {
	            return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
	        };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };
	        /**
	         * @param {?} text
	         * @param {?} context
	         * @return {?}
	         */
	        _Expander.prototype.visitText = function (text, context) { return text; };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        _Expander.prototype.visitComment = function (comment, context) { return comment; };
	        /**
	         * @param {?} icu
	         * @param {?} context
	         * @return {?}
	         */
	        _Expander.prototype.visitExpansion = function (icu, context) {
	            this.isExpanded = true;
	            return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :
	                _expandDefaultForm(icu, this.errors);
	        };
	        /**
	         * @param {?} icuCase
	         * @param {?} context
	         * @return {?}
	         */
	        _Expander.prototype.visitExpansionCase = function (icuCase, context) {
	            throw new Error('Should not be reached');
	        };
	        return _Expander;
	    }());
	    /**
	     * @param {?} ast
	     * @param {?} errors
	     * @return {?}
	     */
	    function _expandPluralForm(ast, errors) {
	        var /** @type {?} */ children = ast.cases.map(function (c) {
	            if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
	                errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of " + PLURAL_CASES.join(", ")));
	            }
	            var /** @type {?} */ expansionResult = expandNodes(c.expression);
	            errors.push.apply(errors, expansionResult.errors);
	            return new Element("template", [new Attribute$1('ngPluralCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	        });
	        var /** @type {?} */ switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
	        return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
	    }
	    /**
	     * @param {?} ast
	     * @param {?} errors
	     * @return {?}
	     */
	    function _expandDefaultForm(ast, errors) {
	        var /** @type {?} */ children = ast.cases.map(function (c) {
	            var /** @type {?} */ expansionResult = expandNodes(c.expression);
	            errors.push.apply(errors, expansionResult.errors);
	            if (c.value === 'other') {
	                // other is the default case when no values match
	                return new Element("template", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	            }
	            return new Element("template", [new Attribute$1('ngSwitchCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	        });
	        var /** @type {?} */ switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
	        return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$16 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ProviderError = (function (_super) {
	        __extends$16(ProviderError, _super);
	        /**
	         * @param {?} message
	         * @param {?} span
	         */
	        function ProviderError(message, span) {
	            _super.call(this, span, message);
	        }
	        return ProviderError;
	    }(ParseError));
	    var ProviderViewContext = (function () {
	        /**
	         * @param {?} component
	         * @param {?} sourceSpan
	         */
	        function ProviderViewContext(component, sourceSpan) {
	            var _this = this;
	            this.component = component;
	            this.sourceSpan = sourceSpan;
	            this.errors = [];
	            this.viewQueries = _getViewQueries(component);
	            this.viewProviders = new Map();
	            component.viewProviders.forEach(function (provider) {
	                if (isBlank(_this.viewProviders.get(tokenReference(provider.token)))) {
	                    _this.viewProviders.set(tokenReference(provider.token), true);
	                }
	            });
	        }
	        return ProviderViewContext;
	    }());
	    var ProviderElementContext = (function () {
	        /**
	         * @param {?} viewContext
	         * @param {?} _parent
	         * @param {?} _isViewRoot
	         * @param {?} _directiveAsts
	         * @param {?} attrs
	         * @param {?} refs
	         * @param {?} _sourceSpan
	         */
	        function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
	            var _this = this;
	            this.viewContext = viewContext;
	            this._parent = _parent;
	            this._isViewRoot = _isViewRoot;
	            this._directiveAsts = _directiveAsts;
	            this._sourceSpan = _sourceSpan;
	            this._transformedProviders = new Map();
	            this._seenProviders = new Map();
	            this._hasViewContainer = false;
	            this._attrs = {};
	            attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });
	            var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });
	            this._allProviders =
	                _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
	            this._contentQueries = _getContentQueries(directivesMeta);
	            var queriedTokens = new Map();
	            Array.from(this._allProviders.values()).forEach(function (provider) {
	                _this._addQueryReadsTo(provider.token, queriedTokens);
	            });
	            refs.forEach(function (refAst) { _this._addQueryReadsTo({ value: refAst.name }, queriedTokens); });
	            if (isPresent(queriedTokens.get(resolveIdentifier(Identifiers.ViewContainerRef)))) {
	                this._hasViewContainer = true;
	            }
	            // create the providers that we know are eager first
	            Array.from(this._allProviders.values()).forEach(function (provider) {
	                var eager = provider.eager || isPresent(queriedTokens.get(tokenReference(provider.token)));
	                if (eager) {
	                    _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
	                }
	            });
	        }
	        /**
	         * @return {?}
	         */
	        ProviderElementContext.prototype.afterElement = function () {
	            var _this = this;
	            // collect lazy providers
	            Array.from(this._allProviders.values()).forEach(function (provider) {
	                _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
	            });
	        };
	        Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return Array.from(this._transformedProviders.values());
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });
	                var /** @type {?} */ sortedDirectives = this._directiveAsts.slice();
	                sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -
	                    sortedProviderTypes.indexOf(dir2.directive.type); });
	                return sortedDirectives;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._hasViewContainer; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} token
	         * @param {?} queryReadTokens
	         * @return {?}
	         */
	        ProviderElementContext.prototype._addQueryReadsTo = function (token, queryReadTokens) {
	            this._getQueriesFor(token).forEach(function (query) {
	                var /** @type {?} */ queryReadToken = query.read || token;
	                if (isBlank(queryReadTokens.get(tokenReference(queryReadToken)))) {
	                    queryReadTokens.set(tokenReference(queryReadToken), true);
	                }
	            });
	        };
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        ProviderElementContext.prototype._getQueriesFor = function (token) {
	            var /** @type {?} */ result = [];
	            var /** @type {?} */ currentEl = this;
	            var /** @type {?} */ distance = 0;
	            var /** @type {?} */ queries;
	            while (currentEl !== null) {
	                queries = currentEl._contentQueries.get(tokenReference(token));
	                if (queries) {
	                    result.push.apply(result, queries.filter(function (query) { return query.descendants || distance <= 1; }));
	                }
	                if (currentEl._directiveAsts.length > 0) {
	                    distance++;
	                }
	                currentEl = currentEl._parent;
	            }
	            queries = this.viewContext.viewQueries.get(tokenReference(token));
	            if (queries) {
	                result.push.apply(result, queries);
	            }
	            return result;
	        };
	        /**
	         * @param {?} requestingProviderType
	         * @param {?} token
	         * @param {?} eager
	         * @return {?}
	         */
	        ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {
	            var _this = this;
	            var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));
	            if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||
	                requestingProviderType === ProviderAstType.PublicService) &&
	                resolvedProvider.providerType === ProviderAstType.PrivateService) ||
	                ((requestingProviderType === ProviderAstType.PrivateService ||
	                    requestingProviderType === ProviderAstType.PublicService) &&
	                    resolvedProvider.providerType === ProviderAstType.Builtin)) {
	                return null;
	            }
	            var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));
	            if (transformedProviderAst) {
	                return transformedProviderAst;
	            }
	            if (isPresent(this._seenProviders.get(tokenReference(token)))) {
	                this.viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + tokenName(token), this._sourceSpan));
	                return null;
	            }
	            this._seenProviders.set(tokenReference(token), true);
	            var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {
	                var /** @type {?} */ transformedUseValue = provider.useValue;
	                var /** @type {?} */ transformedUseExisting = provider.useExisting;
	                var /** @type {?} */ transformedDeps;
	                if (isPresent(provider.useExisting)) {
	                    var /** @type {?} */ existingDiDep = _this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);
	                    if (isPresent(existingDiDep.token)) {
	                        transformedUseExisting = existingDiDep.token;
	                    }
	                    else {
	                        transformedUseExisting = null;
	                        transformedUseValue = existingDiDep.value;
	                    }
	                }
	                else if (provider.useFactory) {
	                    var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;
	                    transformedDeps =
	                        deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
	                }
	                else if (provider.useClass) {
	                    var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;
	                    transformedDeps =
	                        deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
	                }
	                return _transformProvider(provider, {
	                    useExisting: transformedUseExisting,
	                    useValue: transformedUseValue,
	                    deps: transformedDeps
	                });
	            });
	            transformedProviderAst =
	                _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
	            this._transformedProviders.set(tokenReference(token), transformedProviderAst);
	            return transformedProviderAst;
	        };
	        /**
	         * @param {?} requestingProviderType
	         * @param {?} dep
	         * @param {?=} eager
	         * @return {?}
	         */
	        ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {
	            if (eager === void 0) { eager = null; }
	            if (dep.isAttribute) {
	                var /** @type {?} */ attrValue = this._attrs[dep.token.value];
	                return { isValue: true, value: attrValue == null ? null : attrValue };
	            }
	            if (isPresent(dep.token)) {
	                // access builtints
	                if ((requestingProviderType === ProviderAstType.Directive ||
	                    requestingProviderType === ProviderAstType.Component)) {
	                    if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Renderer) ||
	                        tokenReference(dep.token) === resolveIdentifier(Identifiers.ElementRef) ||
	                        tokenReference(dep.token) === resolveIdentifier(Identifiers.ChangeDetectorRef) ||
	                        tokenReference(dep.token) === resolveIdentifier(Identifiers.TemplateRef)) {
	                        return dep;
	                    }
	                    if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ViewContainerRef)) {
	                        this._hasViewContainer = true;
	                    }
	                }
	                // access the injector
	                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {
	                    return dep;
	                }
	                // access providers
	                if (isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
	                    return dep;
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} requestingProviderType
	         * @param {?} dep
	         * @param {?=} eager
	         * @return {?}
	         */
	        ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {
	            if (eager === void 0) { eager = null; }
	            var /** @type {?} */ currElement = this;
	            var /** @type {?} */ currEager = eager;
	            var /** @type {?} */ result = null;
	            if (!dep.isSkipSelf) {
	                result = this._getLocalDependency(requestingProviderType, dep, eager);
	            }
	            if (dep.isSelf) {
	                if (!result && dep.isOptional) {
	                    result = { isValue: true, value: null };
	                }
	            }
	            else {
	                // check parent elements
	                while (!result && currElement._parent) {
	                    var /** @type {?} */ prevElement = currElement;
	                    currElement = currElement._parent;
	                    if (prevElement._isViewRoot) {
	                        currEager = false;
	                    }
	                    result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);
	                }
	                // check @Host restriction
	                if (!result) {
	                    if (!dep.isHost || this.viewContext.component.isHost ||
	                        this.viewContext.component.type.reference === tokenReference(dep.token) ||
	                        isPresent(this.viewContext.viewProviders.get(tokenReference(dep.token)))) {
	                        result = dep;
	                    }
	                    else {
	                        result = dep.isOptional ? result = { isValue: true, value: null } : null;
	                    }
	                }
	            }
	            if (!result) {
	                this.viewContext.errors.push(new ProviderError("No provider for " + tokenName(dep.token), this._sourceSpan));
	            }
	            return result;
	        };
	        return ProviderElementContext;
	    }());
	    var NgModuleProviderAnalyzer = (function () {
	        /**
	         * @param {?} ngModule
	         * @param {?} extraProviders
	         * @param {?} sourceSpan
	         */
	        function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {
	            var _this = this;
	            this._transformedProviders = new Map();
	            this._seenProviders = new Map();
	            this._errors = [];
	            this._allProviders = new Map();
	            ngModule.transitiveModule.modules.forEach(function (ngModuleType) {
	                var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };
	                _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);
	            });
	            _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);
	        }
	        /**
	         * @return {?}
	         */
	        NgModuleProviderAnalyzer.prototype.parse = function () {
	            var _this = this;
	            Array.from(this._allProviders.values()).forEach(function (provider) {
	                _this._getOrCreateLocalProvider(provider.token, provider.eager);
	            });
	            if (this._errors.length > 0) {
	                var /** @type {?} */ errorString = this._errors.join('\n');
	                throw new Error("Provider parse errors:\n" + errorString);
	            }
	            return Array.from(this._transformedProviders.values());
	        };
	        /**
	         * @param {?} token
	         * @param {?} eager
	         * @return {?}
	         */
	        NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {
	            var _this = this;
	            var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));
	            if (!resolvedProvider) {
	                return null;
	            }
	            var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));
	            if (transformedProviderAst) {
	                return transformedProviderAst;
	            }
	            if (isPresent(this._seenProviders.get(tokenReference(token)))) {
	                this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + tokenName(token), resolvedProvider.sourceSpan));
	                return null;
	            }
	            this._seenProviders.set(tokenReference(token), true);
	            var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {
	                var /** @type {?} */ transformedUseValue = provider.useValue;
	                var /** @type {?} */ transformedUseExisting = provider.useExisting;
	                var /** @type {?} */ transformedDeps;
	                if (isPresent(provider.useExisting)) {
	                    var /** @type {?} */ existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);
	                    if (isPresent(existingDiDep.token)) {
	                        transformedUseExisting = existingDiDep.token;
	                    }
	                    else {
	                        transformedUseExisting = null;
	                        transformedUseValue = existingDiDep.value;
	                    }
	                }
	                else if (provider.useFactory) {
	                    var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;
	                    transformedDeps =
	                        deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
	                }
	                else if (provider.useClass) {
	                    var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;
	                    transformedDeps =
	                        deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
	                }
	                return _transformProvider(provider, {
	                    useExisting: transformedUseExisting,
	                    useValue: transformedUseValue,
	                    deps: transformedDeps
	                });
	            });
	            transformedProviderAst =
	                _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
	            this._transformedProviders.set(tokenReference(token), transformedProviderAst);
	            return transformedProviderAst;
	        };
	        /**
	         * @param {?} dep
	         * @param {?=} eager
	         * @param {?} requestorSourceSpan
	         * @return {?}
	         */
	        NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {
	            if (eager === void 0) { eager = null; }
	            var /** @type {?} */ foundLocal = false;
	            if (!dep.isSkipSelf && isPresent(dep.token)) {
	                // access the injector
	                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector) ||
	                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {
	                    foundLocal = true;
	                }
	                else if (isPresent(this._getOrCreateLocalProvider(dep.token, eager))) {
	                    foundLocal = true;
	                }
	            }
	            var /** @type {?} */ result = dep;
	            if (dep.isSelf && !foundLocal) {
	                if (dep.isOptional) {
	                    result = { isValue: true, value: null };
	                }
	                else {
	                    this._errors.push(new ProviderError("No provider for " + tokenName(dep.token), requestorSourceSpan));
	                }
	            }
	            return result;
	        };
	        return NgModuleProviderAnalyzer;
	    }());
	    /**
	     * @param {?} provider
	     * @param {?} __1
	     * @return {?}
	     */
	    function _transformProvider(provider, _a) {
	        var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;
	        return {
	            token: provider.token,
	            useClass: provider.useClass,
	            useExisting: useExisting,
	            useFactory: provider.useFactory,
	            useValue: useValue,
	            deps: deps,
	            multi: provider.multi
	        };
	    }
	    /**
	     * @param {?} provider
	     * @param {?} __1
	     * @return {?}
	     */
	    function _transformProviderAst(provider, _a) {
	        var eager = _a.eager, providers = _a.providers;
	        return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);
	    }
	    /**
	     * @param {?} directives
	     * @param {?} sourceSpan
	     * @param {?} targetErrors
	     * @return {?}
	     */
	    function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
	        var /** @type {?} */ providersByToken = new Map();
	        directives.forEach(function (directive) {
	            var /** @type {?} */ dirProvider = { token: { identifier: directive.type }, useClass: directive.type };
	            _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
	        });
	        // Note: directives need to be able to overwrite providers of a component!
	        var /** @type {?} */ directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));
	        directivesWithComponentFirst.forEach(function (directive) {
	            _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
	            _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
	        });
	        return providersByToken;
	    }
	    /**
	     * @param {?} providers
	     * @param {?} providerType
	     * @param {?} eager
	     * @param {?} sourceSpan
	     * @param {?} targetErrors
	     * @param {?} targetProvidersByToken
	     * @return {?}
	     */
	    function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
	        providers.forEach(function (provider) {
	            var /** @type {?} */ resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));
	            if (isPresent(resolvedProvider) && !!resolvedProvider.multiProvider !== !!provider.multi) {
	                targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + tokenName(resolvedProvider.token), sourceSpan));
	            }
	            if (!resolvedProvider) {
	                var /** @type {?} */ lifecycleHooks = provider.token.identifier &&
	                    ((provider.token.identifier)).lifecycleHooks ?
	                    ((provider.token.identifier)).lifecycleHooks :
	                    [];
	                resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || lifecycleHooks.length > 0, [provider], providerType, lifecycleHooks, sourceSpan);
	                targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);
	            }
	            else {
	                if (!provider.multi) {
	                    resolvedProvider.providers.length = 0;
	                }
	                resolvedProvider.providers.push(provider);
	            }
	        });
	    }
	    /**
	     * @param {?} component
	     * @return {?}
	     */
	    function _getViewQueries(component) {
	        var /** @type {?} */ viewQueries = new Map();
	        if (component.viewQueries) {
	            component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, query); });
	        }
	        return viewQueries;
	    }
	    /**
	     * @param {?} directives
	     * @return {?}
	     */
	    function _getContentQueries(directives) {
	        var /** @type {?} */ contentQueries = new Map();
	        directives.forEach(function (directive) {
	            if (directive.queries) {
	                directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, query); });
	            }
	        });
	        return contentQueries;
	    }
	    /**
	     * @param {?} map
	     * @param {?} query
	     * @return {?}
	     */
	    function _addQueryToTokenMap(map, query) {
	        query.selectors.forEach(function (token) {
	            var /** @type {?} */ entry = map.get(tokenReference(token));
	            if (!entry) {
	                entry = [];
	                map.set(tokenReference(token), entry);
	            }
	            entry.push(query);
	        });
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @abstract
	     */
	    var ElementSchemaRegistry = (function () {
	        function ElementSchemaRegistry() {
	        }
	        /**
	         * @abstract
	         * @param {?} tagName
	         * @param {?} propName
	         * @param {?} schemaMetas
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) { };
	        /**
	         * @abstract
	         * @param {?} tagName
	         * @param {?} schemaMetas
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) { };
	        /**
	         * @abstract
	         * @param {?} elementName
	         * @param {?} propName
	         * @param {?} isAttribute
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.securityContext = function (elementName, propName, isAttribute) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.allKnownElementNames = function () { };
	        /**
	         * @abstract
	         * @param {?} propName
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.validateProperty = function (name) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.validateAttribute = function (name) { };
	        /**
	         * @abstract
	         * @param {?} propName
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) { };
	        /**
	         * @abstract
	         * @param {?} camelCaseProp
	         * @param {?} userProvidedProp
	         * @param {?} val
	         * @return {?}
	         */
	        ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) { };
	        return ElementSchemaRegistry;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var StyleWithImports = (function () {
	        /**
	         * @param {?} style
	         * @param {?} styleUrls
	         */
	        function StyleWithImports(style, styleUrls) {
	            this.style = style;
	            this.styleUrls = styleUrls;
	        }
	        return StyleWithImports;
	    }());
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function isStyleUrlResolvable(url) {
	        if (url == null || url.length === 0 || url[0] == '/')
	            return false;
	        var /** @type {?} */ schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
	        return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
	    }
	    /**
	     * Rewrites stylesheets by resolving and removing the \@import urls that
	     * are either relative or don't have a `package:` scheme
	     * @param {?} resolver
	     * @param {?} baseUrl
	     * @param {?} cssText
	     * @return {?}
	     */
	    function extractStyleUrls(resolver, baseUrl, cssText) {
	        var /** @type {?} */ foundUrls = [];
	        var /** @type {?} */ modifiedCssText = cssText.replace(CSS_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            var /** @type {?} */ url = m[1] || m[2];
	            if (!isStyleUrlResolvable(url)) {
	                // Do not attempt to resolve non-package absolute URLs with URI scheme
	                return m[0];
	            }
	            foundUrls.push(resolver.resolve(baseUrl, url));
	            return '';
	        });
	        return new StyleWithImports(modifiedCssText, foundUrls);
	    }
	    var /** @type {?} */ CSS_IMPORT_REGEXP = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
	    var /** @type {?} */ CSS_COMMENT_REGEXP = /\/\*.+?\*\//g;
	    var /** @type {?} */ URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$17 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ PROPERTY_PARTS_SEPARATOR = '.';
	    var /** @type {?} */ ATTRIBUTE_PREFIX = 'attr';
	    var /** @type {?} */ CLASS_PREFIX = 'class';
	    var /** @type {?} */ STYLE_PREFIX = 'style';
	    var /** @type {?} */ ANIMATE_PROP_PREFIX = 'animate-';
	    var BoundPropertyType = {};
	    BoundPropertyType.DEFAULT = 0;
	    BoundPropertyType.LITERAL_ATTR = 1;
	    BoundPropertyType.ANIMATION = 2;
	    BoundPropertyType[BoundPropertyType.DEFAULT] = "DEFAULT";
	    BoundPropertyType[BoundPropertyType.LITERAL_ATTR] = "LITERAL_ATTR";
	    BoundPropertyType[BoundPropertyType.ANIMATION] = "ANIMATION";
	    /**
	     * Represents a parsed property.
	     */
	    var BoundProperty = (function () {
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} type
	         * @param {?} sourceSpan
	         */
	        function BoundProperty(name, expression, type, sourceSpan) {
	            this.name = name;
	            this.expression = expression;
	            this.type = type;
	            this.sourceSpan = sourceSpan;
	        }
	        Object.defineProperty(BoundProperty.prototype, "isLiteral", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BoundProperty.prototype, "isAnimation", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.type === BoundPropertyType.ANIMATION; },
	            enumerable: true,
	            configurable: true
	        });
	        return BoundProperty;
	    }());
	    /**
	     * Parses bindings in templates and in the directive host area.
	     */
	    var BindingParser = (function () {
	        /**
	         * @param {?} _exprParser
	         * @param {?} _interpolationConfig
	         * @param {?} _schemaRegistry
	         * @param {?} pipes
	         * @param {?} _targetErrors
	         */
	        function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {
	            var _this = this;
	            this._exprParser = _exprParser;
	            this._interpolationConfig = _interpolationConfig;
	            this._schemaRegistry = _schemaRegistry;
	            this._targetErrors = _targetErrors;
	            this.pipesByName = new Map();
	            pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });
	        }
	        /**
	         * @param {?} dirMeta
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, sourceSpan) {
	            var _this = this;
	            if (dirMeta.hostProperties) {
	                var /** @type {?} */ boundProps_1 = [];
	                Object.keys(dirMeta.hostProperties).forEach(function (propName) {
	                    var /** @type {?} */ expression = dirMeta.hostProperties[propName];
	                    if (typeof expression === 'string') {
	                        _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);
	                    }
	                    else {
	                        _this._reportError("Value of the host property binding \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
	                    }
	                });
	                return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(dirMeta.selector, prop); });
	            }
	        };
	        /**
	         * @param {?} dirMeta
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {
	            var _this = this;
	            if (dirMeta.hostListeners) {
	                var /** @type {?} */ targetEventAsts_1 = [];
	                Object.keys(dirMeta.hostListeners).forEach(function (propName) {
	                    var /** @type {?} */ expression = dirMeta.hostListeners[propName];
	                    if (typeof expression === 'string') {
	                        _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);
	                    }
	                    else {
	                        _this._reportError("Value of the host listener \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
	                    }
	                });
	                return targetEventAsts_1;
	            }
	        };
	        /**
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {
	            var /** @type {?} */ sourceInfo = sourceSpan.start.toString();
	            try {
	                var /** @type {?} */ ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
	                if (ast)
	                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
	                this._checkPipes(ast, sourceSpan);
	                return ast;
	            }
	            catch (e) {
	                this._reportError("" + e, sourceSpan);
	                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	            }
	        };
	        /**
	         * @param {?} prefixToken
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @param {?} targetVars
	         * @return {?}
	         */
	        BindingParser.prototype.parseInlineTemplateBinding = function (prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {
	            var /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);
	            for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	                var /** @type {?} */ binding = bindings[i];
	                if (binding.keyIsVar) {
	                    targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));
	                }
	                else if (binding.expression) {
	                    this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);
	                }
	                else {
	                    targetMatchableAttrs.push([binding.key, '']);
	                    this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);
	                }
	            }
	        };
	        /**
	         * @param {?} prefixToken
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype._parseTemplateBindings = function (prefixToken, value, sourceSpan) {
	            var _this = this;
	            var /** @type {?} */ sourceInfo = sourceSpan.start.toString();
	            try {
	                var /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);
	                this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
	                bindingsResult.templateBindings.forEach(function (binding) {
	                    if (binding.expression) {
	                        _this._checkPipes(binding.expression, sourceSpan);
	                    }
	                });
	                bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });
	                return bindingsResult.templateBindings;
	            }
	            catch (e) {
	                this._reportError("" + e, sourceSpan);
	                return [];
	            }
	        };
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @return {?}
	         */
	        BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
	            if (_isAnimationLabel(name)) {
	                name = name.substring(1);
	                if (value) {
	                    this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." +
	                        " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", sourceSpan, ParseErrorLevel.FATAL);
	                }
	                this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);
	            }
	            else {
	                targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));
	            }
	        };
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} isHost
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @return {?}
	         */
	        BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {
	            var /** @type {?} */ isAnimationProp = false;
	            if (name.startsWith(ANIMATE_PROP_PREFIX)) {
	                isAnimationProp = true;
	                name = name.substring(ANIMATE_PROP_PREFIX.length);
	            }
	            else if (_isAnimationLabel(name)) {
	                isAnimationProp = true;
	                name = name.substring(1);
	            }
	            if (isAnimationProp) {
	                this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);
	            }
	            else {
	                this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
	            }
	        };
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @return {?}
	         */
	        BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
	            var /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);
	            if (expr) {
	                this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} name
	         * @param {?} ast
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @return {?}
	         */
	        BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
	            targetMatchableAttrs.push([name, ast.source]);
	            targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));
	        };
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @return {?}
	         */
	        BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
	            // This will occur when a @trigger is not paired with an expression.
	            // For animations it is valid to not have an expression since */void
	            // states will be applied by angular when the element is attached/detached
	            var /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);
	            targetMatchableAttrs.push([name, ast.source]);
	            targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));
	        };
	        /**
	         * @param {?} value
	         * @param {?} isHostBinding
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {
	            var /** @type {?} */ sourceInfo = sourceSpan.start.toString();
	            try {
	                var /** @type {?} */ ast = isHostBinding ?
	                    this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :
	                    this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
	                if (ast)
	                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
	                this._checkPipes(ast, sourceSpan);
	                return ast;
	            }
	            catch (e) {
	                this._reportError("" + e, sourceSpan);
	                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	            }
	        };
	        /**
	         * @param {?} elementSelector
	         * @param {?} boundProp
	         * @return {?}
	         */
	        BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {
	            if (boundProp.isAnimation) {
	                return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, _angular_core.SecurityContext.NONE, false, boundProp.expression, null, boundProp.sourceSpan);
	            }
	            var /** @type {?} */ unit = null;
	            var /** @type {?} */ bindingType;
	            var /** @type {?} */ boundPropertyName = null;
	            var /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
	            var /** @type {?} */ securityContexts;
	            // Check check for special cases (prefix style, attr, class)
	            if (parts.length > 1) {
	                if (parts[0] == ATTRIBUTE_PREFIX) {
	                    boundPropertyName = parts[1];
	                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
	                    securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
	                    var /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');
	                    if (nsSeparatorIdx > -1) {
	                        var /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);
	                        var /** @type {?} */ name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);
	                        boundPropertyName = mergeNsAndName(ns, name_1);
	                    }
	                    bindingType = PropertyBindingType.Attribute;
	                }
	                else if (parts[0] == CLASS_PREFIX) {
	                    boundPropertyName = parts[1];
	                    bindingType = PropertyBindingType.Class;
	                    securityContexts = [_angular_core.SecurityContext.NONE];
	                }
	                else if (parts[0] == STYLE_PREFIX) {
	                    unit = parts.length > 2 ? parts[2] : null;
	                    boundPropertyName = parts[1];
	                    bindingType = PropertyBindingType.Style;
	                    securityContexts = [_angular_core.SecurityContext.STYLE];
	                }
	            }
	            // If not a special case, use the full property name
	            if (boundPropertyName === null) {
	                boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);
	                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);
	                bindingType = PropertyBindingType.Property;
	                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);
	            }
	            return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts.length === 1 ? securityContexts[0] : null, securityContexts.length > 1, boundProp.expression, unit, boundProp.sourceSpan);
	        };
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetEvents
	         * @return {?}
	         */
	        BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	            if (_isAnimationLabel(name)) {
	                name = name.substr(1);
	                this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);
	            }
	            else {
	                this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);
	            }
	        };
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} sourceSpan
	         * @param {?} targetEvents
	         * @return {?}
	         */
	        BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {
	            var /** @type {?} */ matches = splitAtPeriod(name, [name, '']);
	            var /** @type {?} */ eventName = matches[0];
	            var /** @type {?} */ phase = matches[1].toLowerCase();
	            if (phase) {
	                switch (phase) {
	                    case 'start':
	                    case 'done':
	                        var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);
	                        targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));
	                        break;
	                    default:
	                        this._reportError("The provided animation output phase value \"" + phase + "\" for \"@" + eventName + "\" is not supported (use start or done)", sourceSpan);
	                        break;
	                }
	            }
	            else {
	                this._reportError("The animation trigger output event (@" + eventName + ") is missing its phase value name (start or done are currently supported)", sourceSpan);
	            }
	        };
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetEvents
	         * @return {?}
	         */
	        BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	            // long format: 'target: eventName'
	            var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];
	            var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);
	            targetMatchableAttrs.push([name, ast.source]);
	            targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));
	            // Don't detect directives for event names for now,
	            // so don't add the event name to the matchableAttrs
	        };
	        /**
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype._parseAction = function (value, sourceSpan) {
	            var /** @type {?} */ sourceInfo = sourceSpan.start.toString();
	            try {
	                var /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
	                if (ast) {
	                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
	                }
	                if (!ast || ast.ast instanceof EmptyExpr) {
	                    this._reportError("Empty expressions are not allowed", sourceSpan);
	                    return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	                }
	                this._checkPipes(ast, sourceSpan);
	                return ast;
	            }
	            catch (e) {
	                this._reportError("" + e, sourceSpan);
	                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	            }
	        };
	        /**
	         * @param {?} message
	         * @param {?} sourceSpan
	         * @param {?=} level
	         * @return {?}
	         */
	        BindingParser.prototype._reportError = function (message, sourceSpan, level) {
	            if (level === void 0) { level = ParseErrorLevel.FATAL; }
	            this._targetErrors.push(new ParseError(sourceSpan, message, level));
	        };
	        /**
	         * @param {?} errors
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {
	            for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
	                var error = errors_1[_i];
	                this._reportError(error.message, sourceSpan);
	            }
	        };
	        /**
	         * @param {?} ast
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        BindingParser.prototype._checkPipes = function (ast, sourceSpan) {
	            var _this = this;
	            if (ast) {
	                var /** @type {?} */ collector = new PipeCollector();
	                ast.visit(collector);
	                collector.pipes.forEach(function (ast, pipeName) {
	                    if (!_this.pipesByName.has(pipeName)) {
	                        _this._reportError("The pipe '" + pipeName + "' could not be found", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
	                    }
	                });
	            }
	        };
	        /**
	         * @param {?} propName the name of the property / attribute
	         * @param {?} sourceSpan
	         * @param {?} isAttr true when binding to an attribute
	         * @return {?}
	         */
	        BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {
	            var /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
	                this._schemaRegistry.validateProperty(propName);
	            if (report.error) {
	                this._reportError(report.msg, sourceSpan, ParseErrorLevel.FATAL);
	            }
	        };
	        return BindingParser;
	    }());
	    var PipeCollector = (function (_super) {
	        __extends$17(PipeCollector, _super);
	        function PipeCollector() {
	            _super.apply(this, arguments);
	            this.pipes = new Map();
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        PipeCollector.prototype.visitPipe = function (ast, context) {
	            this.pipes.set(ast.name, ast);
	            ast.exp.visit(this);
	            this.visitAll(ast.args, context);
	            return null;
	        };
	        return PipeCollector;
	    }(RecursiveAstVisitor));
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function _isAnimationLabel(name) {
	        return name[0] == '@';
	    }
	    /**
	     * @param {?} registry
	     * @param {?} selector
	     * @param {?} propName
	     * @param {?} isAttribute
	     * @return {?}
	     */
	    function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
	        var /** @type {?} */ ctxs = [];
	        CssSelector.parse(selector).forEach(function (selector) {
	            var /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
	            var /** @type {?} */ notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })
	                .map(function (selector) { return selector.element; }));
	            var /** @type {?} */ possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });
	            ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));
	        });
	        return ctxs.length === 0 ? [_angular_core.SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
	    }

	    var /** @type {?} */ NG_CONTENT_SELECT_ATTR = 'select';
	    var /** @type {?} */ NG_CONTENT_ELEMENT = 'ng-content';
	    var /** @type {?} */ LINK_ELEMENT = 'link';
	    var /** @type {?} */ LINK_STYLE_REL_ATTR = 'rel';
	    var /** @type {?} */ LINK_STYLE_HREF_ATTR = 'href';
	    var /** @type {?} */ LINK_STYLE_REL_VALUE = 'stylesheet';
	    var /** @type {?} */ STYLE_ELEMENT = 'style';
	    var /** @type {?} */ SCRIPT_ELEMENT = 'script';
	    var /** @type {?} */ NG_NON_BINDABLE_ATTR = 'ngNonBindable';
	    var /** @type {?} */ NG_PROJECT_AS = 'ngProjectAs';
	    /**
	     * @param {?} ast
	     * @return {?}
	     */
	    function preparseElement(ast) {
	        var /** @type {?} */ selectAttr = null;
	        var /** @type {?} */ hrefAttr = null;
	        var /** @type {?} */ relAttr = null;
	        var /** @type {?} */ nonBindable = false;
	        var /** @type {?} */ projectAs = null;
	        ast.attrs.forEach(function (attr) {
	            var /** @type {?} */ lcAttrName = attr.name.toLowerCase();
	            if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
	                selectAttr = attr.value;
	            }
	            else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
	                hrefAttr = attr.value;
	            }
	            else if (lcAttrName == LINK_STYLE_REL_ATTR) {
	                relAttr = attr.value;
	            }
	            else if (attr.name == NG_NON_BINDABLE_ATTR) {
	                nonBindable = true;
	            }
	            else if (attr.name == NG_PROJECT_AS) {
	                if (attr.value.length > 0) {
	                    projectAs = attr.value;
	                }
	            }
	        });
	        selectAttr = normalizeNgContentSelect(selectAttr);
	        var /** @type {?} */ nodeName = ast.name.toLowerCase();
	        var /** @type {?} */ type = PreparsedElementType.OTHER;
	        if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
	            type = PreparsedElementType.NG_CONTENT;
	        }
	        else if (nodeName == STYLE_ELEMENT) {
	            type = PreparsedElementType.STYLE;
	        }
	        else if (nodeName == SCRIPT_ELEMENT) {
	            type = PreparsedElementType.SCRIPT;
	        }
	        else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
	            type = PreparsedElementType.STYLESHEET;
	        }
	        return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
	    }
	    var PreparsedElementType = {};
	    PreparsedElementType.NG_CONTENT = 0;
	    PreparsedElementType.STYLE = 1;
	    PreparsedElementType.STYLESHEET = 2;
	    PreparsedElementType.SCRIPT = 3;
	    PreparsedElementType.OTHER = 4;
	    PreparsedElementType[PreparsedElementType.NG_CONTENT] = "NG_CONTENT";
	    PreparsedElementType[PreparsedElementType.STYLE] = "STYLE";
	    PreparsedElementType[PreparsedElementType.STYLESHEET] = "STYLESHEET";
	    PreparsedElementType[PreparsedElementType.SCRIPT] = "SCRIPT";
	    PreparsedElementType[PreparsedElementType.OTHER] = "OTHER";
	    var PreparsedElement = (function () {
	        /**
	         * @param {?} type
	         * @param {?} selectAttr
	         * @param {?} hrefAttr
	         * @param {?} nonBindable
	         * @param {?} projectAs
	         */
	        function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
	            this.type = type;
	            this.selectAttr = selectAttr;
	            this.hrefAttr = hrefAttr;
	            this.nonBindable = nonBindable;
	            this.projectAs = projectAs;
	        }
	        return PreparsedElement;
	    }());
	    /**
	     * @param {?} selectAttr
	     * @return {?}
	     */
	    function normalizeNgContentSelect(selectAttr) {
	        if (selectAttr === null || selectAttr.length === 0) {
	            return '*';
	        }
	        return selectAttr;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    // Group 1 = "bind-"
	    // Group 2 = "let-"
	    // Group 3 = "ref-/#"
	    // Group 4 = "on-"
	    // Group 5 = "bindon-"
	    // Group 6 = "@"
	    // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
	    // Group 8 = identifier inside [()]
	    // Group 9 = identifier inside []
	    // Group 10 = identifier inside ()
	    var /** @type {?} */ BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
	    var /** @type {?} */ KW_BIND_IDX = 1;
	    var /** @type {?} */ KW_LET_IDX = 2;
	    var /** @type {?} */ KW_REF_IDX = 3;
	    var /** @type {?} */ KW_ON_IDX = 4;
	    var /** @type {?} */ KW_BINDON_IDX = 5;
	    var /** @type {?} */ KW_AT_IDX = 6;
	    var /** @type {?} */ IDENT_KW_IDX = 7;
	    var /** @type {?} */ IDENT_BANANA_BOX_IDX = 8;
	    var /** @type {?} */ IDENT_PROPERTY_IDX = 9;
	    var /** @type {?} */ IDENT_EVENT_IDX = 10;
	    var /** @type {?} */ TEMPLATE_ELEMENT = 'template';
	    var /** @type {?} */ TEMPLATE_ATTR = 'template';
	    var /** @type {?} */ TEMPLATE_ATTR_PREFIX = '*';
	    var /** @type {?} */ CLASS_ATTR = 'class';
	    var /** @type {?} */ TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
	    /**
	     * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
	     * parsed templates before compilation is invoked, allowing custom expression syntax
	     * and other advanced transformations.
	     *
	     * This is currently an internal-only feature and not meant for general use.
	     */
	    var /** @type {?} */ TEMPLATE_TRANSFORMS = new _angular_core.OpaqueToken('TemplateTransforms');
	    var TemplateParseError = (function (_super) {
	        __extends(TemplateParseError, _super);
	        /**
	         * @param {?} message
	         * @param {?} span
	         * @param {?} level
	         */
	        function TemplateParseError(message, span, level) {
	            _super.call(this, span, message, level);
	        }
	        return TemplateParseError;
	    }(ParseError));
	    var TemplateParseResult = (function () {
	        /**
	         * @param {?=} templateAst
	         * @param {?=} errors
	         */
	        function TemplateParseResult(templateAst, errors) {
	            this.templateAst = templateAst;
	            this.errors = errors;
	        }
	        return TemplateParseResult;
	    }());
	    var TemplateParser = (function () {
	        /**
	         * @param {?} _exprParser
	         * @param {?} _schemaRegistry
	         * @param {?} _htmlParser
	         * @param {?} _console
	         * @param {?} transforms
	         */
	        function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
	            this._exprParser = _exprParser;
	            this._schemaRegistry = _schemaRegistry;
	            this._htmlParser = _htmlParser;
	            this._console = _console;
	            this.transforms = transforms;
	        }
	        /**
	         * @param {?} component
	         * @param {?} template
	         * @param {?} directives
	         * @param {?} pipes
	         * @param {?} schemas
	         * @param {?} templateUrl
	         * @return {?}
	         */
	        TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {
	            var /** @type {?} */ result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);
	            var /** @type {?} */ warnings = result.errors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; });
	            var /** @type {?} */ errors = result.errors.filter(function (error) { return error.level === ParseErrorLevel.FATAL; });
	            if (warnings.length > 0) {
	                this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
	            }
	            if (errors.length > 0) {
	                var /** @type {?} */ errorString = errors.join('\n');
	                throw new SyntaxError("Template parse errors:\n" + errorString);
	            }
	            return result.templateAst;
	        };
	        /**
	         * @param {?} component
	         * @param {?} template
	         * @param {?} directives
	         * @param {?} pipes
	         * @param {?} schemas
	         * @param {?} templateUrl
	         * @return {?}
	         */
	        TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {
	            return this.tryParseHtml(this.expandHtml(this._htmlParser.parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, template, directives, pipes, schemas, templateUrl);
	        };
	        /**
	         * @param {?} htmlAstWithErrors
	         * @param {?} component
	         * @param {?} template
	         * @param {?} directives
	         * @param {?} pipes
	         * @param {?} schemas
	         * @param {?} templateUrl
	         * @return {?}
	         */
	        TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, template, directives, pipes, schemas, templateUrl) {
	            var /** @type {?} */ result;
	            var /** @type {?} */ errors = htmlAstWithErrors.errors;
	            if (htmlAstWithErrors.rootNodes.length > 0) {
	                var /** @type {?} */ uniqDirectives = removeSummaryDuplicates(directives);
	                var /** @type {?} */ uniqPipes = removeSummaryDuplicates(pipes);
	                var /** @type {?} */ providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
	                var /** @type {?} */ interpolationConfig = void 0;
	                if (component.template && component.template.interpolation) {
	                    interpolationConfig = {
	                        start: component.template.interpolation[0],
	                        end: component.template.interpolation[1]
	                    };
	                }
	                var /** @type {?} */ bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);
	                var /** @type {?} */ parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);
	                result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
	                errors.push.apply(errors, providerViewContext.errors);
	            }
	            else {
	                result = [];
	            }
	            this._assertNoReferenceDuplicationOnTemplate(result, errors);
	            if (errors.length > 0) {
	                return new TemplateParseResult(result, errors);
	            }
	            if (this.transforms) {
	                this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });
	            }
	            return new TemplateParseResult(result, errors);
	        };
	        /**
	         * @param {?} htmlAstWithErrors
	         * @param {?=} forced
	         * @return {?}
	         */
	        TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {
	            if (forced === void 0) { forced = false; }
	            var /** @type {?} */ errors = htmlAstWithErrors.errors;
	            if (errors.length == 0 || forced) {
	                // Transform ICU messages to angular directives
	                var /** @type {?} */ expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
	                errors.push.apply(errors, expandedHtmlAst.errors);
	                htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
	            }
	            return htmlAstWithErrors;
	        };
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        TemplateParser.prototype.getInterpolationConfig = function (component) {
	            if (component.template) {
	                return InterpolationConfig.fromArray(component.template.interpolation);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} result
	         * @param {?} errors
	         * @return {?}
	         */
	        TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {
	            var /** @type {?} */ existingReferences = [];
	            result.filter(function (element) { return !!((element)).references; })
	                .forEach(function (element) { return ((element)).references.forEach(function (reference) {
	                var /** @type {?} */ name = reference.name;
	                if (existingReferences.indexOf(name) < 0) {
	                    existingReferences.push(name);
	                }
	                else {
	                    var /** @type {?} */ error = new TemplateParseError("Reference \"#" + name + "\" is defined several times", reference.sourceSpan, ParseErrorLevel.FATAL);
	                    errors.push(error);
	                }
	            }); });
	        };
	        /** @nocollapse */
	        TemplateParser.ctorParameters = function () { return [
	            { type: Parser, },
	            { type: ElementSchemaRegistry, },
	            { type: I18NHtmlParser, },
	            { type: Console, },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [TEMPLATE_TRANSFORMS,] },] },
	        ]; };
	        TemplateParser = __decorate([
	            CompilerInjectable(), 
	            __metadata('design:paramtypes', [Parser, ElementSchemaRegistry, I18NHtmlParser, Console, Array])
	        ], TemplateParser);
	        return TemplateParser;
	    }());
	    var TemplateParseVisitor = (function () {
	        /**
	         * @param {?} providerViewContext
	         * @param {?} directives
	         * @param {?} _bindingParser
	         * @param {?} _schemaRegistry
	         * @param {?} _schemas
	         * @param {?} _targetErrors
	         */
	        function TemplateParseVisitor(providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {
	            var _this = this;
	            this.providerViewContext = providerViewContext;
	            this._bindingParser = _bindingParser;
	            this._schemaRegistry = _schemaRegistry;
	            this._schemas = _schemas;
	            this._targetErrors = _targetErrors;
	            this.selectorMatcher = new SelectorMatcher();
	            this.directivesIndex = new Map();
	            this.ngContentCount = 0;
	            directives.forEach(function (directive, index) {
	                var selector = CssSelector.parse(directive.selector);
	                _this.selectorMatcher.addSelectables(selector, directive);
	                _this.directivesIndex.set(directive, index);
	            });
	        }
	        /**
	         * @param {?} expansion
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };
	        /**
	         * @param {?} expansionCase
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };
	        /**
	         * @param {?} text
	         * @param {?} parent
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype.visitText = function (text, parent) {
	            var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
	            var /** @type {?} */ expr = this._bindingParser.parseInterpolation(text.value, text.sourceSpan);
	            if (expr) {
	                return new BoundTextAst(expr, ngContentIndex, text.sourceSpan);
	            }
	            else {
	                return new TextAst(text.value, ngContentIndex, text.sourceSpan);
	            }
	        };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {
	            return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
	        };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };
	        /**
	         * @param {?} element
	         * @param {?} parent
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype.visitElement = function (element, parent) {
	            var _this = this;
	            var /** @type {?} */ nodeName = element.name;
	            var /** @type {?} */ preparsedElement = preparseElement(element);
	            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
	                preparsedElement.type === PreparsedElementType.STYLE) {
	                // Skipping <script> for security reasons
	                // Skipping <style> as we already processed them
	                // in the StyleCompiler
	                return null;
	            }
	            if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
	                isStyleUrlResolvable(preparsedElement.hrefAttr)) {
	                // Skipping stylesheets with either relative urls or package scheme as we already processed
	                // them in the StyleCompiler
	                return null;
	            }
	            var /** @type {?} */ matchableAttrs = [];
	            var /** @type {?} */ elementOrDirectiveProps = [];
	            var /** @type {?} */ elementOrDirectiveRefs = [];
	            var /** @type {?} */ elementVars = [];
	            var /** @type {?} */ events = [];
	            var /** @type {?} */ templateElementOrDirectiveProps = [];
	            var /** @type {?} */ templateMatchableAttrs = [];
	            var /** @type {?} */ templateElementVars = [];
	            var /** @type {?} */ hasInlineTemplates = false;
	            var /** @type {?} */ attrs = [];
	            var /** @type {?} */ lcElName = splitNsName(nodeName.toLowerCase())[1];
	            var /** @type {?} */ isTemplateElement = lcElName == TEMPLATE_ELEMENT;
	            element.attrs.forEach(function (attr) {
	                var /** @type {?} */ hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
	                var /** @type {?} */ templateBindingsSource;
	                var /** @type {?} */ prefixToken;
	                var /** @type {?} */ normalizedName = _this._normalizeAttributeName(attr.name);
	                if (normalizedName == TEMPLATE_ATTR) {
	                    templateBindingsSource = attr.value;
	                }
	                else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
	                    templateBindingsSource = attr.value;
	                    prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';
	                }
	                var /** @type {?} */ hasTemplateBinding = isPresent(templateBindingsSource);
	                if (hasTemplateBinding) {
	                    if (hasInlineTemplates) {
	                        _this._reportError("Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *", attr.sourceSpan);
	                    }
	                    hasInlineTemplates = true;
	                    _this._bindingParser.parseInlineTemplateBinding(prefixToken, templateBindingsSource, attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
	                }
	                if (!hasBinding && !hasTemplateBinding) {
	                    // don't include the bindings as attributes as well in the AST
	                    attrs.push(_this.visitAttribute(attr, null));
	                    matchableAttrs.push([attr.name, attr.value]);
	                }
	            });
	            var /** @type {?} */ elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
	            var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;
	            var /** @type {?} */ references = [];
	            var /** @type {?} */ directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
	            var /** @type {?} */ elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts);
	            var /** @type {?} */ isViewRoot = parent.isTemplateElement || hasInlineTemplates;
	            var /** @type {?} */ providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
	            var /** @type {?} */ children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
	            providerContext.afterElement();
	            // Override the actual selector when the `ngProjectAs` attribute is provided
	            var /** @type {?} */ projectionSelector = isPresent(preparsedElement.projectAs) ?
	                CssSelector.parse(preparsedElement.projectAs)[0] :
	                elementCssSelector;
	            var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(projectionSelector);
	            var /** @type {?} */ parsedElement;
	            if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
	                if (element.children && !element.children.every(_isEmptyTextNode)) {
	                    this._reportError("<ng-content> element cannot have content.", element.sourceSpan);
	                }
	                parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
	            }
	            else if (isTemplateElement) {
	                this._assertAllEventsPublishedByDirectives(directiveAsts, events);
	                this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
	                parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
	            }
	            else {
	                this._assertElementExists(matchElement, element);
	                this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
	                var /** @type {?} */ ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
	                parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan);
	                this._findComponentDirectives(directiveAsts)
	                    .forEach(function (componentDirectiveAst) { return _this._validateElementAnimationInputOutputs(componentDirectiveAst.hostProperties, componentDirectiveAst.hostEvents, componentDirectiveAst.directive.template); });
	                var /** @type {?} */ componentTemplate = providerContext.viewContext.component.template;
	                this._validateElementAnimationInputOutputs(elementProps, events, componentTemplate.toSummary());
	            }
	            if (hasInlineTemplates) {
	                var /** @type {?} */ templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
	                var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector).directives;
	                var /** @type {?} */ templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
	                var /** @type {?} */ templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
	                this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
	                var /** @type {?} */ templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
	                templateProviderContext.afterElement();
	                parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
	            }
	            return parsedElement;
	        };
	        /**
	         * @param {?} inputs
	         * @param {?} outputs
	         * @param {?} template
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._validateElementAnimationInputOutputs = function (inputs, outputs, template) {
	            var _this = this;
	            var /** @type {?} */ triggerLookup = new Set();
	            template.animations.forEach(function (entry) { triggerLookup.add(entry); });
	            var /** @type {?} */ animationInputs = inputs.filter(function (input) { return input.isAnimation; });
	            animationInputs.forEach(function (input) {
	                var /** @type {?} */ name = input.name;
	                if (!triggerLookup.has(name)) {
	                    _this._reportError("Couldn't find an animation entry for \"" + name + "\"", input.sourceSpan);
	                }
	            });
	            outputs.forEach(function (output) {
	                if (output.isAnimation) {
	                    var /** @type {?} */ found = animationInputs.find(function (input) { return input.name == output.name; });
	                    if (!found) {
	                        _this._reportError("Unable to listen on (@" + output.name + "." + output.phase + ") because the animation trigger [@" + output.name + "] isn't being used on the same element", output.sourceSpan);
	                    }
	                }
	            });
	        };
	        /**
	         * @param {?} isTemplateElement
	         * @param {?} attr
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetProps
	         * @param {?} targetEvents
	         * @param {?} targetRefs
	         * @param {?} targetVars
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
	            var /** @type {?} */ name = this._normalizeAttributeName(attr.name);
	            var /** @type {?} */ value = attr.value;
	            var /** @type {?} */ srcSpan = attr.sourceSpan;
	            var /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);
	            var /** @type {?} */ hasBinding = false;
	            if (bindParts !== null) {
	                hasBinding = true;
	                if (isPresent(bindParts[KW_BIND_IDX])) {
	                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	                }
	                else if (bindParts[KW_LET_IDX]) {
	                    if (isTemplateElement) {
	                        var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];
	                        this._parseVariable(identifier, value, srcSpan, targetVars);
	                    }
	                    else {
	                        this._reportError("\"let-\" is only supported on template elements.", srcSpan);
	                    }
	                }
	                else if (bindParts[KW_REF_IDX]) {
	                    var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];
	                    this._parseReference(identifier, value, srcSpan, targetRefs);
	                }
	                else if (bindParts[KW_ON_IDX]) {
	                    this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	                }
	                else if (bindParts[KW_BINDON_IDX]) {
	                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	                    this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	                }
	                else if (bindParts[KW_AT_IDX]) {
	                    this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
	                }
	                else if (bindParts[IDENT_BANANA_BOX_IDX]) {
	                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	                    this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	                }
	                else if (bindParts[IDENT_PROPERTY_IDX]) {
	                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
	                }
	                else if (bindParts[IDENT_EVENT_IDX]) {
	                    this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
	                }
	            }
	            else {
	                hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);
	            }
	            if (!hasBinding) {
	                this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
	            }
	            return hasBinding;
	        };
	        /**
	         * @param {?} attrName
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
	            return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
	        };
	        /**
	         * @param {?} identifier
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @param {?} targetVars
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {
	            if (identifier.indexOf('-') > -1) {
	                this._reportError("\"-\" is not allowed in variable names", sourceSpan);
	            }
	            targetVars.push(new VariableAst(identifier, value, sourceSpan));
	        };
	        /**
	         * @param {?} identifier
	         * @param {?} value
	         * @param {?} sourceSpan
	         * @param {?} targetRefs
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {
	            if (identifier.indexOf('-') > -1) {
	                this._reportError("\"-\" is not allowed in reference names", sourceSpan);
	            }
	            targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
	        };
	        /**
	         * @param {?} name
	         * @param {?} expression
	         * @param {?} sourceSpan
	         * @param {?} targetMatchableAttrs
	         * @param {?} targetEvents
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	            this._bindingParser.parseEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
	        };
	        /**
	         * @param {?} selectorMatcher
	         * @param {?} elementCssSelector
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
	            var _this = this;
	            // Need to sort the directives so that we get consistent results throughout,
	            // as selectorMatcher uses Maps inside.
	            // Also deduplicate directives as they might match more than one time!
	            var /** @type {?} */ directives = new Array(this.directivesIndex.size);
	            // Whether any directive selector matches on the element name
	            var /** @type {?} */ matchElement = false;
	            selectorMatcher.match(elementCssSelector, function (selector, directive) {
	                directives[_this.directivesIndex.get(directive)] = directive;
	                matchElement = matchElement || selector.hasElementSelector();
	            });
	            return {
	                directives: directives.filter(function (dir) { return !!dir; }),
	                matchElement: matchElement,
	            };
	        };
	        /**
	         * @param {?} isTemplateElement
	         * @param {?} elementName
	         * @param {?} directives
	         * @param {?} props
	         * @param {?} elementOrDirectiveRefs
	         * @param {?} elementSourceSpan
	         * @param {?} targetReferences
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences) {
	            var _this = this;
	            var /** @type {?} */ matchedReferences = new Set();
	            var /** @type {?} */ component = null;
	            var /** @type {?} */ directiveAsts = directives.map(function (directive) {
	                var /** @type {?} */ sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive " + identifierName(directive.type));
	                if (directive.isComponent) {
	                    component = directive;
	                }
	                var /** @type {?} */ directiveProperties = [];
	                var /** @type {?} */ hostProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, sourceSpan);
	                // Note: We need to check the host properties here as well,
	                // as we don't know the element name in the DirectiveWrapperCompiler yet.
	                _this._checkPropertiesInSchema(elementName, hostProperties);
	                var /** @type {?} */ hostEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);
	                _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
	                elementOrDirectiveRefs.forEach(function (elOrDirRef) {
	                    if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
	                        (directive.exportAs == elOrDirRef.value)) {
	                        targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));
	                        matchedReferences.add(elOrDirRef.name);
	                    }
	                });
	                return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
	            });
	            elementOrDirectiveRefs.forEach(function (elOrDirRef) {
	                if (elOrDirRef.value.length > 0) {
	                    if (!matchedReferences.has(elOrDirRef.name)) {
	                        _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
	                    }
	                }
	                else if (!component) {
	                    var /** @type {?} */ refToken = null;
	                    if (isTemplateElement) {
	                        refToken = createIdentifierToken(Identifiers.TemplateRef);
	                    }
	                    targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
	                }
	            });
	            return directiveAsts;
	        };
	        /**
	         * @param {?} directiveProperties
	         * @param {?} boundProps
	         * @param {?} targetBoundDirectiveProps
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
	            if (directiveProperties) {
	                var /** @type {?} */ boundPropsByName_1 = new Map();
	                boundProps.forEach(function (boundProp) {
	                    var /** @type {?} */ prevValue = boundPropsByName_1.get(boundProp.name);
	                    if (!prevValue || prevValue.isLiteral) {
	                        // give [a]="b" a higher precedence than a="b" on the same element
	                        boundPropsByName_1.set(boundProp.name, boundProp);
	                    }
	                });
	                Object.keys(directiveProperties).forEach(function (dirProp) {
	                    var /** @type {?} */ elProp = directiveProperties[dirProp];
	                    var /** @type {?} */ boundProp = boundPropsByName_1.get(elProp);
	                    // Bindings are optional, so this binding only needs to be set up if an expression is given.
	                    if (boundProp) {
	                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
	                    }
	                });
	            }
	        };
	        /**
	         * @param {?} elementName
	         * @param {?} props
	         * @param {?} directives
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
	            var _this = this;
	            var /** @type {?} */ boundElementProps = [];
	            var /** @type {?} */ boundDirectivePropsIndex = new Map();
	            directives.forEach(function (directive) {
	                directive.inputs.forEach(function (prop) {
	                    boundDirectivePropsIndex.set(prop.templateName, prop);
	                });
	            });
	            props.forEach(function (prop) {
	                if (!prop.isLiteral && !boundDirectivePropsIndex.get(prop.name)) {
	                    boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));
	                }
	            });
	            this._checkPropertiesInSchema(elementName, boundElementProps);
	            return boundElementProps;
	        };
	        /**
	         * @param {?} directives
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {
	            return directives.filter(function (directive) { return directive.directive.isComponent; });
	        };
	        /**
	         * @param {?} directives
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
	            return this._findComponentDirectives(directives)
	                .map(function (directive) { return identifierName(directive.directive.type); });
	        };
	        /**
	         * @param {?} directives
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {
	            var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);
	            if (componentTypeNames.length > 1) {
	                this._reportError("More than one component matched on this element.\n" +
	                    "Make sure that only one component's selector can match a given element.\n" +
	                    ("Conflicting components: " + componentTypeNames.join(',')), sourceSpan);
	            }
	        };
	        /**
	         * Make sure that non-angular tags conform to the schemas.
	         *
	         * Note: An element is considered an angular tag when at least one directive selector matches the
	         * tag name.
	         *
	         * @param {?} matchElement Whether any directive has matched on the tag name
	         * @param {?} element the html element
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {
	            var /** @type {?} */ elName = element.name.replace(/^:xhtml:/, '');
	            if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
	                var /** @type {?} */ errorMsg = ("'" + elName + "' is not a known element:\n") +
	                    ("1. If '" + elName + "' is an Angular component, then verify that it is part of this module.\n") +
	                    ("2. If '" + elName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.");
	                this._reportError(errorMsg, element.sourceSpan);
	            }
	        };
	        /**
	         * @param {?} directives
	         * @param {?} elementProps
	         * @param {?} sourceSpan
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {
	            var _this = this;
	            var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);
	            if (componentTypeNames.length > 0) {
	                this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
	            }
	            elementProps.forEach(function (prop) {
	                _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".", sourceSpan);
	            });
	        };
	        /**
	         * @param {?} directives
	         * @param {?} events
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {
	            var _this = this;
	            var /** @type {?} */ allDirectiveEvents = new Set();
	            directives.forEach(function (directive) {
	                Object.keys(directive.directive.outputs).forEach(function (k) {
	                    var /** @type {?} */ eventName = directive.directive.outputs[k];
	                    allDirectiveEvents.add(eventName);
	                });
	            });
	            events.forEach(function (event) {
	                if (isPresent(event.target) || !allDirectiveEvents.has(event.name)) {
	                    _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".", event.sourceSpan);
	                }
	            });
	        };
	        /**
	         * @param {?} elementName
	         * @param {?} boundProps
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {
	            var _this = this;
	            boundProps.forEach(function (boundProp) {
	                if (boundProp.type === PropertyBindingType.Property &&
	                    !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {
	                    var /** @type {?} */ errorMsg = "Can't bind to '" + boundProp.name + "' since it isn't a known property of '" + elementName + "'.";
	                    if (elementName.indexOf('-') > -1) {
	                        errorMsg +=
	                            ("\n1. If '" + elementName + "' is an Angular component and it has '" + boundProp.name + "' input, then verify that it is part of this module.") +
	                                ("\n2. If '" + elementName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.\n");
	                    }
	                    _this._reportError(errorMsg, boundProp.sourceSpan);
	                }
	            });
	        };
	        /**
	         * @param {?} message
	         * @param {?} sourceSpan
	         * @param {?=} level
	         * @return {?}
	         */
	        TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {
	            if (level === void 0) { level = ParseErrorLevel.FATAL; }
	            this._targetErrors.push(new ParseError(sourceSpan, message, level));
	        };
	        return TemplateParseVisitor;
	    }());
	    var NonBindableVisitor = (function () {
	        function NonBindableVisitor() {
	        }
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        NonBindableVisitor.prototype.visitElement = function (ast, parent) {
	            var /** @type {?} */ preparsedElement = preparseElement(ast);
	            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
	                preparsedElement.type === PreparsedElementType.STYLE ||
	                preparsedElement.type === PreparsedElementType.STYLESHEET) {
	                // Skipping <script> for security reasons
	                // Skipping <style> and stylesheets as we already processed them
	                // in the StyleCompiler
	                return null;
	            }
	            var /** @type {?} */ attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });
	            var /** @type {?} */ selector = createElementCssSelector(ast.name, attrNameAndValues);
	            var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(selector);
	            var /** @type {?} */ children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
	            return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
	        };
	        /**
	         * @param {?} comment
	         * @param {?} context
	         * @return {?}
	         */
	        NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };
	        /**
	         * @param {?} attribute
	         * @param {?} context
	         * @return {?}
	         */
	        NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {
	            return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
	        };
	        /**
	         * @param {?} text
	         * @param {?} parent
	         * @return {?}
	         */
	        NonBindableVisitor.prototype.visitText = function (text, parent) {
	            var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
	            return new TextAst(text.value, ngContentIndex, text.sourceSpan);
	        };
	        /**
	         * @param {?} expansion
	         * @param {?} context
	         * @return {?}
	         */
	        NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };
	        /**
	         * @param {?} expansionCase
	         * @param {?} context
	         * @return {?}
	         */
	        NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };
	        return NonBindableVisitor;
	    }());
	    var ElementOrDirectiveRef = (function () {
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?} sourceSpan
	         */
	        function ElementOrDirectiveRef(name, value, sourceSpan) {
	            this.name = name;
	            this.value = value;
	            this.sourceSpan = sourceSpan;
	        }
	        return ElementOrDirectiveRef;
	    }());
	    /**
	     * @param {?} classAttrValue
	     * @return {?}
	     */
	    function splitClasses(classAttrValue) {
	        return classAttrValue.trim().split(/\s+/g);
	    }
	    var ElementContext = (function () {
	        /**
	         * @param {?} isTemplateElement
	         * @param {?} _ngContentIndexMatcher
	         * @param {?} _wildcardNgContentIndex
	         * @param {?} providerContext
	         */
	        function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
	            this.isTemplateElement = isTemplateElement;
	            this._ngContentIndexMatcher = _ngContentIndexMatcher;
	            this._wildcardNgContentIndex = _wildcardNgContentIndex;
	            this.providerContext = providerContext;
	        }
	        /**
	         * @param {?} isTemplateElement
	         * @param {?} directives
	         * @param {?} providerContext
	         * @return {?}
	         */
	        ElementContext.create = function (isTemplateElement, directives, providerContext) {
	            var /** @type {?} */ matcher = new SelectorMatcher();
	            var /** @type {?} */ wildcardNgContentIndex = null;
	            var /** @type {?} */ component = directives.find(function (directive) { return directive.directive.isComponent; });
	            if (component) {
	                var /** @type {?} */ ngContentSelectors = component.directive.template.ngContentSelectors;
	                for (var /** @type {?} */ i = 0; i < ngContentSelectors.length; i++) {
	                    var /** @type {?} */ selector = ngContentSelectors[i];
	                    if (selector === '*') {
	                        wildcardNgContentIndex = i;
	                    }
	                    else {
	                        matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
	                    }
	                }
	            }
	            return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
	        };
	        /**
	         * @param {?} selector
	         * @return {?}
	         */
	        ElementContext.prototype.findNgContentIndex = function (selector) {
	            var /** @type {?} */ ngContentIndices = [];
	            this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
	            ngContentIndices.sort();
	            if (isPresent(this._wildcardNgContentIndex)) {
	                ngContentIndices.push(this._wildcardNgContentIndex);
	            }
	            return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
	        };
	        return ElementContext;
	    }());
	    /**
	     * @param {?} elementName
	     * @param {?} attributes
	     * @return {?}
	     */
	    function createElementCssSelector(elementName, attributes) {
	        var /** @type {?} */ cssSelector = new CssSelector();
	        var /** @type {?} */ elNameNoNs = splitNsName(elementName)[1];
	        cssSelector.setElement(elNameNoNs);
	        for (var /** @type {?} */ i = 0; i < attributes.length; i++) {
	            var /** @type {?} */ attrName = attributes[i][0];
	            var /** @type {?} */ attrNameNoNs = splitNsName(attrName)[1];
	            var /** @type {?} */ attrValue = attributes[i][1];
	            cssSelector.addAttribute(attrNameNoNs, attrValue);
	            if (attrName.toLowerCase() == CLASS_ATTR) {
	                var /** @type {?} */ classes = splitClasses(attrValue);
	                classes.forEach(function (className) { return cssSelector.addClassName(className); });
	            }
	        }
	        return cssSelector;
	    }
	    var /** @type {?} */ EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
	    var /** @type {?} */ NON_BINDABLE_VISITOR = new NonBindableVisitor();
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function _isEmptyTextNode(node) {
	        return node instanceof Text && node.value.trim().length == 0;
	    }
	    /**
	     * @param {?} items
	     * @return {?}
	     */
	    function removeSummaryDuplicates(items) {
	        var /** @type {?} */ map = new Map();
	        items.forEach(function (item) {
	            if (!map.get(item.type.reference)) {
	                map.set(item.type.reference, item);
	            }
	        });
	        return Array.from(map.values());
	    }

	    var CompilerConfig = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function CompilerConfig(_a) {
	            var _b = _a === void 0 ? {} : _a, _c = _b.renderTypes, renderTypes = _c === void 0 ? new DefaultRenderTypes() : _c, _d = _b.defaultEncapsulation, defaultEncapsulation = _d === void 0 ? _angular_core.ViewEncapsulation.Emulated : _d, genDebugInfo = _b.genDebugInfo, logBindingUpdate = _b.logBindingUpdate, _e = _b.useJit, useJit = _e === void 0 ? true : _e;
	            this.renderTypes = renderTypes;
	            this.defaultEncapsulation = defaultEncapsulation;
	            this._genDebugInfo = genDebugInfo;
	            this._logBindingUpdate = logBindingUpdate;
	            this.useJit = useJit;
	        }
	        Object.defineProperty(CompilerConfig.prototype, "genDebugInfo", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._genDebugInfo === void 0 ? _angular_core.isDevMode() : this._genDebugInfo;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(CompilerConfig.prototype, "logBindingUpdate", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._logBindingUpdate === void 0 ? _angular_core.isDevMode() : this._logBindingUpdate;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return CompilerConfig;
	    }());
	    /**
	     * Types used for the renderer.
	     * Can be replaced to specialize the generated output to a specific renderer
	     * to help tree shaking.
	     * @abstract
	     */
	    var RenderTypes = (function () {
	        function RenderTypes() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderTypes.prototype.renderer = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderTypes.prototype.renderText = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderTypes.prototype.renderElement = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderTypes.prototype.renderComment = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderTypes.prototype.renderNode = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderTypes.prototype.renderEvent = function () { };
	        return RenderTypes;
	    }());
	    var DefaultRenderTypes = (function () {
	        function DefaultRenderTypes() {
	            this.renderText = null;
	            this.renderElement = null;
	            this.renderComment = null;
	            this.renderNode = null;
	            this.renderEvent = null;
	        }
	        Object.defineProperty(DefaultRenderTypes.prototype, "renderer", {
	            /**
	             * @return {?}
	             */
	            get: function () { return createIdentifier(Identifiers.Renderer); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        return DefaultRenderTypes;
	    }());

	    var __extends$19 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     * @abstract
	     */
	    var AnimationAst = (function () {
	        function AnimationAst() {
	            this.startTime = 0;
	            this.playTime = 0;
	        }
	        /**
	         * @abstract
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationAst.prototype.visit = function (visitor, context) { };
	        return AnimationAst;
	    }());
	    /**
	     * @abstract
	     */
	    var AnimationStateAst = (function (_super) {
	        __extends$19(AnimationStateAst, _super);
	        function AnimationStateAst() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @abstract
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationStateAst.prototype.visit = function (visitor, context) { };
	        return AnimationStateAst;
	    }(AnimationAst));
	    var AnimationEntryAst = (function (_super) {
	        __extends$19(AnimationEntryAst, _super);
	        /**
	         * @param {?} name
	         * @param {?} stateDeclarations
	         * @param {?} stateTransitions
	         */
	        function AnimationEntryAst(name, stateDeclarations, stateTransitions) {
	            _super.call(this);
	            this.name = name;
	            this.stateDeclarations = stateDeclarations;
	            this.stateTransitions = stateTransitions;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationEntryAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationEntry(this, context);
	        };
	        return AnimationEntryAst;
	    }(AnimationAst));
	    var AnimationStateDeclarationAst = (function (_super) {
	        __extends$19(AnimationStateDeclarationAst, _super);
	        /**
	         * @param {?} stateName
	         * @param {?} styles
	         */
	        function AnimationStateDeclarationAst(stateName, styles) {
	            _super.call(this);
	            this.stateName = stateName;
	            this.styles = styles;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationStateDeclarationAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationStateDeclaration(this, context);
	        };
	        return AnimationStateDeclarationAst;
	    }(AnimationStateAst));
	    var AnimationStateTransitionExpression = (function () {
	        /**
	         * @param {?} fromState
	         * @param {?} toState
	         */
	        function AnimationStateTransitionExpression(fromState, toState) {
	            this.fromState = fromState;
	            this.toState = toState;
	        }
	        return AnimationStateTransitionExpression;
	    }());
	    var AnimationStateTransitionAst = (function (_super) {
	        __extends$19(AnimationStateTransitionAst, _super);
	        /**
	         * @param {?} stateChanges
	         * @param {?} animation
	         */
	        function AnimationStateTransitionAst(stateChanges, animation) {
	            _super.call(this);
	            this.stateChanges = stateChanges;
	            this.animation = animation;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationStateTransitionAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationStateTransition(this, context);
	        };
	        return AnimationStateTransitionAst;
	    }(AnimationStateAst));
	    var AnimationStepAst = (function (_super) {
	        __extends$19(AnimationStepAst, _super);
	        /**
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         */
	        function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {
	            _super.call(this);
	            this.startingStyles = startingStyles;
	            this.keyframes = keyframes;
	            this.duration = duration;
	            this.delay = delay;
	            this.easing = easing;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationStepAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationStep(this, context);
	        };
	        return AnimationStepAst;
	    }(AnimationAst));
	    var AnimationStylesAst = (function (_super) {
	        __extends$19(AnimationStylesAst, _super);
	        /**
	         * @param {?} styles
	         */
	        function AnimationStylesAst(styles) {
	            _super.call(this);
	            this.styles = styles;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationStylesAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationStyles(this, context);
	        };
	        return AnimationStylesAst;
	    }(AnimationAst));
	    var AnimationKeyframeAst = (function (_super) {
	        __extends$19(AnimationKeyframeAst, _super);
	        /**
	         * @param {?} offset
	         * @param {?} styles
	         */
	        function AnimationKeyframeAst(offset, styles) {
	            _super.call(this);
	            this.offset = offset;
	            this.styles = styles;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationKeyframeAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationKeyframe(this, context);
	        };
	        return AnimationKeyframeAst;
	    }(AnimationAst));
	    /**
	     * @abstract
	     */
	    var AnimationWithStepsAst = (function (_super) {
	        __extends$19(AnimationWithStepsAst, _super);
	        /**
	         * @param {?} steps
	         */
	        function AnimationWithStepsAst(steps) {
	            _super.call(this);
	            this.steps = steps;
	        }
	        return AnimationWithStepsAst;
	    }(AnimationAst));
	    var AnimationGroupAst = (function (_super) {
	        __extends$19(AnimationGroupAst, _super);
	        /**
	         * @param {?} steps
	         */
	        function AnimationGroupAst(steps) {
	            _super.call(this, steps);
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationGroupAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationGroup(this, context);
	        };
	        return AnimationGroupAst;
	    }(AnimationWithStepsAst));
	    var AnimationSequenceAst = (function (_super) {
	        __extends$19(AnimationSequenceAst, _super);
	        /**
	         * @param {?} steps
	         */
	        function AnimationSequenceAst(steps) {
	            _super.call(this, steps);
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        AnimationSequenceAst.prototype.visit = function (visitor, context) {
	            return visitor.visitAnimationSequence(this, context);
	        };
	        return AnimationSequenceAst;
	    }(AnimationWithStepsAst));

	    var StylesCollectionEntry = (function () {
	        /**
	         * @param {?} time
	         * @param {?} value
	         */
	        function StylesCollectionEntry(time, value) {
	            this.time = time;
	            this.value = value;
	        }
	        /**
	         * @param {?} time
	         * @param {?} value
	         * @return {?}
	         */
	        StylesCollectionEntry.prototype.matches = function (time, value) {
	            return time == this.time && value == this.value;
	        };
	        return StylesCollectionEntry;
	    }());
	    var StylesCollection = (function () {
	        function StylesCollection() {
	            this.styles = {};
	        }
	        /**
	         * @param {?} property
	         * @param {?} time
	         * @param {?} value
	         * @return {?}
	         */
	        StylesCollection.prototype.insertAtTime = function (property, time, value) {
	            var /** @type {?} */ tuple = new StylesCollectionEntry(time, value);
	            var /** @type {?} */ entries = this.styles[property];
	            if (!isPresent(entries)) {
	                entries = this.styles[property] = [];
	            }
	            // insert this at the right stop in the array
	            // this way we can keep it sorted
	            var /** @type {?} */ insertionIndex = 0;
	            for (var /** @type {?} */ i = entries.length - 1; i >= 0; i--) {
	                if (entries[i].time <= time) {
	                    insertionIndex = i + 1;
	                    break;
	                }
	            }
	            entries.splice(insertionIndex, 0, tuple);
	        };
	        /**
	         * @param {?} property
	         * @param {?} index
	         * @return {?}
	         */
	        StylesCollection.prototype.getByIndex = function (property, index) {
	            var /** @type {?} */ items = this.styles[property];
	            if (isPresent(items)) {
	                return index >= items.length ? null : items[index];
	            }
	            return null;
	        };
	        /**
	         * @param {?} property
	         * @param {?} time
	         * @return {?}
	         */
	        StylesCollection.prototype.indexOfAtOrBeforeTime = function (property, time) {
	            var /** @type {?} */ entries = this.styles[property];
	            if (isPresent(entries)) {
	                for (var /** @type {?} */ i = entries.length - 1; i >= 0; i--) {
	                    if (entries[i].time <= time)
	                        return i;
	                }
	            }
	            return null;
	        };
	        return StylesCollection;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$18 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$4 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var /** @type {?} */ _INITIAL_KEYFRAME = 0;
	    var /** @type {?} */ _TERMINAL_KEYFRAME = 1;
	    var /** @type {?} */ _ONE_SECOND = 1000;
	    var AnimationParseError = (function (_super) {
	        __extends$18(AnimationParseError, _super);
	        /**
	         * @param {?} message
	         */
	        function AnimationParseError(message) {
	            _super.call(this, null, message);
	        }
	        /**
	         * @return {?}
	         */
	        AnimationParseError.prototype.toString = function () { return "" + this.msg; };
	        return AnimationParseError;
	    }(ParseError));
	    var AnimationEntryParseResult = (function () {
	        /**
	         * @param {?} ast
	         * @param {?} errors
	         */
	        function AnimationEntryParseResult(ast, errors) {
	            this.ast = ast;
	            this.errors = errors;
	        }
	        return AnimationEntryParseResult;
	    }());
	    var AnimationParser = (function () {
	        /**
	         * @param {?} _schema
	         */
	        function AnimationParser(_schema) {
	            this._schema = _schema;
	        }
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        AnimationParser.prototype.parseComponent = function (component) {
	            var _this = this;
	            var /** @type {?} */ errors = [];
	            var /** @type {?} */ componentName = identifierName(component.type);
	            var /** @type {?} */ animationTriggerNames = new Set();
	            var /** @type {?} */ asts = component.template.animations.map(function (entry) {
	                var /** @type {?} */ result = _this.parseEntry(entry);
	                var /** @type {?} */ ast = result.ast;
	                var /** @type {?} */ triggerName = ast.name;
	                if (animationTriggerNames.has(triggerName)) {
	                    result.errors.push(new AnimationParseError("The animation trigger \"" + triggerName + "\" has already been registered for the " + componentName + " component"));
	                }
	                else {
	                    animationTriggerNames.add(triggerName);
	                }
	                if (result.errors.length > 0) {
	                    var /** @type {?} */ errorMessage_1 = "- Unable to parse the animation sequence for \"" + triggerName + "\" on the " + componentName + " component due to the following errors:";
	                    result.errors.forEach(function (error) { errorMessage_1 += '\n-- ' + error.msg; });
	                    errors.push(errorMessage_1);
	                }
	                return ast;
	            });
	            if (errors.length > 0) {
	                var /** @type {?} */ errorString = errors.join('\n');
	                throw new Error("Animation parse errors:\n" + errorString);
	            }
	            return asts;
	        };
	        /**
	         * @param {?} entry
	         * @return {?}
	         */
	        AnimationParser.prototype.parseEntry = function (entry) {
	            var _this = this;
	            var /** @type {?} */ errors = [];
	            var /** @type {?} */ stateStyles = {};
	            var /** @type {?} */ transitions = [];
	            var /** @type {?} */ stateDeclarationAsts = [];
	            entry.definitions.forEach(function (def) {
	                if (def instanceof CompileAnimationStateDeclarationMetadata) {
	                    _parseAnimationDeclarationStates(def, _this._schema, errors).forEach(function (ast) {
	                        stateDeclarationAsts.push(ast);
	                        stateStyles[ast.stateName] = ast.styles;
	                    });
	                }
	                else {
	                    transitions.push(/** @type {?} */ (def));
	                }
	            });
	            var /** @type {?} */ stateTransitionAsts = transitions.map(function (transDef) { return _parseAnimationStateTransition(transDef, stateStyles, _this._schema, errors); });
	            var /** @type {?} */ ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);
	            return new AnimationEntryParseResult(ast, errors);
	        };
	        AnimationParser = __decorate$4([
	            CompilerInjectable(), 
	            __metadata$4('design:paramtypes', [ElementSchemaRegistry])
	        ], AnimationParser);
	        return AnimationParser;
	    }());
	    /**
	     * @param {?} stateMetadata
	     * @param {?} schema
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseAnimationDeclarationStates(stateMetadata, schema, errors) {
	        var /** @type {?} */ normalizedStyles = _normalizeStyleMetadata(stateMetadata.styles, {}, schema, errors, false);
	        var /** @type {?} */ defStyles = new AnimationStylesAst(normalizedStyles);
	        var /** @type {?} */ states = stateMetadata.stateNameExpr.split(/\s*,\s*/);
	        return states.map(function (state) { return new AnimationStateDeclarationAst(state, defStyles); });
	    }
	    /**
	     * @param {?} transitionStateMetadata
	     * @param {?} stateStyles
	     * @param {?} schema
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, schema, errors) {
	        var /** @type {?} */ styles = new StylesCollection();
	        var /** @type {?} */ transitionExprs = [];
	        var /** @type {?} */ transitionStates = transitionStateMetadata.stateChangeExpr.split(/\s*,\s*/);
	        transitionStates.forEach(function (expr) { transitionExprs.push.apply(transitionExprs, _parseAnimationTransitionExpr(expr, errors)); });
	        var /** @type {?} */ entry = _normalizeAnimationEntry(transitionStateMetadata.steps);
	        var /** @type {?} */ animation = _normalizeStyleSteps(entry, stateStyles, schema, errors);
	        var /** @type {?} */ animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);
	        if (errors.length == 0) {
	            _fillAnimationAstStartingKeyframes(animationAst, styles, errors);
	        }
	        var /** @type {?} */ stepsAst = (animationAst instanceof AnimationWithStepsAst) ?
	            animationAst :
	            new AnimationSequenceAst([animationAst]);
	        return new AnimationStateTransitionAst(transitionExprs, stepsAst);
	    }
	    /**
	     * @param {?} alias
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseAnimationAlias(alias, errors) {
	        switch (alias) {
	            case ':enter':
	                return 'void => *';
	            case ':leave':
	                return '* => void';
	            default:
	                errors.push(new AnimationParseError("the transition alias value \"" + alias + "\" is not supported"));
	                return '* => *';
	        }
	    }
	    /**
	     * @param {?} eventStr
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseAnimationTransitionExpr(eventStr, errors) {
	        var /** @type {?} */ expressions = [];
	        if (eventStr[0] == ':') {
	            eventStr = _parseAnimationAlias(eventStr, errors);
	        }
	        var /** @type {?} */ match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
	        if (!isPresent(match) || match.length < 4) {
	            errors.push(new AnimationParseError("the provided " + eventStr + " is not of a supported format"));
	            return expressions;
	        }
	        var /** @type {?} */ fromState = match[1];
	        var /** @type {?} */ separator = match[2];
	        var /** @type {?} */ toState = match[3];
	        expressions.push(new AnimationStateTransitionExpression(fromState, toState));
	        var /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
	        if (separator[0] == '<' && !isFullAnyStateExpr) {
	            expressions.push(new AnimationStateTransitionExpression(toState, fromState));
	        }
	        return expressions;
	    }
	    /**
	     * @param {?} entry
	     * @return {?}
	     */
	    function _normalizeAnimationEntry(entry) {
	        return Array.isArray(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;
	    }
	    /**
	     * @param {?} entry
	     * @param {?} stateStyles
	     * @param {?} schema
	     * @param {?} errors
	     * @param {?} permitStateReferences
	     * @return {?}
	     */
	    function _normalizeStyleMetadata(entry, stateStyles, schema, errors, permitStateReferences) {
	        var /** @type {?} */ offset = entry.offset;
	        if (offset > 1 || offset < 0) {
	            errors.push(new AnimationParseError("Offset values for animations must be between 0 and 1"));
	        }
	        var /** @type {?} */ normalizedStyles = [];
	        entry.styles.forEach(function (styleEntry) {
	            if (typeof styleEntry === 'string') {
	                if (permitStateReferences) {
	                    normalizedStyles.push.apply(normalizedStyles, _resolveStylesFromState(/** @type {?} */ (styleEntry), stateStyles, errors));
	                }
	                else {
	                    errors.push(new AnimationParseError("State based animations cannot contain references to other states"));
	                }
	            }
	            else {
	                var /** @type {?} */ stylesObj_1 = (styleEntry);
	                var /** @type {?} */ normalizedStylesObj_1 = {};
	                Object.keys(stylesObj_1).forEach(function (propName) {
	                    var /** @type {?} */ normalizedProp = schema.normalizeAnimationStyleProperty(propName);
	                    var /** @type {?} */ normalizedOutput = schema.normalizeAnimationStyleValue(normalizedProp, propName, stylesObj_1[propName]);
	                    var /** @type {?} */ normalizationError = normalizedOutput['error'];
	                    if (normalizationError) {
	                        errors.push(new AnimationParseError(normalizationError));
	                    }
	                    normalizedStylesObj_1[normalizedProp] = normalizedOutput['value'];
	                });
	                normalizedStyles.push(normalizedStylesObj_1);
	            }
	        });
	        return normalizedStyles;
	    }
	    /**
	     * @param {?} entry
	     * @param {?} stateStyles
	     * @param {?} schema
	     * @param {?} errors
	     * @return {?}
	     */
	    function _normalizeStyleSteps(entry, stateStyles, schema, errors) {
	        var /** @type {?} */ steps = _normalizeStyleStepEntry(entry, stateStyles, schema, errors);
	        return (entry instanceof CompileAnimationGroupMetadata) ?
	            new CompileAnimationGroupMetadata(steps) :
	            new CompileAnimationSequenceMetadata(steps);
	    }
	    /**
	     * @param {?} stylesList
	     * @param {?} newItem
	     * @return {?}
	     */
	    function _mergeAnimationStyles(stylesList, newItem) {
	        if (typeof newItem === 'object' && newItem !== null && stylesList.length > 0) {
	            var /** @type {?} */ lastIndex = stylesList.length - 1;
	            var /** @type {?} */ lastItem = stylesList[lastIndex];
	            if (typeof lastItem === 'object' && lastItem !== null) {
	                stylesList[lastIndex] = StringMapWrapper.merge(/** @type {?} */ (lastItem), /** @type {?} */ (newItem));
	                return;
	            }
	        }
	        stylesList.push(newItem);
	    }
	    /**
	     * @param {?} entry
	     * @param {?} stateStyles
	     * @param {?} schema
	     * @param {?} errors
	     * @return {?}
	     */
	    function _normalizeStyleStepEntry(entry, stateStyles, schema, errors) {
	        var /** @type {?} */ steps;
	        if (entry instanceof CompileAnimationWithStepsMetadata) {
	            steps = entry.steps;
	        }
	        else {
	            return [entry];
	        }
	        var /** @type {?} */ newSteps = [];
	        var /** @type {?} */ combinedStyles;
	        steps.forEach(function (step) {
	            if (step instanceof CompileAnimationStyleMetadata) {
	                // this occurs when a style step is followed by a previous style step
	                // or when the first style step is run. We want to concatenate all subsequent
	                // style steps together into a single style step such that we have the correct
	                // starting keyframe data to pass into the animation player.
	                if (!isPresent(combinedStyles)) {
	                    combinedStyles = [];
	                }
	                _normalizeStyleMetadata(/** @type {?} */ (step), stateStyles, schema, errors, true)
	                    .forEach(function (entry) { _mergeAnimationStyles(combinedStyles, entry); });
	            }
	            else {
	                // it is important that we create a metadata entry of the combined styles
	                // before we go on an process the animate, sequence or group metadata steps.
	                // This will ensure that the AST will have the previous styles painted on
	                // screen before any further animations that use the styles take place.
	                if (isPresent(combinedStyles)) {
	                    newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
	                    combinedStyles = null;
	                }
	                if (step instanceof CompileAnimationAnimateMetadata) {
	                    // we do not recurse into CompileAnimationAnimateMetadata since
	                    // those style steps are not going to be squashed
	                    var /** @type {?} */ animateStyleValue = ((step)).styles;
	                    if (animateStyleValue instanceof CompileAnimationStyleMetadata) {
	                        animateStyleValue.styles =
	                            _normalizeStyleMetadata(animateStyleValue, stateStyles, schema, errors, true);
	                    }
	                    else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {
	                        animateStyleValue.steps.forEach(function (step) {
	                            step.styles = _normalizeStyleMetadata(step, stateStyles, schema, errors, true);
	                        });
	                    }
	                }
	                else if (step instanceof CompileAnimationWithStepsMetadata) {
	                    var /** @type {?} */ innerSteps = _normalizeStyleStepEntry(step, stateStyles, schema, errors);
	                    step = step instanceof CompileAnimationGroupMetadata ?
	                        new CompileAnimationGroupMetadata(innerSteps) :
	                        new CompileAnimationSequenceMetadata(innerSteps);
	                }
	                newSteps.push(step);
	            }
	        });
	        // this happens when only styles were animated within the sequence
	        if (isPresent(combinedStyles)) {
	            newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
	        }
	        return newSteps;
	    }
	    /**
	     * @param {?} stateName
	     * @param {?} stateStyles
	     * @param {?} errors
	     * @return {?}
	     */
	    function _resolveStylesFromState(stateName, stateStyles, errors) {
	        var /** @type {?} */ styles = [];
	        if (stateName[0] != ':') {
	            errors.push(new AnimationParseError("Animation states via styles must be prefixed with a \":\""));
	        }
	        else {
	            var /** @type {?} */ normalizedStateName = stateName.substring(1);
	            var /** @type {?} */ value = stateStyles[normalizedStateName];
	            if (!isPresent(value)) {
	                errors.push(new AnimationParseError("Unable to apply styles due to missing a state: \"" + normalizedStateName + "\""));
	            }
	            else {
	                value.styles.forEach(function (stylesEntry) {
	                    if (typeof stylesEntry === 'object' && stylesEntry !== null) {
	                        styles.push(/** @type {?} */ (stylesEntry));
	                    }
	                });
	            }
	        }
	        return styles;
	    }
	    var _AnimationTimings = (function () {
	        /**
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         */
	        function _AnimationTimings(duration, delay, easing) {
	            this.duration = duration;
	            this.delay = delay;
	            this.easing = easing;
	        }
	        return _AnimationTimings;
	    }());
	    /**
	     * @param {?} keyframeSequence
	     * @param {?} currentTime
	     * @param {?} collectedStyles
	     * @param {?} stateStyles
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {
	        var /** @type {?} */ totalEntries = keyframeSequence.steps.length;
	        var /** @type {?} */ totalOffsets = 0;
	        keyframeSequence.steps.forEach(function (step) { return totalOffsets += (isPresent(step.offset) ? 1 : 0); });
	        if (totalOffsets > 0 && totalOffsets < totalEntries) {
	            errors.push(new AnimationParseError("Not all style() entries contain an offset for the provided keyframe()"));
	            totalOffsets = totalEntries;
	        }
	        var /** @type {?} */ limit = totalEntries - 1;
	        var /** @type {?} */ margin = totalOffsets == 0 ? (1 / limit) : 0;
	        var /** @type {?} */ rawKeyframes = [];
	        var /** @type {?} */ index = 0;
	        var /** @type {?} */ doSortKeyframes = false;
	        var /** @type {?} */ lastOffset = 0;
	        keyframeSequence.steps.forEach(function (styleMetadata) {
	            var /** @type {?} */ offset = styleMetadata.offset;
	            var /** @type {?} */ keyframeStyles = {};
	            styleMetadata.styles.forEach(function (entry) {
	                Object.keys(entry).forEach(function (prop) {
	                    if (prop != 'offset') {
	                        keyframeStyles[prop] = ((entry))[prop];
	                    }
	                });
	            });
	            if (isPresent(offset)) {
	                doSortKeyframes = doSortKeyframes || (offset < lastOffset);
	            }
	            else {
	                offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);
	            }
	            rawKeyframes.push([offset, keyframeStyles]);
	            lastOffset = offset;
	            index++;
	        });
	        if (doSortKeyframes) {
	            rawKeyframes.sort(function (a, b) { return a[0] <= b[0] ? -1 : 1; });
	        }
	        var /** @type {?} */ firstKeyframe = rawKeyframes[0];
	        if (firstKeyframe[0] != _INITIAL_KEYFRAME) {
	            rawKeyframes.splice(0, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);
	        }
	        var /** @type {?} */ firstKeyframeStyles = firstKeyframe[1];
	        limit = rawKeyframes.length - 1;
	        var /** @type {?} */ lastKeyframe = rawKeyframes[limit];
	        if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {
	            rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);
	            limit++;
	        }
	        var /** @type {?} */ lastKeyframeStyles = lastKeyframe[1];
	        for (var /** @type {?} */ i = 1; i <= limit; i++) {
	            var /** @type {?} */ entry = rawKeyframes[i];
	            var /** @type {?} */ styles = entry[1];
	            Object.keys(styles).forEach(function (prop) {
	                if (!isPresent(firstKeyframeStyles[prop])) {
	                    firstKeyframeStyles[prop] = FILL_STYLE_FLAG;
	                }
	            });
	        }
	        var _loop_1 = function(i) {
	            var /** @type {?} */ entry = rawKeyframes[i];
	            var /** @type {?} */ styles = entry[1];
	            Object.keys(styles).forEach(function (prop) {
	                if (!isPresent(lastKeyframeStyles[prop])) {
	                    lastKeyframeStyles[prop] = styles[prop];
	                }
	            });
	        };
	        for (var /** @type {?} */ i = limit - 1; i >= 0; i--) {
	            _loop_1(i);
	        }
	        return rawKeyframes.map(function (entry) { return new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])); });
	    }
	    /**
	     * @param {?} entry
	     * @param {?} currentTime
	     * @param {?} collectedStyles
	     * @param {?} stateStyles
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {
	        var /** @type {?} */ ast;
	        var /** @type {?} */ playTime = 0;
	        var /** @type {?} */ startingTime = currentTime;
	        if (entry instanceof CompileAnimationWithStepsMetadata) {
	            var /** @type {?} */ maxDuration_1 = 0;
	            var /** @type {?} */ steps_1 = [];
	            var /** @type {?} */ isGroup_1 = entry instanceof CompileAnimationGroupMetadata;
	            var /** @type {?} */ previousStyles_1;
	            entry.steps.forEach(function (entry) {
	                // these will get picked up by the next step...
	                var /** @type {?} */ time = isGroup_1 ? startingTime : currentTime;
	                if (entry instanceof CompileAnimationStyleMetadata) {
	                    entry.styles.forEach(function (stylesEntry) {
	                        // by this point we know that we only have stringmap values
	                        var /** @type {?} */ map = (stylesEntry);
	                        Object.keys(map).forEach(function (prop) { collectedStyles.insertAtTime(prop, time, map[prop]); });
	                    });
	                    previousStyles_1 = entry.styles;
	                    return;
	                }
	                var /** @type {?} */ innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);
	                if (isPresent(previousStyles_1)) {
	                    if (entry instanceof CompileAnimationWithStepsMetadata) {
	                        var /** @type {?} */ startingStyles = new AnimationStylesAst(previousStyles_1);
	                        steps_1.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
	                    }
	                    else {
	                        var /** @type {?} */ innerStep = (innerAst);
	                        (_a = innerStep.startingStyles.styles).push.apply(_a, previousStyles_1);
	                    }
	                    previousStyles_1 = null;
	                }
	                var /** @type {?} */ astDuration = innerAst.playTime;
	                currentTime += astDuration;
	                playTime += astDuration;
	                maxDuration_1 = Math.max(astDuration, maxDuration_1);
	                steps_1.push(innerAst);
	                var _a;
	            });
	            if (isPresent(previousStyles_1)) {
	                var /** @type {?} */ startingStyles = new AnimationStylesAst(previousStyles_1);
	                steps_1.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
	            }
	            if (isGroup_1) {
	                ast = new AnimationGroupAst(steps_1);
	                playTime = maxDuration_1;
	                currentTime = startingTime + playTime;
	            }
	            else {
	                ast = new AnimationSequenceAst(steps_1);
	            }
	        }
	        else if (entry instanceof CompileAnimationAnimateMetadata) {
	            var /** @type {?} */ timings = _parseTimeExpression(entry.timings, errors);
	            var /** @type {?} */ styles = entry.styles;
	            var /** @type {?} */ keyframes = void 0;
	            if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {
	                keyframes =
	                    _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);
	            }
	            else {
	                var /** @type {?} */ styleData = (styles);
	                var /** @type {?} */ offset = _TERMINAL_KEYFRAME;
	                var /** @type {?} */ styleAst = new AnimationStylesAst(/** @type {?} */ (styleData.styles));
	                var /** @type {?} */ keyframe = new AnimationKeyframeAst(offset, styleAst);
	                keyframes = [keyframe];
	            }
	            ast = new AnimationStepAst(new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);
	            playTime = timings.duration + timings.delay;
	            currentTime += playTime;
	            keyframes.forEach(function (keyframe /** TODO #9100 */) { return keyframe.styles.styles.forEach(function (entry /** TODO #9100 */) { return Object.keys(entry).forEach(function (prop) { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); }); }); });
	        }
	        else {
	            // if the code reaches this stage then an error
	            // has already been populated within the _normalizeStyleSteps()
	            // operation...
	            ast = new AnimationStepAst(null, [], 0, 0, '');
	        }
	        ast.playTime = playTime;
	        ast.startTime = startingTime;
	        return ast;
	    }
	    /**
	     * @param {?} ast
	     * @param {?} collectedStyles
	     * @param {?} errors
	     * @return {?}
	     */
	    function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {
	        // steps that only contain style will not be filled
	        if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {
	            var /** @type {?} */ keyframes = ast.keyframes;
	            if (keyframes.length == 1) {
	                var /** @type {?} */ endKeyframe = keyframes[0];
	                var /** @type {?} */ startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);
	                ast.keyframes = [startKeyframe, endKeyframe];
	            }
	        }
	        else if (ast instanceof AnimationWithStepsAst) {
	            ast.steps.forEach(function (entry) { return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors); });
	        }
	    }
	    /**
	     * @param {?} exp
	     * @param {?} errors
	     * @return {?}
	     */
	    function _parseTimeExpression(exp, errors) {
	        var /** @type {?} */ regex = /^([\.\d]+)(m?s)(?:\s+([\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?/i;
	        var /** @type {?} */ duration;
	        var /** @type {?} */ delay = 0;
	        var /** @type {?} */ easing = null;
	        if (typeof exp === 'string') {
	            var /** @type {?} */ matches = exp.match(regex);
	            if (matches === null) {
	                errors.push(new AnimationParseError("The provided timing value \"" + exp + "\" is invalid."));
	                return new _AnimationTimings(0, 0, null);
	            }
	            var /** @type {?} */ durationMatch = parseFloat(matches[1]);
	            var /** @type {?} */ durationUnit = matches[2];
	            if (durationUnit == 's') {
	                durationMatch *= _ONE_SECOND;
	            }
	            duration = Math.floor(durationMatch);
	            var /** @type {?} */ delayMatch = matches[3];
	            var /** @type {?} */ delayUnit = matches[4];
	            if (isPresent(delayMatch)) {
	                var /** @type {?} */ delayVal = parseFloat(delayMatch);
	                if (isPresent(delayUnit) && delayUnit == 's') {
	                    delayVal *= _ONE_SECOND;
	                }
	                delay = Math.floor(delayVal);
	            }
	            var /** @type {?} */ easingVal = matches[5];
	            if (!isBlank(easingVal)) {
	                easing = easingVal;
	            }
	        }
	        else {
	            duration = (exp);
	        }
	        return new _AnimationTimings(duration, delay, easing);
	    }
	    /**
	     * @param {?} endKeyframe
	     * @param {?} startTime
	     * @param {?} duration
	     * @param {?} collectedStyles
	     * @param {?} errors
	     * @return {?}
	     */
	    function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {
	        var /** @type {?} */ values = {};
	        var /** @type {?} */ endTime = startTime + duration;
	        endKeyframe.styles.styles.forEach(function (styleData) {
	            Object.keys(styleData).forEach(function (prop) {
	                var /** @type {?} */ val = styleData[prop];
	                if (prop == 'offset')
	                    return;
	                var /** @type {?} */ resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);
	                var /** @type {?} */ resultEntry /** TODO #9100 */, /** @type {?} */ nextEntry /** TODO #9100 */, /** @type {?} */ value;
	                if (isPresent(resultIndex)) {
	                    resultEntry = collectedStyles.getByIndex(prop, resultIndex);
	                    value = resultEntry.value;
	                    nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);
	                }
	                else {
	                    // this is a flag that the runtime code uses to pass
	                    // in a value either from the state declaration styles
	                    // or using the AUTO_STYLE value (e.g. getComputedStyle)
	                    value = FILL_STYLE_FLAG;
	                }
	                if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {
	                    errors.push(new AnimationParseError("The animated CSS property \"" + prop + "\" unexpectedly changes between steps \"" + resultEntry.time + "ms\" and \"" + endTime + "ms\" at \"" + nextEntry.time + "ms\""));
	                }
	                values[prop] = value;
	            });
	        });
	        return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));
	    }

	    /**
	     * An interface for retrieving documents by URL that the compiler uses
	     * to load templates.
	     */
	    var ResourceLoader = (function () {
	        function ResourceLoader() {
	        }
	        /**
	         * @param {?} url
	         * @return {?}
	         */
	        ResourceLoader.prototype.get = function (url) { return null; };
	        return ResourceLoader;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$6 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    /**
	     * Create a {\@link UrlResolver} with no package prefix.
	     * @return {?}
	     */
	    function createUrlResolverWithoutPackagePrefix() {
	        return new UrlResolver();
	    }
	    /**
	     * @return {?}
	     */
	    function createOfflineCompileUrlResolver() {
	        return new UrlResolver('.');
	    }
	    /**
	     * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
	     */
	    var /** @type {?} */ DEFAULT_PACKAGE_URL_PROVIDER = {
	        provide: _angular_core.PACKAGE_ROOT_URL,
	        useValue: '/'
	    };
	    /**
	     * Used by the {\@link Compiler} when resolving HTML and CSS template URLs.
	     *
	     * This class can be overridden by the application developer to create custom behavior.
	     *
	     * See {\@link Compiler}
	     *
	     * ## Example
	     *
	     * {\@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
	     *
	     * \@security When compiling templates at runtime, you must
	     * ensure that the entire template comes from a trusted source.
	     * Attacker-controlled data introduced by a template could expose your
	     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	     */
	    var UrlResolver = (function () {
	        /**
	         * @param {?=} _packagePrefix
	         */
	        function UrlResolver(_packagePrefix) {
	            if (_packagePrefix === void 0) { _packagePrefix = null; }
	            this._packagePrefix = _packagePrefix;
	        }
	        /**
	         * Resolves the `url` given the `baseUrl`:
	         * - when the `url` is null, the `baseUrl` is returned,
	         * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
	         * `baseUrl` and `url`,
	         * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
	         * returned as is (ignoring the `baseUrl`)
	         * @param {?} baseUrl
	         * @param {?} url
	         * @return {?}
	         */
	        UrlResolver.prototype.resolve = function (baseUrl, url) {
	            var /** @type {?} */ resolvedUrl = url;
	            if (isPresent(baseUrl) && baseUrl.length > 0) {
	                resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
	            }
	            var /** @type {?} */ resolvedParts = _split(resolvedUrl);
	            var /** @type {?} */ prefix = this._packagePrefix;
	            if (isPresent(prefix) && isPresent(resolvedParts) &&
	                resolvedParts[_ComponentIndex.Scheme] == 'package') {
	                var /** @type {?} */ path = resolvedParts[_ComponentIndex.Path];
	                prefix = prefix.replace(/\/+$/, '');
	                path = path.replace(/^\/+/, '');
	                return prefix + "/" + path;
	            }
	            return resolvedUrl;
	        };
	        /** @nocollapse */
	        UrlResolver.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PACKAGE_ROOT_URL,] },] },
	        ]; };
	        UrlResolver = __decorate$6([
	            CompilerInjectable(), 
	            __metadata$6('design:paramtypes', [String])
	        ], UrlResolver);
	        return UrlResolver;
	    }());
	    /**
	     * Extract the scheme of a URL.
	     * @param {?} url
	     * @return {?}
	     */
	    function getUrlScheme(url) {
	        var /** @type {?} */ match = _split(url);
	        return (match && match[_ComponentIndex.Scheme]) || '';
	    }
	    /**
	     * Builds a URI string from already-encoded parts.
	     *
	     * No encoding is performed.  Any component may be omitted as either null or
	     * undefined.
	     *
	     * @param {?=} opt_scheme The scheme such as 'http'.
	     * @param {?=} opt_userInfo The user name before the '\@'.
	     * @param {?=} opt_domain The domain such as 'www.google.com', already
	     *     URI-encoded.
	     * @param {?=} opt_port The port number.
	     * @param {?=} opt_path The path, already URI-encoded.  If it is not
	     *     empty, it must begin with a slash.
	     * @param {?=} opt_queryData The URI-encoded query data.
	     * @param {?=} opt_fragment The URI-encoded fragment identifier.
	     * @return {?} The fully combined URI.
	     */
	    function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
	        var /** @type {?} */ out = [];
	        if (isPresent(opt_scheme)) {
	            out.push(opt_scheme + ':');
	        }
	        if (isPresent(opt_domain)) {
	            out.push('//');
	            if (isPresent(opt_userInfo)) {
	                out.push(opt_userInfo + '@');
	            }
	            out.push(opt_domain);
	            if (isPresent(opt_port)) {
	                out.push(':' + opt_port);
	            }
	        }
	        if (isPresent(opt_path)) {
	            out.push(opt_path);
	        }
	        if (isPresent(opt_queryData)) {
	            out.push('?' + opt_queryData);
	        }
	        if (isPresent(opt_fragment)) {
	            out.push('#' + opt_fragment);
	        }
	        return out.join('');
	    }
	    /**
	     * A regular expression for breaking a URI into its component parts.
	     *
	     * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
	     * As the "first-match-wins" algorithm is identical to the "greedy"
	     * disambiguation method used by POSIX regular expressions, it is natural and
	     * commonplace to use a regular expression for parsing the potential five
	     * components of a URI reference.
	     *
	     * The following line is the regular expression for breaking-down a
	     * well-formed URI reference into its components.
	     *
	     * <pre>
	     * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
	     *  12            3  4          5       6  7        8 9
	     * </pre>
	     *
	     * The numbers in the second line above are only to assist readability; they
	     * indicate the reference points for each subexpression (i.e., each paired
	     * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
	     * For example, matching the above expression to
	     * <pre>
	     *     http://www.ics.uci.edu/pub/ietf/uri/#Related
	     * </pre>
	     * results in the following subexpression matches:
	     * <pre>
	     *    $1 = http:
	     *    $2 = http
	     *    $3 = //www.ics.uci.edu
	     *    $4 = www.ics.uci.edu
	     *    $5 = /pub/ietf/uri/
	     *    $6 = <undefined>
	     *    $7 = <undefined>
	     *    $8 = #Related
	     *    $9 = Related
	     * </pre>
	     * where <undefined> indicates that the component is not present, as is the
	     * case for the query component in the above example. Therefore, we can
	     * determine the value of the five components as
	     * <pre>
	     *    scheme    = $2
	     *    authority = $4
	     *    path      = $5
	     *    query     = $7
	     *    fragment  = $9
	     * </pre>
	     *
	     * The regular expression has been modified slightly to expose the
	     * userInfo, domain, and port separately from the authority.
	     * The modified version yields
	     * <pre>
	     *    $1 = http              scheme
	     *    $2 = <undefined>       userInfo -\
	     *    $3 = www.ics.uci.edu   domain     | authority
	     *    $4 = <undefined>       port     -/
	     *    $5 = /pub/ietf/uri/    path
	     *    $6 = <undefined>       query without ?
	     *    $7 = Related           fragment without #
	     * </pre>
	     * @type {!RegExp}
	     * @internal
	     */
	    var /** @type {?} */ _splitRe = new RegExp('^' +
	        '(?:' +
	        '([^:/?#.]+)' +
	        // used by other URL parts such as :,
	        // ?, /, #, and .
	        ':)?' +
	        '(?://' +
	        '(?:([^/?#]*)@)?' +
	        '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
	        // digits, dashes, dots, percent
	        // escapes, and unicode characters.
	        '(?::([0-9]+))?' +
	        ')?' +
	        '([^?#]+)?' +
	        '(?:\\?([^#]*))?' +
	        '(?:#(.*))?' +
	        '$');
	    var _ComponentIndex = {};
	    _ComponentIndex.Scheme = 1;
	    _ComponentIndex.UserInfo = 2;
	    _ComponentIndex.Domain = 3;
	    _ComponentIndex.Port = 4;
	    _ComponentIndex.Path = 5;
	    _ComponentIndex.QueryData = 6;
	    _ComponentIndex.Fragment = 7;
	    _ComponentIndex[_ComponentIndex.Scheme] = "Scheme";
	    _ComponentIndex[_ComponentIndex.UserInfo] = "UserInfo";
	    _ComponentIndex[_ComponentIndex.Domain] = "Domain";
	    _ComponentIndex[_ComponentIndex.Port] = "Port";
	    _ComponentIndex[_ComponentIndex.Path] = "Path";
	    _ComponentIndex[_ComponentIndex.QueryData] = "QueryData";
	    _ComponentIndex[_ComponentIndex.Fragment] = "Fragment";
	    /**
	     * Splits a URI into its component parts.
	     *
	     * Each component can be accessed via the component indices; for example:
	     * <pre>
	     * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
	     * </pre>
	     *
	     * @param {?} uri The URI string to examine.
	     * @return {?} Each component still URI-encoded.
	     *     Each component that is present will contain the encoded value, whereas
	     *     components that are not present will be undefined or empty, depending
	     *     on the browser's regular expression implementation.  Never null, since
	     *     arbitrary strings may still look like path names.
	     */
	    function _split(uri) {
	        return uri.match(_splitRe);
	    }
	    /**
	     * Removes dot segments in given path component, as described in
	     * RFC 3986, section 5.2.4.
	     *
	     * @param {?} path A non-empty path component.
	     * @return {?} Path component with removed dot segments.
	     */
	    function _removeDotSegments(path) {
	        if (path == '/')
	            return '/';
	        var /** @type {?} */ leadingSlash = path[0] == '/' ? '/' : '';
	        var /** @type {?} */ trailingSlash = path[path.length - 1] === '/' ? '/' : '';
	        var /** @type {?} */ segments = path.split('/');
	        var /** @type {?} */ out = [];
	        var /** @type {?} */ up = 0;
	        for (var /** @type {?} */ pos = 0; pos < segments.length; pos++) {
	            var /** @type {?} */ segment = segments[pos];
	            switch (segment) {
	                case '':
	                case '.':
	                    break;
	                case '..':
	                    if (out.length > 0) {
	                        out.pop();
	                    }
	                    else {
	                        up++;
	                    }
	                    break;
	                default:
	                    out.push(segment);
	            }
	        }
	        if (leadingSlash == '') {
	            while (up-- > 0) {
	                out.unshift('..');
	            }
	            if (out.length === 0)
	                out.push('.');
	        }
	        return leadingSlash + out.join('/') + trailingSlash;
	    }
	    /**
	     * Takes an array of the parts from split and canonicalizes the path part
	     * and then joins all the parts.
	     * @param {?} parts
	     * @return {?}
	     */
	    function _joinAndCanonicalizePath(parts) {
	        var /** @type {?} */ path = parts[_ComponentIndex.Path];
	        path = isBlank(path) ? '' : _removeDotSegments(path);
	        parts[_ComponentIndex.Path] = path;
	        return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
	    }
	    /**
	     * Resolves a URL.
	     * @param {?} base The URL acting as the base URL.
	     * @param {?} url
	     * @return {?}
	     */
	    function _resolveUrl(base, url) {
	        var /** @type {?} */ parts = _split(encodeURI(url));
	        var /** @type {?} */ baseParts = _split(base);
	        if (isPresent(parts[_ComponentIndex.Scheme])) {
	            return _joinAndCanonicalizePath(parts);
	        }
	        else {
	            parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
	        }
	        for (var /** @type {?} */ i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
	            if (isBlank(parts[i])) {
	                parts[i] = baseParts[i];
	            }
	        }
	        if (parts[_ComponentIndex.Path][0] == '/') {
	            return _joinAndCanonicalizePath(parts);
	        }
	        var /** @type {?} */ path = baseParts[_ComponentIndex.Path];
	        if (isBlank(path))
	            path = '/';
	        var /** @type {?} */ index = path.lastIndexOf('/');
	        path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
	        parts[_ComponentIndex.Path] = path;
	        return _joinAndCanonicalizePath(parts);
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$5 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var DirectiveNormalizer = (function () {
	        /**
	         * @param {?} _resourceLoader
	         * @param {?} _urlResolver
	         * @param {?} _htmlParser
	         * @param {?} _config
	         */
	        function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {
	            this._resourceLoader = _resourceLoader;
	            this._urlResolver = _urlResolver;
	            this._htmlParser = _htmlParser;
	            this._config = _config;
	            this._resourceLoaderCache = new Map();
	        }
	        /**
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };
	        /**
	         * @param {?} normalizedDirective
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {
	            var _this = this;
	            if (!normalizedDirective.isComponent) {
	                return;
	            }
	            this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);
	            normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });
	        };
	        /**
	         * @param {?} url
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype._fetch = function (url) {
	            var /** @type {?} */ result = this._resourceLoaderCache.get(url);
	            if (!result) {
	                result = this._resourceLoader.get(url);
	                this._resourceLoaderCache.set(url, result);
	            }
	            return result;
	        };
	        /**
	         * @param {?} prenormData
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {
	            var _this = this;
	            var /** @type {?} */ normalizedTemplateSync = null;
	            var /** @type {?} */ normalizedTemplateAsync;
	            if (isPresent(prenormData.template)) {
	                normalizedTemplateSync = this.normalizeTemplateSync(prenormData);
	                normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);
	            }
	            else if (prenormData.templateUrl) {
	                normalizedTemplateAsync = this.normalizeTemplateAsync(prenormData);
	            }
	            else {
	                throw new SyntaxError("No template specified for component " + stringify(prenormData.componentType));
	            }
	            if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {
	                // sync case
	                return new SyncAsyncResult(normalizedTemplateSync);
	            }
	            else {
	                // async case
	                return new SyncAsyncResult(null, normalizedTemplateAsync.then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); }));
	            }
	        };
	        /**
	         * @param {?} prenomData
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.normalizeTemplateSync = function (prenomData) {
	            return this.normalizeLoadedTemplate(prenomData, prenomData.template, prenomData.moduleUrl);
	        };
	        /**
	         * @param {?} prenomData
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.normalizeTemplateAsync = function (prenomData) {
	            var _this = this;
	            var /** @type {?} */ templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);
	            return this._fetch(templateUrl)
	                .then(function (value) { return _this.normalizeLoadedTemplate(prenomData, value, templateUrl); });
	        };
	        /**
	         * @param {?} prenomData
	         * @param {?} template
	         * @param {?} templateAbsUrl
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (prenomData, template, templateAbsUrl) {
	            var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(prenomData.interpolation);
	            var /** @type {?} */ rootNodesAndErrors = this._htmlParser.parse(template, stringify(prenomData.componentType), true, interpolationConfig);
	            if (rootNodesAndErrors.errors.length > 0) {
	                var /** @type {?} */ errorString = rootNodesAndErrors.errors.join('\n');
	                throw new SyntaxError("Template parse errors:\n" + errorString);
	            }
	            var /** @type {?} */ templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
	                styles: prenomData.styles,
	                styleUrls: prenomData.styleUrls,
	                moduleUrl: prenomData.moduleUrl
	            }));
	            var /** @type {?} */ visitor = new TemplatePreparseVisitor();
	            visitAll(visitor, rootNodesAndErrors.rootNodes);
	            var /** @type {?} */ templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
	            var /** @type {?} */ encapsulation = prenomData.encapsulation;
	            if (isBlank(encapsulation)) {
	                encapsulation = this._config.defaultEncapsulation;
	            }
	            var /** @type {?} */ styles = templateMetadataStyles.styles.concat(templateStyles.styles);
	            var /** @type {?} */ styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
	            if (encapsulation === _angular_core.ViewEncapsulation.Emulated && styles.length === 0 &&
	                styleUrls.length === 0) {
	                encapsulation = _angular_core.ViewEncapsulation.None;
	            }
	            return new CompileTemplateMetadata({
	                encapsulation: encapsulation,
	                template: template,
	                templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,
	                ngContentSelectors: visitor.ngContentSelectors,
	                animations: prenomData.animations,
	                interpolation: prenomData.interpolation,
	            });
	        };
	        /**
	         * @param {?} templateMeta
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {
	            return this._loadMissingExternalStylesheets(templateMeta.styleUrls)
	                .then(function (externalStylesheets) { return new CompileTemplateMetadata({
	                encapsulation: templateMeta.encapsulation,
	                template: templateMeta.template,
	                templateUrl: templateMeta.templateUrl,
	                styles: templateMeta.styles,
	                styleUrls: templateMeta.styleUrls,
	                externalStylesheets: externalStylesheets,
	                ngContentSelectors: templateMeta.ngContentSelectors,
	                animations: templateMeta.animations,
	                interpolation: templateMeta.interpolation
	            }); });
	        };
	        /**
	         * @param {?} styleUrls
	         * @param {?=} loadedStylesheets
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {
	            var _this = this;
	            if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }
	            return Promise
	                .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })
	                .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {
	                var /** @type {?} */ stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
	                loadedStylesheets.set(styleUrl, stylesheet);
	                return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
	            }); }))
	                .then(function (_) { return Array.from(loadedStylesheets.values()); });
	        };
	        /**
	         * @param {?} stylesheet
	         * @return {?}
	         */
	        DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {
	            var _this = this;
	            var /** @type {?} */ allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)
	                .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });
	            var /** @type {?} */ allStyles = stylesheet.styles.map(function (style) {
	                var /** @type {?} */ styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style);
	                allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);
	                return styleWithImports.style;
	            });
	            return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });
	        };
	        DirectiveNormalizer = __decorate$5([
	            CompilerInjectable(), 
	            __metadata$5('design:paramtypes', [ResourceLoader, UrlResolver, HtmlParser, CompilerConfig])
	        ], DirectiveNormalizer);
	        return DirectiveNormalizer;
	    }());
	    var TemplatePreparseVisitor = (function () {
	        function TemplatePreparseVisitor() {
	            this.ngContentSelectors = [];
	            this.styles = [];
	            this.styleUrls = [];
	            this.ngNonBindableStackCount = 0;
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
	            var /** @type {?} */ preparsedElement = preparseElement(ast);
	            switch (preparsedElement.type) {
	                case PreparsedElementType.NG_CONTENT:
	                    if (this.ngNonBindableStackCount === 0) {
	                        this.ngContentSelectors.push(preparsedElement.selectAttr);
	                    }
	                    break;
	                case PreparsedElementType.STYLE:
	                    var /** @type {?} */ textContent_1 = '';
	                    ast.children.forEach(function (child) {
	                        if (child instanceof Text) {
	                            textContent_1 += child.value;
	                        }
	                    });
	                    this.styles.push(textContent_1);
	                    break;
	                case PreparsedElementType.STYLESHEET:
	                    this.styleUrls.push(preparsedElement.hrefAttr);
	                    break;
	                default:
	                    break;
	            }
	            if (preparsedElement.nonBindable) {
	                this.ngNonBindableStackCount++;
	            }
	            visitAll(this, ast.children);
	            if (preparsedElement.nonBindable) {
	                this.ngNonBindableStackCount--;
	            }
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { visitAll(this, ast.cases); };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {
	            visitAll(this, ast.expression);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
	        return TemplatePreparseVisitor;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$7 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var DirectiveResolver = (function () {
	        /**
	         * @param {?=} _reflector
	         */
	        function DirectiveResolver(_reflector) {
	            if (_reflector === void 0) { _reflector = reflector; }
	            this._reflector = _reflector;
	        }
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        DirectiveResolver.prototype.isDirective = function (type) {
	            var /** @type {?} */ typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
	            return typeMetadata && typeMetadata.some(isDirectiveMetadata);
	        };
	        /**
	         * Return {\@link Directive} for a given `Type`.
	         * @param {?} type
	         * @param {?=} throwIfNotFound
	         * @return {?}
	         */
	        DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {
	            if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	            var /** @type {?} */ typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
	            if (typeMetadata) {
	                var /** @type {?} */ metadata = ListWrapper.findLast(typeMetadata, isDirectiveMetadata);
	                if (metadata) {
	                    var /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);
	                    return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
	                }
	            }
	            if (throwIfNotFound) {
	                throw new Error("No Directive annotation found on " + stringify(type));
	            }
	            return null;
	        };
	        /**
	         * @param {?} dm
	         * @param {?} propertyMetadata
	         * @param {?} directiveType
	         * @return {?}
	         */
	        DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {
	            var /** @type {?} */ inputs = [];
	            var /** @type {?} */ outputs = [];
	            var /** @type {?} */ host = {};
	            var /** @type {?} */ queries = {};
	            Object.keys(propertyMetadata).forEach(function (propName) {
	                var /** @type {?} */ input = ListWrapper.findLast(propertyMetadata[propName], function (a) { return a instanceof _angular_core.Input; });
	                if (input) {
	                    if (input.bindingPropertyName) {
	                        inputs.push(propName + ": " + input.bindingPropertyName);
	                    }
	                    else {
	                        inputs.push(propName);
	                    }
	                }
	                var /** @type {?} */ output = ListWrapper.findLast(propertyMetadata[propName], function (a) { return a instanceof _angular_core.Output; });
	                if (output) {
	                    if (output.bindingPropertyName) {
	                        outputs.push(propName + ": " + output.bindingPropertyName);
	                    }
	                    else {
	                        outputs.push(propName);
	                    }
	                }
	                var /** @type {?} */ hostBindings = propertyMetadata[propName].filter(function (a) { return a && a instanceof _angular_core.HostBinding; });
	                hostBindings.forEach(function (hostBinding) {
	                    if (hostBinding.hostPropertyName) {
	                        var /** @type {?} */ startWith = hostBinding.hostPropertyName[0];
	                        if (startWith === '(') {
	                            throw new Error("@HostBinding can not bind to events. Use @HostListener instead.");
	                        }
	                        else if (startWith === '[') {
	                            throw new Error("@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.");
	                        }
	                        host[("[" + hostBinding.hostPropertyName + "]")] = propName;
	                    }
	                    else {
	                        host[("[" + propName + "]")] = propName;
	                    }
	                });
	                var /** @type {?} */ hostListeners = propertyMetadata[propName].filter(function (a) { return a && a instanceof _angular_core.HostListener; });
	                hostListeners.forEach(function (hostListener) {
	                    var /** @type {?} */ args = hostListener.args || [];
	                    host[("(" + hostListener.eventName + ")")] = propName + "(" + args.join(',') + ")";
	                });
	                var /** @type {?} */ query = ListWrapper.findLast(propertyMetadata[propName], function (a) { return a instanceof _angular_core.Query; });
	                if (query) {
	                    queries[propName] = query;
	                }
	            });
	            return this._merge(dm, inputs, outputs, host, queries, directiveType);
	        };
	        /**
	         * @param {?} def
	         * @return {?}
	         */
	        DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };
	        /**
	         * @param {?} bindings
	         * @return {?}
	         */
	        DirectiveResolver.prototype._dedupeBindings = function (bindings) {
	            var /** @type {?} */ names = new Set();
	            var /** @type {?} */ reversedResult = [];
	            // go last to first to allow later entries to overwrite previous entries
	            for (var /** @type {?} */ i = bindings.length - 1; i >= 0; i--) {
	                var /** @type {?} */ binding = bindings[i];
	                var /** @type {?} */ name_1 = this._extractPublicName(binding);
	                if (!names.has(name_1)) {
	                    names.add(name_1);
	                    reversedResult.push(binding);
	                }
	            }
	            return reversedResult.reverse();
	        };
	        /**
	         * @param {?} directive
	         * @param {?} inputs
	         * @param {?} outputs
	         * @param {?} host
	         * @param {?} queries
	         * @param {?} directiveType
	         * @return {?}
	         */
	        DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {
	            var /** @type {?} */ mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);
	            var /** @type {?} */ mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);
	            var /** @type {?} */ mergedHost = directive.host ? StringMapWrapper.merge(directive.host, host) : host;
	            var /** @type {?} */ mergedQueries = directive.queries ? StringMapWrapper.merge(directive.queries, queries) : queries;
	            if (directive instanceof _angular_core.Component) {
	                return new _angular_core.Component({
	                    selector: directive.selector,
	                    inputs: mergedInputs,
	                    outputs: mergedOutputs,
	                    host: mergedHost,
	                    exportAs: directive.exportAs,
	                    moduleId: directive.moduleId,
	                    queries: mergedQueries,
	                    changeDetection: directive.changeDetection,
	                    providers: directive.providers,
	                    viewProviders: directive.viewProviders,
	                    entryComponents: directive.entryComponents,
	                    template: directive.template,
	                    templateUrl: directive.templateUrl,
	                    styles: directive.styles,
	                    styleUrls: directive.styleUrls,
	                    encapsulation: directive.encapsulation,
	                    animations: directive.animations,
	                    interpolation: directive.interpolation
	                });
	            }
	            else {
	                return new _angular_core.Directive({
	                    selector: directive.selector,
	                    inputs: mergedInputs,
	                    outputs: mergedOutputs,
	                    host: mergedHost,
	                    exportAs: directive.exportAs,
	                    queries: mergedQueries,
	                    providers: directive.providers
	                });
	            }
	        };
	        DirectiveResolver = __decorate$7([
	            CompilerInjectable(), 
	            __metadata$7('design:paramtypes', [ReflectorReader])
	        ], DirectiveResolver);
	        return DirectiveResolver;
	    }());
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function isDirectiveMetadata(type) {
	        return type instanceof _angular_core.Directive;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$20 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var TypeModifier = {};
	    TypeModifier.Const = 0;
	    TypeModifier[TypeModifier.Const] = "Const";
	    /**
	     * @abstract
	     */
	    var Type$1 = (function () {
	        /**
	         * @param {?=} modifiers
	         */
	        function Type(modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            this.modifiers = modifiers;
	            if (!modifiers) {
	                this.modifiers = [];
	            }
	        }
	        /**
	         * @abstract
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Type.prototype.visitType = function (visitor, context) { };
	        /**
	         * @param {?} modifier
	         * @return {?}
	         */
	        Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
	        return Type;
	    }());
	    var BuiltinTypeName = {};
	    BuiltinTypeName.Dynamic = 0;
	    BuiltinTypeName.Bool = 1;
	    BuiltinTypeName.String = 2;
	    BuiltinTypeName.Int = 3;
	    BuiltinTypeName.Number = 4;
	    BuiltinTypeName.Function = 5;
	    BuiltinTypeName.Null = 6;
	    BuiltinTypeName[BuiltinTypeName.Dynamic] = "Dynamic";
	    BuiltinTypeName[BuiltinTypeName.Bool] = "Bool";
	    BuiltinTypeName[BuiltinTypeName.String] = "String";
	    BuiltinTypeName[BuiltinTypeName.Int] = "Int";
	    BuiltinTypeName[BuiltinTypeName.Number] = "Number";
	    BuiltinTypeName[BuiltinTypeName.Function] = "Function";
	    BuiltinTypeName[BuiltinTypeName.Null] = "Null";
	    var BuiltinType = (function (_super) {
	        __extends$20(BuiltinType, _super);
	        /**
	         * @param {?} name
	         * @param {?=} modifiers
	         */
	        function BuiltinType(name, modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.name = name;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        BuiltinType.prototype.visitType = function (visitor, context) {
	            return visitor.visitBuiltintType(this, context);
	        };
	        return BuiltinType;
	    }(Type$1));
	    var ExpressionType = (function (_super) {
	        __extends$20(ExpressionType, _super);
	        /**
	         * @param {?} value
	         * @param {?=} typeParams
	         * @param {?=} modifiers
	         */
	        function ExpressionType(value, typeParams, modifiers) {
	            if (typeParams === void 0) { typeParams = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.value = value;
	            this.typeParams = typeParams;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionType.prototype.visitType = function (visitor, context) {
	            return visitor.visitExpressionType(this, context);
	        };
	        return ExpressionType;
	    }(Type$1));
	    var ArrayType = (function (_super) {
	        __extends$20(ArrayType, _super);
	        /**
	         * @param {?} of
	         * @param {?=} modifiers
	         */
	        function ArrayType(of, modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.of = of;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ArrayType.prototype.visitType = function (visitor, context) {
	            return visitor.visitArrayType(this, context);
	        };
	        return ArrayType;
	    }(Type$1));
	    var MapType = (function (_super) {
	        __extends$20(MapType, _super);
	        /**
	         * @param {?} valueType
	         * @param {?=} modifiers
	         */
	        function MapType(valueType, modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.valueType = valueType;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };
	        return MapType;
	    }(Type$1));
	    var /** @type {?} */ DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
	    var /** @type {?} */ BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
	    var /** @type {?} */ INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
	    var /** @type {?} */ NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
	    var /** @type {?} */ STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
	    var /** @type {?} */ FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
	    var /** @type {?} */ NULL_TYPE = new BuiltinType(BuiltinTypeName.Null);
	    var BinaryOperator = {};
	    BinaryOperator.Equals = 0;
	    BinaryOperator.NotEquals = 1;
	    BinaryOperator.Identical = 2;
	    BinaryOperator.NotIdentical = 3;
	    BinaryOperator.Minus = 4;
	    BinaryOperator.Plus = 5;
	    BinaryOperator.Divide = 6;
	    BinaryOperator.Multiply = 7;
	    BinaryOperator.Modulo = 8;
	    BinaryOperator.And = 9;
	    BinaryOperator.Or = 10;
	    BinaryOperator.Lower = 11;
	    BinaryOperator.LowerEquals = 12;
	    BinaryOperator.Bigger = 13;
	    BinaryOperator.BiggerEquals = 14;
	    BinaryOperator[BinaryOperator.Equals] = "Equals";
	    BinaryOperator[BinaryOperator.NotEquals] = "NotEquals";
	    BinaryOperator[BinaryOperator.Identical] = "Identical";
	    BinaryOperator[BinaryOperator.NotIdentical] = "NotIdentical";
	    BinaryOperator[BinaryOperator.Minus] = "Minus";
	    BinaryOperator[BinaryOperator.Plus] = "Plus";
	    BinaryOperator[BinaryOperator.Divide] = "Divide";
	    BinaryOperator[BinaryOperator.Multiply] = "Multiply";
	    BinaryOperator[BinaryOperator.Modulo] = "Modulo";
	    BinaryOperator[BinaryOperator.And] = "And";
	    BinaryOperator[BinaryOperator.Or] = "Or";
	    BinaryOperator[BinaryOperator.Lower] = "Lower";
	    BinaryOperator[BinaryOperator.LowerEquals] = "LowerEquals";
	    BinaryOperator[BinaryOperator.Bigger] = "Bigger";
	    BinaryOperator[BinaryOperator.BiggerEquals] = "BiggerEquals";
	    /**
	     * @abstract
	     */
	    var Expression = (function () {
	        /**
	         * @param {?} type
	         */
	        function Expression(type) {
	            this.type = type;
	        }
	        /**
	         * @abstract
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Expression.prototype.visitExpression = function (visitor, context) { };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Expression.prototype.prop = function (name) { return new ReadPropExpr(this, name); };
	        /**
	         * @param {?} index
	         * @param {?=} type
	         * @return {?}
	         */
	        Expression.prototype.key = function (index, type) {
	            if (type === void 0) { type = null; }
	            return new ReadKeyExpr(this, index, type);
	        };
	        /**
	         * @param {?} name
	         * @param {?} params
	         * @return {?}
	         */
	        Expression.prototype.callMethod = function (name, params) {
	            return new InvokeMethodExpr(this, name, params);
	        };
	        /**
	         * @param {?} params
	         * @return {?}
	         */
	        Expression.prototype.callFn = function (params) { return new InvokeFunctionExpr(this, params); };
	        /**
	         * @param {?} params
	         * @param {?=} type
	         * @return {?}
	         */
	        Expression.prototype.instantiate = function (params, type) {
	            if (type === void 0) { type = null; }
	            return new InstantiateExpr(this, params, type);
	        };
	        /**
	         * @param {?} trueCase
	         * @param {?=} falseCase
	         * @return {?}
	         */
	        Expression.prototype.conditional = function (trueCase, falseCase) {
	            if (falseCase === void 0) { falseCase = null; }
	            return new ConditionalExpr(this, trueCase, falseCase);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.equals = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.notEquals = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.identical = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.notIdentical = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.minus = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.plus = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.divide = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.multiply = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.modulo = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.and = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.or = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.lower = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.lowerEquals = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.bigger = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
	        };
	        /**
	         * @param {?} rhs
	         * @return {?}
	         */
	        Expression.prototype.biggerEquals = function (rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
	        };
	        /**
	         * @return {?}
	         */
	        Expression.prototype.isBlank = function () {
	            // Note: We use equals by purpose here to compare to null and undefined in JS.
	            // We use the typed null to allow strictNullChecks to narrow types.
	            return this.equals(TYPED_NULL_EXPR);
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        Expression.prototype.cast = function (type) { return new CastExpr(this, type); };
	        /**
	         * @return {?}
	         */
	        Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };
	        return Expression;
	    }());
	    var BuiltinVar = {};
	    BuiltinVar.This = 0;
	    BuiltinVar.Super = 1;
	    BuiltinVar.CatchError = 2;
	    BuiltinVar.CatchStack = 3;
	    BuiltinVar[BuiltinVar.This] = "This";
	    BuiltinVar[BuiltinVar.Super] = "Super";
	    BuiltinVar[BuiltinVar.CatchError] = "CatchError";
	    BuiltinVar[BuiltinVar.CatchStack] = "CatchStack";
	    var ReadVarExpr = (function (_super) {
	        __extends$20(ReadVarExpr, _super);
	        /**
	         * @param {?} name
	         * @param {?=} type
	         */
	        function ReadVarExpr(name, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            if (typeof name === 'string') {
	                this.name = name;
	                this.builtin = null;
	            }
	            else {
	                this.name = null;
	                this.builtin = name;
	            }
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ReadVarExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitReadVarExpr(this, context);
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ReadVarExpr.prototype.set = function (value) { return new WriteVarExpr(this.name, value); };
	        return ReadVarExpr;
	    }(Expression));
	    var WriteVarExpr = (function (_super) {
	        __extends$20(WriteVarExpr, _super);
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?=} type
	         */
	        function WriteVarExpr(name, value, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type || value.type);
	            this.name = name;
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        WriteVarExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitWriteVarExpr(this, context);
	        };
	        /**
	         * @param {?=} type
	         * @param {?=} modifiers
	         * @return {?}
	         */
	        WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {
	            if (type === void 0) { type = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            return new DeclareVarStmt(this.name, this.value, type, modifiers);
	        };
	        return WriteVarExpr;
	    }(Expression));
	    var WriteKeyExpr = (function (_super) {
	        __extends$20(WriteKeyExpr, _super);
	        /**
	         * @param {?} receiver
	         * @param {?} index
	         * @param {?} value
	         * @param {?=} type
	         */
	        function WriteKeyExpr(receiver, index, value, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type || value.type);
	            this.receiver = receiver;
	            this.index = index;
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        WriteKeyExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitWriteKeyExpr(this, context);
	        };
	        return WriteKeyExpr;
	    }(Expression));
	    var WritePropExpr = (function (_super) {
	        __extends$20(WritePropExpr, _super);
	        /**
	         * @param {?} receiver
	         * @param {?} name
	         * @param {?} value
	         * @param {?=} type
	         */
	        function WritePropExpr(receiver, name, value, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type || value.type);
	            this.receiver = receiver;
	            this.name = name;
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        WritePropExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitWritePropExpr(this, context);
	        };
	        return WritePropExpr;
	    }(Expression));
	    var BuiltinMethod = {};
	    BuiltinMethod.ConcatArray = 0;
	    BuiltinMethod.SubscribeObservable = 1;
	    BuiltinMethod.Bind = 2;
	    BuiltinMethod[BuiltinMethod.ConcatArray] = "ConcatArray";
	    BuiltinMethod[BuiltinMethod.SubscribeObservable] = "SubscribeObservable";
	    BuiltinMethod[BuiltinMethod.Bind] = "Bind";
	    var InvokeMethodExpr = (function (_super) {
	        __extends$20(InvokeMethodExpr, _super);
	        /**
	         * @param {?} receiver
	         * @param {?} method
	         * @param {?} args
	         * @param {?=} type
	         */
	        function InvokeMethodExpr(receiver, method, args, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.receiver = receiver;
	            this.args = args;
	            if (typeof method === 'string') {
	                this.name = method;
	                this.builtin = null;
	            }
	            else {
	                this.name = null;
	                this.builtin = method;
	            }
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitInvokeMethodExpr(this, context);
	        };
	        return InvokeMethodExpr;
	    }(Expression));
	    var InvokeFunctionExpr = (function (_super) {
	        __extends$20(InvokeFunctionExpr, _super);
	        /**
	         * @param {?} fn
	         * @param {?} args
	         * @param {?=} type
	         */
	        function InvokeFunctionExpr(fn, args, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.fn = fn;
	            this.args = args;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitInvokeFunctionExpr(this, context);
	        };
	        return InvokeFunctionExpr;
	    }(Expression));
	    var InstantiateExpr = (function (_super) {
	        __extends$20(InstantiateExpr, _super);
	        /**
	         * @param {?} classExpr
	         * @param {?} args
	         * @param {?=} type
	         */
	        function InstantiateExpr(classExpr, args, type) {
	            _super.call(this, type);
	            this.classExpr = classExpr;
	            this.args = args;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        InstantiateExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitInstantiateExpr(this, context);
	        };
	        return InstantiateExpr;
	    }(Expression));
	    var LiteralExpr = (function (_super) {
	        __extends$20(LiteralExpr, _super);
	        /**
	         * @param {?} value
	         * @param {?=} type
	         */
	        function LiteralExpr(value, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        LiteralExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitLiteralExpr(this, context);
	        };
	        return LiteralExpr;
	    }(Expression));
	    var ExternalExpr = (function (_super) {
	        __extends$20(ExternalExpr, _super);
	        /**
	         * @param {?} value
	         * @param {?=} type
	         * @param {?=} typeParams
	         */
	        function ExternalExpr(value, type, typeParams) {
	            if (type === void 0) { type = null; }
	            if (typeParams === void 0) { typeParams = null; }
	            _super.call(this, type);
	            this.value = value;
	            this.typeParams = typeParams;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ExternalExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitExternalExpr(this, context);
	        };
	        return ExternalExpr;
	    }(Expression));
	    var ConditionalExpr = (function (_super) {
	        __extends$20(ConditionalExpr, _super);
	        /**
	         * @param {?} condition
	         * @param {?} trueCase
	         * @param {?=} falseCase
	         * @param {?=} type
	         */
	        function ConditionalExpr(condition, trueCase, falseCase, type) {
	            if (falseCase === void 0) { falseCase = null; }
	            if (type === void 0) { type = null; }
	            _super.call(this, type || trueCase.type);
	            this.condition = condition;
	            this.falseCase = falseCase;
	            this.trueCase = trueCase;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ConditionalExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitConditionalExpr(this, context);
	        };
	        return ConditionalExpr;
	    }(Expression));
	    var NotExpr = (function (_super) {
	        __extends$20(NotExpr, _super);
	        /**
	         * @param {?} condition
	         */
	        function NotExpr(condition) {
	            _super.call(this, BOOL_TYPE);
	            this.condition = condition;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        NotExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitNotExpr(this, context);
	        };
	        return NotExpr;
	    }(Expression));
	    var CastExpr = (function (_super) {
	        __extends$20(CastExpr, _super);
	        /**
	         * @param {?} value
	         * @param {?} type
	         */
	        function CastExpr(value, type) {
	            _super.call(this, type);
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        CastExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitCastExpr(this, context);
	        };
	        return CastExpr;
	    }(Expression));
	    var FnParam = (function () {
	        /**
	         * @param {?} name
	         * @param {?=} type
	         */
	        function FnParam(name, type) {
	            if (type === void 0) { type = null; }
	            this.name = name;
	            this.type = type;
	        }
	        return FnParam;
	    }());
	    var FunctionExpr = (function (_super) {
	        __extends$20(FunctionExpr, _super);
	        /**
	         * @param {?} params
	         * @param {?} statements
	         * @param {?=} type
	         */
	        function FunctionExpr(params, statements, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.params = params;
	            this.statements = statements;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        FunctionExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitFunctionExpr(this, context);
	        };
	        /**
	         * @param {?} name
	         * @param {?=} modifiers
	         * @return {?}
	         */
	        FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
	        };
	        return FunctionExpr;
	    }(Expression));
	    var BinaryOperatorExpr = (function (_super) {
	        __extends$20(BinaryOperatorExpr, _super);
	        /**
	         * @param {?} operator
	         * @param {?} lhs
	         * @param {?} rhs
	         * @param {?=} type
	         */
	        function BinaryOperatorExpr(operator, lhs, rhs, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type || lhs.type);
	            this.operator = operator;
	            this.rhs = rhs;
	            this.lhs = lhs;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitBinaryOperatorExpr(this, context);
	        };
	        return BinaryOperatorExpr;
	    }(Expression));
	    var ReadPropExpr = (function (_super) {
	        __extends$20(ReadPropExpr, _super);
	        /**
	         * @param {?} receiver
	         * @param {?} name
	         * @param {?=} type
	         */
	        function ReadPropExpr(receiver, name, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.receiver = receiver;
	            this.name = name;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ReadPropExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitReadPropExpr(this, context);
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ReadPropExpr.prototype.set = function (value) {
	            return new WritePropExpr(this.receiver, this.name, value);
	        };
	        return ReadPropExpr;
	    }(Expression));
	    var ReadKeyExpr = (function (_super) {
	        __extends$20(ReadKeyExpr, _super);
	        /**
	         * @param {?} receiver
	         * @param {?} index
	         * @param {?=} type
	         */
	        function ReadKeyExpr(receiver, index, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.receiver = receiver;
	            this.index = index;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ReadKeyExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitReadKeyExpr(this, context);
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ReadKeyExpr.prototype.set = function (value) {
	            return new WriteKeyExpr(this.receiver, this.index, value);
	        };
	        return ReadKeyExpr;
	    }(Expression));
	    var LiteralArrayExpr = (function (_super) {
	        __extends$20(LiteralArrayExpr, _super);
	        /**
	         * @param {?} entries
	         * @param {?=} type
	         */
	        function LiteralArrayExpr(entries, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.entries = entries;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitLiteralArrayExpr(this, context);
	        };
	        return LiteralArrayExpr;
	    }(Expression));
	    var LiteralMapEntry = (function () {
	        /**
	         * @param {?} key
	         * @param {?} value
	         * @param {?=} quoted
	         */
	        function LiteralMapEntry(key, value, quoted) {
	            if (quoted === void 0) { quoted = false; }
	            this.key = key;
	            this.value = value;
	            this.quoted = quoted;
	        }
	        return LiteralMapEntry;
	    }());
	    var LiteralMapExpr = (function (_super) {
	        __extends$20(LiteralMapExpr, _super);
	        /**
	         * @param {?} entries
	         * @param {?=} type
	         */
	        function LiteralMapExpr(entries, type) {
	            if (type === void 0) { type = null; }
	            _super.call(this, type);
	            this.entries = entries;
	            this.valueType = null;
	            if (isPresent(type)) {
	                this.valueType = type.valueType;
	            }
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        LiteralMapExpr.prototype.visitExpression = function (visitor, context) {
	            return visitor.visitLiteralMapExpr(this, context);
	        };
	        return LiteralMapExpr;
	    }(Expression));
	    var /** @type {?} */ THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
	    var /** @type {?} */ SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
	    var /** @type {?} */ CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
	    var /** @type {?} */ CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
	    var /** @type {?} */ NULL_EXPR = new LiteralExpr(null, null);
	    var /** @type {?} */ TYPED_NULL_EXPR = new LiteralExpr(null, NULL_TYPE);
	    var StmtModifier = {};
	    StmtModifier.Final = 0;
	    StmtModifier.Private = 1;
	    StmtModifier[StmtModifier.Final] = "Final";
	    StmtModifier[StmtModifier.Private] = "Private";
	    /**
	     * @abstract
	     */
	    var Statement = (function () {
	        /**
	         * @param {?=} modifiers
	         */
	        function Statement(modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            this.modifiers = modifiers;
	            if (!modifiers) {
	                this.modifiers = [];
	            }
	        }
	        /**
	         * @abstract
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        Statement.prototype.visitStatement = function (visitor, context) { };
	        /**
	         * @param {?} modifier
	         * @return {?}
	         */
	        Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
	        return Statement;
	    }());
	    var DeclareVarStmt = (function (_super) {
	        __extends$20(DeclareVarStmt, _super);
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @param {?=} type
	         * @param {?=} modifiers
	         */
	        function DeclareVarStmt(name, value, type, modifiers) {
	            if (type === void 0) { type = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.name = name;
	            this.value = value;
	            this.type = type || value.type;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        DeclareVarStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitDeclareVarStmt(this, context);
	        };
	        return DeclareVarStmt;
	    }(Statement));
	    var DeclareFunctionStmt = (function (_super) {
	        __extends$20(DeclareFunctionStmt, _super);
	        /**
	         * @param {?} name
	         * @param {?} params
	         * @param {?} statements
	         * @param {?=} type
	         * @param {?=} modifiers
	         */
	        function DeclareFunctionStmt(name, params, statements, type, modifiers) {
	            if (type === void 0) { type = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.name = name;
	            this.params = params;
	            this.statements = statements;
	            this.type = type;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitDeclareFunctionStmt(this, context);
	        };
	        return DeclareFunctionStmt;
	    }(Statement));
	    var ExpressionStatement = (function (_super) {
	        __extends$20(ExpressionStatement, _super);
	        /**
	         * @param {?} expr
	         */
	        function ExpressionStatement(expr) {
	            _super.call(this);
	            this.expr = expr;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionStatement.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitExpressionStmt(this, context);
	        };
	        return ExpressionStatement;
	    }(Statement));
	    var ReturnStatement = (function (_super) {
	        __extends$20(ReturnStatement, _super);
	        /**
	         * @param {?} value
	         */
	        function ReturnStatement(value) {
	            _super.call(this);
	            this.value = value;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ReturnStatement.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitReturnStmt(this, context);
	        };
	        return ReturnStatement;
	    }(Statement));
	    var AbstractClassPart = (function () {
	        /**
	         * @param {?=} type
	         * @param {?} modifiers
	         */
	        function AbstractClassPart(type, modifiers) {
	            if (type === void 0) { type = null; }
	            this.type = type;
	            this.modifiers = modifiers;
	            if (!modifiers) {
	                this.modifiers = [];
	            }
	        }
	        /**
	         * @param {?} modifier
	         * @return {?}
	         */
	        AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
	        return AbstractClassPart;
	    }());
	    var ClassField = (function (_super) {
	        __extends$20(ClassField, _super);
	        /**
	         * @param {?} name
	         * @param {?=} type
	         * @param {?=} modifiers
	         */
	        function ClassField(name, type, modifiers) {
	            if (type === void 0) { type = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, type, modifiers);
	            this.name = name;
	        }
	        return ClassField;
	    }(AbstractClassPart));
	    var ClassMethod = (function (_super) {
	        __extends$20(ClassMethod, _super);
	        /**
	         * @param {?} name
	         * @param {?} params
	         * @param {?} body
	         * @param {?=} type
	         * @param {?=} modifiers
	         */
	        function ClassMethod(name, params, body, type, modifiers) {
	            if (type === void 0) { type = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, type, modifiers);
	            this.name = name;
	            this.params = params;
	            this.body = body;
	        }
	        return ClassMethod;
	    }(AbstractClassPart));
	    var ClassGetter = (function (_super) {
	        __extends$20(ClassGetter, _super);
	        /**
	         * @param {?} name
	         * @param {?} body
	         * @param {?=} type
	         * @param {?=} modifiers
	         */
	        function ClassGetter(name, body, type, modifiers) {
	            if (type === void 0) { type = null; }
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, type, modifiers);
	            this.name = name;
	            this.body = body;
	        }
	        return ClassGetter;
	    }(AbstractClassPart));
	    var ClassStmt = (function (_super) {
	        __extends$20(ClassStmt, _super);
	        /**
	         * @param {?} name
	         * @param {?} parent
	         * @param {?} fields
	         * @param {?} getters
	         * @param {?} constructorMethod
	         * @param {?} methods
	         * @param {?=} modifiers
	         */
	        function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
	            if (modifiers === void 0) { modifiers = null; }
	            _super.call(this, modifiers);
	            this.name = name;
	            this.parent = parent;
	            this.fields = fields;
	            this.getters = getters;
	            this.constructorMethod = constructorMethod;
	            this.methods = methods;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ClassStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitDeclareClassStmt(this, context);
	        };
	        return ClassStmt;
	    }(Statement));
	    var IfStmt = (function (_super) {
	        __extends$20(IfStmt, _super);
	        /**
	         * @param {?} condition
	         * @param {?} trueCase
	         * @param {?=} falseCase
	         */
	        function IfStmt(condition, trueCase, falseCase) {
	            if (falseCase === void 0) { falseCase = []; }
	            _super.call(this);
	            this.condition = condition;
	            this.trueCase = trueCase;
	            this.falseCase = falseCase;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        IfStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitIfStmt(this, context);
	        };
	        return IfStmt;
	    }(Statement));
	    var CommentStmt = (function (_super) {
	        __extends$20(CommentStmt, _super);
	        /**
	         * @param {?} comment
	         */
	        function CommentStmt(comment) {
	            _super.call(this);
	            this.comment = comment;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        CommentStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitCommentStmt(this, context);
	        };
	        return CommentStmt;
	    }(Statement));
	    var TryCatchStmt = (function (_super) {
	        __extends$20(TryCatchStmt, _super);
	        /**
	         * @param {?} bodyStmts
	         * @param {?} catchStmts
	         */
	        function TryCatchStmt(bodyStmts, catchStmts) {
	            _super.call(this);
	            this.bodyStmts = bodyStmts;
	            this.catchStmts = catchStmts;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        TryCatchStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitTryCatchStmt(this, context);
	        };
	        return TryCatchStmt;
	    }(Statement));
	    var ThrowStmt = (function (_super) {
	        __extends$20(ThrowStmt, _super);
	        /**
	         * @param {?} error
	         */
	        function ThrowStmt(error) {
	            _super.call(this);
	            this.error = error;
	        }
	        /**
	         * @param {?} visitor
	         * @param {?} context
	         * @return {?}
	         */
	        ThrowStmt.prototype.visitStatement = function (visitor, context) {
	            return visitor.visitThrowStmt(this, context);
	        };
	        return ThrowStmt;
	    }(Statement));
	    var ExpressionTransformer = (function () {
	        function ExpressionTransformer() {
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitReadVarExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} expr
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitWriteVarExpr = function (expr, context) {
	            return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
	        };
	        /**
	         * @param {?} expr
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitWriteKeyExpr = function (expr, context) {
	            return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
	        };
	        /**
	         * @param {?} expr
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitWritePropExpr = function (expr, context) {
	            return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {
	            var /** @type {?} */ method = ast.builtin || ast.name;
	            return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {
	            return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitInstantiateExpr = function (ast, context) {
	            return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitLiteralExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitExternalExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitConditionalExpr = function (ast, context) {
	            return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitNotExpr = function (ast, context) {
	            return new NotExpr(ast.condition.visitExpression(this, context));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitCastExpr = function (ast, context) {
	            return new CastExpr(ast.value.visitExpression(this, context), context);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitFunctionExpr = function (ast, context) {
	            // Don't descend into nested functions
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {
	            return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitReadPropExpr = function (ast, context) {
	            return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitReadKeyExpr = function (ast, context) {
	            return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {
	            return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitLiteralMapExpr = function (ast, context) {
	            var _this = this;
	            var /** @type {?} */ entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });
	            return new LiteralMapExpr(entries);
	        };
	        /**
	         * @param {?} exprs
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitAllExpressions = function (exprs, context) {
	            var _this = this;
	            return exprs.map(function (expr) { return expr.visitExpression(_this, context); });
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {
	            return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitExpressionStmt = function (stmt, context) {
	            return new ExpressionStatement(stmt.expr.visitExpression(this, context));
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitReturnStmt = function (stmt, context) {
	            return new ReturnStatement(stmt.value.visitExpression(this, context));
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitIfStmt = function (stmt, context) {
	            return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitTryCatchStmt = function (stmt, context) {
	            return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitThrowStmt = function (stmt, context) {
	            return new ThrowStmt(stmt.error.visitExpression(this, context));
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
	        /**
	         * @param {?} stmts
	         * @param {?} context
	         * @return {?}
	         */
	        ExpressionTransformer.prototype.visitAllStatements = function (stmts, context) {
	            var _this = this;
	            return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });
	        };
	        return ExpressionTransformer;
	    }());
	    var RecursiveExpressionVisitor = (function () {
	        function RecursiveExpressionVisitor() {
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitReadVarExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} expr
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function (expr, context) {
	            expr.value.visitExpression(this, context);
	            return expr;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function (expr, context) {
	            expr.receiver.visitExpression(this, context);
	            expr.index.visitExpression(this, context);
	            expr.value.visitExpression(this, context);
	            return expr;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitWritePropExpr = function (expr, context) {
	            expr.receiver.visitExpression(this, context);
	            expr.value.visitExpression(this, context);
	            return expr;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {
	            ast.receiver.visitExpression(this, context);
	            this.visitAllExpressions(ast.args, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {
	            ast.fn.visitExpression(this, context);
	            this.visitAllExpressions(ast.args, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function (ast, context) {
	            ast.classExpr.visitExpression(this, context);
	            this.visitAllExpressions(ast.args, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitLiteralExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitExternalExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitConditionalExpr = function (ast, context) {
	            ast.condition.visitExpression(this, context);
	            ast.trueCase.visitExpression(this, context);
	            ast.falseCase.visitExpression(this, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitNotExpr = function (ast, context) {
	            ast.condition.visitExpression(this, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitCastExpr = function (ast, context) {
	            ast.value.visitExpression(this, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitFunctionExpr = function (ast, context) { return ast; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {
	            ast.lhs.visitExpression(this, context);
	            ast.rhs.visitExpression(this, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitReadPropExpr = function (ast, context) {
	            ast.receiver.visitExpression(this, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function (ast, context) {
	            ast.receiver.visitExpression(this, context);
	            ast.index.visitExpression(this, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {
	            this.visitAllExpressions(ast.entries, context);
	            return ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function (ast, context) {
	            var _this = this;
	            ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });
	            return ast;
	        };
	        /**
	         * @param {?} exprs
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitAllExpressions = function (exprs, context) {
	            var _this = this;
	            exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {
	            stmt.value.visitExpression(this, context);
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitExpressionStmt = function (stmt, context) {
	            stmt.expr.visitExpression(this, context);
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitReturnStmt = function (stmt, context) {
	            stmt.value.visitExpression(this, context);
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitIfStmt = function (stmt, context) {
	            stmt.condition.visitExpression(this, context);
	            this.visitAllStatements(stmt.trueCase, context);
	            this.visitAllStatements(stmt.falseCase, context);
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function (stmt, context) {
	            this.visitAllStatements(stmt.bodyStmts, context);
	            this.visitAllStatements(stmt.catchStmts, context);
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitThrowStmt = function (stmt, context) {
	            stmt.error.visitExpression(this, context);
	            return stmt;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
	        /**
	         * @param {?} stmts
	         * @param {?} context
	         * @return {?}
	         */
	        RecursiveExpressionVisitor.prototype.visitAllStatements = function (stmts, context) {
	            var _this = this;
	            stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });
	        };
	        return RecursiveExpressionVisitor;
	    }());
	    /**
	     * @param {?} varName
	     * @param {?} newValue
	     * @param {?} expression
	     * @return {?}
	     */
	    function replaceVarInExpression(varName, newValue, expression) {
	        var /** @type {?} */ transformer = new _ReplaceVariableTransformer(varName, newValue);
	        return expression.visitExpression(transformer, null);
	    }
	    var _ReplaceVariableTransformer = (function (_super) {
	        __extends$20(_ReplaceVariableTransformer, _super);
	        /**
	         * @param {?} _varName
	         * @param {?} _newValue
	         */
	        function _ReplaceVariableTransformer(_varName, _newValue) {
	            _super.call(this);
	            this._varName = _varName;
	            this._newValue = _newValue;
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _ReplaceVariableTransformer.prototype.visitReadVarExpr = function (ast, context) {
	            return ast.name == this._varName ? this._newValue : ast;
	        };
	        return _ReplaceVariableTransformer;
	    }(ExpressionTransformer));
	    /**
	     * @param {?} stmts
	     * @return {?}
	     */
	    function findReadVarNames(stmts) {
	        var /** @type {?} */ finder = new _VariableFinder();
	        finder.visitAllStatements(stmts, null);
	        return finder.varNames;
	    }
	    var _VariableFinder = (function (_super) {
	        __extends$20(_VariableFinder, _super);
	        function _VariableFinder() {
	            _super.apply(this, arguments);
	            this.varNames = new Set();
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _VariableFinder.prototype.visitReadVarExpr = function (ast, context) {
	            this.varNames.add(ast.name);
	            return null;
	        };
	        return _VariableFinder;
	    }(RecursiveExpressionVisitor));
	    /**
	     * @param {?} name
	     * @param {?=} type
	     * @return {?}
	     */
	    function variable(name, type) {
	        if (type === void 0) { type = null; }
	        return new ReadVarExpr(name, type);
	    }
	    /**
	     * @param {?} id
	     * @param {?=} typeParams
	     * @return {?}
	     */
	    function importExpr(id, typeParams) {
	        if (typeParams === void 0) { typeParams = null; }
	        return new ExternalExpr(id, null, typeParams);
	    }
	    /**
	     * @param {?} id
	     * @param {?=} typeParams
	     * @param {?=} typeModifiers
	     * @return {?}
	     */
	    function importType(id, typeParams, typeModifiers) {
	        if (typeParams === void 0) { typeParams = null; }
	        if (typeModifiers === void 0) { typeModifiers = null; }
	        return isPresent(id) ? expressionType(importExpr(id), typeParams, typeModifiers) : null;
	    }
	    /**
	     * @param {?} expr
	     * @param {?=} typeParams
	     * @param {?=} typeModifiers
	     * @return {?}
	     */
	    function expressionType(expr, typeParams, typeModifiers) {
	        if (typeParams === void 0) { typeParams = null; }
	        if (typeModifiers === void 0) { typeModifiers = null; }
	        return isPresent(expr) ? new ExpressionType(expr, typeParams, typeModifiers) : null;
	    }
	    /**
	     * @param {?} values
	     * @param {?=} type
	     * @return {?}
	     */
	    function literalArr(values, type) {
	        if (type === void 0) { type = null; }
	        return new LiteralArrayExpr(values, type);
	    }
	    /**
	     * @param {?} values
	     * @param {?=} type
	     * @param {?=} quoted
	     * @return {?}
	     */
	    function literalMap(values, type, quoted) {
	        if (type === void 0) { type = null; }
	        if (quoted === void 0) { quoted = false; }
	        return new LiteralMapExpr(values.map(function (entry) { return new LiteralMapEntry(entry[0], entry[1], quoted); }), type);
	    }
	    /**
	     * @param {?} expr
	     * @return {?}
	     */
	    function not(expr) {
	        return new NotExpr(expr);
	    }
	    /**
	     * @param {?} params
	     * @param {?} body
	     * @param {?=} type
	     * @return {?}
	     */
	    function fn(params, body, type) {
	        if (type === void 0) { type = null; }
	        return new FunctionExpr(params, body, type);
	    }
	    /**
	     * @param {?} value
	     * @param {?=} type
	     * @return {?}
	     */
	    function literal(value, type) {
	        if (type === void 0) { type = null; }
	        return new LiteralExpr(value, type);
	    }

	    var CheckBindingField = (function () {
	        /**
	         * @param {?} expression
	         * @param {?} bindingId
	         */
	        function CheckBindingField(expression, bindingId) {
	            this.expression = expression;
	            this.bindingId = bindingId;
	        }
	        return CheckBindingField;
	    }());
	    /**
	     * @param {?} builder
	     * @return {?}
	     */
	    function createCheckBindingField(builder) {
	        var /** @type {?} */ bindingId = "" + builder.fields.length;
	        var /** @type {?} */ fieldExpr = createBindFieldExpr(bindingId);
	        // private is fine here as no child view will reference the cached value...
	        builder.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));
	        builder.ctorStmts.push(THIS_EXPR.prop(fieldExpr.name)
	            .set(importExpr(createIdentifier(Identifiers.UNINITIALIZED)))
	            .toStmt());
	        return new CheckBindingField(fieldExpr, bindingId);
	    }
	    /**
	     * @param {?} evalResult
	     * @param {?} fieldExpr
	     * @param {?} throwOnChangeVar
	     * @param {?} actions
	     * @return {?}
	     */
	    function createCheckBindingStmt(evalResult, fieldExpr, throwOnChangeVar, actions) {
	        var /** @type {?} */ condition = importExpr(createIdentifier(Identifiers.checkBinding)).callFn([
	            throwOnChangeVar, fieldExpr, evalResult.currValExpr
	        ]);
	        if (evalResult.forceUpdate) {
	            condition = evalResult.forceUpdate.or(condition);
	        }
	        return evalResult.stmts.concat([
	            new IfStmt(condition, actions.concat([(THIS_EXPR.prop(fieldExpr.name).set(evalResult.currValExpr).toStmt())
	            ]))
	        ]);
	    }
	    /**
	     * @param {?} bindingId
	     * @return {?}
	     */
	    function createBindFieldExpr(bindingId) {
	        return THIS_EXPR.prop("_expr_" + bindingId);
	    }

	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function createDiTokenExpression(token) {
	        if (isPresent(token.value)) {
	            return literal(token.value);
	        }
	        else {
	            return importExpr(token.identifier);
	        }
	    }
	    /**
	     * @param {?} values
	     * @return {?}
	     */
	    function createInlineArray(values) {
	        if (values.length === 0) {
	            return importExpr(createIdentifier(Identifiers.EMPTY_INLINE_ARRAY));
	        }
	        var /** @type {?} */ log2 = Math.log(values.length) / Math.log(2);
	        var /** @type {?} */ index = Math.ceil(log2);
	        var /** @type {?} */ identifierSpec = index < Identifiers.inlineArrays.length ? Identifiers.inlineArrays[index] :
	            Identifiers.InlineArrayDynamic;
	        var /** @type {?} */ identifier = createIdentifier(identifierSpec);
	        return importExpr(identifier).instantiate([(literal(values.length))
	        ].concat(values));
	    }
	    /**
	     * @param {?} fn
	     * @param {?} argCount
	     * @param {?} pureProxyProp
	     * @param {?} builder
	     * @return {?}
	     */
	    function createPureProxy(fn, argCount, pureProxyProp, builder) {
	        builder.fields.push(new ClassField(pureProxyProp.name, null));
	        var /** @type {?} */ pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;
	        if (!pureProxyId) {
	            throw new Error("Unsupported number of argument for pure functions: " + argCount);
	        }
	        builder.ctorStmts.push(THIS_EXPR.prop(pureProxyProp.name)
	            .set(importExpr(createIdentifier(pureProxyId)).callFn([fn]))
	            .toStmt());
	    }
	    /**
	     * @param {?} enumType
	     * @param {?} enumValue
	     * @return {?}
	     */
	    function createEnumExpression(enumType, enumValue) {
	        var /** @type {?} */ enumName = Object.keys(enumType.runtime).find(function (propName) { return enumType.runtime[propName] === enumValue; });
	        if (!enumName) {
	            throw new Error("Unknown enum value " + enumValue + " in " + enumType.name);
	        }
	        return importExpr(createEnumIdentifier(enumType, enumName));
	    }

	    var /** @type {?} */ VAL_UNWRAPPER_VAR = variable("valUnwrapper");
	    var EventHandlerVars = (function () {
	        function EventHandlerVars() {
	        }
	        EventHandlerVars.event = variable('$event');
	        return EventHandlerVars;
	    }());
	    var ConvertPropertyBindingResult = (function () {
	        /**
	         * @param {?} stmts
	         * @param {?} currValExpr
	         * @param {?} forceUpdate
	         */
	        function ConvertPropertyBindingResult(stmts, currValExpr, forceUpdate) {
	            this.stmts = stmts;
	            this.currValExpr = currValExpr;
	            this.forceUpdate = forceUpdate;
	        }
	        return ConvertPropertyBindingResult;
	    }());
	    /**
	     * Converts the given expression AST into an executable output AST, assuming the expression is
	     * used in a property binding.
	     * @param {?} builder
	     * @param {?} nameResolver
	     * @param {?} implicitReceiver
	     * @param {?} expression
	     * @param {?} bindingId
	     * @return {?}
	     */
	    function convertPropertyBinding(builder, nameResolver, implicitReceiver, expression, bindingId) {
	        var /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);
	        var /** @type {?} */ stmts = [];
	        if (!nameResolver) {
	            nameResolver = new DefaultNameResolver();
	        }
	        var /** @type {?} */ visitor = new _AstToIrVisitor(builder, nameResolver, implicitReceiver, VAL_UNWRAPPER_VAR, bindingId, false);
	        var /** @type {?} */ outputExpr = expression.visit(visitor, _Mode.Expression);
	        if (!outputExpr) {
	            // e.g. an empty expression was given
	            return null;
	        }
	        if (visitor.temporaryCount) {
	            for (var /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {
	                stmts.push(temporaryDeclaration(bindingId, i));
	            }
	        }
	        if (visitor.needsValueUnwrapper) {
	            var /** @type {?} */ initValueUnwrapperStmt = VAL_UNWRAPPER_VAR.callMethod('reset', []).toStmt();
	            stmts.push(initValueUnwrapperStmt);
	        }
	        stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));
	        if (visitor.needsValueUnwrapper) {
	            return new ConvertPropertyBindingResult(stmts, currValExpr, VAL_UNWRAPPER_VAR.prop('hasWrappedValue'));
	        }
	        else {
	            return new ConvertPropertyBindingResult(stmts, currValExpr, null);
	        }
	    }
	    var ConvertActionBindingResult = (function () {
	        /**
	         * @param {?} stmts
	         * @param {?} preventDefault
	         */
	        function ConvertActionBindingResult(stmts, preventDefault) {
	            this.stmts = stmts;
	            this.preventDefault = preventDefault;
	        }
	        return ConvertActionBindingResult;
	    }());
	    /**
	     * Converts the given expression AST into an executable output AST, assuming the expression is
	     * used in an action binding (e.g. an event handler).
	     * @param {?} builder
	     * @param {?} nameResolver
	     * @param {?} implicitReceiver
	     * @param {?} action
	     * @param {?} bindingId
	     * @return {?}
	     */
	    function convertActionBinding(builder, nameResolver, implicitReceiver, action, bindingId) {
	        if (!nameResolver) {
	            nameResolver = new DefaultNameResolver();
	        }
	        var /** @type {?} */ visitor = new _AstToIrVisitor(builder, nameResolver, implicitReceiver, null, bindingId, true);
	        var /** @type {?} */ actionStmts = [];
	        flattenStatements(action.visit(visitor, _Mode.Statement), actionStmts);
	        prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
	        var /** @type {?} */ lastIndex = actionStmts.length - 1;
	        var /** @type {?} */ preventDefaultVar = null;
	        if (lastIndex >= 0) {
	            var /** @type {?} */ lastStatement = actionStmts[lastIndex];
	            var /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);
	            if (returnExpr) {
	                // Note: We need to cast the result of the method call to dynamic,
	                // as it might be a void method!
	                preventDefaultVar = createPreventDefaultVar(bindingId);
	                actionStmts[lastIndex] =
	                    preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
	                        .toDeclStmt(null, [StmtModifier.Final]);
	            }
	        }
	        return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
	    }
	    /**
	     * Creates variables that are shared by multiple calls to `convertActionBinding` /
	     * `convertPropertyBinding`
	     * @param {?} stmts
	     * @return {?}
	     */
	    function createSharedBindingVariablesIfNeeded(stmts) {
	        var /** @type {?} */ unwrapperStmts = [];
	        var /** @type {?} */ readVars = findReadVarNames(stmts);
	        if (readVars.has(VAL_UNWRAPPER_VAR.name)) {
	            unwrapperStmts.push(VAL_UNWRAPPER_VAR
	                .set(importExpr(createIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))
	                .toDeclStmt(null, [StmtModifier.Final]));
	        }
	        return unwrapperStmts;
	    }
	    /**
	     * @param {?} bindingId
	     * @param {?} temporaryNumber
	     * @return {?}
	     */
	    function temporaryName(bindingId, temporaryNumber) {
	        return "tmp_" + bindingId + "_" + temporaryNumber;
	    }
	    /**
	     * @param {?} bindingId
	     * @param {?} temporaryNumber
	     * @return {?}
	     */
	    function temporaryDeclaration(bindingId, temporaryNumber) {
	        return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);
	    }
	    /**
	     * @param {?} temporaryCount
	     * @param {?} bindingId
	     * @param {?} statements
	     * @return {?}
	     */
	    function prependTemporaryDecls(temporaryCount, bindingId, statements) {
	        for (var /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {
	            statements.unshift(temporaryDeclaration(bindingId, i));
	        }
	    }
	    var _Mode = {};
	    _Mode.Statement = 0;
	    _Mode.Expression = 1;
	    _Mode[_Mode.Statement] = "Statement";
	    _Mode[_Mode.Expression] = "Expression";
	    /**
	     * @param {?} mode
	     * @param {?} ast
	     * @return {?}
	     */
	    function ensureStatementMode(mode, ast) {
	        if (mode !== _Mode.Statement) {
	            throw new Error("Expected a statement, but saw " + ast);
	        }
	    }
	    /**
	     * @param {?} mode
	     * @param {?} ast
	     * @return {?}
	     */
	    function ensureExpressionMode(mode, ast) {
	        if (mode !== _Mode.Expression) {
	            throw new Error("Expected an expression, but saw " + ast);
	        }
	    }
	    /**
	     * @param {?} mode
	     * @param {?} expr
	     * @return {?}
	     */
	    function convertToStatementIfNeeded(mode, expr) {
	        if (mode === _Mode.Statement) {
	            return expr.toStmt();
	        }
	        else {
	            return expr;
	        }
	    }
	    var _AstToIrVisitor = (function () {
	        /**
	         * @param {?} _builder
	         * @param {?} _nameResolver
	         * @param {?} _implicitReceiver
	         * @param {?} _valueUnwrapper
	         * @param {?} bindingId
	         * @param {?} isAction
	         */
	        function _AstToIrVisitor(_builder, _nameResolver, _implicitReceiver, _valueUnwrapper, bindingId, isAction) {
	            this._builder = _builder;
	            this._nameResolver = _nameResolver;
	            this._implicitReceiver = _implicitReceiver;
	            this._valueUnwrapper = _valueUnwrapper;
	            this.bindingId = bindingId;
	            this.isAction = isAction;
	            this._nodeMap = new Map();
	            this._resultMap = new Map();
	            this._currentTemporary = 0;
	            this.needsValueUnwrapper = false;
	            this.temporaryCount = 0;
	        }
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {
	            var /** @type {?} */ op;
	            switch (ast.operation) {
	                case '+':
	                    op = BinaryOperator.Plus;
	                    break;
	                case '-':
	                    op = BinaryOperator.Minus;
	                    break;
	                case '*':
	                    op = BinaryOperator.Multiply;
	                    break;
	                case '/':
	                    op = BinaryOperator.Divide;
	                    break;
	                case '%':
	                    op = BinaryOperator.Modulo;
	                    break;
	                case '&&':
	                    op = BinaryOperator.And;
	                    break;
	                case '||':
	                    op = BinaryOperator.Or;
	                    break;
	                case '==':
	                    op = BinaryOperator.Equals;
	                    break;
	                case '!=':
	                    op = BinaryOperator.NotEquals;
	                    break;
	                case '===':
	                    op = BinaryOperator.Identical;
	                    break;
	                case '!==':
	                    op = BinaryOperator.NotIdentical;
	                    break;
	                case '<':
	                    op = BinaryOperator.Lower;
	                    break;
	                case '>':
	                    op = BinaryOperator.Bigger;
	                    break;
	                case '<=':
	                    op = BinaryOperator.LowerEquals;
	                    break;
	                case '>=':
	                    op = BinaryOperator.BiggerEquals;
	                    break;
	                default:
	                    throw new Error("Unsupported operation " + ast.operation);
	            }
	            return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitChain = function (ast, mode) {
	            ensureStatementMode(mode, ast);
	            return this.visitAll(ast.expressions, mode);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {
	            var /** @type {?} */ value = this.visit(ast.condition, _Mode.Expression);
	            return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {
	            var /** @type {?} */ input = this.visit(ast.exp, _Mode.Expression);
	            var /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);
	            var /** @type {?} */ value = this._nameResolver.callPipe(ast.name, input, args);
	            if (!value) {
	                throw new Error("Illegal state: Pipe " + ast.name + " is not allowed here!");
	            }
	            this.needsValueUnwrapper = true;
	            return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {
	            return convertToStatementIfNeeded(mode, this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {
	            ensureExpressionMode(mode, ast);
	            return this._implicitReceiver;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {
	            ensureExpressionMode(mode, ast);
	            var /** @type {?} */ args = [literal(ast.expressions.length)];
	            for (var /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {
	                args.push(literal(ast.strings[i]));
	                args.push(this.visit(ast.expressions[i], _Mode.Expression));
	            }
	            args.push(literal(ast.strings[ast.strings.length - 1]));
	            return ast.expressions.length <= 9 ?
	                importExpr(createIdentifier(Identifiers.inlineInterpolate)).callFn(args) :
	                importExpr(createIdentifier(Identifiers.interpolate)).callFn([
	                    args[0], literalArr(args.slice(1))
	                ]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {
	            var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);
	            if (leftMostSafe) {
	                return this.convertSafeAccess(ast, leftMostSafe, mode);
	            }
	            else {
	                return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));
	            }
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {
	            var /** @type {?} */ obj = this.visit(ast.obj, _Mode.Expression);
	            var /** @type {?} */ key = this.visit(ast.key, _Mode.Expression);
	            var /** @type {?} */ value = this.visit(ast.value, _Mode.Expression);
	            return convertToStatementIfNeeded(mode, obj.key(key).set(value));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {
	            var /** @type {?} */ parts = this.visitAll(ast.expressions, mode);
	            var /** @type {?} */ literalArr$$ = this.isAction ? literalArr(parts) : createCachedLiteralArray(this._builder, parts);
	            return convertToStatementIfNeeded(mode, literalArr$$);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {
	            var /** @type {?} */ parts = [];
	            for (var /** @type {?} */ i = 0; i < ast.keys.length; i++) {
	                parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);
	            }
	            var /** @type {?} */ literalMap$$ = this.isAction ? literalMap(parts) : createCachedLiteralMap(this._builder, parts);
	            return convertToStatementIfNeeded(mode, literalMap$$);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {
	            return convertToStatementIfNeeded(mode, literal(ast.value));
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype._getLocal = function (name) {
	            if (this.isAction && name == EventHandlerVars.event.name) {
	                return EventHandlerVars.event;
	            }
	            return this._nameResolver.getLocal(name);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {
	            var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);
	            if (leftMostSafe) {
	                return this.convertSafeAccess(ast, leftMostSafe, mode);
	            }
	            else {
	                var /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);
	                var /** @type {?} */ result = null;
	                var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);
	                if (receiver === this._implicitReceiver) {
	                    var /** @type {?} */ varExpr = this._getLocal(ast.name);
	                    if (varExpr) {
	                        result = varExpr.callFn(args);
	                    }
	                }
	                if (isBlank(result)) {
	                    result = receiver.callMethod(ast.name, args);
	                }
	                return convertToStatementIfNeeded(mode, result);
	            }
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {
	            return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {
	            var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);
	            if (leftMostSafe) {
	                return this.convertSafeAccess(ast, leftMostSafe, mode);
	            }
	            else {
	                var /** @type {?} */ result = null;
	                var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);
	                if (receiver === this._implicitReceiver) {
	                    result = this._getLocal(ast.name);
	                }
	                if (isBlank(result)) {
	                    result = receiver.prop(ast.name);
	                }
	                return convertToStatementIfNeeded(mode, result);
	            }
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {
	            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);
	            if (receiver === this._implicitReceiver) {
	                var /** @type {?} */ varExpr = this._getLocal(ast.name);
	                if (varExpr) {
	                    throw new Error('Cannot assign to a reference or variable!');
	                }
	            }
	            return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {
	            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {
	            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
	        };
	        /**
	         * @param {?} asts
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitAll = function (asts, mode) {
	            var _this = this;
	            return asts.map(function (ast) { return _this.visit(ast, mode); });
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {
	            throw new Error('Quotes are not supported for evaluation!');
	        };
	        /**
	         * @param {?} ast
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.visit = function (ast, mode) {
	            var /** @type {?} */ result = this._resultMap.get(ast);
	            if (result)
	                return result;
	            return (this._nodeMap.get(ast) || ast).visit(this, mode);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} leftMostSafe
	         * @param {?} mode
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {
	            // If the expression contains a safe access node on the left it needs to be converted to
	            // an expression that guards the access to the member by checking the receiver for blank. As
	            // execution proceeds from left to right, the left most part of the expression must be guarded
	            // first but, because member access is left associative, the right side of the expression is at
	            // the top of the AST. The desired result requires lifting a copy of the the left part of the
	            // expression up to test it for blank before generating the unguarded version.
	            // Consider, for example the following expression: a?.b.c?.d.e
	            // This results in the ast:
	            //         .
	            //        / \
	            //       ?.   e
	            //      /  \
	            //     .    d
	            //    / \
	            //   ?.  c
	            //  /  \
	            // a    b
	            // The following tree should be generated:
	            //
	            //        /---- ? ----\
	            //       /      |      \
	            //     a   /--- ? ---\  null
	            //        /     |     \
	            //       .      .     null
	            //      / \    / \
	            //     .  c   .   e
	            //    / \    / \
	            //   a   b  ,   d
	            //         / \
	            //        .   c
	            //       / \
	            //      a   b
	            //
	            // Notice that the first guard condition is the left hand of the left most safe access node
	            // which comes in as leftMostSafe to this routine.
	            var /** @type {?} */ guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);
	            var /** @type {?} */ temporary;
	            if (this.needsTemporary(leftMostSafe.receiver)) {
	                // If the expression has method calls or pipes then we need to save the result into a
	                // temporary variable to avoid calling stateful or impure code more than once.
	                temporary = this.allocateTemporary();
	                // Preserve the result in the temporary variable
	                guardedExpression = temporary.set(guardedExpression);
	                // Ensure all further references to the guarded expression refer to the temporary instead.
	                this._resultMap.set(leftMostSafe.receiver, temporary);
	            }
	            var /** @type {?} */ condition = guardedExpression.isBlank();
	            // Convert the ast to an unguarded access to the receiver's member. The map will substitute
	            // leftMostNode with its unguarded version in the call to `this.visit()`.
	            if (leftMostSafe instanceof SafeMethodCall) {
	                this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
	            }
	            else {
	                this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
	            }
	            // Recursively convert the node now without the guarded member access.
	            var /** @type {?} */ access = this.visit(ast, _Mode.Expression);
	            // Remove the mapping. This is not strictly required as the converter only traverses each node
	            // once but is safer if the conversion is changed to traverse the nodes more than once.
	            this._nodeMap.delete(leftMostSafe);
	            // If we allcoated a temporary, release it.
	            if (temporary) {
	                this.releaseTemporary(temporary);
	            }
	            // Produce the conditional
	            return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
	        };
	        /**
	         * @param {?} ast
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {
	            var _this = this;
	            var /** @type {?} */ visit = function (visitor, ast) {
	                return (_this._nodeMap.get(ast) || ast).visit(visitor);
	            };
	            return ast.visit({
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitBinary: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitChain: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitConditional: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitFunctionCall: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitImplicitReceiver: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitInterpolation: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitKeyedRead: function (ast) { return visit(this, ast.obj); },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitKeyedWrite: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitLiteralArray: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitLiteralMap: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitLiteralPrimitive: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitMethodCall: function (ast) { return visit(this, ast.receiver); },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPipe: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPrefixNot: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPropertyRead: function (ast) { return visit(this, ast.receiver); },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPropertyWrite: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitQuote: function (ast) { return null; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitSafePropertyRead: function (ast) {
	                    return visit(this, ast.receiver) || ast;
	                }
	            });
	        };
	        /**
	         * @param {?} ast
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.needsTemporary = function (ast) {
	            var _this = this;
	            var /** @type {?} */ visit = function (visitor, ast) {
	                return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);
	            };
	            var /** @type {?} */ visitSome = function (visitor, ast) {
	                return ast.some(function (ast) { return visit(visitor, ast); });
	            };
	            return ast.visit({
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitChain: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitConditional: function (ast) {
	                    return visit(this, ast.condition) || visit(this, ast.trueExp) ||
	                        visit(this, ast.falseExp);
	                },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitFunctionCall: function (ast) { return true; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitImplicitReceiver: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitKeyedRead: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitKeyedWrite: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitLiteralArray: function (ast) { return true; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitLiteralMap: function (ast) { return true; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitLiteralPrimitive: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitMethodCall: function (ast) { return true; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPipe: function (ast) { return true; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPrefixNot: function (ast) { return visit(this, ast.expression); },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPropertyRead: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitPropertyWrite: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitQuote: function (ast) { return false; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitSafeMethodCall: function (ast) { return true; },
	                /**
	                 * @param {?} ast
	                 * @return {?}
	                 */
	                visitSafePropertyRead: function (ast) { return false; }
	            });
	        };
	        /**
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.allocateTemporary = function () {
	            var /** @type {?} */ tempNumber = this._currentTemporary++;
	            this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
	            return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
	        };
	        /**
	         * @param {?} temporary
	         * @return {?}
	         */
	        _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {
	            this._currentTemporary--;
	            if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
	                throw new Error("Temporary " + temporary.name + " released out of order");
	            }
	        };
	        return _AstToIrVisitor;
	    }());
	    /**
	     * @param {?} arg
	     * @param {?} output
	     * @return {?}
	     */
	    function flattenStatements(arg, output) {
	        if (Array.isArray(arg)) {
	            ((arg)).forEach(function (entry) { return flattenStatements(entry, output); });
	        }
	        else {
	            output.push(arg);
	        }
	    }
	    /**
	     * @param {?} builder
	     * @param {?} values
	     * @return {?}
	     */
	    function createCachedLiteralArray(builder, values) {
	        if (values.length === 0) {
	            return importExpr(createIdentifier(Identifiers.EMPTY_ARRAY));
	        }
	        var /** @type {?} */ proxyExpr = THIS_EXPR.prop("_arr_" + builder.fields.length);
	        var /** @type {?} */ proxyParams = [];
	        var /** @type {?} */ proxyReturnEntries = [];
	        for (var /** @type {?} */ i = 0; i < values.length; i++) {
	            var /** @type {?} */ paramName = "p" + i;
	            proxyParams.push(new FnParam(paramName));
	            proxyReturnEntries.push(variable(paramName));
	        }
	        createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))], new ArrayType(DYNAMIC_TYPE)), values.length, proxyExpr, builder);
	        return proxyExpr.callFn(values);
	    }
	    /**
	     * @param {?} builder
	     * @param {?} entries
	     * @return {?}
	     */
	    function createCachedLiteralMap(builder, entries) {
	        if (entries.length === 0) {
	            return importExpr(createIdentifier(Identifiers.EMPTY_MAP));
	        }
	        var /** @type {?} */ proxyExpr = THIS_EXPR.prop("_map_" + builder.fields.length);
	        var /** @type {?} */ proxyParams = [];
	        var /** @type {?} */ proxyReturnEntries = [];
	        var /** @type {?} */ values = [];
	        for (var /** @type {?} */ i = 0; i < entries.length; i++) {
	            var /** @type {?} */ paramName = "p" + i;
	            proxyParams.push(new FnParam(paramName));
	            proxyReturnEntries.push([entries[i][0], variable(paramName)]);
	            values.push(/** @type {?} */ (entries[i][1]));
	        }
	        createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))], new MapType(DYNAMIC_TYPE)), entries.length, proxyExpr, builder);
	        return proxyExpr.callFn(values);
	    }
	    var DefaultNameResolver = (function () {
	        function DefaultNameResolver() {
	        }
	        /**
	         * @param {?} name
	         * @param {?} input
	         * @param {?} args
	         * @return {?}
	         */
	        DefaultNameResolver.prototype.callPipe = function (name, input, args) { return null; };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        DefaultNameResolver.prototype.getLocal = function (name) { return null; };
	        return DefaultNameResolver;
	    }());
	    /**
	     * @param {?} bindingId
	     * @return {?}
	     */
	    function createCurrValueExpr(bindingId) {
	        return variable("currVal_" + bindingId); // fix syntax highlighting: `
	    }
	    /**
	     * @param {?} bindingId
	     * @return {?}
	     */
	    function createPreventDefaultVar(bindingId) {
	        return variable("pd_" + bindingId);
	    }
	    /**
	     * @param {?} stmt
	     * @return {?}
	     */
	    function convertStmtIntoExpression(stmt) {
	        if (stmt instanceof ExpressionStatement) {
	            return stmt.expr;
	        }
	        else if (stmt instanceof ReturnStatement) {
	            return stmt.value;
	        }
	        return null;
	    }

	    /**
	     * @param {?} view
	     * @param {?} boundProp
	     * @param {?} renderElement
	     * @param {?} renderValue
	     * @param {?} logBindingUpdate
	     * @param {?=} securityContextExpression
	     * @return {?}
	     */
	    function writeToRenderer(view, boundProp, renderElement, renderValue, logBindingUpdate, securityContextExpression) {
	        var /** @type {?} */ updateStmts = [];
	        var /** @type {?} */ renderer = view.prop('renderer');
	        renderValue = sanitizedValue(view, boundProp, renderValue, securityContextExpression);
	        switch (boundProp.type) {
	            case PropertyBindingType.Property:
	                if (logBindingUpdate) {
	                    updateStmts.push(importExpr(createIdentifier(Identifiers.setBindingDebugInfo))
	                        .callFn([renderer, renderElement, literal(boundProp.name), renderValue])
	                        .toStmt());
	                }
	                updateStmts.push(renderer
	                    .callMethod('setElementProperty', [renderElement, literal(boundProp.name), renderValue])
	                    .toStmt());
	                break;
	            case PropertyBindingType.Attribute:
	                renderValue =
	                    renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));
	                updateStmts.push(renderer
	                    .callMethod('setElementAttribute', [renderElement, literal(boundProp.name), renderValue])
	                    .toStmt());
	                break;
	            case PropertyBindingType.Class:
	                updateStmts.push(renderer
	                    .callMethod('setElementClass', [renderElement, literal(boundProp.name), renderValue])
	                    .toStmt());
	                break;
	            case PropertyBindingType.Style:
	                var /** @type {?} */ strValue = renderValue.callMethod('toString', []);
	                if (isPresent(boundProp.unit)) {
	                    strValue = strValue.plus(literal(boundProp.unit));
	                }
	                renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);
	                updateStmts.push(renderer
	                    .callMethod('setElementStyle', [renderElement, literal(boundProp.name), renderValue])
	                    .toStmt());
	                break;
	            case PropertyBindingType.Animation:
	                throw new Error('Illegal state: Should not come here!');
	        }
	        return updateStmts;
	    }
	    /**
	     * @param {?} view
	     * @param {?} boundProp
	     * @param {?} renderValue
	     * @param {?=} securityContextExpression
	     * @return {?}
	     */
	    function sanitizedValue(view, boundProp, renderValue, securityContextExpression) {
	        if (boundProp.securityContext === _angular_core.SecurityContext.NONE) {
	            return renderValue; // No sanitization needed.
	        }
	        if (!boundProp.needsRuntimeSecurityContext) {
	            securityContextExpression =
	                createEnumExpression(Identifiers.SecurityContext, boundProp.securityContext);
	        }
	        if (!securityContextExpression) {
	            throw new Error("internal error, no SecurityContext given " + boundProp.name);
	        }
	        var /** @type {?} */ ctx = view.prop('viewUtils').prop('sanitizer');
	        var /** @type {?} */ args = [securityContextExpression, renderValue];
	        return ctx.callMethod('sanitize', args);
	    }
	    /**
	     * @param {?} view
	     * @param {?} componentView
	     * @param {?} boundProp
	     * @param {?} boundOutputs
	     * @param {?} eventListener
	     * @param {?} renderElement
	     * @param {?} renderValue
	     * @param {?} lastRenderValue
	     * @return {?}
	     */
	    function triggerAnimation(view, componentView, boundProp, boundOutputs, eventListener, renderElement, renderValue, lastRenderValue) {
	        var /** @type {?} */ detachStmts = [];
	        var /** @type {?} */ updateStmts = [];
	        var /** @type {?} */ animationName = boundProp.name;
	        var /** @type {?} */ animationFnExpr = componentView.prop('componentType').prop('animations').key(literal(animationName));
	        // it's important to normalize the void value as `void` explicitly
	        // so that the styles data can be obtained from the stringmap
	        var /** @type {?} */ emptyStateValue = literal(EMPTY_STATE);
	        var /** @type {?} */ unitializedValue = importExpr(createIdentifier(Identifiers.UNINITIALIZED));
	        var /** @type {?} */ animationTransitionVar = variable('animationTransition_' + animationName);
	        updateStmts.push(animationTransitionVar
	            .set(animationFnExpr.callFn([
	            view, renderElement,
	            lastRenderValue.equals(unitializedValue).conditional(emptyStateValue, lastRenderValue),
	            renderValue.equals(unitializedValue).conditional(emptyStateValue, renderValue)
	        ]))
	            .toDeclStmt());
	        detachStmts.push(animationTransitionVar
	            .set(animationFnExpr.callFn([view, renderElement, lastRenderValue, emptyStateValue]))
	            .toDeclStmt());
	        var /** @type {?} */ registerStmts = [];
	        var /** @type {?} */ animationStartMethodExists = boundOutputs.find(function (event) { return event.isAnimation && event.name == animationName && event.phase == 'start'; });
	        if (animationStartMethodExists) {
	            registerStmts.push(animationTransitionVar
	                .callMethod('onStart', [eventListener.callMethod(BuiltinMethod.Bind, [view, literal(BoundEventAst.calcFullName(animationName, null, 'start'))])])
	                .toStmt());
	        }
	        var /** @type {?} */ animationDoneMethodExists = boundOutputs.find(function (event) { return event.isAnimation && event.name == animationName && event.phase == 'done'; });
	        if (animationDoneMethodExists) {
	            registerStmts.push(animationTransitionVar
	                .callMethod('onDone', [eventListener.callMethod(BuiltinMethod.Bind, [view, literal(BoundEventAst.calcFullName(animationName, null, 'done'))])])
	                .toStmt());
	        }
	        updateStmts.push.apply(updateStmts, registerStmts);
	        detachStmts.push.apply(detachStmts, registerStmts);
	        return { updateStmts: updateStmts, detachStmts: detachStmts };
	    }

	    /**
	     * Create a new class stmts based on the given data.
	     * @param {?} config
	     * @return {?}
	     */
	    function createClassStmt(config) {
	        var /** @type {?} */ parentArgs = config.parentArgs || [];
	        var /** @type {?} */ superCtorStmts = config.parent ? [SUPER_EXPR.callFn(parentArgs).toStmt()] : [];
	        var /** @type {?} */ builder = concatClassBuilderParts(Array.isArray(config.builders) ? config.builders : [config.builders]);
	        var /** @type {?} */ ctor = new ClassMethod(null, config.ctorParams || [], superCtorStmts.concat(builder.ctorStmts));
	        return new ClassStmt(config.name, config.parent, builder.fields, builder.getters, ctor, builder.methods, config.modifiers || []);
	    }
	    /**
	     * @param {?} builders
	     * @return {?}
	     */
	    function concatClassBuilderParts(builders) {
	        return {
	            fields: (_a = []).concat.apply(_a, builders.map(function (builder) { return builder.fields || []; })),
	            methods: (_b = []).concat.apply(_b, builders.map(function (builder) { return builder.methods || []; })),
	            getters: (_c = []).concat.apply(_c, builders.map(function (builder) { return builder.getters || []; })),
	            ctorStmts: (_d = []).concat.apply(_d, builders.map(function (builder) { return builder.ctorStmts || []; })),
	        };
	        var _a, _b, _c, _d;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$8 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var DirectiveWrapperCompileResult = (function () {
	        /**
	         * @param {?} statements
	         * @param {?} dirWrapperClassVar
	         */
	        function DirectiveWrapperCompileResult(statements, dirWrapperClassVar) {
	            this.statements = statements;
	            this.dirWrapperClassVar = dirWrapperClassVar;
	        }
	        return DirectiveWrapperCompileResult;
	    }());
	    var /** @type {?} */ CONTEXT_FIELD_NAME = 'context';
	    var /** @type {?} */ CHANGES_FIELD_NAME = '_changes';
	    var /** @type {?} */ CHANGED_FIELD_NAME = '_changed';
	    var /** @type {?} */ EVENT_HANDLER_FIELD_NAME = '_eventHandler';
	    var /** @type {?} */ CURR_VALUE_VAR = variable('currValue');
	    var /** @type {?} */ THROW_ON_CHANGE_VAR = variable('throwOnChange');
	    var /** @type {?} */ FORCE_UPDATE_VAR = variable('forceUpdate');
	    var /** @type {?} */ VIEW_VAR = variable('view');
	    var /** @type {?} */ COMPONENT_VIEW_VAR = variable('componentView');
	    var /** @type {?} */ RENDER_EL_VAR = variable('el');
	    var /** @type {?} */ EVENT_NAME_VAR = variable('eventName');
	    var /** @type {?} */ RESET_CHANGES_STMT = THIS_EXPR.prop(CHANGES_FIELD_NAME).set(literalMap([])).toStmt();
	    /**
	     * We generate directive wrappers to prevent code bloat when a directive is used.
	     * A directive wrapper encapsulates
	     * the dirty checking for `\@Input`, the handling of `\@HostListener` / `\@HostBinding`
	     * and calling the lifecyclehooks `ngOnInit`, `ngOnChanges`, `ngDoCheck`.
	     *
	     * So far, only `\@Input` and the lifecycle hooks have been implemented.
	     */
	    var DirectiveWrapperCompiler = (function () {
	        /**
	         * @param {?} compilerConfig
	         * @param {?} _exprParser
	         * @param {?} _schemaRegistry
	         * @param {?} _console
	         */
	        function DirectiveWrapperCompiler(compilerConfig, _exprParser, _schemaRegistry, _console) {
	            this.compilerConfig = compilerConfig;
	            this._exprParser = _exprParser;
	            this._schemaRegistry = _schemaRegistry;
	            this._console = _console;
	        }
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        DirectiveWrapperCompiler.dirWrapperClassName = function (id) {
	            return "Wrapper_" + identifierName(id);
	        };
	        /**
	         * @param {?} dirMeta
	         * @return {?}
	         */
	        DirectiveWrapperCompiler.prototype.compile = function (dirMeta) {
	            var /** @type {?} */ hostParseResult = parseHostBindings(dirMeta, this._exprParser, this._schemaRegistry);
	            reportParseErrors(hostParseResult.errors, this._console);
	            var /** @type {?} */ builder = new DirectiveWrapperBuilder(this.compilerConfig, dirMeta);
	            Object.keys(dirMeta.inputs).forEach(function (inputFieldName) {
	                addCheckInputMethod(inputFieldName, builder);
	            });
	            addNgDoCheckMethod(builder);
	            addCheckHostMethod(hostParseResult.hostProps, hostParseResult.hostListeners, builder);
	            addHandleEventMethod(hostParseResult.hostListeners, builder);
	            addSubscribeMethod(dirMeta, builder);
	            var /** @type {?} */ classStmt = builder.build();
	            return new DirectiveWrapperCompileResult([classStmt], classStmt.name);
	        };
	        DirectiveWrapperCompiler = __decorate$8([
	            CompilerInjectable(), 
	            __metadata$8('design:paramtypes', [CompilerConfig, Parser, ElementSchemaRegistry, Console])
	        ], DirectiveWrapperCompiler);
	        return DirectiveWrapperCompiler;
	    }());
	    var DirectiveWrapperBuilder = (function () {
	        /**
	         * @param {?} compilerConfig
	         * @param {?} dirMeta
	         */
	        function DirectiveWrapperBuilder(compilerConfig, dirMeta) {
	            this.compilerConfig = compilerConfig;
	            this.dirMeta = dirMeta;
	            this.fields = [];
	            this.getters = [];
	            this.methods = [];
	            this.ctorStmts = [];
	            this.detachStmts = [];
	            this.destroyStmts = [];
	            var dirLifecycleHooks = dirMeta.type.lifecycleHooks;
	            this.genChanges = dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1 ||
	                this.compilerConfig.logBindingUpdate;
	            this.ngOnChanges = dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1;
	            this.ngOnInit = dirLifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1;
	            this.ngDoCheck = dirLifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1;
	            this.ngOnDestroy = dirLifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1;
	            if (this.ngOnDestroy) {
	                this.destroyStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngOnDestroy', []).toStmt());
	            }
	        }
	        /**
	         * @return {?}
	         */
	        DirectiveWrapperBuilder.prototype.build = function () {
	            var /** @type {?} */ dirDepParamNames = [];
	            for (var /** @type {?} */ i = 0; i < this.dirMeta.type.diDeps.length; i++) {
	                dirDepParamNames.push("p" + i);
	            }
	            var /** @type {?} */ methods = [
	                new ClassMethod('ngOnDetach', [
	                    new FnParam(VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	                    new FnParam(COMPONENT_VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	                    new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),
	                ], this.detachStmts),
	                new ClassMethod('ngOnDestroy', [], this.destroyStmts),
	            ];
	            var /** @type {?} */ fields = [
	                new ClassField(EVENT_HANDLER_FIELD_NAME, FUNCTION_TYPE, [StmtModifier.Private]),
	                new ClassField(CONTEXT_FIELD_NAME, importType(this.dirMeta.type)),
	                new ClassField(CHANGED_FIELD_NAME, BOOL_TYPE, [StmtModifier.Private]),
	            ];
	            var /** @type {?} */ ctorStmts = [THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt()];
	            if (this.genChanges) {
	                fields.push(new ClassField(CHANGES_FIELD_NAME, new MapType(DYNAMIC_TYPE), [StmtModifier.Private]));
	                ctorStmts.push(RESET_CHANGES_STMT);
	            }
	            ctorStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
	                .set(importExpr(this.dirMeta.type)
	                .instantiate(dirDepParamNames.map(function (paramName) { return variable(paramName); })))
	                .toStmt());
	            return createClassStmt({
	                name: DirectiveWrapperCompiler.dirWrapperClassName(this.dirMeta.type),
	                ctorParams: dirDepParamNames.map(function (paramName) { return new FnParam(paramName, DYNAMIC_TYPE); }),
	                builders: [{ fields: fields, ctorStmts: ctorStmts, methods: methods }, this]
	            });
	        };
	        return DirectiveWrapperBuilder;
	    }());
	    /**
	     * @param {?} builder
	     * @return {?}
	     */
	    function addNgDoCheckMethod(builder) {
	        var /** @type {?} */ changedVar = variable('changed');
	        var /** @type {?} */ stmts = [
	            changedVar.set(THIS_EXPR.prop(CHANGED_FIELD_NAME)).toDeclStmt(),
	            THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt(),
	        ];
	        var /** @type {?} */ lifecycleStmts = [];
	        if (builder.genChanges) {
	            var /** @type {?} */ onChangesStmts = [];
	            if (builder.ngOnChanges) {
	                onChangesStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
	                    .callMethod('ngOnChanges', [THIS_EXPR.prop(CHANGES_FIELD_NAME)])
	                    .toStmt());
	            }
	            if (builder.compilerConfig.logBindingUpdate) {
	                onChangesStmts.push(importExpr(createIdentifier(Identifiers.setBindingDebugInfoForChanges))
	                    .callFn([VIEW_VAR.prop('renderer'), RENDER_EL_VAR, THIS_EXPR.prop(CHANGES_FIELD_NAME)])
	                    .toStmt());
	            }
	            onChangesStmts.push(RESET_CHANGES_STMT);
	            lifecycleStmts.push(new IfStmt(changedVar, onChangesStmts));
	        }
	        if (builder.ngOnInit) {
	            lifecycleStmts.push(new IfStmt(VIEW_VAR.prop('numberOfChecks').identical(new LiteralExpr(0)), [THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngOnInit', []).toStmt()]));
	        }
	        if (builder.ngDoCheck) {
	            lifecycleStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngDoCheck', []).toStmt());
	        }
	        if (lifecycleStmts.length > 0) {
	            stmts.push(new IfStmt(not(THROW_ON_CHANGE_VAR), lifecycleStmts));
	        }
	        stmts.push(new ReturnStatement(changedVar));
	        builder.methods.push(new ClassMethod('ngDoCheck', [
	            new FnParam(VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	            new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),
	            new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
	        ], stmts, BOOL_TYPE));
	    }
	    /**
	     * @param {?} input
	     * @param {?} builder
	     * @return {?}
	     */
	    function addCheckInputMethod(input, builder) {
	        var /** @type {?} */ field = createCheckBindingField(builder);
	        var /** @type {?} */ onChangeStatements = [
	            THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(true)).toStmt(),
	            THIS_EXPR.prop(CONTEXT_FIELD_NAME).prop(input).set(CURR_VALUE_VAR).toStmt(),
	        ];
	        if (builder.genChanges) {
	            onChangeStatements.push(THIS_EXPR.prop(CHANGES_FIELD_NAME)
	                .key(literal(input))
	                .set(importExpr(createIdentifier(Identifiers.SimpleChange))
	                .instantiate([field.expression, CURR_VALUE_VAR]))
	                .toStmt());
	        }
	        var /** @type {?} */ methodBody = createCheckBindingStmt({ currValExpr: CURR_VALUE_VAR, forceUpdate: FORCE_UPDATE_VAR, stmts: [] }, field.expression, THROW_ON_CHANGE_VAR, onChangeStatements);
	        builder.methods.push(new ClassMethod("check_" + input, [
	            new FnParam(CURR_VALUE_VAR.name, DYNAMIC_TYPE),
	            new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
	            new FnParam(FORCE_UPDATE_VAR.name, BOOL_TYPE),
	        ], methodBody));
	    }
	    /**
	     * @param {?} hostProps
	     * @param {?} hostEvents
	     * @param {?} builder
	     * @return {?}
	     */
	    function addCheckHostMethod(hostProps, hostEvents, builder) {
	        var /** @type {?} */ stmts = [];
	        var /** @type {?} */ methodParams = [
	            new FnParam(VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	            new FnParam(COMPONENT_VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	            new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),
	            new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
	        ];
	        hostProps.forEach(function (hostProp, hostPropIdx) {
	            var /** @type {?} */ field = createCheckBindingField(builder);
	            var /** @type {?} */ evalResult = convertPropertyBinding(builder, null, THIS_EXPR.prop(CONTEXT_FIELD_NAME), hostProp.value, field.bindingId);
	            if (!evalResult) {
	                return;
	            }
	            var /** @type {?} */ securityContextExpr;
	            if (hostProp.needsRuntimeSecurityContext) {
	                securityContextExpr = variable("secCtx_" + methodParams.length);
	                methodParams.push(new FnParam(securityContextExpr.name, importType(createIdentifier(Identifiers.SecurityContext))));
	            }
	            var /** @type {?} */ checkBindingStmts;
	            if (hostProp.isAnimation) {
	                var _a = triggerAnimation(VIEW_VAR, COMPONENT_VIEW_VAR, hostProp, hostEvents, THIS_EXPR.prop(EVENT_HANDLER_FIELD_NAME)
	                    .or(importExpr(createIdentifier(Identifiers.noop))), RENDER_EL_VAR, evalResult.currValExpr, field.expression), updateStmts = _a.updateStmts, detachStmts = _a.detachStmts;
	                checkBindingStmts = updateStmts;
	                (_b = builder.detachStmts).push.apply(_b, detachStmts);
	            }
	            else {
	                checkBindingStmts = writeToRenderer(VIEW_VAR, hostProp, RENDER_EL_VAR, evalResult.currValExpr, builder.compilerConfig.logBindingUpdate, securityContextExpr);
	            }
	            stmts.push.apply(stmts, createCheckBindingStmt(evalResult, field.expression, THROW_ON_CHANGE_VAR, checkBindingStmts));
	            var _b;
	        });
	        builder.methods.push(new ClassMethod('checkHost', methodParams, stmts));
	    }
	    /**
	     * @param {?} hostListeners
	     * @param {?} builder
	     * @return {?}
	     */
	    function addHandleEventMethod(hostListeners, builder) {
	        var /** @type {?} */ resultVar = variable("result");
	        var /** @type {?} */ actionStmts = [resultVar.set(literal(true)).toDeclStmt(BOOL_TYPE)];
	        hostListeners.forEach(function (hostListener, eventIdx) {
	            var /** @type {?} */ evalResult = convertActionBinding(builder, null, THIS_EXPR.prop(CONTEXT_FIELD_NAME), hostListener.handler, "sub_" + eventIdx);
	            var /** @type {?} */ trueStmts = evalResult.stmts;
	            if (evalResult.preventDefault) {
	                trueStmts.push(resultVar.set(evalResult.preventDefault.and(resultVar)).toStmt());
	            }
	            // TODO(tbosch): convert this into a `switch` once our OutputAst supports it.
	            actionStmts.push(new IfStmt(EVENT_NAME_VAR.equals(literal(hostListener.fullName)), trueStmts));
	        });
	        actionStmts.push(new ReturnStatement(resultVar));
	        builder.methods.push(new ClassMethod('handleEvent', [
	            new FnParam(EVENT_NAME_VAR.name, STRING_TYPE),
	            new FnParam(EventHandlerVars.event.name, DYNAMIC_TYPE)
	        ], actionStmts, BOOL_TYPE));
	    }
	    /**
	     * @param {?} dirMeta
	     * @param {?} builder
	     * @return {?}
	     */
	    function addSubscribeMethod(dirMeta, builder) {
	        var /** @type {?} */ methodParams = [
	            new FnParam(VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	            new FnParam(EVENT_HANDLER_FIELD_NAME, DYNAMIC_TYPE)
	        ];
	        var /** @type {?} */ stmts = [
	            THIS_EXPR.prop(EVENT_HANDLER_FIELD_NAME).set(variable(EVENT_HANDLER_FIELD_NAME)).toStmt()
	        ];
	        Object.keys(dirMeta.outputs).forEach(function (emitterPropName, emitterIdx) {
	            var /** @type {?} */ eventName = dirMeta.outputs[emitterPropName];
	            var /** @type {?} */ paramName = "emit" + emitterIdx;
	            methodParams.push(new FnParam(paramName, BOOL_TYPE));
	            var /** @type {?} */ subscriptionFieldName = "subscription" + emitterIdx;
	            builder.fields.push(new ClassField(subscriptionFieldName, DYNAMIC_TYPE));
	            stmts.push(new IfStmt(variable(paramName), [
	                THIS_EXPR.prop(subscriptionFieldName)
	                    .set(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
	                    .prop(emitterPropName)
	                    .callMethod(BuiltinMethod.SubscribeObservable, [variable(EVENT_HANDLER_FIELD_NAME)
	                        .callMethod(BuiltinMethod.Bind, [VIEW_VAR, literal(eventName)])]))
	                    .toStmt()
	            ]));
	            builder.destroyStmts.push(THIS_EXPR.prop(subscriptionFieldName)
	                .and(THIS_EXPR.prop(subscriptionFieldName).callMethod('unsubscribe', []))
	                .toStmt());
	        });
	        builder.methods.push(new ClassMethod('subscribe', methodParams, stmts));
	    }
	    var ParseResult = (function () {
	        /**
	         * @param {?} hostProps
	         * @param {?} hostListeners
	         * @param {?} errors
	         */
	        function ParseResult(hostProps, hostListeners, errors) {
	            this.hostProps = hostProps;
	            this.hostListeners = hostListeners;
	            this.errors = errors;
	        }
	        return ParseResult;
	    }());
	    /**
	     * @param {?} dirMeta
	     * @param {?} exprParser
	     * @param {?} schemaRegistry
	     * @return {?}
	     */
	    function parseHostBindings(dirMeta, exprParser, schemaRegistry) {
	        var /** @type {?} */ errors = [];
	        var /** @type {?} */ parser = new BindingParser(exprParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [], errors);
	        var /** @type {?} */ moduleUrl = identifierModuleUrl(dirMeta.type);
	        var /** @type {?} */ sourceFileName = moduleUrl ?
	            "in Directive " + identifierName(dirMeta.type) + " in " + moduleUrl :
	            "in Directive " + identifierName(dirMeta.type);
	        var /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);
	        var /** @type {?} */ sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));
	        var /** @type {?} */ parsedHostProps = parser.createDirectiveHostPropertyAsts(dirMeta.toSummary(), sourceSpan);
	        var /** @type {?} */ parsedHostListeners = parser.createDirectiveHostEventAsts(dirMeta.toSummary(), sourceSpan);
	        return new ParseResult(parsedHostProps, parsedHostListeners, errors);
	    }
	    /**
	     * @param {?} parseErrors
	     * @param {?} console
	     * @return {?}
	     */
	    function reportParseErrors(parseErrors, console) {
	        var /** @type {?} */ warnings = parseErrors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; });
	        var /** @type {?} */ errors = parseErrors.filter(function (error) { return error.level === ParseErrorLevel.FATAL; });
	        if (warnings.length > 0) {
	            this._console.warn("Directive parse warnings:\n" + warnings.join('\n'));
	        }
	        if (errors.length > 0) {
	            throw new Error("Directive parse errors:\n" + errors.join('\n'));
	        }
	    }
	    var DirectiveWrapperExpressions = (function () {
	        function DirectiveWrapperExpressions() {
	        }
	        /**
	         * @param {?} dir
	         * @param {?} depsExpr
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.create = function (dir, depsExpr) {
	            return importExpr(dir).instantiate(depsExpr, importType(dir));
	        };
	        /**
	         * @param {?} dirWrapper
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.context = function (dirWrapper) {
	            return dirWrapper.prop(CONTEXT_FIELD_NAME);
	        };
	        /**
	         * @param {?} dirWrapper
	         * @param {?} view
	         * @param {?} renderElement
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.ngDoCheck = function (dirWrapper, view, renderElement, throwOnChange) {
	            return dirWrapper.callMethod('ngDoCheck', [view, renderElement, throwOnChange]);
	        };
	        /**
	         * @param {?} hostProps
	         * @param {?} dirWrapper
	         * @param {?} view
	         * @param {?} componentView
	         * @param {?} renderElement
	         * @param {?} throwOnChange
	         * @param {?} runtimeSecurityContexts
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.checkHost = function (hostProps, dirWrapper, view, componentView, renderElement, throwOnChange, runtimeSecurityContexts) {
	            if (hostProps.length) {
	                return [dirWrapper
	                        .callMethod('checkHost', [view, componentView, renderElement, throwOnChange].concat(runtimeSecurityContexts))
	                        .toStmt()];
	            }
	            else {
	                return [];
	            }
	        };
	        /**
	         * @param {?} hostProps
	         * @param {?} dirWrapper
	         * @param {?} view
	         * @param {?} componentView
	         * @param {?} renderEl
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.ngOnDetach = function (hostProps, dirWrapper, view, componentView, renderEl) {
	            if (hostProps.some(function (prop) { return prop.isAnimation; })) {
	                return [dirWrapper
	                        .callMethod('ngOnDetach', [
	                        view,
	                        componentView,
	                        renderEl,
	                    ])
	                        .toStmt()];
	            }
	            else {
	                return [];
	            }
	        };
	        /**
	         * @param {?} dir
	         * @param {?} dirWrapper
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.ngOnDestroy = function (dir, dirWrapper) {
	            if (dir.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1 ||
	                Object.keys(dir.outputs).length > 0) {
	                return [dirWrapper.callMethod('ngOnDestroy', []).toStmt()];
	            }
	            else {
	                return [];
	            }
	        };
	        /**
	         * @param {?} dirMeta
	         * @param {?} hostProps
	         * @param {?} usedEvents
	         * @param {?} dirWrapper
	         * @param {?} view
	         * @param {?} eventListener
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.subscribe = function (dirMeta, hostProps, usedEvents, dirWrapper, view, eventListener) {
	            var /** @type {?} */ needsSubscribe = false;
	            var /** @type {?} */ eventFlags = [];
	            Object.keys(dirMeta.outputs).forEach(function (propName) {
	                var /** @type {?} */ eventName = dirMeta.outputs[propName];
	                var /** @type {?} */ eventUsed = usedEvents.indexOf(eventName) > -1;
	                needsSubscribe = needsSubscribe || eventUsed;
	                eventFlags.push(literal(eventUsed));
	            });
	            hostProps.forEach(function (hostProp) {
	                if (hostProp.isAnimation && usedEvents.length > 0) {
	                    needsSubscribe = true;
	                }
	            });
	            if (needsSubscribe) {
	                return [
	                    dirWrapper.callMethod('subscribe', [view, eventListener].concat(eventFlags)).toStmt()
	                ];
	            }
	            else {
	                return [];
	            }
	        };
	        /**
	         * @param {?} hostEvents
	         * @param {?} dirWrapper
	         * @param {?} eventName
	         * @param {?} event
	         * @return {?}
	         */
	        DirectiveWrapperExpressions.handleEvent = function (hostEvents, dirWrapper, eventName, event) {
	            return dirWrapper.callMethod('handleEvent', [eventName, event]);
	        };
	        return DirectiveWrapperExpressions;
	    }());

	    /**
	     * @param {?} hook
	     * @param {?} token
	     * @return {?}
	     */
	    function hasLifecycleHook(hook, token) {
	        return reflector.hasLifecycleHook(token, getHookName(hook));
	    }
	    /**
	     * @param {?} hook
	     * @return {?}
	     */
	    function getHookName(hook) {
	        switch (hook) {
	            case LifecycleHooks.OnInit:
	                return 'ngOnInit';
	            case LifecycleHooks.OnDestroy:
	                return 'ngOnDestroy';
	            case LifecycleHooks.DoCheck:
	                return 'ngDoCheck';
	            case LifecycleHooks.OnChanges:
	                return 'ngOnChanges';
	            case LifecycleHooks.AfterContentInit:
	                return 'ngAfterContentInit';
	            case LifecycleHooks.AfterContentChecked:
	                return 'ngAfterContentChecked';
	            case LifecycleHooks.AfterViewInit:
	                return 'ngAfterViewInit';
	            case LifecycleHooks.AfterViewChecked:
	                return 'ngAfterViewChecked';
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$10 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$10 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function _isNgModuleMetadata(obj) {
	        return obj instanceof _angular_core.NgModule;
	    }
	    /**
	     * Resolves types to {\@link NgModule}.
	     */
	    var NgModuleResolver = (function () {
	        /**
	         * @param {?=} _reflector
	         */
	        function NgModuleResolver(_reflector) {
	            if (_reflector === void 0) { _reflector = reflector; }
	            this._reflector = _reflector;
	        }
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(_isNgModuleMetadata); };
	        /**
	         * @param {?} type
	         * @param {?=} throwIfNotFound
	         * @return {?}
	         */
	        NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {
	            if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	            var /** @type {?} */ ngModuleMeta = ListWrapper.findLast(this._reflector.annotations(type), _isNgModuleMetadata);
	            if (ngModuleMeta) {
	                return ngModuleMeta;
	            }
	            else {
	                if (throwIfNotFound) {
	                    throw new Error("No NgModule metadata found for '" + stringify(type) + "'.");
	                }
	                return null;
	            }
	        };
	        NgModuleResolver = __decorate$10([
	            CompilerInjectable(), 
	            __metadata$10('design:paramtypes', [ReflectorReader])
	        ], NgModuleResolver);
	        return NgModuleResolver;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$11 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$11 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function _isPipeMetadata(type) {
	        return type instanceof _angular_core.Pipe;
	    }
	    /**
	     * Resolve a `Type` for {\@link Pipe}.
	     *
	     * This interface can be overridden by the application developer to create custom behavior.
	     *
	     * See {\@link Compiler}
	     */
	    var PipeResolver = (function () {
	        /**
	         * @param {?=} _reflector
	         */
	        function PipeResolver(_reflector) {
	            if (_reflector === void 0) { _reflector = reflector; }
	            this._reflector = _reflector;
	        }
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        PipeResolver.prototype.isPipe = function (type) {
	            var /** @type {?} */ typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
	            return typeMetadata && typeMetadata.some(_isPipeMetadata);
	        };
	        /**
	         * Return {\@link Pipe} for a given `Type`.
	         * @param {?} type
	         * @param {?=} throwIfNotFound
	         * @return {?}
	         */
	        PipeResolver.prototype.resolve = function (type, throwIfNotFound) {
	            if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	            var /** @type {?} */ metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));
	            if (metas) {
	                var /** @type {?} */ annotation = ListWrapper.findLast(metas, _isPipeMetadata);
	                if (annotation) {
	                    return annotation;
	                }
	            }
	            if (throwIfNotFound) {
	                throw new Error("No Pipe decorator found on " + stringify(type));
	            }
	            return null;
	        };
	        PipeResolver = __decorate$11([
	            CompilerInjectable(), 
	            __metadata$11('design:paramtypes', [ReflectorReader])
	        ], PipeResolver);
	        return PipeResolver;
	    }());

	    var __decorate$12 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$12 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var SummaryResolver = (function () {
	        function SummaryResolver() {
	        }
	        /**
	         * @param {?} reference
	         * @return {?}
	         */
	        SummaryResolver.prototype.resolveSummary = function (reference) { return null; };
	        ;
	        /**
	         * @param {?} filePath
	         * @return {?}
	         */
	        SummaryResolver.prototype.getSymbolsOf = function (filePath) { return []; };
	        SummaryResolver = __decorate$12([
	            CompilerInjectable(), 
	            __metadata$12('design:paramtypes', [])
	        ], SummaryResolver);
	        return SummaryResolver;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$21 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$9 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var /** @type {?} */ ERROR_COLLECTOR_TOKEN = new _angular_core.OpaqueToken('ErrorCollector');
	    var CompileMetadataResolver = (function () {
	        /**
	         * @param {?} _ngModuleResolver
	         * @param {?} _directiveResolver
	         * @param {?} _pipeResolver
	         * @param {?} _summaryResolver
	         * @param {?} _schemaRegistry
	         * @param {?} _directiveNormalizer
	         * @param {?=} _reflector
	         * @param {?=} _errorCollector
	         */
	        function CompileMetadataResolver(_ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _reflector, _errorCollector) {
	            if (_reflector === void 0) { _reflector = reflector; }
	            this._ngModuleResolver = _ngModuleResolver;
	            this._directiveResolver = _directiveResolver;
	            this._pipeResolver = _pipeResolver;
	            this._summaryResolver = _summaryResolver;
	            this._schemaRegistry = _schemaRegistry;
	            this._directiveNormalizer = _directiveNormalizer;
	            this._reflector = _reflector;
	            this._errorCollector = _errorCollector;
	            this._directiveCache = new Map();
	            this._summaryCache = new Map();
	            this._pipeCache = new Map();
	            this._ngModuleCache = new Map();
	            this._ngModuleOfTypes = new Map();
	        }
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.clearCacheFor = function (type) {
	            var /** @type {?} */ dirMeta = this._directiveCache.get(type);
	            this._directiveCache.delete(type);
	            this._summaryCache.delete(type);
	            this._pipeCache.delete(type);
	            this._ngModuleOfTypes.delete(type);
	            // Clear all of the NgModule as they contain transitive information!
	            this._ngModuleCache.clear();
	            if (dirMeta) {
	                this._directiveNormalizer.clearCacheFor(dirMeta);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.clearCache = function () {
	            this._directiveCache.clear();
	            this._summaryCache.clear();
	            this._pipeCache.clear();
	            this._ngModuleCache.clear();
	            this._ngModuleOfTypes.clear();
	            this._directiveNormalizer.clearCache();
	        };
	        /**
	         * @param {?} entry
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getAnimationEntryMetadata = function (entry) {
	            var _this = this;
	            var /** @type {?} */ defs = entry.definitions.map(function (def) { return _this._getAnimationStateMetadata(def); });
	            return new CompileAnimationEntryMetadata(entry.name, defs);
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getAnimationStateMetadata = function (value) {
	            if (value instanceof _angular_core.AnimationStateDeclarationMetadata) {
	                var /** @type {?} */ styles = this._getAnimationStyleMetadata(value.styles);
	                return new CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);
	            }
	            if (value instanceof _angular_core.AnimationStateTransitionMetadata) {
	                return new CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this._getAnimationMetadata(value.steps));
	            }
	            return null;
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getAnimationStyleMetadata = function (value) {
	            return new CompileAnimationStyleMetadata(value.offset, value.styles);
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getAnimationMetadata = function (value) {
	            var _this = this;
	            if (value instanceof _angular_core.AnimationStyleMetadata) {
	                return this._getAnimationStyleMetadata(value);
	            }
	            if (value instanceof _angular_core.AnimationKeyframesSequenceMetadata) {
	                return new CompileAnimationKeyframesSequenceMetadata(value.steps.map(function (entry) { return _this._getAnimationStyleMetadata(entry); }));
	            }
	            if (value instanceof _angular_core.AnimationAnimateMetadata) {
	                var /** @type {?} */ animateData = (this
	                    ._getAnimationMetadata(value.styles));
	                return new CompileAnimationAnimateMetadata(value.timings, animateData);
	            }
	            if (value instanceof _angular_core.AnimationWithStepsMetadata) {
	                var /** @type {?} */ steps = value.steps.map(function (step) { return _this._getAnimationMetadata(step); });
	                if (value instanceof _angular_core.AnimationGroupMetadata) {
	                    return new CompileAnimationGroupMetadata(steps);
	                }
	                return new CompileAnimationSequenceMetadata(steps);
	            }
	            return null;
	        };
	        /**
	         * @param {?} type
	         * @param {?} kind
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._loadSummary = function (type, kind) {
	            var /** @type {?} */ typeSummary = this._summaryCache.get(type);
	            if (!typeSummary) {
	                var /** @type {?} */ summary = this._summaryResolver.resolveSummary(type);
	                typeSummary = summary ? summary.type : null;
	                this._summaryCache.set(type, typeSummary);
	            }
	            return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;
	        };
	        /**
	         * @param {?} directiveType
	         * @param {?} isSync
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._loadDirectiveMetadata = function (directiveType, isSync) {
	            var _this = this;
	            if (this._directiveCache.has(directiveType)) {
	                return;
	            }
	            directiveType = _angular_core.resolveForwardRef(directiveType);
	            var _a = this.getNonNormalizedDirectiveMetadata(directiveType), annotation = _a.annotation, metadata = _a.metadata;
	            var /** @type {?} */ createDirectiveMetadata = function (templateMetadata) {
	                var /** @type {?} */ normalizedDirMeta = new CompileDirectiveMetadata({
	                    type: metadata.type,
	                    isComponent: metadata.isComponent,
	                    selector: metadata.selector,
	                    exportAs: metadata.exportAs,
	                    changeDetection: metadata.changeDetection,
	                    inputs: metadata.inputs,
	                    outputs: metadata.outputs,
	                    hostListeners: metadata.hostListeners,
	                    hostProperties: metadata.hostProperties,
	                    hostAttributes: metadata.hostAttributes,
	                    providers: metadata.providers,
	                    viewProviders: metadata.viewProviders,
	                    queries: metadata.queries,
	                    viewQueries: metadata.viewQueries,
	                    entryComponents: metadata.entryComponents,
	                    template: templateMetadata
	                });
	                _this._directiveCache.set(directiveType, normalizedDirMeta);
	                _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());
	                return normalizedDirMeta;
	            };
	            if (metadata.isComponent) {
	                var /** @type {?} */ templateMeta = this._directiveNormalizer.normalizeTemplate({
	                    componentType: directiveType,
	                    moduleUrl: componentModuleUrl(this._reflector, directiveType, annotation),
	                    encapsulation: metadata.template.encapsulation,
	                    template: metadata.template.template,
	                    templateUrl: metadata.template.templateUrl,
	                    styles: metadata.template.styles,
	                    styleUrls: metadata.template.styleUrls,
	                    animations: metadata.template.animations,
	                    interpolation: metadata.template.interpolation
	                });
	                if (templateMeta.syncResult) {
	                    createDirectiveMetadata(templateMeta.syncResult);
	                    return null;
	                }
	                else {
	                    if (isSync) {
	                        this._reportError(new ComponentStillLoadingError(directiveType), directiveType);
	                        return null;
	                    }
	                    return templateMeta.asyncResult.then(createDirectiveMetadata);
	                }
	            }
	            else {
	                // directive
	                createDirectiveMetadata(null);
	                return null;
	            }
	        };
	        /**
	         * @param {?} directiveType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {
	            var _this = this;
	            directiveType = _angular_core.resolveForwardRef(directiveType);
	            var /** @type {?} */ dirMeta = this._directiveResolver.resolve(directiveType);
	            if (!dirMeta) {
	                return null;
	            }
	            var /** @type {?} */ nonNormalizedTemplateMetadata;
	            if (dirMeta instanceof _angular_core.Component) {
	                // component
	                assertArrayOfStrings('styles', dirMeta.styles);
	                assertArrayOfStrings('styleUrls', dirMeta.styleUrls);
	                assertInterpolationSymbols('interpolation', dirMeta.interpolation);
	                var /** @type {?} */ animations = dirMeta.animations ?
	                    dirMeta.animations.map(function (e) { return _this.getAnimationEntryMetadata(e); }) :
	                    null;
	                nonNormalizedTemplateMetadata = new CompileTemplateMetadata({
	                    encapsulation: dirMeta.encapsulation,
	                    template: dirMeta.template,
	                    templateUrl: dirMeta.templateUrl,
	                    styles: dirMeta.styles,
	                    styleUrls: dirMeta.styleUrls,
	                    animations: animations,
	                    interpolation: dirMeta.interpolation
	                });
	            }
	            var /** @type {?} */ changeDetectionStrategy = null;
	            var /** @type {?} */ viewProviders = [];
	            var /** @type {?} */ entryComponentMetadata = [];
	            var /** @type {?} */ selector = dirMeta.selector;
	            if (dirMeta instanceof _angular_core.Component) {
	                // Component
	                changeDetectionStrategy = dirMeta.changeDetection;
	                if (dirMeta.viewProviders) {
	                    viewProviders = this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, "viewProviders for \"" + stringifyType(directiveType) + "\"", [], directiveType);
	                }
	                if (dirMeta.entryComponents) {
	                    entryComponentMetadata = flattenAndDedupeArray(dirMeta.entryComponents)
	                        .map(function (type) { return _this._getIdentifierMetadata(type); })
	                        .concat(entryComponentMetadata);
	                }
	                if (!selector) {
	                    selector = this._schemaRegistry.getDefaultComponentElementName();
	                }
	            }
	            else {
	                // Directive
	                if (!selector) {
	                    this._reportError(new SyntaxError("Directive " + stringifyType(directiveType) + " has no selector, please add it!"), directiveType);
	                    selector = 'error';
	                }
	            }
	            var /** @type {?} */ providers = [];
	            if (isPresent(dirMeta.providers)) {
	                providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, "providers for \"" + stringifyType(directiveType) + "\"", [], directiveType);
	            }
	            var /** @type {?} */ queries = [];
	            var /** @type {?} */ viewQueries = [];
	            if (isPresent(dirMeta.queries)) {
	                queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);
	                viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);
	            }
	            var /** @type {?} */ metadata = CompileDirectiveMetadata.create({
	                selector: selector,
	                exportAs: dirMeta.exportAs,
	                isComponent: !!nonNormalizedTemplateMetadata,
	                type: this._getTypeMetadata(directiveType),
	                template: nonNormalizedTemplateMetadata,
	                changeDetection: changeDetectionStrategy,
	                inputs: dirMeta.inputs,
	                outputs: dirMeta.outputs,
	                host: dirMeta.host,
	                providers: providers,
	                viewProviders: viewProviders,
	                queries: queries,
	                viewQueries: viewQueries,
	                entryComponents: entryComponentMetadata
	            });
	            return { metadata: metadata, annotation: dirMeta };
	        };
	        /**
	         * Gets the metadata for the given directive.
	         * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
	         * @param {?} directiveType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {
	            var /** @type {?} */ dirMeta = this._directiveCache.get(directiveType);
	            if (!dirMeta) {
	                this._reportError(new SyntaxError("Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive " + stringifyType(directiveType) + "."), directiveType);
	            }
	            return dirMeta;
	        };
	        /**
	         * @param {?} dirType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {
	            var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));
	            if (!dirSummary) {
	                this._reportError(new SyntaxError("Illegal state: Could not load the summary for directive " + stringifyType(dirType) + "."), dirType);
	            }
	            return dirSummary;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.isDirective = function (type) { return this._directiveResolver.isDirective(type); };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.isPipe = function (type) { return this._pipeResolver.isPipe(type); };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType) {
	            var /** @type {?} */ moduleSummary = (this._loadSummary(moduleType, CompileSummaryKind.NgModule));
	            if (!moduleSummary) {
	                var /** @type {?} */ moduleMeta = this.getNgModuleMetadata(moduleType, false);
	                moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;
	                if (moduleSummary) {
	                    this._summaryCache.set(moduleType, moduleSummary);
	                }
	            }
	            return moduleSummary;
	        };
	        /**
	         * Loads the declared directives and pipes of an NgModule.
	         * @param {?} moduleType
	         * @param {?} isSync
	         * @param {?=} throwIfNotFound
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {
	            var _this = this;
	            if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	            var /** @type {?} */ ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);
	            var /** @type {?} */ loading = [];
	            if (ngModule) {
	                ngModule.declaredDirectives.forEach(function (id) {
	                    var /** @type {?} */ promise = _this._loadDirectiveMetadata(id.reference, isSync);
	                    if (promise) {
	                        loading.push(promise);
	                    }
	                });
	                ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });
	            }
	            return Promise.all(loading);
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?=} throwIfNotFound
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {
	            var _this = this;
	            if (throwIfNotFound === void 0) { throwIfNotFound = true; }
	            moduleType = _angular_core.resolveForwardRef(moduleType);
	            var /** @type {?} */ compileMeta = this._ngModuleCache.get(moduleType);
	            if (compileMeta) {
	                return compileMeta;
	            }
	            var /** @type {?} */ meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
	            if (!meta) {
	                return null;
	            }
	            var /** @type {?} */ declaredDirectives = [];
	            var /** @type {?} */ exportedNonModuleIdentifiers = [];
	            var /** @type {?} */ declaredPipes = [];
	            var /** @type {?} */ importedModules = [];
	            var /** @type {?} */ exportedModules = [];
	            var /** @type {?} */ providers = [];
	            var /** @type {?} */ entryComponents = [];
	            var /** @type {?} */ bootstrapComponents = [];
	            var /** @type {?} */ schemas = [];
	            if (meta.imports) {
	                flattenAndDedupeArray(meta.imports).forEach(function (importedType) {
	                    var /** @type {?} */ importedModuleType;
	                    if (isValidType(importedType)) {
	                        importedModuleType = importedType;
	                    }
	                    else if (importedType && importedType.ngModule) {
	                        var /** @type {?} */ moduleWithProviders = importedType;
	                        importedModuleType = moduleWithProviders.ngModule;
	                        if (moduleWithProviders.providers) {
	                            providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, "provider for the NgModule '" + stringifyType(importedModuleType) + "'", [], importedType));
	                        }
	                    }
	                    if (importedModuleType) {
	                        var /** @type {?} */ importedModuleSummary = _this.getNgModuleSummary(importedModuleType);
	                        if (!importedModuleSummary) {
	                            _this._reportError(new SyntaxError("Unexpected " + _this._getTypeDescriptor(importedType) + " '" + stringifyType(importedType) + "' imported by the module '" + stringifyType(moduleType) + "'"), moduleType);
	                            return;
	                        }
	                        importedModules.push(importedModuleSummary);
	                    }
	                    else {
	                        _this._reportError(new SyntaxError("Unexpected value '" + stringifyType(importedType) + "' imported by the module '" + stringifyType(moduleType) + "'"), moduleType);
	                        return;
	                    }
	                });
	            }
	            if (meta.exports) {
	                flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {
	                    if (!isValidType(exportedType)) {
	                        _this._reportError(new SyntaxError("Unexpected value '" + stringifyType(exportedType) + "' exported by the module '" + stringifyType(moduleType) + "'"), moduleType);
	                        return;
	                    }
	                    var /** @type {?} */ exportedModuleSummary = _this.getNgModuleSummary(exportedType);
	                    if (exportedModuleSummary) {
	                        exportedModules.push(exportedModuleSummary);
	                    }
	                    else {
	                        exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));
	                    }
	                });
	            }
	            // Note: This will be modified later, so we rely on
	            // getting a new instance every time!
	            var /** @type {?} */ transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);
	            if (meta.declarations) {
	                flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {
	                    if (!isValidType(declaredType)) {
	                        _this._reportError(new SyntaxError("Unexpected value '" + stringifyType(declaredType) + "' declared by the module '" + stringifyType(moduleType) + "'"), moduleType);
	                        return;
	                    }
	                    var /** @type {?} */ declaredIdentifier = _this._getIdentifierMetadata(declaredType);
	                    if (_this._directiveResolver.isDirective(declaredType)) {
	                        transitiveModule.addDirective(declaredIdentifier);
	                        declaredDirectives.push(declaredIdentifier);
	                        _this._addTypeToModule(declaredType, moduleType);
	                    }
	                    else if (_this._pipeResolver.isPipe(declaredType)) {
	                        transitiveModule.addPipe(declaredIdentifier);
	                        transitiveModule.pipes.push(declaredIdentifier);
	                        declaredPipes.push(declaredIdentifier);
	                        _this._addTypeToModule(declaredType, moduleType);
	                    }
	                    else {
	                        _this._reportError(new SyntaxError("Unexpected " + _this._getTypeDescriptor(declaredType) + " '" + stringifyType(declaredType) + "' declared by the module '" + stringifyType(moduleType) + "'"), moduleType);
	                        return;
	                    }
	                });
	            }
	            var /** @type {?} */ exportedDirectives = [];
	            var /** @type {?} */ exportedPipes = [];
	            exportedNonModuleIdentifiers.forEach(function (exportedId) {
	                if (transitiveModule.directivesSet.has(exportedId.reference)) {
	                    exportedDirectives.push(exportedId);
	                    transitiveModule.addExportedDirective(exportedId);
	                }
	                else if (transitiveModule.pipesSet.has(exportedId.reference)) {
	                    exportedPipes.push(exportedId);
	                    transitiveModule.addExportedPipe(exportedId);
	                }
	                else {
	                    _this._reportError(new SyntaxError("Can't export " + _this._getTypeDescriptor(exportedId.reference) + " " + stringifyType(exportedId.reference) + " from " + stringifyType(moduleType) + " as it was neither declared nor imported!"), moduleType);
	                }
	            });
	            // The providers of the module have to go last
	            // so that they overwrite any other provider we already added.
	            if (meta.providers) {
	                providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, "provider for the NgModule '" + stringifyType(moduleType) + "'", [], moduleType));
	            }
	            if (meta.entryComponents) {
	                entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents)
	                    .map(function (type) { return _this._getIdentifierMetadata(type); }));
	            }
	            if (meta.bootstrap) {
	                flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {
	                    if (!isValidType(type)) {
	                        _this._reportError(new SyntaxError("Unexpected value '" + stringifyType(type) + "' used in the bootstrap property of module '" + stringifyType(moduleType) + "'"), moduleType);
	                        return;
	                    }
	                    bootstrapComponents.push(_this._getIdentifierMetadata(type));
	                });
	            }
	            entryComponents.push.apply(entryComponents, bootstrapComponents);
	            if (meta.schemas) {
	                schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));
	            }
	            compileMeta = new CompileNgModuleMetadata({
	                type: this._getTypeMetadata(moduleType),
	                providers: providers,
	                entryComponents: entryComponents,
	                bootstrapComponents: bootstrapComponents,
	                schemas: schemas,
	                declaredDirectives: declaredDirectives,
	                exportedDirectives: exportedDirectives,
	                declaredPipes: declaredPipes,
	                exportedPipes: exportedPipes,
	                importedModules: importedModules,
	                exportedModules: exportedModules,
	                transitiveModule: transitiveModule,
	                id: meta.id,
	            });
	            entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });
	            providers.forEach(function (provider) { return transitiveModule.addProvider(provider, compileMeta.type); });
	            transitiveModule.addModule(compileMeta.type);
	            this._ngModuleCache.set(moduleType, compileMeta);
	            return compileMeta;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {
	            if (this._directiveResolver.isDirective(type)) {
	                return 'directive';
	            }
	            if (this._pipeResolver.isPipe(type)) {
	                return 'pipe';
	            }
	            if (this._ngModuleResolver.isNgModule(type)) {
	                return 'module';
	            }
	            if (((type)).provide) {
	                return 'provider';
	            }
	            return 'value';
	        };
	        /**
	         * @param {?} type
	         * @param {?} moduleType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {
	            var /** @type {?} */ oldModule = this._ngModuleOfTypes.get(type);
	            if (oldModule && oldModule !== moduleType) {
	                this._reportError(new SyntaxError(("Type " + stringifyType(type) + " is part of the declarations of 2 modules: " + stringifyType(oldModule) + " and " + stringifyType(moduleType) + "! ") +
	                    ("Please consider moving " + stringifyType(type) + " to a higher module that imports " + stringifyType(oldModule) + " and " + stringifyType(moduleType) + ". ") +
	                    ("You can also create a new NgModule that exports and includes " + stringifyType(type) + " then import that NgModule in " + stringifyType(oldModule) + " and " + stringifyType(moduleType) + ".")), moduleType);
	            }
	            this._ngModuleOfTypes.set(type, moduleType);
	        };
	        /**
	         * @param {?} importedModules
	         * @param {?} exportedModules
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {
	            // collect `providers` / `entryComponents` from all imported and all exported modules
	            var /** @type {?} */ result = new TransitiveCompileNgModuleMetadata();
	            var /** @type {?} */ modulesByToken = new Map();
	            importedModules.concat(exportedModules).forEach(function (modSummary) {
	                modSummary.modules.forEach(function (mod) { return result.addModule(mod); });
	                modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });
	                var /** @type {?} */ addedTokens = new Set();
	                modSummary.providers.forEach(function (entry) {
	                    var /** @type {?} */ tokenRef = tokenReference(entry.provider.token);
	                    var /** @type {?} */ prevModules = modulesByToken.get(tokenRef);
	                    if (!prevModules) {
	                        prevModules = new Set();
	                        modulesByToken.set(tokenRef, prevModules);
	                    }
	                    var /** @type {?} */ moduleRef = entry.module.reference;
	                    // Note: the providers of one module may still contain multiple providers
	                    // per token (e.g. for multi providers), and we need to preserve these.
	                    if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {
	                        prevModules.add(moduleRef);
	                        addedTokens.add(tokenRef);
	                        result.addProvider(entry.provider, entry.module);
	                    }
	                });
	            });
	            exportedModules.forEach(function (modSummary) {
	                modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });
	                modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });
	            });
	            importedModules.forEach(function (modSummary) {
	                modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });
	                modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });
	            });
	            return result;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {
	            type = _angular_core.resolveForwardRef(type);
	            return { reference: type };
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.isInjectable = function (type) {
	            var /** @type {?} */ annotations = this._reflector.annotations(type);
	            // Note: We need an exact check here as @Component / @Directive / ... inherit
	            // from @CompilerInjectable!
	            return annotations.some(function (ann) { return ann.constructor === _angular_core.Injectable; });
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getInjectableSummary = function (type) {
	            return { summaryKind: CompileSummaryKind.Injectable, type: this._getTypeMetadata(type) };
	        };
	        /**
	         * @param {?} type
	         * @param {?=} dependencies
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getInjectableMetadata = function (type, dependencies) {
	            if (dependencies === void 0) { dependencies = null; }
	            var /** @type {?} */ typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);
	            if (typeSummary) {
	                return typeSummary.type;
	            }
	            return this._getTypeMetadata(type, dependencies);
	        };
	        /**
	         * @param {?} type
	         * @param {?=} dependencies
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies) {
	            if (dependencies === void 0) { dependencies = null; }
	            var /** @type {?} */ identifier = this._getIdentifierMetadata(type);
	            return {
	                reference: identifier.reference,
	                diDeps: this._getDependenciesMetadata(identifier.reference, dependencies),
	                lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(hook, identifier.reference); }),
	            };
	        };
	        /**
	         * @param {?} factory
	         * @param {?=} dependencies
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {
	            if (dependencies === void 0) { dependencies = null; }
	            factory = _angular_core.resolveForwardRef(factory);
	            return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };
	        };
	        /**
	         * Gets the metadata for the given pipe.
	         * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
	         * @param {?} pipeType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {
	            var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);
	            if (!pipeMeta) {
	                this._reportError(new SyntaxError("Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe " + stringifyType(pipeType) + "."), pipeType);
	            }
	            return pipeMeta;
	        };
	        /**
	         * @param {?} pipeType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {
	            var /** @type {?} */ pipeSummary = (this._loadSummary(pipeType, CompileSummaryKind.Pipe));
	            if (!pipeSummary) {
	                this._reportError(new SyntaxError("Illegal state: Could not load the summary for pipe " + stringifyType(pipeType) + "."), pipeType);
	            }
	            return pipeSummary;
	        };
	        /**
	         * @param {?} pipeType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {
	            var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);
	            if (!pipeMeta) {
	                pipeMeta = this._loadPipeMetadata(pipeType);
	            }
	            return pipeMeta;
	        };
	        /**
	         * @param {?} pipeType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {
	            pipeType = _angular_core.resolveForwardRef(pipeType);
	            var /** @type {?} */ pipeAnnotation = this._pipeResolver.resolve(pipeType);
	            var /** @type {?} */ pipeMeta = new CompilePipeMetadata({
	                type: this._getTypeMetadata(pipeType),
	                name: pipeAnnotation.name,
	                pure: pipeAnnotation.pure
	            });
	            this._pipeCache.set(pipeType, pipeMeta);
	            this._summaryCache.set(pipeType, pipeMeta.toSummary());
	            return pipeMeta;
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} dependencies
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies) {
	            var _this = this;
	            var /** @type {?} */ hasUnknownDeps = false;
	            var /** @type {?} */ params = dependencies || this._reflector.parameters(typeOrFunc) || [];
	            var /** @type {?} */ dependenciesMetadata = params.map(function (param) {
	                var /** @type {?} */ isAttribute = false;
	                var /** @type {?} */ isHost = false;
	                var /** @type {?} */ isSelf = false;
	                var /** @type {?} */ isSkipSelf = false;
	                var /** @type {?} */ isOptional = false;
	                var /** @type {?} */ token = null;
	                if (Array.isArray(param)) {
	                    param.forEach(function (paramEntry) {
	                        if (paramEntry instanceof _angular_core.Host) {
	                            isHost = true;
	                        }
	                        else if (paramEntry instanceof _angular_core.Self) {
	                            isSelf = true;
	                        }
	                        else if (paramEntry instanceof _angular_core.SkipSelf) {
	                            isSkipSelf = true;
	                        }
	                        else if (paramEntry instanceof _angular_core.Optional) {
	                            isOptional = true;
	                        }
	                        else if (paramEntry instanceof _angular_core.Attribute) {
	                            isAttribute = true;
	                            token = paramEntry.attributeName;
	                        }
	                        else if (paramEntry instanceof _angular_core.Inject) {
	                            token = paramEntry.token;
	                        }
	                        else if (isValidType(paramEntry) && isBlank(token)) {
	                            token = paramEntry;
	                        }
	                    });
	                }
	                else {
	                    token = param;
	                }
	                if (isBlank(token)) {
	                    hasUnknownDeps = true;
	                    return null;
	                }
	                return {
	                    isAttribute: isAttribute,
	                    isHost: isHost,
	                    isSelf: isSelf,
	                    isSkipSelf: isSkipSelf,
	                    isOptional: isOptional,
	                    token: _this._getTokenMetadata(token)
	                };
	            });
	            if (hasUnknownDeps) {
	                var /** @type {?} */ depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringifyType(dep.token) : '?'; }).join(', ');
	                this._reportError(new SyntaxError("Can't resolve all parameters for " + stringifyType(typeOrFunc) + ": (" + depsTokens + ")."), typeOrFunc);
	            }
	            return dependenciesMetadata;
	        };
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getTokenMetadata = function (token) {
	            token = _angular_core.resolveForwardRef(token);
	            var /** @type {?} */ compileToken;
	            if (typeof token === 'string') {
	                compileToken = { value: token };
	            }
	            else {
	                compileToken = { identifier: { reference: token } };
	            }
	            return compileToken;
	        };
	        /**
	         * @param {?} providers
	         * @param {?} targetEntryComponents
	         * @param {?=} debugInfo
	         * @param {?=} compileProviders
	         * @param {?=} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {
	            var _this = this;
	            if (compileProviders === void 0) { compileProviders = []; }
	            providers.forEach(function (provider, providerIdx) {
	                if (Array.isArray(provider)) {
	                    _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);
	                }
	                else {
	                    provider = _angular_core.resolveForwardRef(provider);
	                    var /** @type {?} */ providerMeta = void 0;
	                    if (provider && typeof provider == 'object' && provider.hasOwnProperty('provide')) {
	                        providerMeta = new ProviderMeta(provider.provide, provider);
	                    }
	                    else if (isValidType(provider)) {
	                        providerMeta = new ProviderMeta(provider, { useClass: provider });
	                    }
	                    else {
	                        var /** @type {?} */ providersInfo = ((providers.reduce(function (soFar, seenProvider, seenProviderIdx) {
	                            if (seenProviderIdx < providerIdx) {
	                                soFar.push("" + stringifyType(seenProvider));
	                            }
	                            else if (seenProviderIdx == providerIdx) {
	                                soFar.push("?" + stringifyType(seenProvider) + "?");
	                            }
	                            else if (seenProviderIdx == providerIdx + 1) {
	                                soFar.push('...');
	                            }
	                            return soFar;
	                        }, [])))
	                            .join(', ');
	                        _this._reportError(new SyntaxError("Invalid " + (debugInfo ? debugInfo : 'provider') + " - only instances of Provider and Type are allowed, got: [" + providersInfo + "]"), type);
	                    }
	                    if (providerMeta.token === resolveIdentifier(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {
	                        targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(providerMeta, type));
	                    }
	                    else {
	                        compileProviders.push(_this.getProviderMetadata(providerMeta));
	                    }
	                }
	            });
	            return compileProviders;
	        };
	        /**
	         * @param {?} provider
	         * @param {?=} type
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {
	            var _this = this;
	            var /** @type {?} */ components = [];
	            var /** @type {?} */ collectedIdentifiers = [];
	            if (provider.useFactory || provider.useExisting || provider.useClass) {
	                this._reportError(new SyntaxError("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!"), type);
	                return [];
	            }
	            if (!provider.multi) {
	                this._reportError(new SyntaxError("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!"), type);
	                return [];
	            }
	            extractIdentifiers(provider.useValue, collectedIdentifiers);
	            collectedIdentifiers.forEach(function (identifier) {
	                if (_this._directiveResolver.isDirective(identifier.reference) ||
	                    _this._loadSummary(identifier.reference, CompileSummaryKind.Directive)) {
	                    components.push(identifier);
	                }
	            });
	            return components;
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {
	            var /** @type {?} */ compileDeps;
	            var /** @type {?} */ compileTypeMetadata = null;
	            var /** @type {?} */ compileFactoryMetadata = null;
	            var /** @type {?} */ token = this._getTokenMetadata(provider.token);
	            if (provider.useClass) {
	                compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);
	                compileDeps = compileTypeMetadata.diDeps;
	                if (provider.token === provider.useClass) {
	                    // use the compileTypeMetadata as it contains information about lifecycleHooks...
	                    token = { identifier: compileTypeMetadata };
	                }
	            }
	            else if (provider.useFactory) {
	                compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);
	                compileDeps = compileFactoryMetadata.diDeps;
	            }
	            return {
	                token: token,
	                useClass: compileTypeMetadata,
	                useValue: provider.useValue,
	                useFactory: compileFactoryMetadata,
	                useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : null,
	                deps: compileDeps,
	                multi: provider.multi
	            };
	        };
	        /**
	         * @param {?} queries
	         * @param {?} isViewQuery
	         * @param {?} directiveType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {
	            var _this = this;
	            var /** @type {?} */ res = [];
	            Object.keys(queries).forEach(function (propertyName) {
	                var /** @type {?} */ query = queries[propertyName];
	                if (query.isViewQuery === isViewQuery) {
	                    res.push(_this._getQueryMetadata(query, propertyName, directiveType));
	                }
	            });
	            return res;
	        };
	        /**
	         * @param {?} selector
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\s*,\s*/); };
	        /**
	         * @param {?} q
	         * @param {?} propertyName
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {
	            var _this = this;
	            var /** @type {?} */ selectors;
	            if (typeof q.selector === 'string') {
	                selectors =
	                    this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });
	            }
	            else {
	                if (!q.selector) {
	                    this._reportError(new SyntaxError("Can't construct a query for the property \"" + propertyName + "\" of \"" + stringifyType(typeOrFunc) + "\" since the query selector wasn't defined."), typeOrFunc);
	                }
	                selectors = [this._getTokenMetadata(q.selector)];
	            }
	            return {
	                selectors: selectors,
	                first: q.first,
	                descendants: q.descendants, propertyName: propertyName,
	                read: q.read ? this._getTokenMetadata(q.read) : null
	            };
	        };
	        /**
	         * @param {?} error
	         * @param {?=} type
	         * @param {?=} otherType
	         * @return {?}
	         */
	        CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {
	            if (this._errorCollector) {
	                this._errorCollector(error, type);
	                if (otherType) {
	                    this._errorCollector(error, otherType);
	                }
	            }
	            else {
	                throw error;
	            }
	        };
	        /** @nocollapse */
	        CompileMetadataResolver.ctorParameters = function () { return [
	            { type: NgModuleResolver, },
	            { type: DirectiveResolver, },
	            { type: PipeResolver, },
	            { type: SummaryResolver, },
	            { type: ElementSchemaRegistry, },
	            { type: DirectiveNormalizer, },
	            { type: ReflectorReader, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ERROR_COLLECTOR_TOKEN,] },] },
	        ]; };
	        CompileMetadataResolver = __decorate$9([
	            CompilerInjectable(), 
	            __metadata$9('design:paramtypes', [NgModuleResolver, DirectiveResolver, PipeResolver, SummaryResolver, ElementSchemaRegistry, DirectiveNormalizer, ReflectorReader, Function])
	        ], CompileMetadataResolver);
	        return CompileMetadataResolver;
	    }());
	    /**
	     * @param {?} tree
	     * @param {?=} out
	     * @return {?}
	     */
	    function flattenArray(tree, out) {
	        if (out === void 0) { out = []; }
	        if (tree) {
	            for (var /** @type {?} */ i = 0; i < tree.length; i++) {
	                var /** @type {?} */ item = _angular_core.resolveForwardRef(tree[i]);
	                if (Array.isArray(item)) {
	                    flattenArray(item, out);
	                }
	                else {
	                    out.push(item);
	                }
	            }
	        }
	        return out;
	    }
	    /**
	     * @param {?} array
	     * @return {?}
	     */
	    function dedupeArray(array) {
	        if (array) {
	            return Array.from(new Set(array));
	        }
	        return [];
	    }
	    /**
	     * @param {?} tree
	     * @return {?}
	     */
	    function flattenAndDedupeArray(tree) {
	        return dedupeArray(flattenArray(tree));
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function isValidType(value) {
	        return (value instanceof StaticSymbol) || (value instanceof _angular_core.Type);
	    }
	    /**
	     * @param {?} reflector
	     * @param {?} type
	     * @param {?} cmpMetadata
	     * @return {?}
	     */
	    function componentModuleUrl(reflector, type, cmpMetadata) {
	        if (type instanceof StaticSymbol) {
	            return type.filePath;
	        }
	        var /** @type {?} */ moduleId = cmpMetadata.moduleId;
	        if (typeof moduleId === 'string') {
	            var /** @type {?} */ scheme = getUrlScheme(moduleId);
	            return scheme ? moduleId : "package:" + moduleId + MODULE_SUFFIX;
	        }
	        else if (moduleId !== null && moduleId !== void 0) {
	            throw new SyntaxError(("moduleId should be a string in \"" + stringifyType(type) + "\". See https://goo.gl/wIDDiL for more information.\n") +
	                "If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.");
	        }
	        return reflector.importUri(type);
	    }
	    /**
	     * @param {?} value
	     * @param {?} targetIdentifiers
	     * @return {?}
	     */
	    function extractIdentifiers(value, targetIdentifiers) {
	        visitValue(value, new _CompileValueConverter(), targetIdentifiers);
	    }
	    var _CompileValueConverter = (function (_super) {
	        __extends$21(_CompileValueConverter, _super);
	        function _CompileValueConverter() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} value
	         * @param {?} targetIdentifiers
	         * @return {?}
	         */
	        _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {
	            targetIdentifiers.push({ reference: value });
	        };
	        return _CompileValueConverter;
	    }(ValueTransformer));
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function stringifyType(type) {
	        if (type instanceof StaticSymbol) {
	            return type.name + " in " + type.filePath;
	        }
	        else {
	            return stringify(type);
	        }
	    }

	    var /** @type {?} */ QUOTED_KEYS = '$quoted$';
	    /**
	     * @param {?} value
	     * @param {?=} type
	     * @return {?}
	     */
	    function convertValueToOutputAst(value, type) {
	        if (type === void 0) { type = null; }
	        return visitValue(value, new _ValueOutputAstTransformer(), type);
	    }
	    var _ValueOutputAstTransformer = (function () {
	        function _ValueOutputAstTransformer() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} type
	         * @return {?}
	         */
	        _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {
	            var _this = this;
	            return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);
	        };
	        /**
	         * @param {?} map
	         * @param {?} type
	         * @return {?}
	         */
	        _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {
	            var _this = this;
	            var /** @type {?} */ entries = [];
	            var /** @type {?} */ quotedSet = new Set(map && map[QUOTED_KEYS]);
	            Object.keys(map).forEach(function (key) {
	                entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));
	            });
	            return new LiteralMapExpr(entries, type);
	        };
	        /**
	         * @param {?} value
	         * @param {?} type
	         * @return {?}
	         */
	        _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };
	        /**
	         * @param {?} value
	         * @param {?} type
	         * @return {?}
	         */
	        _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {
	            if (value instanceof Expression) {
	                return value;
	            }
	            else {
	                return importExpr({ reference: value });
	            }
	        };
	        return _ValueOutputAstTransformer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$13 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$13 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var ComponentFactoryDependency = (function () {
	        /**
	         * @param {?} comp
	         * @param {?} placeholder
	         */
	        function ComponentFactoryDependency(comp, placeholder) {
	            this.comp = comp;
	            this.placeholder = placeholder;
	        }
	        return ComponentFactoryDependency;
	    }());
	    var NgModuleCompileResult = (function () {
	        /**
	         * @param {?} statements
	         * @param {?} ngModuleFactoryVar
	         * @param {?} dependencies
	         */
	        function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {
	            this.statements = statements;
	            this.ngModuleFactoryVar = ngModuleFactoryVar;
	            this.dependencies = dependencies;
	        }
	        return NgModuleCompileResult;
	    }());
	    var NgModuleCompiler = (function () {
	        function NgModuleCompiler() {
	        }
	        /**
	         * @param {?} ngModuleMeta
	         * @param {?} extraProviders
	         * @return {?}
	         */
	        NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {
	            var /** @type {?} */ moduleUrl = identifierModuleUrl(ngModuleMeta.type);
	            var /** @type {?} */ sourceFileName = isPresent(moduleUrl) ?
	                "in NgModule " + identifierName(ngModuleMeta.type) + " in " + moduleUrl :
	                "in NgModule " + identifierName(ngModuleMeta.type);
	            var /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);
	            var /** @type {?} */ sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));
	            var /** @type {?} */ deps = [];
	            var /** @type {?} */ bootstrapComponentFactories = [];
	            var /** @type {?} */ entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {
	                var /** @type {?} */ id = { reference: null };
	                if (ngModuleMeta.bootstrapComponents.some(function (id) { return id.reference === entryComponent.reference; })) {
	                    bootstrapComponentFactories.push(id);
	                }
	                deps.push(new ComponentFactoryDependency(entryComponent, id));
	                return id;
	            });
	            var /** @type {?} */ builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);
	            var /** @type {?} */ providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);
	            providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });
	            var /** @type {?} */ injectorClass = builder.build();
	            var /** @type {?} */ ngModuleFactoryVar = identifierName(ngModuleMeta.type) + "NgFactory";
	            var /** @type {?} */ ngModuleFactoryStmt = variable(ngModuleFactoryVar)
	                .set(importExpr(createIdentifier(Identifiers.NgModuleFactory))
	                .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(createIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))
	                .toDeclStmt(null, [StmtModifier.Final]);
	            var /** @type {?} */ stmts = [injectorClass, ngModuleFactoryStmt];
	            if (ngModuleMeta.id) {
	                var /** @type {?} */ registerFactoryStmt = importExpr(createIdentifier(Identifiers.RegisterModuleFactoryFn))
	                    .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])
	                    .toStmt();
	                stmts.push(registerFactoryStmt);
	            }
	            return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);
	        };
	        NgModuleCompiler = __decorate$13([
	            CompilerInjectable(), 
	            __metadata$13('design:paramtypes', [])
	        ], NgModuleCompiler);
	        return NgModuleCompiler;
	    }());
	    var _InjectorBuilder = (function () {
	        /**
	         * @param {?} _ngModuleMeta
	         * @param {?} _entryComponentFactories
	         * @param {?} _bootstrapComponentFactories
	         * @param {?} _sourceSpan
	         */
	        function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {
	            this._ngModuleMeta = _ngModuleMeta;
	            this._entryComponentFactories = _entryComponentFactories;
	            this._bootstrapComponentFactories = _bootstrapComponentFactories;
	            this._sourceSpan = _sourceSpan;
	            this.fields = [];
	            this.getters = [];
	            this.methods = [];
	            this.ctorStmts = [];
	            this._tokens = [];
	            this._instances = new Map();
	            this._createStmts = [];
	            this._destroyStmts = [];
	        }
	        /**
	         * @param {?} resolvedProvider
	         * @return {?}
	         */
	        _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {
	            var _this = this;
	            var /** @type {?} */ providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });
	            var /** @type {?} */ propName = "_" + tokenName(resolvedProvider.token) + "_" + this._instances.size;
	            var /** @type {?} */ instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);
	            if (resolvedProvider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
	                this._destroyStmts.push(instance.callMethod('ngOnDestroy', []).toStmt());
	            }
	            this._tokens.push(resolvedProvider.token);
	            this._instances.set(tokenReference(resolvedProvider.token), instance);
	        };
	        /**
	         * @return {?}
	         */
	        _InjectorBuilder.prototype.build = function () {
	            var _this = this;
	            var /** @type {?} */ getMethodStmts = this._tokens.map(function (token) {
	                var /** @type {?} */ providerExpr = _this._instances.get(tokenReference(token));
	                return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);
	            });
	            var /** @type {?} */ methods = [
	                new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),
	                new ClassMethod('getInternal', [
	                    new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),
	                    new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)
	                ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars.notFoundResult)]), DYNAMIC_TYPE),
	                new ClassMethod('destroyInternal', [], this._destroyStmts),
	            ];
	            var /** @type {?} */ parentArgs = [
	                variable(InjectorProps.parent.name),
	                literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),
	                literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))
	            ];
	            var /** @type {?} */ injClassName = identifierName(this._ngModuleMeta.type) + "Injector";
	            return createClassStmt({
	                name: injClassName,
	                ctorParams: [new FnParam(InjectorProps.parent.name, importType(createIdentifier(Identifiers.Injector)))],
	                parent: importExpr(createIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]),
	                parentArgs: parentArgs,
	                builders: [{ methods: methods }, this]
	            });
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        _InjectorBuilder.prototype._getProviderValue = function (provider) {
	            var _this = this;
	            var /** @type {?} */ result;
	            if (isPresent(provider.useExisting)) {
	                result = this._getDependency({ token: provider.useExisting });
	            }
	            else if (isPresent(provider.useFactory)) {
	                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;
	                var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
	                result = importExpr(provider.useFactory).callFn(depsExpr);
	            }
	            else if (isPresent(provider.useClass)) {
	                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;
	                var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
	                result =
	                    importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));
	            }
	            else {
	                result = convertValueToOutputAst(provider.useValue);
	            }
	            return result;
	        };
	        /**
	         * @param {?} propName
	         * @param {?} provider
	         * @param {?} providerValueExpressions
	         * @param {?} isMulti
	         * @param {?} isEager
	         * @return {?}
	         */
	        _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {
	            var /** @type {?} */ resolvedProviderValueExpr;
	            var /** @type {?} */ type;
	            if (isMulti) {
	                resolvedProviderValueExpr = literalArr(providerValueExpressions);
	                type = new ArrayType(DYNAMIC_TYPE);
	            }
	            else {
	                resolvedProviderValueExpr = providerValueExpressions[0];
	                type = providerValueExpressions[0].type;
	            }
	            if (!type) {
	                type = DYNAMIC_TYPE;
	            }
	            if (isEager) {
	                this.fields.push(new ClassField(propName, type));
	                this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
	            }
	            else {
	                var /** @type {?} */ internalField = "_" + propName;
	                this.fields.push(new ClassField(internalField, type));
	                // Note: Equals is important for JS so that it also checks the undefined case!
	                var /** @type {?} */ getterStmts = [
	                    new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]),
	                    new ReturnStatement(THIS_EXPR.prop(internalField))
	                ];
	                this.getters.push(new ClassGetter(propName, getterStmts, type));
	            }
	            return THIS_EXPR.prop(propName);
	        };
	        /**
	         * @param {?} dep
	         * @return {?}
	         */
	        _InjectorBuilder.prototype._getDependency = function (dep) {
	            var /** @type {?} */ result = null;
	            if (dep.isValue) {
	                result = literal(dep.value);
	            }
	            if (!dep.isSkipSelf) {
	                if (dep.token &&
	                    (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector) ||
	                        tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver))) {
	                    result = THIS_EXPR;
	                }
	                if (!result) {
	                    result = this._instances.get(tokenReference(dep.token));
	                }
	            }
	            if (!result) {
	                var /** @type {?} */ args = [createDiTokenExpression(dep.token)];
	                if (dep.isOptional) {
	                    args.push(NULL_EXPR);
	                }
	                result = InjectorProps.parent.callMethod('get', args);
	            }
	            return result;
	        };
	        return _InjectorBuilder;
	    }());
	    var InjectorProps = (function () {
	        function InjectorProps() {
	        }
	        InjectorProps.parent = THIS_EXPR.prop('parent');
	        return InjectorProps;
	    }());
	    var InjectMethodVars = (function () {
	        function InjectMethodVars() {
	        }
	        InjectMethodVars.token = variable('token');
	        InjectMethodVars.notFoundResult = variable('notFoundResult');
	        return InjectMethodVars;
	    }());

	    var /** @type {?} */ _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
	    var /** @type {?} */ _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
	    var /** @type {?} */ CATCH_ERROR_VAR$1 = variable('error');
	    var /** @type {?} */ CATCH_STACK_VAR$1 = variable('stack');
	    var _EmittedLine = (function () {
	        /**
	         * @param {?} indent
	         */
	        function _EmittedLine(indent) {
	            this.indent = indent;
	            this.parts = [];
	        }
	        return _EmittedLine;
	    }());
	    var EmitterVisitorContext = (function () {
	        /**
	         * @param {?} _exportedVars
	         * @param {?} _indent
	         */
	        function EmitterVisitorContext(_exportedVars, _indent) {
	            this._exportedVars = _exportedVars;
	            this._indent = _indent;
	            this._classes = [];
	            this._lines = [new _EmittedLine(_indent)];
	        }
	        /**
	         * @param {?} exportedVars
	         * @return {?}
	         */
	        EmitterVisitorContext.createRoot = function (exportedVars) {
	            return new EmitterVisitorContext(exportedVars, 0);
	        };
	        Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._lines[this._lines.length - 1]; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} varName
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };
	        /**
	         * @param {?=} lastPart
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.println = function (lastPart) {
	            if (lastPart === void 0) { lastPart = ''; }
	            this.print(lastPart, true);
	        };
	        /**
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };
	        /**
	         * @param {?} part
	         * @param {?=} newLine
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.print = function (part, newLine) {
	            if (newLine === void 0) { newLine = false; }
	            if (part.length > 0) {
	                this._currentLine.parts.push(part);
	            }
	            if (newLine) {
	                this._lines.push(new _EmittedLine(this._indent));
	            }
	        };
	        /**
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.removeEmptyLastLine = function () {
	            if (this.lineIsEmpty()) {
	                this._lines.pop();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.incIndent = function () {
	            this._indent++;
	            this._currentLine.indent = this._indent;
	        };
	        /**
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.decIndent = function () {
	            this._indent--;
	            this._currentLine.indent = this._indent;
	        };
	        /**
	         * @param {?} clazz
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };
	        /**
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };
	        Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        EmitterVisitorContext.prototype.toSource = function () {
	            var /** @type {?} */ lines = this._lines;
	            if (lines[lines.length - 1].parts.length === 0) {
	                lines = lines.slice(0, lines.length - 1);
	            }
	            return lines
	                .map(function (line) {
	                if (line.parts.length > 0) {
	                    return _createIndent(line.indent) + line.parts.join('');
	                }
	                else {
	                    return '';
	                }
	            })
	                .join('\n');
	        };
	        return EmitterVisitorContext;
	    }());
	    /**
	     * @abstract
	     */
	    var AbstractEmitterVisitor = (function () {
	        /**
	         * @param {?} _escapeDollarInStrings
	         */
	        function AbstractEmitterVisitor(_escapeDollarInStrings) {
	            this._escapeDollarInStrings = _escapeDollarInStrings;
	        }
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {
	            stmt.expr.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {
	            ctx.print("return ");
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        };
	        /**
	         * @abstract
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitCastExpr = function (ast, context) { };
	        /**
	         * @abstract
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) { };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {
	            ctx.print("if (");
	            stmt.condition.visitExpression(this, ctx);
	            ctx.print(") {");
	            var /** @type {?} */ hasElseCase = isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
	            if (stmt.trueCase.length <= 1 && !hasElseCase) {
	                ctx.print(" ");
	                this.visitAllStatements(stmt.trueCase, ctx);
	                ctx.removeEmptyLastLine();
	                ctx.print(" ");
	            }
	            else {
	                ctx.println();
	                ctx.incIndent();
	                this.visitAllStatements(stmt.trueCase, ctx);
	                ctx.decIndent();
	                if (hasElseCase) {
	                    ctx.println("} else {");
	                    ctx.incIndent();
	                    this.visitAllStatements(stmt.falseCase, ctx);
	                    ctx.decIndent();
	                }
	            }
	            ctx.println("}");
	            return null;
	        };
	        /**
	         * @abstract
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) { };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {
	            ctx.print("throw ");
	            stmt.error.visitExpression(this, ctx);
	            ctx.println(";");
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {
	            var /** @type {?} */ lines = stmt.comment.split('\n');
	            lines.forEach(function (line) { ctx.println("// " + line); });
	            return null;
	        };
	        /**
	         * @abstract
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) { };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {
	            var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();
	            if (!lineWasEmpty) {
	                ctx.print('(');
	            }
	            ctx.print(expr.name + " = ");
	            expr.value.visitExpression(this, ctx);
	            if (!lineWasEmpty) {
	                ctx.print(')');
	            }
	            return null;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {
	            var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();
	            if (!lineWasEmpty) {
	                ctx.print('(');
	            }
	            expr.receiver.visitExpression(this, ctx);
	            ctx.print("[");
	            expr.index.visitExpression(this, ctx);
	            ctx.print("] = ");
	            expr.value.visitExpression(this, ctx);
	            if (!lineWasEmpty) {
	                ctx.print(')');
	            }
	            return null;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {
	            var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();
	            if (!lineWasEmpty) {
	                ctx.print('(');
	            }
	            expr.receiver.visitExpression(this, ctx);
	            ctx.print("." + expr.name + " = ");
	            expr.value.visitExpression(this, ctx);
	            if (!lineWasEmpty) {
	                ctx.print(')');
	            }
	            return null;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {
	            expr.receiver.visitExpression(this, ctx);
	            var /** @type {?} */ name = expr.name;
	            if (isPresent(expr.builtin)) {
	                name = this.getBuiltinMethodName(expr.builtin);
	                if (isBlank(name)) {
	                    // some builtins just mean to skip the call.
	                    return null;
	                }
	            }
	            ctx.print("." + name + "(");
	            this.visitAllExpressions(expr.args, ctx, ",");
	            ctx.print(")");
	            return null;
	        };
	        /**
	         * @abstract
	         * @param {?} method
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.getBuiltinMethodName = function (method) { };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
	            expr.fn.visitExpression(this, ctx);
	            ctx.print("(");
	            this.visitAllExpressions(expr.args, ctx, ',');
	            ctx.print(")");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
	            var /** @type {?} */ varName = ast.name;
	            if (isPresent(ast.builtin)) {
	                switch (ast.builtin) {
	                    case BuiltinVar.Super:
	                        varName = 'super';
	                        break;
	                    case BuiltinVar.This:
	                        varName = 'this';
	                        break;
	                    case BuiltinVar.CatchError:
	                        varName = CATCH_ERROR_VAR$1.name;
	                        break;
	                    case BuiltinVar.CatchStack:
	                        varName = CATCH_STACK_VAR$1.name;
	                        break;
	                    default:
	                        throw new Error("Unknown builtin variable " + ast.builtin);
	                }
	            }
	            ctx.print(varName);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {
	            ctx.print("new ");
	            ast.classExpr.visitExpression(this, ctx);
	            ctx.print("(");
	            this.visitAllExpressions(ast.args, ctx, ',');
	            ctx.print(")");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {
	            var /** @type {?} */ value = ast.value;
	            if (typeof value === 'string') {
	                ctx.print(escapeIdentifier(value, this._escapeDollarInStrings));
	            }
	            else {
	                ctx.print("" + value);
	            }
	            return null;
	        };
	        /**
	         * @abstract
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) { };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {
	            ctx.print("(");
	            ast.condition.visitExpression(this, ctx);
	            ctx.print('? ');
	            ast.trueCase.visitExpression(this, ctx);
	            ctx.print(': ');
	            ast.falseCase.visitExpression(this, ctx);
	            ctx.print(")");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {
	            ctx.print('!');
	            ast.condition.visitExpression(this, ctx);
	            return null;
	        };
	        /**
	         * @abstract
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) { };
	        /**
	         * @abstract
	         * @param {?} stmt
	         * @param {?} context
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) { };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
	            var /** @type {?} */ opStr;
	            switch (ast.operator) {
	                case BinaryOperator.Equals:
	                    opStr = '==';
	                    break;
	                case BinaryOperator.Identical:
	                    opStr = '===';
	                    break;
	                case BinaryOperator.NotEquals:
	                    opStr = '!=';
	                    break;
	                case BinaryOperator.NotIdentical:
	                    opStr = '!==';
	                    break;
	                case BinaryOperator.And:
	                    opStr = '&&';
	                    break;
	                case BinaryOperator.Or:
	                    opStr = '||';
	                    break;
	                case BinaryOperator.Plus:
	                    opStr = '+';
	                    break;
	                case BinaryOperator.Minus:
	                    opStr = '-';
	                    break;
	                case BinaryOperator.Divide:
	                    opStr = '/';
	                    break;
	                case BinaryOperator.Multiply:
	                    opStr = '*';
	                    break;
	                case BinaryOperator.Modulo:
	                    opStr = '%';
	                    break;
	                case BinaryOperator.Lower:
	                    opStr = '<';
	                    break;
	                case BinaryOperator.LowerEquals:
	                    opStr = '<=';
	                    break;
	                case BinaryOperator.Bigger:
	                    opStr = '>';
	                    break;
	                case BinaryOperator.BiggerEquals:
	                    opStr = '>=';
	                    break;
	                default:
	                    throw new Error("Unknown operator " + ast.operator);
	            }
	            ctx.print("(");
	            ast.lhs.visitExpression(this, ctx);
	            ctx.print(" " + opStr + " ");
	            ast.rhs.visitExpression(this, ctx);
	            ctx.print(")");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {
	            ast.receiver.visitExpression(this, ctx);
	            ctx.print(".");
	            ctx.print(ast.name);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {
	            ast.receiver.visitExpression(this, ctx);
	            ctx.print("[");
	            ast.index.visitExpression(this, ctx);
	            ctx.print("]");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
	            var /** @type {?} */ useNewLine = ast.entries.length > 1;
	            ctx.print("[", useNewLine);
	            ctx.incIndent();
	            this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
	            ctx.decIndent();
	            ctx.print("]", useNewLine);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {
	            var _this = this;
	            var /** @type {?} */ useNewLine = ast.entries.length > 1;
	            ctx.print("{", useNewLine);
	            ctx.incIndent();
	            this.visitAllObjects(function (entry) {
	                ctx.print(escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + ": ");
	                entry.value.visitExpression(_this, ctx);
	            }, ast.entries, ctx, ',', useNewLine);
	            ctx.decIndent();
	            ctx.print("}", useNewLine);
	            return null;
	        };
	        /**
	         * @param {?} expressions
	         * @param {?} ctx
	         * @param {?} separator
	         * @param {?=} newLine
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {
	            var _this = this;
	            if (newLine === void 0) { newLine = false; }
	            this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);
	        };
	        /**
	         * @param {?} handler
	         * @param {?} expressions
	         * @param {?} ctx
	         * @param {?} separator
	         * @param {?=} newLine
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {
	            if (newLine === void 0) { newLine = false; }
	            for (var /** @type {?} */ i = 0; i < expressions.length; i++) {
	                if (i > 0) {
	                    ctx.print(separator, newLine);
	                }
	                handler(expressions[i]);
	            }
	            if (newLine) {
	                ctx.println();
	            }
	        };
	        /**
	         * @param {?} statements
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {
	            var _this = this;
	            statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });
	        };
	        return AbstractEmitterVisitor;
	    }());
	    /**
	     * @param {?} input
	     * @param {?} escapeDollar
	     * @param {?=} alwaysQuote
	     * @return {?}
	     */
	    function escapeIdentifier(input, escapeDollar, alwaysQuote) {
	        if (alwaysQuote === void 0) { alwaysQuote = true; }
	        if (isBlank(input)) {
	            return null;
	        }
	        var /** @type {?} */ body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {
	            var match = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                match[_i - 0] = arguments[_i];
	            }
	            if (match[0] == '$') {
	                return escapeDollar ? '\\$' : '$';
	            }
	            else if (match[0] == '\n') {
	                return '\\n';
	            }
	            else if (match[0] == '\r') {
	                return '\\r';
	            }
	            else {
	                return "\\" + match[0];
	            }
	        });
	        var /** @type {?} */ requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
	        return requiresQuotes ? "'" + body + "'" : body;
	    }
	    /**
	     * @param {?} count
	     * @return {?}
	     */
	    function _createIndent(count) {
	        var /** @type {?} */ res = '';
	        for (var /** @type {?} */ i = 0; i < count; i++) {
	            res += '  ';
	        }
	        return res;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$22 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _debugModuleUrl = '/debug/lib';
	    /**
	     * @param {?} ast
	     * @return {?}
	     */
	    function debugOutputAstAsTypeScript(ast) {
	        var /** @type {?} */ converter = new _TsEmitterVisitor(_debugModuleUrl);
	        var /** @type {?} */ ctx = EmitterVisitorContext.createRoot([]);
	        var /** @type {?} */ asts = Array.isArray(ast) ? ast : [ast];
	        asts.forEach(function (ast) {
	            if (ast instanceof Statement) {
	                ast.visitStatement(converter, ctx);
	            }
	            else if (ast instanceof Expression) {
	                ast.visitExpression(converter, ctx);
	            }
	            else if (ast instanceof Type$1) {
	                ast.visitType(converter, ctx);
	            }
	            else {
	                throw new Error("Don't know how to print debug info for " + ast);
	            }
	        });
	        return ctx.toSource();
	    }
	    var TypeScriptEmitter = (function () {
	        /**
	         * @param {?} _importGenerator
	         */
	        function TypeScriptEmitter(_importGenerator) {
	            this._importGenerator = _importGenerator;
	        }
	        /**
	         * @param {?} moduleUrl
	         * @param {?} stmts
	         * @param {?} exportedVars
	         * @return {?}
	         */
	        TypeScriptEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {
	            var _this = this;
	            var /** @type {?} */ converter = new _TsEmitterVisitor(moduleUrl);
	            var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(exportedVars);
	            converter.visitAllStatements(stmts, ctx);
	            var /** @type {?} */ srcParts = [];
	            converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
	                // Note: can't write the real word for import as it screws up system.js auto detection...
	                srcParts.push("imp" +
	                    ("ort * as " + prefix + " from '" + _this._importGenerator.fileNameToModuleName(importedModuleUrl, moduleUrl) + "';"));
	            });
	            srcParts.push(ctx.toSource());
	            return srcParts.join('\n');
	        };
	        return TypeScriptEmitter;
	    }());
	    var _TsEmitterVisitor = (function (_super) {
	        __extends$22(_TsEmitterVisitor, _super);
	        /**
	         * @param {?} _moduleUrl
	         */
	        function _TsEmitterVisitor(_moduleUrl) {
	            _super.call(this, false);
	            this._moduleUrl = _moduleUrl;
	            this.importsWithPrefixes = new Map();
	        }
	        /**
	         * @param {?} t
	         * @param {?} ctx
	         * @param {?=} defaultType
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {
	            if (defaultType === void 0) { defaultType = 'any'; }
	            if (isPresent(t)) {
	                t.visitType(this, ctx);
	            }
	            else {
	                ctx.print(defaultType);
	            }
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {
	            var /** @type {?} */ value = ast.value;
	            if (isBlank(value) && ast.type != NULL_TYPE) {
	                ctx.print("(" + value + " as any)");
	                return null;
	            }
	            return _super.prototype.visitLiteralExpr.call(this, ast, ctx);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
	            if (ast.entries.length === 0) {
	                ctx.print('(');
	            }
	            var /** @type {?} */ result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);
	            if (ast.entries.length === 0) {
	                ctx.print(' as any[])');
	            }
	            return result;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
	            this._visitIdentifier(ast.value, ast.typeParams, ctx);
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
	            if (ctx.isExportedVar(stmt.name)) {
	                ctx.print("export ");
	            }
	            if (stmt.hasModifier(StmtModifier.Final)) {
	                ctx.print("const");
	            }
	            else {
	                ctx.print("var");
	            }
	            ctx.print(" " + stmt.name + ":");
	            this.visitType(stmt.type, ctx);
	            ctx.print(" = ");
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(";");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
	            ctx.print("(<");
	            ast.type.visitType(this, ctx);
	            ctx.print(">");
	            ast.value.visitExpression(this, ctx);
	            ctx.print(")");
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
	            var _this = this;
	            ctx.pushClass(stmt);
	            if (ctx.isExportedVar(stmt.name)) {
	                ctx.print("export ");
	            }
	            ctx.print("class " + stmt.name);
	            if (isPresent(stmt.parent)) {
	                ctx.print(" extends ");
	                stmt.parent.visitExpression(this, ctx);
	            }
	            ctx.println(" {");
	            ctx.incIndent();
	            stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });
	            if (isPresent(stmt.constructorMethod)) {
	                this._visitClassConstructor(stmt, ctx);
	            }
	            stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });
	            stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });
	            ctx.decIndent();
	            ctx.println("}");
	            ctx.popClass();
	            return null;
	        };
	        /**
	         * @param {?} field
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {
	            if (field.hasModifier(StmtModifier.Private)) {
	                // comment out as a workaround for #10967
	                ctx.print("/*private*/ ");
	            }
	            ctx.print(field.name);
	            ctx.print(':');
	            this.visitType(field.type, ctx);
	            ctx.println(";");
	        };
	        /**
	         * @param {?} getter
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {
	            if (getter.hasModifier(StmtModifier.Private)) {
	                ctx.print("private ");
	            }
	            ctx.print("get " + getter.name + "()");
	            ctx.print(':');
	            this.visitType(getter.type, ctx);
	            ctx.println(" {");
	            ctx.incIndent();
	            this.visitAllStatements(getter.body, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
	            ctx.print("constructor(");
	            this._visitParams(stmt.constructorMethod.params, ctx);
	            ctx.println(") {");
	            ctx.incIndent();
	            this.visitAllStatements(stmt.constructorMethod.body, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	        };
	        /**
	         * @param {?} method
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {
	            if (method.hasModifier(StmtModifier.Private)) {
	                ctx.print("private ");
	            }
	            ctx.print(method.name + "(");
	            this._visitParams(method.params, ctx);
	            ctx.print("):");
	            this.visitType(method.type, ctx, 'void');
	            ctx.println(" {");
	            ctx.incIndent();
	            this.visitAllStatements(method.body, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
	            ctx.print("(");
	            this._visitParams(ast.params, ctx);
	            ctx.print("):");
	            this.visitType(ast.type, ctx, 'void');
	            ctx.println(" => {");
	            ctx.incIndent();
	            this.visitAllStatements(ast.statements, ctx);
	            ctx.decIndent();
	            ctx.print("}");
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
	            if (ctx.isExportedVar(stmt.name)) {
	                ctx.print("export ");
	            }
	            ctx.print("function " + stmt.name + "(");
	            this._visitParams(stmt.params, ctx);
	            ctx.print("):");
	            this.visitType(stmt.type, ctx, 'void');
	            ctx.println(" {");
	            ctx.incIndent();
	            this.visitAllStatements(stmt.statements, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
	            ctx.println("try {");
	            ctx.incIndent();
	            this.visitAllStatements(stmt.bodyStmts, ctx);
	            ctx.decIndent();
	            ctx.println("} catch (" + CATCH_ERROR_VAR$1.name + ") {");
	            ctx.incIndent();
	            var /** @type {?} */ catchStmts = [(CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [
	                    StmtModifier.Final
	                ]))].concat(stmt.catchStmts);
	            this.visitAllStatements(catchStmts, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	            return null;
	        };
	        /**
	         * @param {?} type
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {
	            var /** @type {?} */ typeStr;
	            switch (type.name) {
	                case BuiltinTypeName.Bool:
	                    typeStr = 'boolean';
	                    break;
	                case BuiltinTypeName.Dynamic:
	                    typeStr = 'any';
	                    break;
	                case BuiltinTypeName.Function:
	                    typeStr = 'Function';
	                    break;
	                case BuiltinTypeName.Number:
	                    typeStr = 'number';
	                    break;
	                case BuiltinTypeName.Int:
	                    typeStr = 'number';
	                    break;
	                case BuiltinTypeName.String:
	                    typeStr = 'string';
	                    break;
	                default:
	                    throw new Error("Unsupported builtin type " + type.name);
	            }
	            ctx.print(typeStr);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {
	            var _this = this;
	            ast.value.visitExpression(this, ctx);
	            if (isPresent(ast.typeParams) && ast.typeParams.length > 0) {
	                ctx.print("<");
	                this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, ast.typeParams, ctx, ',');
	                ctx.print(">");
	            }
	            return null;
	        };
	        /**
	         * @param {?} type
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {
	            this.visitType(type.of, ctx);
	            ctx.print("[]");
	            return null;
	        };
	        /**
	         * @param {?} type
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {
	            ctx.print("{[key: string]:");
	            this.visitType(type.valueType, ctx);
	            ctx.print("}");
	            return null;
	        };
	        /**
	         * @param {?} method
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
	            var /** @type {?} */ name;
	            switch (method) {
	                case BuiltinMethod.ConcatArray:
	                    name = 'concat';
	                    break;
	                case BuiltinMethod.SubscribeObservable:
	                    name = 'subscribe';
	                    break;
	                case BuiltinMethod.Bind:
	                    name = 'bind';
	                    break;
	                default:
	                    throw new Error("Unknown builtin method: " + method);
	            }
	            return name;
	        };
	        /**
	         * @param {?} params
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {
	            var _this = this;
	            this.visitAllObjects(function (param) {
	                ctx.print(param.name);
	                ctx.print(':');
	                _this.visitType(param.type, ctx);
	            }, params, ctx, ',');
	        };
	        /**
	         * @param {?} value
	         * @param {?} typeParams
	         * @param {?} ctx
	         * @return {?}
	         */
	        _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {
	            var _this = this;
	            var /** @type {?} */ name = identifierName(value);
	            var /** @type {?} */ moduleUrl = identifierModuleUrl(value);
	            if (isBlank(name)) {
	                throw new Error("Internal error: unknown identifier " + value);
	            }
	            if (isPresent(moduleUrl) && moduleUrl != this._moduleUrl) {
	                var /** @type {?} */ prefix = this.importsWithPrefixes.get(moduleUrl);
	                if (isBlank(prefix)) {
	                    prefix = "import" + this.importsWithPrefixes.size;
	                    this.importsWithPrefixes.set(moduleUrl, prefix);
	                }
	                ctx.print(prefix + ".");
	            }
	            if (value.reference && value.reference.members && value.reference.members.length) {
	                ctx.print(value.reference.name);
	                ctx.print('.');
	                ctx.print(value.reference.members.join('.'));
	            }
	            else {
	                ctx.print(name);
	            }
	            if (isPresent(typeParams) && typeParams.length > 0) {
	                ctx.print("<");
	                this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');
	                ctx.print(">");
	            }
	        };
	        return _TsEmitterVisitor;
	    }(AbstractEmitterVisitor));

	    // =================================================================================================
	    // =================================================================================================
	    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
	    // =================================================================================================
	    // =================================================================================================
	    //
	    //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
	    //                               Reach out to mprobst for details.
	    //
	    // =================================================================================================
	    /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
	    var /** @type {?} */ SECURITY_SCHEMA = {};
	    /**
	     * @param {?} ctx
	     * @param {?} specs
	     * @return {?}
	     */
	    function registerContext(ctx, specs) {
	        for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
	            var spec = specs_1[_i];
	            SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
	        }
	    }
	    // Case is insignificant below, all element and attribute names are lower-cased for lookup.
	    registerContext(_angular_core.SecurityContext.HTML, [
	        'iframe|srcdoc',
	        '*|innerHTML',
	        '*|outerHTML',
	    ]);
	    registerContext(_angular_core.SecurityContext.STYLE, ['*|style']);
	    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
	    registerContext(_angular_core.SecurityContext.URL, [
	        '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
	        'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
	        'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
	        'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
	    ]);
	    registerContext(_angular_core.SecurityContext.RESOURCE_URL, [
	        'applet|code',
	        'applet|codebase',
	        'base|href',
	        'embed|src',
	        'frame|src',
	        'head|profile',
	        'html|manifest',
	        'iframe|src',
	        'link|href',
	        'media|src',
	        'object|codebase',
	        'object|data',
	        'script|src',
	    ]);

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$23 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate$14 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$14 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var /** @type {?} */ BOOLEAN = 'boolean';
	    var /** @type {?} */ NUMBER = 'number';
	    var /** @type {?} */ STRING = 'string';
	    var /** @type {?} */ OBJECT = 'object';
	    /**
	     * This array represents the DOM schema. It encodes inheritance, properties, and events.
	     *
	     * ## Overview
	     *
	     * Each line represents one kind of element. The `element_inheritance` and properties are joined
	     * using `element_inheritance|properties` syntax.
	     *
	     * ## Element Inheritance
	     *
	     * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
	     * Here the individual elements are separated by `,` (commas). Every element in the list
	     * has identical properties.
	     *
	     * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
	     * specified then `""` (blank) element is assumed.
	     *
	     * NOTE: The blank element inherits from root `[Element]` element, the super element of all
	     * elements.
	     *
	     * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
	     *
	     * ## Properties
	     *
	     * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
	     * by a special character designating its type:
	     *
	     * - (no prefix): property is a string.
	     * - `*`: property represents an event.
	     * - `!`: property is a boolean.
	     * - `#`: property is a number.
	     * - `%`: property is an object.
	     *
	     * ## Query
	     *
	     * The class creates an internal squas representation which allows to easily answer the query of
	     * if a given property exist on a given element.
	     *
	     * NOTE: We don't yet support querying for types or events.
	     * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
	     *       see dom_element_schema_registry_spec.ts
	     */
	    // =================================================================================================
	    // =================================================================================================
	    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
	    // =================================================================================================
	    // =================================================================================================
	    //
	    //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
	    //
	    // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
	    // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
	    //
	    // =================================================================================================
	    var /** @type {?} */ SCHEMA = [
	        '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',
	        '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
	        'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
	        'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',
	        ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
	        ':svg:graphics^:svg:|',
	        ':svg:animation^:svg:|*begin,*end,*repeat',
	        ':svg:geometry^:svg:|',
	        ':svg:componentTransferFunction^:svg:|',
	        ':svg:gradient^:svg:|',
	        ':svg:textContent^:svg:graphics|',
	        ':svg:textPositioning^:svg:textContent|',
	        'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
	        'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',
	        'audio^media|',
	        'br^[HTMLElement]|clear',
	        'base^[HTMLElement]|href,target',
	        'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
	        'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
	        'canvas^[HTMLElement]|#height,#width',
	        'content^[HTMLElement]|select',
	        'dl^[HTMLElement]|!compact',
	        'datalist^[HTMLElement]|',
	        'details^[HTMLElement]|!open',
	        'dialog^[HTMLElement]|!open,returnValue',
	        'dir^[HTMLElement]|!compact',
	        'div^[HTMLElement]|align',
	        'embed^[HTMLElement]|align,height,name,src,type,width',
	        'fieldset^[HTMLElement]|!disabled,name',
	        'font^[HTMLElement]|color,face,size',
	        'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
	        'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
	        'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
	        'hr^[HTMLElement]|align,color,!noShade,size,width',
	        'head^[HTMLElement]|',
	        'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
	        'html^[HTMLElement]|version',
	        'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
	        'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
	        'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
	        'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',
	        'li^[HTMLElement]|type,#value',
	        'label^[HTMLElement]|htmlFor',
	        'legend^[HTMLElement]|align',
	        'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',
	        'map^[HTMLElement]|name',
	        'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
	        'menu^[HTMLElement]|!compact',
	        'meta^[HTMLElement]|content,httpEquiv,name,scheme',
	        'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
	        'ins,del^[HTMLElement]|cite,dateTime',
	        'ol^[HTMLElement]|!compact,!reversed,#start,type',
	        'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
	        'optgroup^[HTMLElement]|!disabled,label',
	        'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
	        'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
	        'p^[HTMLElement]|align',
	        'param^[HTMLElement]|name,type,value,valueType',
	        'picture^[HTMLElement]|',
	        'pre^[HTMLElement]|#width',
	        'progress^[HTMLElement]|#max,#value',
	        'q,blockquote,cite^[HTMLElement]|',
	        'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
	        'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
	        'shadow^[HTMLElement]|',
	        'source^[HTMLElement]|media,sizes,src,srcset,type',
	        'span^[HTMLElement]|',
	        'style^[HTMLElement]|!disabled,media,type',
	        'caption^[HTMLElement]|align',
	        'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
	        'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
	        'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
	        'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
	        'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
	        'template^[HTMLElement]|',
	        'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
	        'title^[HTMLElement]|text',
	        'track^[HTMLElement]|!default,kind,label,src,srclang',
	        'ul^[HTMLElement]|!compact,type',
	        'unknown^[HTMLElement]|',
	        'video^media|#height,poster,#width',
	        ':svg:a^:svg:graphics|',
	        ':svg:animate^:svg:animation|',
	        ':svg:animateMotion^:svg:animation|',
	        ':svg:animateTransform^:svg:animation|',
	        ':svg:circle^:svg:geometry|',
	        ':svg:clipPath^:svg:graphics|',
	        ':svg:cursor^:svg:|',
	        ':svg:defs^:svg:graphics|',
	        ':svg:desc^:svg:|',
	        ':svg:discard^:svg:|',
	        ':svg:ellipse^:svg:geometry|',
	        ':svg:feBlend^:svg:|',
	        ':svg:feColorMatrix^:svg:|',
	        ':svg:feComponentTransfer^:svg:|',
	        ':svg:feComposite^:svg:|',
	        ':svg:feConvolveMatrix^:svg:|',
	        ':svg:feDiffuseLighting^:svg:|',
	        ':svg:feDisplacementMap^:svg:|',
	        ':svg:feDistantLight^:svg:|',
	        ':svg:feDropShadow^:svg:|',
	        ':svg:feFlood^:svg:|',
	        ':svg:feFuncA^:svg:componentTransferFunction|',
	        ':svg:feFuncB^:svg:componentTransferFunction|',
	        ':svg:feFuncG^:svg:componentTransferFunction|',
	        ':svg:feFuncR^:svg:componentTransferFunction|',
	        ':svg:feGaussianBlur^:svg:|',
	        ':svg:feImage^:svg:|',
	        ':svg:feMerge^:svg:|',
	        ':svg:feMergeNode^:svg:|',
	        ':svg:feMorphology^:svg:|',
	        ':svg:feOffset^:svg:|',
	        ':svg:fePointLight^:svg:|',
	        ':svg:feSpecularLighting^:svg:|',
	        ':svg:feSpotLight^:svg:|',
	        ':svg:feTile^:svg:|',
	        ':svg:feTurbulence^:svg:|',
	        ':svg:filter^:svg:|',
	        ':svg:foreignObject^:svg:graphics|',
	        ':svg:g^:svg:graphics|',
	        ':svg:image^:svg:graphics|',
	        ':svg:line^:svg:geometry|',
	        ':svg:linearGradient^:svg:gradient|',
	        ':svg:mpath^:svg:|',
	        ':svg:marker^:svg:|',
	        ':svg:mask^:svg:|',
	        ':svg:metadata^:svg:|',
	        ':svg:path^:svg:geometry|',
	        ':svg:pattern^:svg:|',
	        ':svg:polygon^:svg:geometry|',
	        ':svg:polyline^:svg:geometry|',
	        ':svg:radialGradient^:svg:gradient|',
	        ':svg:rect^:svg:geometry|',
	        ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
	        ':svg:script^:svg:|type',
	        ':svg:set^:svg:animation|',
	        ':svg:stop^:svg:|',
	        ':svg:style^:svg:|!disabled,media,title,type',
	        ':svg:switch^:svg:graphics|',
	        ':svg:symbol^:svg:|',
	        ':svg:tspan^:svg:textPositioning|',
	        ':svg:text^:svg:textPositioning|',
	        ':svg:textPath^:svg:textContent|',
	        ':svg:title^:svg:|',
	        ':svg:use^:svg:graphics|',
	        ':svg:view^:svg:|#zoomAndPan',
	        'data^[HTMLElement]|value',
	        'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
	        'summary^[HTMLElement]|',
	        'time^[HTMLElement]|dateTime',
	    ];
	    var /** @type {?} */ _ATTR_TO_PROP = {
	        'class': 'className',
	        'for': 'htmlFor',
	        'formaction': 'formAction',
	        'innerHtml': 'innerHTML',
	        'readonly': 'readOnly',
	        'tabindex': 'tabIndex',
	    };
	    var DomElementSchemaRegistry = (function (_super) {
	        __extends$23(DomElementSchemaRegistry, _super);
	        function DomElementSchemaRegistry() {
	            var _this = this;
	            _super.call(this);
	            this._schema = {};
	            SCHEMA.forEach(function (encodedType) {
	                var type = {};
	                var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];
	                var properties = strProperties.split(',');
	                var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];
	                typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });
	                var superType = superName && _this._schema[superName.toLowerCase()];
	                if (superType) {
	                    Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });
	                }
	                properties.forEach(function (property) {
	                    if (property.length > 0) {
	                        switch (property[0]) {
	                            case '*':
	                                // We don't yet support events.
	                                // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
	                                // will
	                                // almost certainly introduce bad XSS vulnerabilities.
	                                // type[property.substring(1)] = EVENT;
	                                break;
	                            case '!':
	                                type[property.substring(1)] = BOOLEAN;
	                                break;
	                            case '#':
	                                type[property.substring(1)] = NUMBER;
	                                break;
	                            case '%':
	                                type[property.substring(1)] = OBJECT;
	                                break;
	                            default:
	                                type[property] = STRING;
	                        }
	                    }
	                });
	            });
	        }
	        /**
	         * @param {?} tagName
	         * @param {?} propName
	         * @param {?} schemaMetas
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {
	            if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
	                return true;
	            }
	            if (tagName.indexOf('-') > -1) {
	                if (tagName === 'ng-container' || tagName === 'ng-content') {
	                    return false;
	                }
	                if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
	                    // Can't tell now as we don't know which properties a custom element will get
	                    // once it is instantiated
	                    return true;
	                }
	            }
	            var /** @type {?} */ elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
	            return !!elementProperties[propName];
	        };
	        /**
	         * @param {?} tagName
	         * @param {?} schemaMetas
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {
	            if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
	                return true;
	            }
	            if (tagName.indexOf('-') > -1) {
	                if (tagName === 'ng-container' || tagName === 'ng-content') {
	                    return true;
	                }
	                if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
	                    // Allow any custom elements
	                    return true;
	                }
	            }
	            return !!this._schema[tagName.toLowerCase()];
	        };
	        /**
	         * securityContext returns the security context for the given property on the given DOM tag.
	         *
	         * Tag and property name are statically known and cannot change at runtime, i.e. it is not
	         * possible to bind a value into a changing attribute or tag name.
	         *
	         * The filtering is white list based. All attributes in the schema above are assumed to have the
	         * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
	         * attack vectors are assigned their appropriate context.
	         * @param {?} tagName
	         * @param {?} propName
	         * @param {?} isAttribute
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {
	            if (isAttribute) {
	                // NB: For security purposes, use the mapped property name, not the attribute name.
	                propName = this.getMappedPropName(propName);
	            }
	            // Make sure comparisons are case insensitive, so that case differences between attribute and
	            // property names do not have a security impact.
	            tagName = tagName.toLowerCase();
	            propName = propName.toLowerCase();
	            var /** @type {?} */ ctx = SECURITY_SCHEMA[tagName + '|' + propName];
	            if (ctx) {
	                return ctx;
	            }
	            ctx = SECURITY_SCHEMA['*|' + propName];
	            return ctx ? ctx : _angular_core.SecurityContext.NONE;
	        };
	        /**
	         * @param {?} propName
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };
	        /**
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.validateProperty = function (name) {
	            if (name.toLowerCase().startsWith('on')) {
	                var /** @type {?} */ msg = ("Binding to event property '" + name + "' is disallowed for security reasons, ") +
	                    ("please use (" + name.slice(2) + ")=...") +
	                    ("\nIf '" + name + "' is a directive input, make sure the directive is imported by the") +
	                    " current module.";
	                return { error: true, msg: msg };
	            }
	            else {
	                return { error: false };
	            }
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.validateAttribute = function (name) {
	            if (name.toLowerCase().startsWith('on')) {
	                var /** @type {?} */ msg = ("Binding to event attribute '" + name + "' is disallowed for security reasons, ") +
	                    ("please use (" + name.slice(2) + ")=...");
	                return { error: true, msg: msg };
	            }
	            else {
	                return { error: false };
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };
	        /**
	         * @param {?} propName
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {
	            return dashCaseToCamelCase(propName);
	        };
	        /**
	         * @param {?} camelCaseProp
	         * @param {?} userProvidedProp
	         * @param {?} val
	         * @return {?}
	         */
	        DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {
	            var /** @type {?} */ unit = '';
	            var /** @type {?} */ strVal = val.toString().trim();
	            var /** @type {?} */ errorMsg = null;
	            if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
	                if (typeof val === 'number') {
	                    unit = 'px';
	                }
	                else {
	                    var /** @type {?} */ valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
	                    if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
	                        errorMsg = "Please provide a CSS unit value for " + userProvidedProp + ":" + val;
	                    }
	                }
	            }
	            return { error: errorMsg, value: strVal + unit };
	        };
	        DomElementSchemaRegistry = __decorate$14([
	            CompilerInjectable(), 
	            __metadata$14('design:paramtypes', [])
	        ], DomElementSchemaRegistry);
	        return DomElementSchemaRegistry;
	    }(ElementSchemaRegistry));
	    /**
	     * @param {?} prop
	     * @return {?}
	     */
	    function _isPixelDimensionStyle(prop) {
	        switch (prop) {
	            case 'width':
	            case 'height':
	            case 'minWidth':
	            case 'minHeight':
	            case 'maxWidth':
	            case 'maxHeight':
	            case 'left':
	            case 'top':
	            case 'bottom':
	            case 'right':
	            case 'fontSize':
	            case 'outlineWidth':
	            case 'outlineOffset':
	            case 'paddingTop':
	            case 'paddingLeft':
	            case 'paddingBottom':
	            case 'paddingRight':
	            case 'marginTop':
	            case 'marginLeft':
	            case 'marginBottom':
	            case 'marginRight':
	            case 'borderRadius':
	            case 'borderWidth':
	            case 'borderTopWidth':
	            case 'borderLeftWidth':
	            case 'borderRightWidth':
	            case 'borderBottomWidth':
	            case 'textIndent':
	                return true;
	            default:
	                return false;
	        }
	    }

	    var ShadowCss = (function () {
	        function ShadowCss() {
	            this.strictStyling = true;
	        }
	        /**
	         * @param {?} cssText
	         * @param {?} selector
	         * @param {?=} hostSelector
	         * @return {?}
	         */
	        ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
	            if (hostSelector === void 0) { hostSelector = ''; }
	            var /** @type {?} */ sourceMappingUrl = extractSourceMappingUrl(cssText);
	            cssText = stripComments(cssText);
	            cssText = this._insertDirectives(cssText);
	            return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._insertDirectives = function (cssText) {
	            cssText = this._insertPolyfillDirectivesInCssText(cssText);
	            return this._insertPolyfillRulesInCssText(cssText);
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
	            // Difference with webcomponents.js: does not handle comments
	            return cssText.replace(_cssContentNextSelectorRe, function () {
	                var m = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    m[_i - 0] = arguments[_i];
	                }
	                return m[2] + '{';
	            });
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
	            // Difference with webcomponents.js: does not handle comments
	            return cssText.replace(_cssContentRuleRe, function () {
	                var m = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    m[_i - 0] = arguments[_i];
	                }
	                var /** @type {?} */ rule = m[0].replace(m[1], '').replace(m[2], '');
	                return m[4] + rule;
	            });
	        };
	        /**
	         * @param {?} cssText
	         * @param {?} scopeSelector
	         * @param {?} hostSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
	            var /** @type {?} */ unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
	            // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
	            cssText = this._insertPolyfillHostInCssText(cssText);
	            cssText = this._convertColonHost(cssText);
	            cssText = this._convertColonHostContext(cssText);
	            cssText = this._convertShadowDOMSelectors(cssText);
	            if (scopeSelector) {
	                cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
	            }
	            cssText = cssText + '\n' + unscopedRules;
	            return cssText.trim();
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
	            // Difference with webcomponents.js: does not handle comments
	            var /** @type {?} */ r = '';
	            var /** @type {?} */ m;
	            _cssContentUnscopedRuleRe.lastIndex = 0;
	            while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
	                var /** @type {?} */ rule = m[0].replace(m[2], '').replace(m[1], m[4]);
	                r += rule + '\n\n';
	            }
	            return r;
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._convertColonHost = function (cssText) {
	            return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._convertColonHostContext = function (cssText) {
	            return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
	        };
	        /**
	         * @param {?} cssText
	         * @param {?} regExp
	         * @param {?} partReplacer
	         * @return {?}
	         */
	        ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
	            // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
	            return cssText.replace(regExp, function () {
	                var m = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    m[_i - 0] = arguments[_i];
	                }
	                if (m[2]) {
	                    var /** @type {?} */ parts = m[2].split(',');
	                    var /** @type {?} */ r = [];
	                    for (var /** @type {?} */ i = 0; i < parts.length; i++) {
	                        var /** @type {?} */ p = parts[i].trim();
	                        if (!p)
	                            break;
	                        r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
	                    }
	                    return r.join(',');
	                }
	                else {
	                    return _polyfillHostNoCombinator + m[3];
	                }
	            });
	        };
	        /**
	         * @param {?} host
	         * @param {?} part
	         * @param {?} suffix
	         * @return {?}
	         */
	        ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
	            if (part.indexOf(_polyfillHost) > -1) {
	                return this._colonHostPartReplacer(host, part, suffix);
	            }
	            else {
	                return host + part + suffix + ', ' + part + ' ' + host + suffix;
	            }
	        };
	        /**
	         * @param {?} host
	         * @param {?} part
	         * @param {?} suffix
	         * @return {?}
	         */
	        ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
	            return host + part.replace(_polyfillHost, '') + suffix;
	        };
	        /**
	         * @param {?} cssText
	         * @return {?}
	         */
	        ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
	            return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);
	        };
	        /**
	         * @param {?} cssText
	         * @param {?} scopeSelector
	         * @param {?} hostSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {
	            var _this = this;
	            return processRules(cssText, function (rule) {
	                var /** @type {?} */ selector = rule.selector;
	                var /** @type {?} */ content = rule.content;
	                if (rule.selector[0] != '@') {
	                    selector =
	                        _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
	                }
	                else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
	                    rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
	                    content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
	                }
	                return new CssRule(selector, content);
	            });
	        };
	        /**
	         * @param {?} selector
	         * @param {?} scopeSelector
	         * @param {?} hostSelector
	         * @param {?} strict
	         * @return {?}
	         */
	        ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
	            var _this = this;
	            return selector.split(',')
	                .map(function (part) { return part.trim().split(_shadowDeepSelectors); })
	                .map(function (deepParts) {
	                var shallowPart = deepParts[0], otherParts = deepParts.slice(1);
	                var /** @type {?} */ applyScope = function (shallowPart) {
	                    if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {
	                        return strict ?
	                            _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
	                            _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
	                    }
	                    else {
	                        return shallowPart;
	                    }
	                };
	                return [applyScope(shallowPart)].concat(otherParts).join(' ');
	            })
	                .join(', ');
	        };
	        /**
	         * @param {?} selector
	         * @param {?} scopeSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
	            var /** @type {?} */ re = this._makeScopeMatcher(scopeSelector);
	            return !re.test(selector);
	        };
	        /**
	         * @param {?} scopeSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
	            var /** @type {?} */ lre = /\[/g;
	            var /** @type {?} */ rre = /\]/g;
	            scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
	            return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
	        };
	        /**
	         * @param {?} selector
	         * @param {?} scopeSelector
	         * @param {?} hostSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
	            // Difference from webcomponents.js: scopeSelector could not be an array
	            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
	        };
	        /**
	         * @param {?} selector
	         * @param {?} scopeSelector
	         * @param {?} hostSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
	            // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
	            _polyfillHostRe.lastIndex = 0;
	            if (_polyfillHostRe.test(selector)) {
	                var /** @type {?} */ replaceBy_1 = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
	                return selector
	                    .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {
	                    return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {
	                        return before + replaceBy_1 + colon + after;
	                    });
	                })
	                    .replace(_polyfillHostRe, replaceBy_1 + ' ');
	            }
	            return scopeSelector + ' ' + selector;
	        };
	        /**
	         * @param {?} selector
	         * @param {?} scopeSelector
	         * @param {?} hostSelector
	         * @return {?}
	         */
	        ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {
	            var _this = this;
	            var /** @type {?} */ isRe = /\[is=([^\]]*)\]/g;
	            scopeSelector = scopeSelector.replace(isRe, function (_) {
	                var parts = [];
	                for (var _i = 1; _i < arguments.length; _i++) {
	                    parts[_i - 1] = arguments[_i];
	                }
	                return parts[0];
	            });
	            var /** @type {?} */ attrName = '[' + scopeSelector + ']';
	            var /** @type {?} */ _scopeSelectorPart = function (p) {
	                var /** @type {?} */ scopedP = p.trim();
	                if (!scopedP) {
	                    return '';
	                }
	                if (p.indexOf(_polyfillHostNoCombinator) > -1) {
	                    scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
	                }
	                else {
	                    // remove :host since it should be unnecessary
	                    var /** @type {?} */ t = p.replace(_polyfillHostRe, '');
	                    if (t.length > 0) {
	                        var /** @type {?} */ matches = t.match(/([^:]*)(:*)(.*)/);
	                        if (matches) {
	                            scopedP = matches[1] + attrName + matches[2] + matches[3];
	                        }
	                    }
	                }
	                return scopedP;
	            };
	            var /** @type {?} */ safeContent = new SafeSelector(selector);
	            selector = safeContent.content();
	            var /** @type {?} */ scopedSelector = '';
	            var /** @type {?} */ startIndex = 0;
	            var /** @type {?} */ res;
	            var /** @type {?} */ sep = /( |>|\+|~(?!=))\s*/g;
	            var /** @type {?} */ scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
	            while ((res = sep.exec(selector)) !== null) {
	                var /** @type {?} */ separator = res[1];
	                var /** @type {?} */ part = selector.slice(startIndex, res.index).trim();
	                // if a selector appears before :host-context it should not be shimmed as it
	                // matches on ancestor elements and not on elements in the host's shadow
	                var /** @type {?} */ scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
	                scopedSelector += scopedPart + " " + separator + " ";
	                startIndex = sep.lastIndex;
	            }
	            scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
	            // replace the placeholders with their original values
	            return safeContent.restore(scopedSelector);
	        };
	        /**
	         * @param {?} selector
	         * @return {?}
	         */
	        ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
	            return selector.replace(_colonHostContextRe, _polyfillHostContext)
	                .replace(_colonHostRe, _polyfillHost);
	        };
	        return ShadowCss;
	    }());
	    var SafeSelector = (function () {
	        /**
	         * @param {?} selector
	         */
	        function SafeSelector(selector) {
	            var _this = this;
	            this.placeholders = [];
	            this.index = 0;
	            // Replaces attribute selectors with placeholders.
	            // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
	            selector = selector.replace(/(\[[^\]]*\])/g, function (_, keep) {
	                var replaceBy = "__ph-" + _this.index + "__";
	                _this.placeholders.push(keep);
	                _this.index++;
	                return replaceBy;
	            });
	            // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
	            // WS and "+" would otherwise be interpreted as selector separators.
	            this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, function (_, pseudo, exp) {
	                var replaceBy = "__ph-" + _this.index + "__";
	                _this.placeholders.push(exp);
	                _this.index++;
	                return pseudo + replaceBy;
	            });
	        }
	        ;
	        /**
	         * @param {?} content
	         * @return {?}
	         */
	        SafeSelector.prototype.restore = function (content) {
	            var _this = this;
	            return content.replace(/__ph-(\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });
	        };
	        /**
	         * @return {?}
	         */
	        SafeSelector.prototype.content = function () { return this._content; };
	        return SafeSelector;
	    }());
	    var /** @type {?} */ _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
	    var /** @type {?} */ _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
	    var /** @type {?} */ _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
	    var /** @type {?} */ _polyfillHost = '-shadowcsshost';
	    // note: :host-context pre-processed to -shadowcsshostcontext.
	    var /** @type {?} */ _polyfillHostContext = '-shadowcsscontext';
	    var /** @type {?} */ _parenSuffix = ')(?:\\((' +
	        '(?:\\([^)(]*\\)|[^)(]*)+?' +
	        ')\\))?([^,{]*)';
	    var /** @type {?} */ _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
	    var /** @type {?} */ _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
	    var /** @type {?} */ _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
	    var /** @type {?} */ _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
	    var /** @type {?} */ _shadowDOMSelectorsRe = [
	        /::shadow/g,
	        /::content/g,
	        // Deprecated selectors
	        /\/shadow-deep\//g,
	        /\/shadow\//g,
	    ];
	    var /** @type {?} */ _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
	    var /** @type {?} */ _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
	    var /** @type {?} */ _polyfillHostRe = /-shadowcsshost/gim;
	    var /** @type {?} */ _colonHostRe = /:host/gim;
	    var /** @type {?} */ _colonHostContextRe = /:host-context/gim;
	    var /** @type {?} */ _commentRe = /\/\*\s*[\s\S]*?\*\//g;
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function stripComments(input) {
	        return input.replace(_commentRe, '');
	    }
	    // all comments except inline source mapping
	    var /** @type {?} */ _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function extractSourceMappingUrl(input) {
	        var /** @type {?} */ matcher = input.match(_sourceMappingUrlRe);
	        return matcher ? matcher[0] : '';
	    }
	    var /** @type {?} */ _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
	    var /** @type {?} */ _curlyRe = /([{}])/g;
	    var /** @type {?} */ OPEN_CURLY = '{';
	    var /** @type {?} */ CLOSE_CURLY = '}';
	    var /** @type {?} */ BLOCK_PLACEHOLDER = '%BLOCK%';
	    var CssRule = (function () {
	        /**
	         * @param {?} selector
	         * @param {?} content
	         */
	        function CssRule(selector, content) {
	            this.selector = selector;
	            this.content = content;
	        }
	        return CssRule;
	    }());
	    /**
	     * @param {?} input
	     * @param {?} ruleCallback
	     * @return {?}
	     */
	    function processRules(input, ruleCallback) {
	        var /** @type {?} */ inputWithEscapedBlocks = escapeBlocks(input);
	        var /** @type {?} */ nextBlockIndex = 0;
	        return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            var /** @type {?} */ selector = m[2];
	            var /** @type {?} */ content = '';
	            var /** @type {?} */ suffix = m[4];
	            var /** @type {?} */ contentPrefix = '';
	            if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
	                content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
	                suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
	                contentPrefix = '{';
	            }
	            var /** @type {?} */ rule = ruleCallback(new CssRule(selector, content));
	            return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
	        });
	    }
	    var StringWithEscapedBlocks = (function () {
	        /**
	         * @param {?} escapedString
	         * @param {?} blocks
	         */
	        function StringWithEscapedBlocks(escapedString, blocks) {
	            this.escapedString = escapedString;
	            this.blocks = blocks;
	        }
	        return StringWithEscapedBlocks;
	    }());
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function escapeBlocks(input) {
	        var /** @type {?} */ inputParts = input.split(_curlyRe);
	        var /** @type {?} */ resultParts = [];
	        var /** @type {?} */ escapedBlocks = [];
	        var /** @type {?} */ bracketCount = 0;
	        var /** @type {?} */ currentBlockParts = [];
	        for (var /** @type {?} */ partIndex = 0; partIndex < inputParts.length; partIndex++) {
	            var /** @type {?} */ part = inputParts[partIndex];
	            if (part == CLOSE_CURLY) {
	                bracketCount--;
	            }
	            if (bracketCount > 0) {
	                currentBlockParts.push(part);
	            }
	            else {
	                if (currentBlockParts.length > 0) {
	                    escapedBlocks.push(currentBlockParts.join(''));
	                    resultParts.push(BLOCK_PLACEHOLDER);
	                    currentBlockParts = [];
	                }
	                resultParts.push(part);
	            }
	            if (part == OPEN_CURLY) {
	                bracketCount++;
	            }
	        }
	        if (currentBlockParts.length > 0) {
	            escapedBlocks.push(currentBlockParts.join(''));
	            resultParts.push(BLOCK_PLACEHOLDER);
	        }
	        return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$15 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$15 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var /** @type {?} */ COMPONENT_VARIABLE = '%COMP%';
	    var /** @type {?} */ HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
	    var /** @type {?} */ CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
	    var StylesCompileDependency = (function () {
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} isShimmed
	         * @param {?} valuePlaceholder
	         */
	        function StylesCompileDependency(name, moduleUrl, isShimmed, valuePlaceholder) {
	            this.name = name;
	            this.moduleUrl = moduleUrl;
	            this.isShimmed = isShimmed;
	            this.valuePlaceholder = valuePlaceholder;
	        }
	        return StylesCompileDependency;
	    }());
	    var StylesCompileResult = (function () {
	        /**
	         * @param {?} componentStylesheet
	         * @param {?} externalStylesheets
	         */
	        function StylesCompileResult(componentStylesheet, externalStylesheets) {
	            this.componentStylesheet = componentStylesheet;
	            this.externalStylesheets = externalStylesheets;
	        }
	        return StylesCompileResult;
	    }());
	    var CompiledStylesheet = (function () {
	        /**
	         * @param {?} statements
	         * @param {?} stylesVar
	         * @param {?} dependencies
	         * @param {?} isShimmed
	         * @param {?} meta
	         */
	        function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {
	            this.statements = statements;
	            this.stylesVar = stylesVar;
	            this.dependencies = dependencies;
	            this.isShimmed = isShimmed;
	            this.meta = meta;
	        }
	        return CompiledStylesheet;
	    }());
	    var StyleCompiler = (function () {
	        /**
	         * @param {?} _urlResolver
	         */
	        function StyleCompiler(_urlResolver) {
	            this._urlResolver = _urlResolver;
	            this._shadowCss = new ShadowCss();
	        }
	        /**
	         * @param {?} comp
	         * @return {?}
	         */
	        StyleCompiler.prototype.compileComponent = function (comp) {
	            var _this = this;
	            var /** @type {?} */ externalStylesheets = [];
	            var /** @type {?} */ componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({
	                styles: comp.template.styles,
	                styleUrls: comp.template.styleUrls,
	                moduleUrl: identifierModuleUrl(comp.type)
	            }), true);
	            comp.template.externalStylesheets.forEach(function (stylesheetMeta) {
	                var /** @type {?} */ compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);
	                externalStylesheets.push(compiledStylesheet);
	            });
	            return new StylesCompileResult(componentStylesheet, externalStylesheets);
	        };
	        /**
	         * @param {?} comp
	         * @param {?} stylesheet
	         * @param {?} isComponentStylesheet
	         * @return {?}
	         */
	        StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {
	            var _this = this;
	            var /** @type {?} */ shim = comp.template.encapsulation === _angular_core.ViewEncapsulation.Emulated;
	            var /** @type {?} */ styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });
	            var /** @type {?} */ dependencies = [];
	            for (var /** @type {?} */ i = 0; i < stylesheet.styleUrls.length; i++) {
	                var /** @type {?} */ identifier = { reference: null };
	                dependencies.push(new StylesCompileDependency(getStylesVarName(null), stylesheet.styleUrls[i], shim, identifier));
	                styleExpressions.push(new ExternalExpr(identifier));
	            }
	            // styles variable contains plain strings and arrays of other styles arrays (recursive),
	            // so we set its type to dynamic.
	            var /** @type {?} */ stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
	            var /** @type {?} */ stmt = variable(stylesVar)
	                .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))
	                .toDeclStmt(null, [StmtModifier.Final]);
	            return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);
	        };
	        /**
	         * @param {?} style
	         * @param {?} shim
	         * @return {?}
	         */
	        StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
	            return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
	        };
	        StyleCompiler = __decorate$15([
	            CompilerInjectable(), 
	            __metadata$15('design:paramtypes', [UrlResolver])
	        ], StyleCompiler);
	        return StyleCompiler;
	    }());
	    /**
	     * @param {?} component
	     * @return {?}
	     */
	    function getStylesVarName(component) {
	        var /** @type {?} */ result = "styles";
	        if (component) {
	            result += "_" + identifierName(component.type);
	        }
	        return result;
	    }

	    var _DebugState = (function () {
	        /**
	         * @param {?} nodeIndex
	         * @param {?} sourceAst
	         */
	        function _DebugState(nodeIndex, sourceAst) {
	            this.nodeIndex = nodeIndex;
	            this.sourceAst = sourceAst;
	        }
	        return _DebugState;
	    }());
	    var /** @type {?} */ NULL_DEBUG_STATE = new _DebugState(null, null);
	    var CompileMethod = (function () {
	        /**
	         * @param {?} _view
	         */
	        function CompileMethod(_view) {
	            this._view = _view;
	            this._newState = NULL_DEBUG_STATE;
	            this._currState = NULL_DEBUG_STATE;
	            this._bodyStatements = [];
	            this._debugEnabled = this._view.genConfig.genDebugInfo;
	        }
	        /**
	         * @return {?}
	         */
	        CompileMethod.prototype._updateDebugContextIfNeeded = function () {
	            if (this._newState.nodeIndex !== this._currState.nodeIndex ||
	                this._newState.sourceAst !== this._currState.sourceAst) {
	                var /** @type {?} */ expr = this._updateDebugContext(this._newState);
	                if (expr) {
	                    this._bodyStatements.push(expr.toStmt());
	                }
	            }
	        };
	        /**
	         * @param {?} newState
	         * @return {?}
	         */
	        CompileMethod.prototype._updateDebugContext = function (newState) {
	            this._currState = this._newState = newState;
	            if (this._debugEnabled) {
	                var /** @type {?} */ sourceLocation = newState.sourceAst ? newState.sourceAst.sourceSpan.start : null;
	                return THIS_EXPR.callMethod('debug', [
	                    literal(newState.nodeIndex),
	                    sourceLocation ? literal(sourceLocation.line) : NULL_EXPR,
	                    sourceLocation ? literal(sourceLocation.col) : NULL_EXPR
	                ]);
	            }
	            else {
	                return null;
	            }
	        };
	        /**
	         * @param {?} nodeIndex
	         * @param {?} templateAst
	         * @return {?}
	         */
	        CompileMethod.prototype.resetDebugInfoExpr = function (nodeIndex, templateAst) {
	            var /** @type {?} */ res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
	            return res || NULL_EXPR;
	        };
	        /**
	         * @param {?} nodeIndex
	         * @param {?} templateAst
	         * @return {?}
	         */
	        CompileMethod.prototype.resetDebugInfo = function (nodeIndex, templateAst) {
	            this._newState = new _DebugState(nodeIndex, templateAst);
	        };
	        /**
	         * @param {...?} stmts
	         * @return {?}
	         */
	        CompileMethod.prototype.push = function () {
	            var stmts = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                stmts[_i - 0] = arguments[_i];
	            }
	            this.addStmts(stmts);
	        };
	        /**
	         * @param {?} stmt
	         * @return {?}
	         */
	        CompileMethod.prototype.addStmt = function (stmt) {
	            this._updateDebugContextIfNeeded();
	            this._bodyStatements.push(stmt);
	        };
	        /**
	         * @param {?} stmts
	         * @return {?}
	         */
	        CompileMethod.prototype.addStmts = function (stmts) {
	            this._updateDebugContextIfNeeded();
	            (_a = this._bodyStatements).push.apply(_a, stmts);
	            var _a;
	        };
	        /**
	         * @return {?}
	         */
	        CompileMethod.prototype.finish = function () { return this._bodyStatements; };
	        /**
	         * @return {?}
	         */
	        CompileMethod.prototype.isEmpty = function () { return this._bodyStatements.length === 0; };
	        return CompileMethod;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$25 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @param {?} property
	     * @param {?} callingView
	     * @param {?} definedView
	     * @return {?}
	     */
	    function getPropertyInView(property, callingView, definedView) {
	        if (callingView === definedView) {
	            return property;
	        }
	        else {
	            var /** @type {?} */ viewProp = THIS_EXPR;
	            var /** @type {?} */ currView = callingView;
	            while (currView !== definedView && currView.declarationElement.view) {
	                currView = currView.declarationElement.view;
	                viewProp = viewProp.prop('parentView');
	            }
	            if (currView !== definedView) {
	                throw new Error("Internal error: Could not calculate a property in a parent view: " + property);
	            }
	            return property.visitExpression(new _ReplaceViewTransformer(viewProp, definedView), null);
	        }
	    }
	    var _ReplaceViewTransformer = (function (_super) {
	        __extends$25(_ReplaceViewTransformer, _super);
	        /**
	         * @param {?} _viewExpr
	         * @param {?} _view
	         */
	        function _ReplaceViewTransformer(_viewExpr, _view) {
	            _super.call(this);
	            this._viewExpr = _viewExpr;
	            this._view = _view;
	        }
	        /**
	         * @param {?} expr
	         * @return {?}
	         */
	        _ReplaceViewTransformer.prototype._isThis = function (expr) {
	            return expr instanceof ReadVarExpr && expr.builtin === BuiltinVar.This;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _ReplaceViewTransformer.prototype.visitReadVarExpr = function (ast, context) {
	            return this._isThis(ast) ? this._viewExpr : ast;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _ReplaceViewTransformer.prototype.visitReadPropExpr = function (ast, context) {
	            if (this._isThis(ast.receiver)) {
	                // Note: Don't cast for members of the AppView base class...
	                if (this._view.fields.some(function (field) { return field.name == ast.name; }) ||
	                    this._view.getters.some(function (field) { return field.name == ast.name; })) {
	                    return this._viewExpr.cast(this._view.classType).prop(ast.name);
	                }
	            }
	            return _super.prototype.visitReadPropExpr.call(this, ast, context);
	        };
	        return _ReplaceViewTransformer;
	    }(ExpressionTransformer));
	    /**
	     * @param {?} view
	     * @param {?} token
	     * @param {?} optional
	     * @return {?}
	     */
	    function injectFromViewParentInjector(view, token, optional) {
	        var /** @type {?} */ viewExpr;
	        if (view.viewType === ViewType.HOST) {
	            viewExpr = THIS_EXPR;
	        }
	        else {
	            viewExpr = THIS_EXPR.prop('parentView');
	        }
	        var /** @type {?} */ args = [createDiTokenExpression(token), THIS_EXPR.prop('parentIndex')];
	        if (optional) {
	            args.push(NULL_EXPR);
	        }
	        return viewExpr.callMethod('injectorGet', args);
	    }
	    /**
	     * @param {?} component
	     * @param {?} embeddedTemplateIndex
	     * @return {?}
	     */
	    function getViewClassName(component, embeddedTemplateIndex) {
	        return "View_" + identifierName(component.type) + embeddedTemplateIndex;
	    }
	    /**
	     * @param {?} elementIndex
	     * @return {?}
	     */
	    function getHandleEventMethodName(elementIndex) {
	        return "handleEvent_" + elementIndex;
	    }

	    var ViewQueryValues = (function () {
	        /**
	         * @param {?} view
	         * @param {?} values
	         */
	        function ViewQueryValues(view, values) {
	            this.view = view;
	            this.values = values;
	        }
	        return ViewQueryValues;
	    }());
	    var CompileQuery = (function () {
	        /**
	         * @param {?} meta
	         * @param {?} queryList
	         * @param {?} ownerDirectiveExpression
	         * @param {?} view
	         */
	        function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
	            this.meta = meta;
	            this.queryList = queryList;
	            this.ownerDirectiveExpression = ownerDirectiveExpression;
	            this.view = view;
	            this._values = new ViewQueryValues(view, []);
	        }
	        /**
	         * @param {?} value
	         * @param {?} view
	         * @return {?}
	         */
	        CompileQuery.prototype.addValue = function (value, view) {
	            var /** @type {?} */ currentView = view;
	            var /** @type {?} */ elPath = [];
	            while (currentView && currentView !== this.view) {
	                var /** @type {?} */ parentEl = currentView.declarationElement;
	                elPath.unshift(parentEl);
	                currentView = parentEl.view;
	            }
	            var /** @type {?} */ queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);
	            var /** @type {?} */ viewValues = this._values;
	            elPath.forEach(function (el) {
	                var /** @type {?} */ last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
	                if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
	                    viewValues = last;
	                }
	                else {
	                    var /** @type {?} */ newViewValues = new ViewQueryValues(el.embeddedView, []);
	                    viewValues.values.push(newViewValues);
	                    viewValues = newViewValues;
	                }
	            });
	            viewValues.values.push(value);
	            if (elPath.length > 0) {
	                view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
	            }
	        };
	        /**
	         * @return {?}
	         */
	        CompileQuery.prototype._isStatic = function () {
	            return !this._values.values.some(function (value) { return value instanceof ViewQueryValues; });
	        };
	        /**
	         * @param {?} targetStaticMethod
	         * @param {?} targetDynamicMethod
	         * @return {?}
	         */
	        CompileQuery.prototype.generateStatements = function (targetStaticMethod, targetDynamicMethod) {
	            var /** @type {?} */ values = createQueryValues(this._values);
	            var /** @type {?} */ updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];
	            if (this.ownerDirectiveExpression) {
	                var /** @type {?} */ valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
	                updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
	            }
	            if (!this.meta.first) {
	                updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
	            }
	            if (this.meta.first && this._isStatic()) {
	                // for queries that don't change and the user asked for a single element,
	                // set it immediately. That is e.g. needed for querying for ViewContainerRefs, ...
	                // we don't do this for QueryLists for now as this would break the timing when
	                // we call QueryList listeners...
	                targetStaticMethod.addStmts(updateStmts);
	            }
	            else {
	                targetDynamicMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));
	            }
	        };
	        return CompileQuery;
	    }());
	    /**
	     * @param {?} viewValues
	     * @return {?}
	     */
	    function createQueryValues(viewValues) {
	        return ListWrapper.flatten(viewValues.values.map(function (entry) {
	            if (entry instanceof ViewQueryValues) {
	                return mapNestedViews(entry.view.declarationElement.viewContainer, entry.view, createQueryValues(entry));
	            }
	            else {
	                return (entry);
	            }
	        }));
	    }
	    /**
	     * @param {?} viewContainer
	     * @param {?} view
	     * @param {?} expressions
	     * @return {?}
	     */
	    function mapNestedViews(viewContainer, view, expressions) {
	        var /** @type {?} */ adjustedExpressions = expressions.map(function (expr) { return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr); });
	        return viewContainer.callMethod('mapNestedViews', [
	            variable(view.className),
	            fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))], DYNAMIC_TYPE)
	        ]);
	    }
	    /**
	     * @param {?} propertyName
	     * @param {?} compileView
	     * @return {?}
	     */
	    function createQueryList(propertyName, compileView) {
	        compileView.fields.push(new ClassField(propertyName, importType(createIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])));
	        var /** @type {?} */ expr = THIS_EXPR.prop(propertyName);
	        compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName)
	            .set(importExpr(createIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE]).instantiate([]))
	            .toStmt());
	        return expr;
	    }
	    /**
	     * @param {?} map
	     * @param {?} query
	     * @return {?}
	     */
	    function addQueryToTokenMap(map, query) {
	        query.meta.selectors.forEach(function (selector) {
	            var /** @type {?} */ entry = map.get(tokenReference(selector));
	            if (!entry) {
	                entry = [];
	                map.set(tokenReference(selector), entry);
	            }
	            entry.push(query);
	        });
	    }

	    var ViewTypeEnum = (function () {
	        function ViewTypeEnum() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ViewTypeEnum.fromValue = function (value) {
	            return createEnumExpression(Identifiers.ViewType, value);
	        };
	        return ViewTypeEnum;
	    }());
	    var ViewEncapsulationEnum = (function () {
	        function ViewEncapsulationEnum() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ViewEncapsulationEnum.fromValue = function (value) {
	            return createEnumExpression(Identifiers.ViewEncapsulation, value);
	        };
	        return ViewEncapsulationEnum;
	    }());
	    var ChangeDetectorStatusEnum = (function () {
	        function ChangeDetectorStatusEnum() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ChangeDetectorStatusEnum.fromValue = function (value) {
	            return createEnumExpression(Identifiers.ChangeDetectorStatus, value);
	        };
	        return ChangeDetectorStatusEnum;
	    }());
	    var ViewConstructorVars = (function () {
	        function ViewConstructorVars() {
	        }
	        ViewConstructorVars.viewUtils = variable('viewUtils');
	        ViewConstructorVars.parentView = variable('parentView');
	        ViewConstructorVars.parentIndex = variable('parentIndex');
	        ViewConstructorVars.parentElement = variable('parentElement');
	        return ViewConstructorVars;
	    }());
	    var ViewProperties = (function () {
	        function ViewProperties() {
	        }
	        ViewProperties.renderer = THIS_EXPR.prop('renderer');
	        ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');
	        return ViewProperties;
	    }());
	    var InjectMethodVars$1 = (function () {
	        function InjectMethodVars() {
	        }
	        InjectMethodVars.token = variable('token');
	        InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');
	        InjectMethodVars.notFoundResult = variable('notFoundResult');
	        return InjectMethodVars;
	    }());
	    var DetectChangesVars = (function () {
	        function DetectChangesVars() {
	        }
	        DetectChangesVars.throwOnChange = variable("throwOnChange");
	        DetectChangesVars.changes = variable("changes");
	        DetectChangesVars.changed = variable("changed");
	        return DetectChangesVars;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var ViewClassDependency = (function () {
	        /**
	         * @param {?} comp
	         * @param {?} name
	         * @param {?} placeholder
	         */
	        function ViewClassDependency(comp, name, placeholder) {
	            this.comp = comp;
	            this.name = name;
	            this.placeholder = placeholder;
	        }
	        return ViewClassDependency;
	    }());
	    var ComponentFactoryDependency$1 = (function () {
	        /**
	         * @param {?} comp
	         * @param {?} placeholder
	         */
	        function ComponentFactoryDependency(comp, placeholder) {
	            this.comp = comp;
	            this.placeholder = placeholder;
	        }
	        return ComponentFactoryDependency;
	    }());
	    var DirectiveWrapperDependency = (function () {
	        /**
	         * @param {?} dir
	         * @param {?} name
	         * @param {?} placeholder
	         */
	        function DirectiveWrapperDependency(dir, name, placeholder) {
	            this.dir = dir;
	            this.name = name;
	            this.placeholder = placeholder;
	        }
	        return DirectiveWrapperDependency;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$24 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var CompileNode = (function () {
	        /**
	         * @param {?} parent
	         * @param {?} view
	         * @param {?} nodeIndex
	         * @param {?} renderNode
	         * @param {?} sourceAst
	         */
	        function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
	            this.parent = parent;
	            this.view = view;
	            this.nodeIndex = nodeIndex;
	            this.renderNode = renderNode;
	            this.sourceAst = sourceAst;
	        }
	        /**
	         * @return {?}
	         */
	        CompileNode.prototype.isNull = function () { return !this.renderNode; };
	        /**
	         * @return {?}
	         */
	        CompileNode.prototype.isRootElement = function () { return this.view != this.parent.view; };
	        return CompileNode;
	    }());
	    var CompileElement = (function (_super) {
	        __extends$24(CompileElement, _super);
	        /**
	         * @param {?} parent
	         * @param {?} view
	         * @param {?} nodeIndex
	         * @param {?} renderNode
	         * @param {?} sourceAst
	         * @param {?} component
	         * @param {?} _directives
	         * @param {?} _resolvedProvidersArray
	         * @param {?} hasViewContainer
	         * @param {?} hasEmbeddedView
	         * @param {?} references
	         */
	        function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references) {
	            var _this = this;
	            _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
	            this.component = component;
	            this._directives = _directives;
	            this._resolvedProvidersArray = _resolvedProvidersArray;
	            this.hasViewContainer = hasViewContainer;
	            this.hasEmbeddedView = hasEmbeddedView;
	            this.compViewExpr = null;
	            this.instances = new Map();
	            this.directiveWrapperInstance = new Map();
	            this._queryCount = 0;
	            this._queries = new Map();
	            this.contentNodesByNgContentIndex = null;
	            this.referenceTokens = {};
	            references.forEach(function (ref) { return _this.referenceTokens[ref.name] = ref.value; });
	            this.elementRef =
	                importExpr(createIdentifier(Identifiers.ElementRef)).instantiate([this.renderNode]);
	            this.instances.set(resolveIdentifier(Identifiers.ElementRef), this.elementRef);
	            this.instances.set(resolveIdentifier(Identifiers.Injector), THIS_EXPR.callMethod('injector', [literal(this.nodeIndex)]));
	            this.instances.set(resolveIdentifier(Identifiers.Renderer), THIS_EXPR.prop('renderer'));
	            if (this.hasViewContainer || this.hasEmbeddedView) {
	                this._createViewContainer();
	            }
	            if (this.component) {
	                this._createComponentFactoryResolver();
	            }
	        }
	        /**
	         * @return {?}
	         */
	        CompileElement.createNull = function () {
	            return new CompileElement(null, null, null, null, null, null, [], [], false, false, []);
	        };
	        /**
	         * @return {?}
	         */
	        CompileElement.prototype._createViewContainer = function () {
	            var /** @type {?} */ fieldName = "_vc_" + this.nodeIndex;
	            var /** @type {?} */ parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
	            // private is fine here as no child view will reference a ViewContainer
	            this.view.fields.push(new ClassField(fieldName, importType(createIdentifier(Identifiers.ViewContainer)), [StmtModifier.Private]));
	            var /** @type {?} */ statement = THIS_EXPR.prop(fieldName)
	                .set(importExpr(createIdentifier(Identifiers.ViewContainer)).instantiate([
	                literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode
	            ]))
	                .toStmt();
	            this.view.createMethod.addStmt(statement);
	            this.viewContainer = THIS_EXPR.prop(fieldName);
	            this.instances.set(resolveIdentifier(Identifiers.ViewContainer), this.viewContainer);
	            this.view.viewContainers.push(this.viewContainer);
	        };
	        /**
	         * @return {?}
	         */
	        CompileElement.prototype._createComponentFactoryResolver = function () {
	            var _this = this;
	            var /** @type {?} */ entryComponents = this.component.entryComponents.map(function (entryComponent) {
	                var /** @type {?} */ id = { reference: null };
	                _this.view.targetDependencies.push(new ComponentFactoryDependency$1(entryComponent, id));
	                return id;
	            });
	            if (!entryComponents || entryComponents.length === 0) {
	                return;
	            }
	            var /** @type {?} */ createComponentFactoryResolverExpr = importExpr(createIdentifier(Identifiers.CodegenComponentFactoryResolver)).instantiate([
	                literalArr(entryComponents.map(function (entryComponent) { return importExpr(entryComponent); })),
	                injectFromViewParentInjector(this.view, createIdentifierToken(Identifiers.ComponentFactoryResolver), false)
	            ]);
	            var /** @type {?} */ provider = {
	                token: createIdentifierToken(Identifiers.ComponentFactoryResolver),
	                useValue: createComponentFactoryResolverExpr
	            };
	            // Add ComponentFactoryResolver as first provider as it does not have deps on other providers
	            // ProviderAstType.PrivateService as only the component and its view can see it,
	            // but nobody else
	            this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], ProviderAstType.PrivateService, [], this.sourceAst.sourceSpan));
	        };
	        /**
	         * @param {?} compViewExpr
	         * @return {?}
	         */
	        CompileElement.prototype.setComponentView = function (compViewExpr) {
	            this.compViewExpr = compViewExpr;
	            this.contentNodesByNgContentIndex =
	                new Array(this.component.template.ngContentSelectors.length);
	            for (var /** @type {?} */ i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
	                this.contentNodesByNgContentIndex[i] = [];
	            }
	        };
	        /**
	         * @param {?} embeddedView
	         * @return {?}
	         */
	        CompileElement.prototype.setEmbeddedView = function (embeddedView) {
	            this.embeddedView = embeddedView;
	            if (isPresent(embeddedView)) {
	                var /** @type {?} */ createTemplateRefExpr = importExpr(createIdentifier(Identifiers.TemplateRef_)).instantiate([
	                    THIS_EXPR, literal(this.nodeIndex), this.renderNode
	                ]);
	                var /** @type {?} */ provider = {
	                    token: createIdentifierToken(Identifiers.TemplateRef),
	                    useValue: createTemplateRefExpr
	                };
	                // Add TemplateRef as first provider as it does not have deps on other providers
	                this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], ProviderAstType.Builtin, [], this.sourceAst.sourceSpan));
	            }
	        };
	        /**
	         * @return {?}
	         */
	        CompileElement.prototype.beforeChildren = function () {
	            var _this = this;
	            if (this.hasViewContainer) {
	                this.instances.set(resolveIdentifier(Identifiers.ViewContainerRef), this.viewContainer.prop('vcRef'));
	            }
	            this._resolvedProviders = new Map();
	            this._resolvedProvidersArray.forEach(function (provider) { return _this._resolvedProviders.set(tokenReference(provider.token), provider); });
	            // create all the provider instances, some in the view constructor,
	            // some as getters. We rely on the fact that they are already sorted topologically.
	            Array.from(this._resolvedProviders.values()).forEach(function (resolvedProvider) {
	                var /** @type {?} */ isDirectiveWrapper = resolvedProvider.providerType === ProviderAstType.Component ||
	                    resolvedProvider.providerType === ProviderAstType.Directive;
	                var /** @type {?} */ providerValueExpressions = resolvedProvider.providers.map(function (provider) {
	                    if (provider.useExisting) {
	                        return _this._getDependency(resolvedProvider.providerType, { token: provider.useExisting });
	                    }
	                    else if (provider.useFactory) {
	                        var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;
	                        var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
	                        return importExpr(provider.useFactory).callFn(depsExpr);
	                    }
	                    else if (provider.useClass) {
	                        var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;
	                        var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
	                        if (isDirectiveWrapper) {
	                            var /** @type {?} */ directiveWrapperIdentifier = { reference: null };
	                            _this.view.targetDependencies.push(new DirectiveWrapperDependency(provider.useClass, DirectiveWrapperCompiler.dirWrapperClassName(provider.useClass), directiveWrapperIdentifier));
	                            return DirectiveWrapperExpressions.create(directiveWrapperIdentifier, depsExpr);
	                        }
	                        else {
	                            return importExpr(provider.useClass)
	                                .instantiate(depsExpr, importType(provider.useClass));
	                        }
	                    }
	                    else {
	                        return convertValueToOutputAst(provider.useValue);
	                    }
	                });
	                var /** @type {?} */ propName = "_" + tokenName(resolvedProvider.token) + "_" + _this.nodeIndex + "_" + _this.instances.size;
	                var /** @type {?} */ instance = createProviderProperty(propName, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
	                if (isDirectiveWrapper) {
	                    _this.directiveWrapperInstance.set(tokenReference(resolvedProvider.token), instance);
	                    _this.instances.set(tokenReference(resolvedProvider.token), DirectiveWrapperExpressions.context(instance));
	                }
	                else {
	                    _this.instances.set(tokenReference(resolvedProvider.token), instance);
	                }
	            });
	            var _loop_1 = function(i) {
	                var /** @type {?} */ directive = this_1._directives[i];
	                var /** @type {?} */ directiveInstance = this_1.instances.get(tokenReference(identifierToken(directive.type)));
	                directive.queries.forEach(function (queryMeta) { _this._addQuery(queryMeta, directiveInstance); });
	            };
	            var this_1 = this;
	            for (var /** @type {?} */ i = 0; i < this._directives.length; i++) {
	                _loop_1(i);
	            }
	            Object.keys(this.referenceTokens).forEach(function (varName) {
	                var /** @type {?} */ token = _this.referenceTokens[varName];
	                var /** @type {?} */ varValue;
	                if (token) {
	                    varValue = _this.instances.get(tokenReference(token));
	                }
	                else {
	                    varValue = _this.renderNode;
	                }
	                _this.view.locals.set(varName, varValue);
	            });
	        };
	        /**
	         * @param {?} childNodeCount
	         * @return {?}
	         */
	        CompileElement.prototype.afterChildren = function (childNodeCount) {
	            var _this = this;
	            Array.from(this._resolvedProviders.values()).forEach(function (resolvedProvider) {
	                // Note: afterChildren is called after recursing into children.
	                // This is good so that an injector match in an element that is closer to a requesting element
	                // matches first.
	                var /** @type {?} */ providerExpr = _this.instances.get(tokenReference(resolvedProvider.token));
	                // Note: view providers are only visible on the injector of that element.
	                // This is not fully correct as the rules during codegen don't allow a directive
	                // to get hold of a view provdier on the same element. We still do this semantic
	                // as it simplifies our model to having only one runtime injector per element.
	                var /** @type {?} */ providerChildNodeCount = resolvedProvider.providerType === ProviderAstType.PrivateService ? 0 : childNodeCount;
	                _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
	            });
	        };
	        /**
	         * @return {?}
	         */
	        CompileElement.prototype.finish = function () {
	            var _this = this;
	            Array.from(this._queries.values())
	                .forEach(function (queries) { return queries.forEach(function (q) { return q.generateStatements(_this.view.createMethod, _this.view.updateContentQueriesMethod); }); });
	        };
	        /**
	         * @param {?} ngContentIndex
	         * @param {?} nodeExpr
	         * @return {?}
	         */
	        CompileElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {
	            this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
	        };
	        /**
	         * @return {?}
	         */
	        CompileElement.prototype.getComponent = function () {
	            return isPresent(this.component) ?
	                this.instances.get(tokenReference(identifierToken(this.component.type))) :
	                null;
	        };
	        /**
	         * @return {?}
	         */
	        CompileElement.prototype.getProviderTokens = function () {
	            return Array.from(this._resolvedProviders.values()).map(function (provider) { return provider.token; });
	        };
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        CompileElement.prototype.getQueriesFor = function (token) {
	            var /** @type {?} */ result = [];
	            var /** @type {?} */ currentEl = this;
	            var /** @type {?} */ distance = 0;
	            var /** @type {?} */ queries;
	            while (!currentEl.isNull()) {
	                queries = currentEl._queries.get(tokenReference(token));
	                if (isPresent(queries)) {
	                    result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));
	                }
	                if (currentEl._directives.length > 0) {
	                    distance++;
	                }
	                currentEl = currentEl.parent;
	            }
	            queries = this.view.componentView.viewQueries.get(tokenReference(token));
	            if (isPresent(queries)) {
	                result.push.apply(result, queries);
	            }
	            return result;
	        };
	        /**
	         * @param {?} queryMeta
	         * @param {?} directiveInstance
	         * @return {?}
	         */
	        CompileElement.prototype._addQuery = function (queryMeta, directiveInstance) {
	            var /** @type {?} */ propName = "_query_" + tokenName(queryMeta.selectors[0]) + "_" + this.nodeIndex + "_" + this._queryCount++;
	            var /** @type {?} */ queryList = createQueryList(propName, this.view);
	            var /** @type {?} */ query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);
	            addQueryToTokenMap(this._queries, query);
	            return query;
	        };
	        /**
	         * @param {?} requestingProviderType
	         * @param {?} dep
	         * @return {?}
	         */
	        CompileElement.prototype._getLocalDependency = function (requestingProviderType, dep) {
	            var /** @type {?} */ result = null;
	            if (isPresent(dep.token)) {
	                // access builtins with special visibility
	                if (!result) {
	                    if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ChangeDetectorRef)) {
	                        if (requestingProviderType === ProviderAstType.Component) {
	                            return this.compViewExpr.prop('ref');
	                        }
	                        else {
	                            return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);
	                        }
	                    }
	                }
	                // access regular providers on the element
	                if (!result) {
	                    var /** @type {?} */ resolvedProvider = this._resolvedProviders.get(tokenReference(dep.token));
	                    // don't allow directives / public services to access private services.
	                    // only components and private services can access private services.
	                    if (resolvedProvider && (requestingProviderType === ProviderAstType.Directive ||
	                        requestingProviderType === ProviderAstType.PublicService) &&
	                        resolvedProvider.providerType === ProviderAstType.PrivateService) {
	                        return null;
	                    }
	                    result = this.instances.get(tokenReference(dep.token));
	                }
	            }
	            return result;
	        };
	        /**
	         * @param {?} requestingProviderType
	         * @param {?} dep
	         * @return {?}
	         */
	        CompileElement.prototype._getDependency = function (requestingProviderType, dep) {
	            var /** @type {?} */ currElement = this;
	            var /** @type {?} */ result = null;
	            if (dep.isValue) {
	                result = literal(dep.value);
	            }
	            if (!result && !dep.isSkipSelf) {
	                result = this._getLocalDependency(requestingProviderType, dep);
	            }
	            // check parent elements
	            while (!result && !currElement.parent.isNull()) {
	                currElement = currElement.parent;
	                result = currElement._getLocalDependency(ProviderAstType.PublicService, { token: dep.token });
	            }
	            if (!result) {
	                result = injectFromViewParentInjector(this.view, dep.token, dep.isOptional);
	            }
	            if (!result) {
	                result = NULL_EXPR;
	            }
	            return getPropertyInView(result, this.view, currElement.view);
	        };
	        return CompileElement;
	    }(CompileNode));
	    /**
	     * @param {?} nodeIndex
	     * @param {?} childNodeCount
	     * @param {?} provider
	     * @param {?} providerExpr
	     * @return {?}
	     */
	    function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
	        var /** @type {?} */ indexCondition;
	        if (childNodeCount > 0) {
	            indexCondition = literal(nodeIndex)
	                .lowerEquals(InjectMethodVars$1.requestNodeIndex)
	                .and(InjectMethodVars$1.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));
	        }
	        else {
	            indexCondition = literal(nodeIndex).identical(InjectMethodVars$1.requestNodeIndex);
	        }
	        return new IfStmt(InjectMethodVars$1.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);
	    }
	    /**
	     * @param {?} propName
	     * @param {?} providerValueExpressions
	     * @param {?} isMulti
	     * @param {?} isEager
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function createProviderProperty(propName, providerValueExpressions, isMulti, isEager, compileElement) {
	        var /** @type {?} */ view = compileElement.view;
	        var /** @type {?} */ resolvedProviderValueExpr;
	        var /** @type {?} */ type;
	        if (isMulti) {
	            resolvedProviderValueExpr = literalArr(providerValueExpressions);
	            type = new ArrayType(DYNAMIC_TYPE);
	        }
	        else {
	            resolvedProviderValueExpr = providerValueExpressions[0];
	            type = providerValueExpressions[0].type;
	        }
	        if (!type) {
	            type = DYNAMIC_TYPE;
	        }
	        if (isEager) {
	            view.fields.push(new ClassField(propName, type));
	            view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
	        }
	        else {
	            var /** @type {?} */ internalField = "_" + propName;
	            view.fields.push(new ClassField(internalField, type));
	            var /** @type {?} */ getter = new CompileMethod(view);
	            getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	            // Note: Equals is important for JS so that it also checks the undefined case!
	            getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
	            getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));
	            view.getters.push(new ClassGetter(propName, getter.finish(), type));
	        }
	        return THIS_EXPR.prop(propName);
	    }

	    var CompilePipe = (function () {
	        /**
	         * @param {?} view
	         * @param {?} meta
	         */
	        function CompilePipe(view, meta) {
	            var _this = this;
	            this.view = view;
	            this.meta = meta;
	            this._purePipeProxyCount = 0;
	            this.instance = THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
	            var deps = this.meta.type.diDeps.map(function (diDep) {
	                if (tokenReference(diDep.token) === resolveIdentifier(Identifiers.ChangeDetectorRef)) {
	                    return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
	                }
	                return injectFromViewParentInjector(view, diDep.token, false);
	            });
	            this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));
	            this.view.createMethod.resetDebugInfo(null, null);
	            this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name)
	                .set(importExpr(this.meta.type).instantiate(deps))
	                .toStmt());
	        }
	        /**
	         * @param {?} view
	         * @param {?} name
	         * @param {?} args
	         * @return {?}
	         */
	        CompilePipe.call = function (view, name, args) {
	            var /** @type {?} */ compView = view.componentView;
	            var /** @type {?} */ meta = _findPipeMeta(compView, name);
	            var /** @type {?} */ pipe;
	            if (meta.pure) {
	                // pure pipes live on the component view
	                pipe = compView.purePipes.get(name);
	                if (!pipe) {
	                    pipe = new CompilePipe(compView, meta);
	                    compView.purePipes.set(name, pipe);
	                    compView.pipes.push(pipe);
	                }
	            }
	            else {
	                // Non pure pipes live on the view that called it
	                pipe = new CompilePipe(view, meta);
	                view.pipes.push(pipe);
	            }
	            return pipe._call(view, args);
	        };
	        Object.defineProperty(CompilePipe.prototype, "pure", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.meta.pure; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} callingView
	         * @param {?} args
	         * @return {?}
	         */
	        CompilePipe.prototype._call = function (callingView, args) {
	            if (this.meta.pure) {
	                // PurePipeProxies live on the view that called them.
	                var /** @type {?} */ purePipeProxyInstance = THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxyCount++);
	                var /** @type {?} */ pipeInstanceSeenFromPureProxy = getPropertyInView(this.instance, callingView, this.view);
	                createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform')
	                    .callMethod(BuiltinMethod.Bind, [pipeInstanceSeenFromPureProxy]), args.length, purePipeProxyInstance, { fields: callingView.fields, ctorStmts: callingView.createMethod });
	                return importExpr(createIdentifier(Identifiers.castByValue))
	                    .callFn([purePipeProxyInstance, pipeInstanceSeenFromPureProxy.prop('transform')])
	                    .callFn(args);
	            }
	            else {
	                return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
	            }
	        };
	        return CompilePipe;
	    }());
	    /**
	     * @param {?} view
	     * @param {?} name
	     * @return {?}
	     */
	    function _findPipeMeta(view, name) {
	        var /** @type {?} */ pipeMeta = null;
	        for (var /** @type {?} */ i = view.pipeMetas.length - 1; i >= 0; i--) {
	            var /** @type {?} */ localPipeMeta = view.pipeMetas[i];
	            if (localPipeMeta.name == name) {
	                pipeMeta = localPipeMeta;
	                break;
	            }
	        }
	        if (!pipeMeta) {
	            throw new Error("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
	        }
	        return pipeMeta;
	    }

	    var CompileViewRootNodeType = {};
	    CompileViewRootNodeType.Node = 0;
	    CompileViewRootNodeType.ViewContainer = 1;
	    CompileViewRootNodeType.NgContent = 2;
	    CompileViewRootNodeType[CompileViewRootNodeType.Node] = "Node";
	    CompileViewRootNodeType[CompileViewRootNodeType.ViewContainer] = "ViewContainer";
	    CompileViewRootNodeType[CompileViewRootNodeType.NgContent] = "NgContent";
	    var CompileViewRootNode = (function () {
	        /**
	         * @param {?} type
	         * @param {?} expr
	         * @param {?=} ngContentIndex
	         */
	        function CompileViewRootNode(type, expr, ngContentIndex) {
	            this.type = type;
	            this.expr = expr;
	            this.ngContentIndex = ngContentIndex;
	        }
	        return CompileViewRootNode;
	    }());
	    var CompileView = (function () {
	        /**
	         * @param {?} component
	         * @param {?} genConfig
	         * @param {?} pipeMetas
	         * @param {?} styles
	         * @param {?} animations
	         * @param {?} viewIndex
	         * @param {?} declarationElement
	         * @param {?} templateVariableBindings
	         * @param {?} targetDependencies
	         */
	        function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings, targetDependencies) {
	            var _this = this;
	            this.component = component;
	            this.genConfig = genConfig;
	            this.pipeMetas = pipeMetas;
	            this.styles = styles;
	            this.animations = animations;
	            this.viewIndex = viewIndex;
	            this.declarationElement = declarationElement;
	            this.templateVariableBindings = templateVariableBindings;
	            this.targetDependencies = targetDependencies;
	            this.viewChildren = [];
	            this.nodes = [];
	            this.rootNodes = [];
	            this.lastRenderNode = NULL_EXPR;
	            this.viewContainers = [];
	            this.methods = [];
	            this.ctorStmts = [];
	            this.fields = [];
	            this.getters = [];
	            this.disposables = [];
	            this.purePipes = new Map();
	            this.pipes = [];
	            this.locals = new Map();
	            this.literalArrayCount = 0;
	            this.literalMapCount = 0;
	            this.pipeCount = 0;
	            this.createMethod = new CompileMethod(this);
	            this.animationBindingsMethod = new CompileMethod(this);
	            this.injectorGetMethod = new CompileMethod(this);
	            this.updateContentQueriesMethod = new CompileMethod(this);
	            this.dirtyParentQueriesMethod = new CompileMethod(this);
	            this.updateViewQueriesMethod = new CompileMethod(this);
	            this.detectChangesInInputsMethod = new CompileMethod(this);
	            this.detectChangesRenderPropertiesMethod = new CompileMethod(this);
	            this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);
	            this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);
	            this.destroyMethod = new CompileMethod(this);
	            this.detachMethod = new CompileMethod(this);
	            this.viewType = getViewType(component, viewIndex);
	            this.className = getViewClassName(component, viewIndex);
	            this.classType = expressionType(variable(this.className));
	            this.classExpr = variable(this.className);
	            if (this.viewType === ViewType.COMPONENT || this.viewType === ViewType.HOST) {
	                this.componentView = this;
	            }
	            else {
	                this.componentView = this.declarationElement.view.componentView;
	            }
	            this.componentContext =
	                getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);
	            var viewQueries = new Map();
	            if (this.viewType === ViewType.COMPONENT) {
	                var directiveInstance_1 = THIS_EXPR.prop('context');
	                this.component.viewQueries.forEach(function (queryMeta, queryIndex) {
	                    var propName = "_viewQuery_" + tokenName(queryMeta.selectors[0]) + "_" + queryIndex;
	                    var queryList = createQueryList(propName, _this);
	                    var query = new CompileQuery(queryMeta, queryList, directiveInstance_1, _this);
	                    addQueryToTokenMap(viewQueries, query);
	                });
	            }
	            this.viewQueries = viewQueries;
	            templateVariableBindings.forEach(function (entry) { _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0])); });
	            if (!this.declarationElement.isNull()) {
	                this.declarationElement.setEmbeddedView(this);
	            }
	        }
	        /**
	         * @param {?} name
	         * @param {?} input
	         * @param {?} args
	         * @return {?}
	         */
	        CompileView.prototype.callPipe = function (name, input, args) {
	            return CompilePipe.call(this, name, [input].concat(args));
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        CompileView.prototype.getLocal = function (name) {
	            if (name == EventHandlerVars.event.name) {
	                return EventHandlerVars.event;
	            }
	            var /** @type {?} */ currView = this;
	            var /** @type {?} */ result = currView.locals.get(name);
	            while (!result && isPresent(currView.declarationElement.view)) {
	                currView = currView.declarationElement.view;
	                result = currView.locals.get(name);
	            }
	            if (isPresent(result)) {
	                return getPropertyInView(result, this, currView);
	            }
	            else {
	                return null;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        CompileView.prototype.finish = function () {
	            var _this = this;
	            Array.from(this.viewQueries.values())
	                .forEach(function (queries) { return queries.forEach(function (q) { return q.generateStatements(_this.createMethod, _this.updateViewQueriesMethod); }); });
	        };
	        return CompileView;
	    }());
	    /**
	     * @param {?} component
	     * @param {?} embeddedTemplateIndex
	     * @return {?}
	     */
	    function getViewType(component, embeddedTemplateIndex) {
	        if (embeddedTemplateIndex > 0) {
	            return ViewType.EMBEDDED;
	        }
	        if (component.isHost) {
	            return ViewType.HOST;
	        }
	        return ViewType.COMPONENT;
	    }

	    /**
	     * @param {?} boundEvents
	     * @param {?} directives
	     * @param {?} compileElement
	     * @param {?} bindToRenderer
	     * @return {?}
	     */
	    function bindOutputs(boundEvents, directives, compileElement, bindToRenderer) {
	        var /** @type {?} */ usedEvents = collectEvents(boundEvents, directives);
	        if (!usedEvents.size) {
	            return false;
	        }
	        if (bindToRenderer) {
	            subscribeToRenderEvents(usedEvents, compileElement);
	        }
	        subscribeToDirectiveEvents(usedEvents, directives, compileElement);
	        generateHandleEventMethod(boundEvents, directives, compileElement);
	        return true;
	    }
	    /**
	     * @param {?} boundEvents
	     * @param {?} directives
	     * @return {?}
	     */
	    function collectEvents(boundEvents, directives) {
	        var /** @type {?} */ usedEvents = new Map();
	        boundEvents.forEach(function (event) { usedEvents.set(event.fullName, event); });
	        directives.forEach(function (dirAst) {
	            dirAst.hostEvents.forEach(function (event) { usedEvents.set(event.fullName, event); });
	        });
	        return usedEvents;
	    }
	    /**
	     * @param {?} usedEvents
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function subscribeToRenderEvents(usedEvents, compileElement) {
	        var /** @type {?} */ eventAndTargetExprs = [];
	        usedEvents.forEach(function (event) {
	            if (!event.phase) {
	                eventAndTargetExprs.push(literal(event.name), literal(event.target));
	            }
	        });
	        if (eventAndTargetExprs.length) {
	            var /** @type {?} */ disposableVar = variable("disposable_" + compileElement.view.disposables.length);
	            compileElement.view.disposables.push(disposableVar);
	            compileElement.view.createMethod.addStmt(disposableVar
	                .set(importExpr(createIdentifier(Identifiers.subscribeToRenderElement)).callFn([
	                THIS_EXPR, compileElement.renderNode, createInlineArray(eventAndTargetExprs),
	                handleEventExpr(compileElement)
	            ]))
	                .toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));
	        }
	    }
	    /**
	     * @param {?} usedEvents
	     * @param {?} directives
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function subscribeToDirectiveEvents(usedEvents, directives, compileElement) {
	        var /** @type {?} */ usedEventNames = Array.from(usedEvents.keys());
	        directives.forEach(function (dirAst) {
	            var /** @type {?} */ dirWrapper = compileElement.directiveWrapperInstance.get(dirAst.directive.type.reference);
	            compileElement.view.createMethod.addStmts(DirectiveWrapperExpressions.subscribe(dirAst.directive, dirAst.hostProperties, usedEventNames, dirWrapper, THIS_EXPR, handleEventExpr(compileElement)));
	        });
	    }
	    /**
	     * @param {?} boundEvents
	     * @param {?} directives
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function generateHandleEventMethod(boundEvents, directives, compileElement) {
	        var /** @type {?} */ hasComponentHostListener = directives.some(function (dirAst) { return dirAst.hostEvents.some(function (event) { return dirAst.directive.isComponent; }); });
	        var /** @type {?} */ markPathToRootStart = hasComponentHostListener ? compileElement.compViewExpr : THIS_EXPR;
	        var /** @type {?} */ handleEventStmts = new CompileMethod(compileElement.view);
	        handleEventStmts.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	        handleEventStmts.push(markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt());
	        var /** @type {?} */ eventNameVar = variable('eventName');
	        var /** @type {?} */ resultVar = variable('result');
	        handleEventStmts.push(resultVar.set(literal(true)).toDeclStmt(BOOL_TYPE));
	        directives.forEach(function (dirAst, dirIdx) {
	            var /** @type {?} */ dirWrapper = compileElement.directiveWrapperInstance.get(dirAst.directive.type.reference);
	            if (dirAst.hostEvents.length > 0) {
	                handleEventStmts.push(resultVar
	                    .set(DirectiveWrapperExpressions
	                    .handleEvent(dirAst.hostEvents, dirWrapper, eventNameVar, EventHandlerVars.event)
	                    .and(resultVar))
	                    .toStmt());
	            }
	        });
	        boundEvents.forEach(function (renderEvent, renderEventIdx) {
	            var /** @type {?} */ evalResult = convertActionBinding(compileElement.view, compileElement.view, compileElement.view.componentContext, renderEvent.handler, "sub_" + renderEventIdx);
	            var /** @type {?} */ trueStmts = evalResult.stmts;
	            if (evalResult.preventDefault) {
	                trueStmts.push(resultVar.set(evalResult.preventDefault.and(resultVar)).toStmt());
	            }
	            // TODO(tbosch): convert this into a `switch` once our OutputAst supports it.
	            handleEventStmts.push(new IfStmt(eventNameVar.equals(literal(renderEvent.fullName)), trueStmts));
	        });
	        handleEventStmts.push(new ReturnStatement(resultVar));
	        compileElement.view.methods.push(new ClassMethod(getHandleEventMethodName(compileElement.nodeIndex), [
	            new FnParam(eventNameVar.name, STRING_TYPE),
	            new FnParam(EventHandlerVars.event.name, DYNAMIC_TYPE)
	        ], handleEventStmts.finish(), BOOL_TYPE));
	    }
	    /**
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function handleEventExpr(compileElement) {
	        var /** @type {?} */ handleEventMethodName = getHandleEventMethodName(compileElement.nodeIndex);
	        return THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(handleEventMethodName)]);
	    }

	    var /** @type {?} */ STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('numberOfChecks').identical(new LiteralExpr(0));
	    var /** @type {?} */ NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);
	    /**
	     * @param {?} directiveMeta
	     * @param {?} directiveInstance
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	        var /** @type {?} */ view = compileElement.view;
	        var /** @type {?} */ lifecycleHooks = directiveMeta.type.lifecycleHooks;
	        var /** @type {?} */ afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
	        afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	        if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentInit) !== -1) {
	            afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
	        }
	        if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentChecked) !== -1) {
	            afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
	        }
	    }
	    /**
	     * @param {?} directiveMeta
	     * @param {?} directiveInstance
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	        var /** @type {?} */ view = compileElement.view;
	        var /** @type {?} */ lifecycleHooks = directiveMeta.type.lifecycleHooks;
	        var /** @type {?} */ afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
	        afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	        if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewInit) !== -1) {
	            afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
	        }
	        if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewChecked) !== -1) {
	            afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
	        }
	    }
	    /**
	     * @param {?} dir
	     * @param {?} directiveWrapperIntance
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function bindDirectiveWrapperLifecycleCallbacks(dir, directiveWrapperIntance, compileElement) {
	        compileElement.view.destroyMethod.addStmts(DirectiveWrapperExpressions.ngOnDestroy(dir.directive, directiveWrapperIntance));
	        compileElement.view.detachMethod.addStmts(DirectiveWrapperExpressions.ngOnDetach(dir.hostProperties, directiveWrapperIntance, THIS_EXPR, compileElement.compViewExpr || THIS_EXPR, compileElement.renderNode));
	    }
	    /**
	     * @param {?} provider
	     * @param {?} providerInstance
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function bindInjectableDestroyLifecycleCallbacks(provider, providerInstance, compileElement) {
	        var /** @type {?} */ onDestroyMethod = compileElement.view.destroyMethod;
	        onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	        if (provider.providerType !== ProviderAstType.Directive &&
	            provider.providerType !== ProviderAstType.Component &&
	            provider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
	            onDestroyMethod.addStmt(providerInstance.callMethod('ngOnDestroy', []).toStmt());
	        }
	    }
	    /**
	     * @param {?} pipeMeta
	     * @param {?} pipeInstance
	     * @param {?} view
	     * @return {?}
	     */
	    function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
	        var /** @type {?} */ onDestroyMethod = view.destroyMethod;
	        if (pipeMeta.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
	            onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
	        }
	    }

	    /**
	     * @param {?} boundText
	     * @param {?} compileNode
	     * @param {?} view
	     * @return {?}
	     */
	    function bindRenderText(boundText, compileNode, view) {
	        var /** @type {?} */ valueField = createCheckBindingField(view);
	        var /** @type {?} */ evalResult = convertPropertyBinding(view, view, view.componentContext, boundText.value, valueField.bindingId);
	        if (!evalResult) {
	            return null;
	        }
	        view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
	        view.detectChangesRenderPropertiesMethod.addStmts(createCheckBindingStmt(evalResult, valueField.expression, DetectChangesVars.throwOnChange, [THIS_EXPR.prop('renderer')
	                .callMethod('setText', [compileNode.renderNode, evalResult.currValExpr])
	                .toStmt()]));
	    }
	    /**
	     * @param {?} boundProps
	     * @param {?} boundOutputs
	     * @param {?} hasEvents
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function bindRenderInputs(boundProps, boundOutputs, hasEvents, compileElement) {
	        var /** @type {?} */ view = compileElement.view;
	        var /** @type {?} */ renderNode = compileElement.renderNode;
	        boundProps.forEach(function (boundProp) {
	            var /** @type {?} */ bindingField = createCheckBindingField(view);
	            view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
	            var /** @type {?} */ evalResult = convertPropertyBinding(view, view, compileElement.view.componentContext, boundProp.value, bindingField.bindingId);
	            if (!evalResult) {
	                return;
	            }
	            var /** @type {?} */ checkBindingStmts = [];
	            var /** @type {?} */ compileMethod = view.detectChangesRenderPropertiesMethod;
	            switch (boundProp.type) {
	                case PropertyBindingType.Property:
	                case PropertyBindingType.Attribute:
	                case PropertyBindingType.Class:
	                case PropertyBindingType.Style:
	                    checkBindingStmts.push.apply(checkBindingStmts, writeToRenderer(THIS_EXPR, boundProp, renderNode, evalResult.currValExpr, view.genConfig.logBindingUpdate));
	                    break;
	                case PropertyBindingType.Animation:
	                    compileMethod = view.animationBindingsMethod;
	                    var _a = triggerAnimation(THIS_EXPR, THIS_EXPR, boundProp, boundOutputs, (hasEvents ? THIS_EXPR.prop(getHandleEventMethodName(compileElement.nodeIndex)) :
	                        importExpr(createIdentifier(Identifiers.noop)))
	                        .callMethod(BuiltinMethod.Bind, [THIS_EXPR]), compileElement.renderNode, evalResult.currValExpr, bindingField.expression), updateStmts = _a.updateStmts, detachStmts = _a.detachStmts;
	                    checkBindingStmts.push.apply(checkBindingStmts, updateStmts);
	                    view.detachMethod.addStmts(detachStmts);
	                    break;
	            }
	            compileMethod.addStmts(createCheckBindingStmt(evalResult, bindingField.expression, DetectChangesVars.throwOnChange, checkBindingStmts));
	        });
	    }
	    /**
	     * @param {?} directiveAst
	     * @param {?} directiveWrapperInstance
	     * @param {?} compileElement
	     * @param {?} elementName
	     * @param {?} schemaRegistry
	     * @return {?}
	     */
	    function bindDirectiveHostProps(directiveAst, directiveWrapperInstance, compileElement, elementName, schemaRegistry) {
	        // We need to provide the SecurityContext for properties that could need sanitization.
	        var /** @type {?} */ runtimeSecurityCtxExprs = directiveAst.hostProperties.filter(function (boundProp) { return boundProp.needsRuntimeSecurityContext; })
	            .map(function (boundProp) {
	            var /** @type {?} */ ctx;
	            switch (boundProp.type) {
	                case PropertyBindingType.Property:
	                    ctx = schemaRegistry.securityContext(elementName, boundProp.name, false);
	                    break;
	                case PropertyBindingType.Attribute:
	                    ctx = schemaRegistry.securityContext(elementName, boundProp.name, true);
	                    break;
	                default:
	                    throw new Error("Illegal state: Only property / attribute bindings can have an unknown security context! Binding " + boundProp.name);
	            }
	            return createEnumExpression(Identifiers.SecurityContext, ctx);
	        });
	        compileElement.view.detectChangesRenderPropertiesMethod.addStmts(DirectiveWrapperExpressions.checkHost(directiveAst.hostProperties, directiveWrapperInstance, THIS_EXPR, compileElement.compViewExpr || THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange, runtimeSecurityCtxExprs));
	    }
	    /**
	     * @param {?} directiveAst
	     * @param {?} directiveWrapperInstance
	     * @param {?} dirIndex
	     * @param {?} compileElement
	     * @return {?}
	     */
	    function bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement) {
	        var /** @type {?} */ view = compileElement.view;
	        var /** @type {?} */ detectChangesInInputsMethod = view.detectChangesInInputsMethod;
	        detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	        directiveAst.inputs.forEach(function (input, inputIdx) {
	            // Note: We can't use `fields.length` here, as we are not adding a field!
	            var /** @type {?} */ bindingId = compileElement.nodeIndex + "_" + dirIndex + "_" + inputIdx;
	            detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
	            var /** @type {?} */ evalResult = convertPropertyBinding(view, view, view.componentContext, input.value, bindingId);
	            if (!evalResult) {
	                return;
	            }
	            detectChangesInInputsMethod.addStmts(evalResult.stmts);
	            detectChangesInInputsMethod.addStmt(directiveWrapperInstance
	                .callMethod("check_" + input.directiveName, [
	                evalResult.currValExpr, DetectChangesVars.throwOnChange,
	                evalResult.forceUpdate || literal(false)
	            ])
	                .toStmt());
	        });
	        var /** @type {?} */ isOnPushComp = directiveAst.directive.isComponent &&
	            !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
	        var /** @type {?} */ directiveDetectChangesExpr = DirectiveWrapperExpressions.ngDoCheck(directiveWrapperInstance, THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange);
	        var /** @type {?} */ directiveDetectChangesStmt = isOnPushComp ?
	            new IfStmt(directiveDetectChangesExpr, [compileElement.compViewExpr.callMethod('markAsCheckOnce', []).toStmt()]) :
	            directiveDetectChangesExpr.toStmt();
	        detectChangesInInputsMethod.addStmt(directiveDetectChangesStmt);
	    }

	    /**
	     * @param {?} ce
	     * @return {?}
	     */
	    function bindQueryValues(ce) {
	        var /** @type {?} */ queriesWithReads = [];
	        ce.getProviderTokens().forEach(function (token) {
	            var /** @type {?} */ queriesForProvider = ce.getQueriesFor(token);
	            queriesWithReads.push.apply(queriesWithReads, queriesForProvider.map(function (query) { return new _QueryWithRead(query, token); }));
	        });
	        Object.keys(ce.referenceTokens).forEach(function (varName) {
	            var /** @type {?} */ varToken = { value: varName };
	            queriesWithReads.push.apply(queriesWithReads, ce.getQueriesFor(varToken).map(function (query) { return new _QueryWithRead(query, varToken); }));
	        });
	        queriesWithReads.forEach(function (queryWithRead) {
	            var /** @type {?} */ value;
	            if (queryWithRead.read.identifier) {
	                // query for an identifier
	                value = ce.instances.get(tokenReference(queryWithRead.read));
	            }
	            else {
	                // query for a reference
	                var /** @type {?} */ token = ce.referenceTokens[queryWithRead.read.value];
	                if (token) {
	                    value = ce.instances.get(tokenReference(token));
	                }
	                else {
	                    value = ce.elementRef;
	                }
	            }
	            if (value) {
	                queryWithRead.query.addValue(value, ce.view);
	            }
	        });
	    }
	    var _QueryWithRead = (function () {
	        /**
	         * @param {?} query
	         * @param {?} match
	         */
	        function _QueryWithRead(query, match) {
	            this.query = query;
	            this.read = query.meta.read || match;
	        }
	        return _QueryWithRead;
	    }());

	    /**
	     * @param {?} view
	     * @param {?} parsedTemplate
	     * @param {?} schemaRegistry
	     * @return {?}
	     */
	    function bindView(view, parsedTemplate, schemaRegistry) {
	        var /** @type {?} */ visitor = new ViewBinderVisitor(view, schemaRegistry);
	        templateVisitAll(visitor, parsedTemplate);
	        view.pipes.forEach(function (pipe) { bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view); });
	    }
	    var ViewBinderVisitor = (function () {
	        /**
	         * @param {?} view
	         * @param {?} _schemaRegistry
	         */
	        function ViewBinderVisitor(view, _schemaRegistry) {
	            this.view = view;
	            this._schemaRegistry = _schemaRegistry;
	            this._nodeIndex = 0;
	        }
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitBoundText = function (ast, parent) {
	            var /** @type {?} */ node = this.view.nodes[this._nodeIndex++];
	            bindRenderText(ast, node, this.view);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitText = function (ast, parent) {
	            this._nodeIndex++;
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitNgContent = function (ast, parent) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitElement = function (ast, parent) {
	            var _this = this;
	            var /** @type {?} */ compileElement = (this.view.nodes[this._nodeIndex++]);
	            bindQueryValues(compileElement);
	            var /** @type {?} */ hasEvents = bindOutputs(ast.outputs, ast.directives, compileElement, true);
	            bindRenderInputs(ast.inputs, ast.outputs, hasEvents, compileElement);
	            ast.directives.forEach(function (directiveAst, dirIndex) {
	                var /** @type {?} */ directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
	                bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement);
	                bindDirectiveHostProps(directiveAst, directiveWrapperInstance, compileElement, ast.name, _this._schemaRegistry);
	            });
	            templateVisitAll(this, ast.children, compileElement);
	            // afterContent and afterView lifecycles need to be called bottom up
	            // so that children are notified before parents
	            ast.directives.forEach(function (directiveAst) {
	                var /** @type {?} */ directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
	                var /** @type {?} */ directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
	                bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveWrapperLifecycleCallbacks(directiveAst, directiveWrapperInstance, compileElement);
	            });
	            ast.providers.forEach(function (providerAst) {
	                var /** @type {?} */ providerInstance = compileElement.instances.get(tokenReference(providerAst.token));
	                bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
	            });
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
	            var /** @type {?} */ compileElement = (this.view.nodes[this._nodeIndex++]);
	            bindQueryValues(compileElement);
	            bindOutputs(ast.outputs, ast.directives, compileElement, false);
	            ast.directives.forEach(function (directiveAst, dirIndex) {
	                var /** @type {?} */ directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
	                var /** @type {?} */ directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
	                bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement);
	                bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveWrapperLifecycleCallbacks(directiveAst, directiveWrapperInstance, compileElement);
	            });
	            ast.providers.forEach(function (providerAst) {
	                var /** @type {?} */ providerInstance = compileElement.instances.get(tokenReference(providerAst.token));
	                bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
	            });
	            bindView(compileElement.embeddedView, ast.children, this._schemaRegistry);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} eventTargetAndNames
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ViewBinderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
	        return ViewBinderVisitor;
	    }());

	    var /** @type {?} */ IMPLICIT_TEMPLATE_VAR = '\$implicit';
	    var /** @type {?} */ CLASS_ATTR$1 = 'class';
	    var /** @type {?} */ STYLE_ATTR = 'style';
	    var /** @type {?} */ NG_CONTAINER_TAG = 'ng-container';
	    var /** @type {?} */ parentRenderNodeVar = variable('parentRenderNode');
	    var /** @type {?} */ rootSelectorVar = variable('rootSelector');
	    /**
	     * @param {?} view
	     * @param {?} template
	     * @param {?} targetDependencies
	     * @return {?}
	     */
	    function buildView(view, template, targetDependencies) {
	        var /** @type {?} */ builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
	        var /** @type {?} */ parentEl = view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent;
	        templateVisitAll(builderVisitor, template, parentEl);
	        if (view.viewType === ViewType.EMBEDDED || view.viewType === ViewType.HOST) {
	            view.lastRenderNode = builderVisitor.getOrCreateLastRenderNode();
	        }
	        return builderVisitor.nestedViewCount;
	    }
	    /**
	     * @param {?} view
	     * @param {?} targetStatements
	     * @return {?}
	     */
	    function finishView(view, targetStatements) {
	        view.nodes.forEach(function (node) {
	            if (node instanceof CompileElement) {
	                node.finish();
	                if (node.hasEmbeddedView) {
	                    finishView(node.embeddedView, targetStatements);
	                }
	            }
	        });
	        view.finish();
	        createViewTopLevelStmts(view, targetStatements);
	    }
	    var ViewBuilderVisitor = (function () {
	        /**
	         * @param {?} view
	         * @param {?} targetDependencies
	         */
	        function ViewBuilderVisitor(view, targetDependencies) {
	            this.view = view;
	            this.targetDependencies = targetDependencies;
	            this.nestedViewCount = 0;
	        }
	        /**
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype._isRootNode = function (parent) { return parent.view !== this.view; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype._addRootNodeAndProject = function (node) {
	            var /** @type {?} */ projectedNode = _getOuterContainerOrSelf(node);
	            var /** @type {?} */ parent = projectedNode.parent;
	            var /** @type {?} */ ngContentIndex = ((projectedNode.sourceAst)).ngContentIndex;
	            var /** @type {?} */ viewContainer = (node instanceof CompileElement && node.hasViewContainer) ? node.viewContainer : null;
	            if (this._isRootNode(parent)) {
	                if (this.view.viewType !== ViewType.COMPONENT) {
	                    this.view.rootNodes.push(new CompileViewRootNode(viewContainer ? CompileViewRootNodeType.ViewContainer : CompileViewRootNodeType.Node, viewContainer || node.renderNode));
	                }
	            }
	            else if (isPresent(parent.component) && isPresent(ngContentIndex)) {
	                parent.addContentNode(ngContentIndex, new CompileViewRootNode(viewContainer ? CompileViewRootNodeType.ViewContainer : CompileViewRootNodeType.Node, viewContainer || node.renderNode));
	            }
	        };
	        /**
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype._getParentRenderNode = function (parent) {
	            parent = _getOuterContainerParentOrSelf(parent);
	            if (this._isRootNode(parent)) {
	                if (this.view.viewType === ViewType.COMPONENT) {
	                    return parentRenderNodeVar;
	                }
	                else {
	                    // root node of an embedded/host view
	                    return NULL_EXPR;
	                }
	            }
	            else {
	                return isPresent(parent.component) &&
	                    parent.component.template.encapsulation !== _angular_core.ViewEncapsulation.Native ?
	                    NULL_EXPR :
	                    parent.renderNode;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.getOrCreateLastRenderNode = function () {
	            var /** @type {?} */ view = this.view;
	            if (view.rootNodes.length === 0 ||
	                view.rootNodes[view.rootNodes.length - 1].type !== CompileViewRootNodeType.Node) {
	                var /** @type {?} */ fieldName = "_el_" + view.nodes.length;
	                view.fields.push(new ClassField(fieldName, importType(view.genConfig.renderTypes.renderElement)));
	                view.createMethod.addStmt(THIS_EXPR.prop(fieldName)
	                    .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [NULL_EXPR, NULL_EXPR]))
	                    .toStmt());
	                view.rootNodes.push(new CompileViewRootNode(CompileViewRootNodeType.Node, THIS_EXPR.prop(fieldName)));
	            }
	            return view.rootNodes[view.rootNodes.length - 1].expr;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {
	            return this._visitText(ast, '', parent);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitText = function (ast, parent) {
	            return this._visitText(ast, ast.value, parent);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} value
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype._visitText = function (ast, value, parent) {
	            var /** @type {?} */ fieldName = "_text_" + this.view.nodes.length;
	            this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));
	            var /** @type {?} */ renderNode = THIS_EXPR.prop(fieldName);
	            var /** @type {?} */ compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
	            var /** @type {?} */ createRenderNode = THIS_EXPR.prop(fieldName)
	                .set(ViewProperties.renderer.callMethod('createText', [
	                this._getParentRenderNode(parent), literal(value),
	                this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)
	            ]))
	                .toStmt();
	            this.view.nodes.push(compileNode);
	            this.view.createMethod.addStmt(createRenderNode);
	            this._addRootNodeAndProject(compileNode);
	            return renderNode;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {
	            // the projected nodes originate from a different view, so we don't
	            // have debug information for them...
	            this.view.createMethod.resetDebugInfo(null, ast);
	            var /** @type {?} */ parentRenderNode = this._getParentRenderNode(parent);
	            if (parentRenderNode !== NULL_EXPR) {
	                this.view.createMethod.addStmt(THIS_EXPR.callMethod('projectNodes', [parentRenderNode, literal(ast.index)])
	                    .toStmt());
	            }
	            else if (this._isRootNode(parent)) {
	                if (this.view.viewType !== ViewType.COMPONENT) {
	                    // store root nodes only for embedded/host views
	                    this.view.rootNodes.push(new CompileViewRootNode(CompileViewRootNodeType.NgContent, null, ast.index));
	                }
	            }
	            else {
	                if (isPresent(parent.component) && isPresent(ast.ngContentIndex)) {
	                    parent.addContentNode(ast.ngContentIndex, new CompileViewRootNode(CompileViewRootNodeType.NgContent, null, ast.index));
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {
	            var /** @type {?} */ nodeIndex = this.view.nodes.length;
	            var /** @type {?} */ createRenderNodeExpr;
	            var /** @type {?} */ debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
	            var /** @type {?} */ directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
	            var /** @type {?} */ component = directives.find(function (directive) { return directive.isComponent; });
	            if (ast.name === NG_CONTAINER_TAG) {
	                createRenderNodeExpr = ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);
	            }
	            else {
	                var /** @type {?} */ htmlAttrs = _readHtmlAttrs(ast.attrs);
	                var /** @type {?} */ attrNameAndValues = createInlineArray(_mergeHtmlAndDirectiveAttrs(htmlAttrs, directives).map(function (v) { return literal(v); }));
	                if (nodeIndex === 0 && this.view.viewType === ViewType.HOST) {
	                    createRenderNodeExpr =
	                        importExpr(createIdentifier(Identifiers.selectOrCreateRenderHostElement)).callFn([
	                            ViewProperties.renderer, literal(ast.name), attrNameAndValues, rootSelectorVar,
	                            debugContextExpr
	                        ]);
	                }
	                else {
	                    createRenderNodeExpr =
	                        importExpr(createIdentifier(Identifiers.createRenderElement)).callFn([
	                            ViewProperties.renderer, this._getParentRenderNode(parent), literal(ast.name),
	                            attrNameAndValues, debugContextExpr
	                        ]);
	                }
	            }
	            var /** @type {?} */ fieldName = "_el_" + nodeIndex;
	            this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));
	            this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
	            var /** @type {?} */ renderNode = THIS_EXPR.prop(fieldName);
	            var /** @type {?} */ compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references);
	            this.view.nodes.push(compileElement);
	            var /** @type {?} */ compViewExpr = null;
	            if (isPresent(component)) {
	                var /** @type {?} */ nestedComponentIdentifier = { reference: null };
	                this.targetDependencies.push(new ViewClassDependency(component.type, getViewClassName(component, 0), nestedComponentIdentifier));
	                compViewExpr = THIS_EXPR.prop("compView_" + nodeIndex); // fix highlighting: `
	                this.view.fields.push(new ClassField(compViewExpr.name, importType(createIdentifier(Identifiers.AppView), [importType(component.type)])));
	                this.view.viewChildren.push(compViewExpr);
	                compileElement.setComponentView(compViewExpr);
	                this.view.createMethod.addStmt(compViewExpr
	                    .set(importExpr(nestedComponentIdentifier).instantiate([
	                    ViewProperties.viewUtils, THIS_EXPR, literal(nodeIndex), renderNode
	                ]))
	                    .toStmt());
	            }
	            compileElement.beforeChildren();
	            this._addRootNodeAndProject(compileElement);
	            templateVisitAll(this, ast.children, compileElement);
	            compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
	            if (isPresent(compViewExpr)) {
	                this.view.createMethod.addStmt(compViewExpr.callMethod('create', [compileElement.getComponent()]).toStmt());
	            }
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} parent
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
	            var /** @type {?} */ nodeIndex = this.view.nodes.length;
	            var /** @type {?} */ fieldName = "_anchor_" + nodeIndex;
	            this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));
	            this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName)
	                .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [
	                this._getParentRenderNode(parent),
	                this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)
	            ]))
	                .toStmt());
	            var /** @type {?} */ renderNode = THIS_EXPR.prop(fieldName);
	            var /** @type {?} */ templateVariableBindings = ast.variables.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });
	            var /** @type {?} */ directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
	            var /** @type {?} */ compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references);
	            this.view.nodes.push(compileElement);
	            this.nestedViewCount++;
	            var /** @type {?} */ embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, this.view.animations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings, this.targetDependencies);
	            this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
	            compileElement.beforeChildren();
	            this._addRootNodeAndProject(compileElement);
	            compileElement.afterChildren(0);
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} eventTargetAndNames
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
	        return ViewBuilderVisitor;
	    }());
	    /**
	     * Walks up the nodes while the direct parent is a container.
	     *
	     * Returns the outer container or the node itself when it is not a direct child of a container.
	     *
	     * \@internal
	     * @param {?} node
	     * @return {?}
	     */
	    function _getOuterContainerOrSelf(node) {
	        var /** @type {?} */ view = node.view;
	        while (_isNgContainer(node.parent, view)) {
	            node = node.parent;
	        }
	        return node;
	    }
	    /**
	     * Walks up the nodes while they are container and returns the first parent which is not.
	     *
	     * Returns the parent of the outer container or the node itself when it is not a container.
	     *
	     * \@internal
	     * @param {?} el
	     * @return {?}
	     */
	    function _getOuterContainerParentOrSelf(el) {
	        var /** @type {?} */ view = el.view;
	        while (_isNgContainer(el, view)) {
	            el = el.parent;
	        }
	        return el;
	    }
	    /**
	     * @param {?} node
	     * @param {?} view
	     * @return {?}
	     */
	    function _isNgContainer(node, view) {
	        return !node.isNull() && ((node.sourceAst)).name === NG_CONTAINER_TAG &&
	            node.view === view;
	    }
	    /**
	     * @param {?} declaredHtmlAttrs
	     * @param {?} directives
	     * @return {?}
	     */
	    function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
	        var /** @type {?} */ mapResult = {};
	        Object.keys(declaredHtmlAttrs).forEach(function (key) { mapResult[key] = declaredHtmlAttrs[key]; });
	        directives.forEach(function (directiveMeta) {
	            Object.keys(directiveMeta.hostAttributes).forEach(function (name) {
	                var /** @type {?} */ value = directiveMeta.hostAttributes[name];
	                var /** @type {?} */ prevValue = mapResult[name];
	                mapResult[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
	            });
	        });
	        var /** @type {?} */ arrResult = [];
	        // Note: We need to sort to get a defined output order
	        // for tests and for caching generated artifacts...
	        Object.keys(mapResult).sort().forEach(function (attrName) { arrResult.push(attrName, mapResult[attrName]); });
	        return arrResult;
	    }
	    /**
	     * @param {?} attrs
	     * @return {?}
	     */
	    function _readHtmlAttrs(attrs) {
	        var /** @type {?} */ htmlAttrs = {};
	        attrs.forEach(function (ast) { htmlAttrs[ast.name] = ast.value; });
	        return htmlAttrs;
	    }
	    /**
	     * @param {?} attrName
	     * @param {?} attrValue1
	     * @param {?} attrValue2
	     * @return {?}
	     */
	    function mergeAttributeValue(attrName, attrValue1, attrValue2) {
	        if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
	            return attrValue1 + " " + attrValue2;
	        }
	        else {
	            return attrValue2;
	        }
	    }
	    /**
	     * @param {?} view
	     * @param {?} targetStatements
	     * @return {?}
	     */
	    function createViewTopLevelStmts(view, targetStatements) {
	        var /** @type {?} */ nodeDebugInfosVar = NULL_EXPR;
	        if (view.genConfig.genDebugInfo) {
	            nodeDebugInfosVar = variable("nodeDebugInfos_" + identifierName(view.component.type) + view.viewIndex); // fix
	            // highlighting:
	            // `
	            targetStatements.push(((nodeDebugInfosVar))
	                .set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(importType(createIdentifier(Identifiers.StaticNodeDebugInfo)), [TypeModifier.Const])))
	                .toDeclStmt(null, [StmtModifier.Final]));
	        }
	        var /** @type {?} */ renderCompTypeVar = variable("renderType_" + identifierName(view.component.type)); // fix highlighting: `
	        if (view.viewIndex === 0) {
	            var /** @type {?} */ templateUrlInfo = void 0;
	            if (view.component.template.templateUrl == identifierModuleUrl(view.component.type)) {
	                templateUrlInfo =
	                    identifierModuleUrl(view.component.type) + " class " + identifierName(view.component.type) + " - inline template";
	            }
	            else {
	                templateUrlInfo = view.component.template.templateUrl;
	            }
	            targetStatements.push(renderCompTypeVar
	                .set(importExpr(createIdentifier(Identifiers.createRenderComponentType)).callFn([
	                view.genConfig.genDebugInfo ? literal(templateUrlInfo) : literal(''),
	                literal(view.component.template.ngContentSelectors.length),
	                ViewEncapsulationEnum.fromValue(view.component.template.encapsulation),
	                view.styles,
	                literalMap(view.animations.map(function (entry) { return [entry.name, entry.fnExp]; }), null, true),
	            ]))
	                .toDeclStmt(importType(createIdentifier(Identifiers.RenderComponentType))));
	        }
	        var /** @type {?} */ viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
	        targetStatements.push(viewClass);
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function createStaticNodeDebugInfo(node) {
	        var /** @type {?} */ compileElement = node instanceof CompileElement ? node : null;
	        var /** @type {?} */ providerTokens = [];
	        var /** @type {?} */ componentToken = NULL_EXPR;
	        var /** @type {?} */ varTokenEntries = [];
	        if (isPresent(compileElement)) {
	            providerTokens =
	                compileElement.getProviderTokens().map(function (token) { return createDiTokenExpression(token); });
	            if (isPresent(compileElement.component)) {
	                componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));
	            }
	            Object.keys(compileElement.referenceTokens).forEach(function (varName) {
	                var /** @type {?} */ token = compileElement.referenceTokens[varName];
	                varTokenEntries.push([varName, isPresent(token) ? createDiTokenExpression(token) : NULL_EXPR]);
	            });
	        }
	        return importExpr(createIdentifier(Identifiers.StaticNodeDebugInfo))
	            .instantiate([
	            literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])),
	            componentToken,
	            literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))
	        ], importType(createIdentifier(Identifiers.StaticNodeDebugInfo), null, [TypeModifier.Const]));
	    }
	    /**
	     * @param {?} view
	     * @param {?} renderCompTypeVar
	     * @param {?} nodeDebugInfosVar
	     * @return {?}
	     */
	    function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
	        var /** @type {?} */ viewConstructorArgs = [
	            new FnParam(ViewConstructorVars.viewUtils.name, importType(createIdentifier(Identifiers.ViewUtils))),
	            new FnParam(ViewConstructorVars.parentView.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	            new FnParam(ViewConstructorVars.parentIndex.name, NUMBER_TYPE),
	            new FnParam(ViewConstructorVars.parentElement.name, DYNAMIC_TYPE)
	        ];
	        var /** @type {?} */ superConstructorArgs = [
	            variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType),
	            ViewConstructorVars.viewUtils, ViewConstructorVars.parentView, ViewConstructorVars.parentIndex,
	            ViewConstructorVars.parentElement,
	            ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))
	        ];
	        if (view.genConfig.genDebugInfo) {
	            superConstructorArgs.push(nodeDebugInfosVar);
	        }
	        if (view.viewType === ViewType.EMBEDDED) {
	            viewConstructorArgs.push(new FnParam('declaredViewContainer', importType(createIdentifier(Identifiers.ViewContainer))));
	            superConstructorArgs.push(variable('declaredViewContainer'));
	        }
	        var /** @type {?} */ viewMethods = [
	            new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(createIdentifier(Identifiers.ComponentRef), [DYNAMIC_TYPE])),
	            new ClassMethod('injectorGetInternal', [
	                new FnParam(InjectMethodVars$1.token.name, DYNAMIC_TYPE),
	                // Note: Can't use o.INT_TYPE here as the method in AppView uses number
	                new FnParam(InjectMethodVars$1.requestNodeIndex.name, NUMBER_TYPE),
	                new FnParam(InjectMethodVars$1.notFoundResult.name, DYNAMIC_TYPE)
	            ], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars$1.notFoundResult), DYNAMIC_TYPE),
	            new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)),
	            new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()),
	            new ClassMethod('destroyInternal', [], generateDestroyMethod(view)),
	            new ClassMethod('detachInternal', [], view.detachMethod.finish()),
	            generateVisitRootNodesMethod(view), generateVisitProjectableNodesMethod(view),
	            generateCreateEmbeddedViewsMethod(view)
	        ].filter(function (method) { return method.body.length > 0; });
	        var /** @type {?} */ superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;
	        var /** @type {?} */ viewClass = createClassStmt({
	            name: view.className,
	            parent: importExpr(createIdentifier(superClass), [getContextType(view)]),
	            parentArgs: superConstructorArgs,
	            ctorParams: viewConstructorArgs,
	            builders: [{ methods: viewMethods }, view]
	        });
	        return viewClass;
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function generateDestroyMethod(view) {
	        var /** @type {?} */ stmts = [];
	        view.viewContainers.forEach(function (viewContainer) {
	            stmts.push(viewContainer.callMethod('destroyNestedViews', []).toStmt());
	        });
	        view.viewChildren.forEach(function (viewChild) { stmts.push(viewChild.callMethod('destroy', []).toStmt()); });
	        stmts.push.apply(stmts, view.destroyMethod.finish());
	        return stmts;
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function generateCreateMethod(view) {
	        var /** @type {?} */ parentRenderNodeExpr = NULL_EXPR;
	        var /** @type {?} */ parentRenderNodeStmts = [];
	        if (view.viewType === ViewType.COMPONENT) {
	            parentRenderNodeExpr =
	                ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('parentElement')]);
	            parentRenderNodeStmts =
	                [parentRenderNodeVar.set(parentRenderNodeExpr)
	                        .toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];
	        }
	        var /** @type {?} */ resultExpr;
	        if (view.viewType === ViewType.HOST) {
	            var /** @type {?} */ hostEl = (view.nodes[0]);
	            resultExpr =
	                importExpr(createIdentifier(Identifiers.ComponentRef_), [DYNAMIC_TYPE]).instantiate([
	                    literal(hostEl.nodeIndex), THIS_EXPR, hostEl.renderNode, hostEl.getComponent()
	                ]);
	        }
	        else {
	            resultExpr = NULL_EXPR;
	        }
	        var /** @type {?} */ allNodesExpr = ViewProperties.renderer.cast(DYNAMIC_TYPE)
	            .prop('directRenderer')
	            .conditional(NULL_EXPR, literalArr(view.nodes.map(function (node) { return node.renderNode; })));
	        return parentRenderNodeStmts.concat(view.createMethod.finish(), [
	            THIS_EXPR
	                .callMethod('init', [
	                view.lastRenderNode,
	                allNodesExpr,
	                view.disposables.length ? literalArr(view.disposables) : NULL_EXPR,
	            ])
	                .toStmt(),
	            new ReturnStatement(resultExpr)
	        ]);
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function generateDetectChangesMethod(view) {
	        var /** @type {?} */ stmts = [];
	        if (view.animationBindingsMethod.isEmpty() && view.detectChangesInInputsMethod.isEmpty() &&
	            view.updateContentQueriesMethod.isEmpty() &&
	            view.afterContentLifecycleCallbacksMethod.isEmpty() &&
	            view.detectChangesRenderPropertiesMethod.isEmpty() &&
	            view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty() &&
	            view.viewContainers.length === 0 && view.viewChildren.length === 0) {
	            return stmts;
	        }
	        stmts.push.apply(stmts, view.animationBindingsMethod.finish());
	        stmts.push.apply(stmts, view.detectChangesInInputsMethod.finish());
	        view.viewContainers.forEach(function (viewContainer) {
	            stmts.push(viewContainer.callMethod('detectChangesInNestedViews', [DetectChangesVars.throwOnChange])
	                .toStmt());
	        });
	        var /** @type {?} */ afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
	        if (afterContentStmts.length > 0) {
	            stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));
	        }
	        stmts.push.apply(stmts, view.detectChangesRenderPropertiesMethod.finish());
	        view.viewChildren.forEach(function (viewChild) {
	            stmts.push(viewChild.callMethod('internalDetectChanges', [DetectChangesVars.throwOnChange]).toStmt());
	        });
	        var /** @type {?} */ afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
	        if (afterViewStmts.length > 0) {
	            stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));
	        }
	        var /** @type {?} */ varStmts = [];
	        var /** @type {?} */ readVars = findReadVarNames(stmts);
	        if (readVars.has(DetectChangesVars.changed.name)) {
	            varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));
	        }
	        if (readVars.has(DetectChangesVars.changes.name)) {
	            varStmts.push(DetectChangesVars.changes.set(NULL_EXPR)
	                .toDeclStmt(new MapType(importType(createIdentifier(Identifiers.SimpleChange)))));
	        }
	        varStmts.push.apply(varStmts, createSharedBindingVariablesIfNeeded(stmts));
	        return varStmts.concat(stmts);
	    }
	    /**
	     * @param {?} statements
	     * @param {?} value
	     * @return {?}
	     */
	    function addReturnValuefNotEmpty(statements, value) {
	        if (statements.length > 0) {
	            return statements.concat([new ReturnStatement(value)]);
	        }
	        else {
	            return statements;
	        }
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function getContextType(view) {
	        if (view.viewType === ViewType.COMPONENT) {
	            return importType(view.component.type);
	        }
	        return DYNAMIC_TYPE;
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function getChangeDetectionMode(view) {
	        var /** @type {?} */ mode;
	        if (view.viewType === ViewType.COMPONENT) {
	            mode = isDefaultChangeDetectionStrategy(view.component.changeDetection) ?
	                ChangeDetectorStatus.CheckAlways :
	                ChangeDetectorStatus.CheckOnce;
	        }
	        else {
	            mode = ChangeDetectorStatus.CheckAlways;
	        }
	        return mode;
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function generateVisitRootNodesMethod(view) {
	        var /** @type {?} */ cbVar = variable('cb');
	        var /** @type {?} */ ctxVar = variable('ctx');
	        var /** @type {?} */ stmts = generateVisitNodesStmts(view.rootNodes, cbVar, ctxVar);
	        return new ClassMethod('visitRootNodesInternal', [new FnParam(cbVar.name, DYNAMIC_TYPE), new FnParam(ctxVar.name, DYNAMIC_TYPE)], stmts);
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function generateVisitProjectableNodesMethod(view) {
	        var /** @type {?} */ nodeIndexVar = variable('nodeIndex');
	        var /** @type {?} */ ngContentIndexVar = variable('ngContentIndex');
	        var /** @type {?} */ cbVar = variable('cb');
	        var /** @type {?} */ ctxVar = variable('ctx');
	        var /** @type {?} */ stmts = [];
	        view.nodes.forEach(function (node) {
	            if (node instanceof CompileElement && node.component) {
	                node.contentNodesByNgContentIndex.forEach(function (projectedNodes, ngContentIndex) {
	                    stmts.push(new IfStmt(nodeIndexVar.equals(literal(node.nodeIndex))
	                        .and(ngContentIndexVar.equals(literal(ngContentIndex))), generateVisitNodesStmts(projectedNodes, cbVar, ctxVar)));
	                });
	            }
	        });
	        return new ClassMethod('visitProjectableNodesInternal', [
	            new FnParam(nodeIndexVar.name, NUMBER_TYPE),
	            new FnParam(ngContentIndexVar.name, NUMBER_TYPE),
	            new FnParam(cbVar.name, DYNAMIC_TYPE), new FnParam(ctxVar.name, DYNAMIC_TYPE)
	        ], stmts);
	    }
	    /**
	     * @param {?} nodes
	     * @param {?} cb
	     * @param {?} ctx
	     * @return {?}
	     */
	    function generateVisitNodesStmts(nodes, cb, ctx) {
	        var /** @type {?} */ stmts = [];
	        nodes.forEach(function (node) {
	            switch (node.type) {
	                case CompileViewRootNodeType.Node:
	                    stmts.push(cb.callFn([node.expr, ctx]).toStmt());
	                    break;
	                case CompileViewRootNodeType.ViewContainer:
	                    stmts.push(cb.callFn([node.expr.prop('nativeElement'), ctx]).toStmt());
	                    stmts.push(node.expr.callMethod('visitNestedViewRootNodes', [cb, ctx]).toStmt());
	                    break;
	                case CompileViewRootNodeType.NgContent:
	                    stmts.push(THIS_EXPR.callMethod('visitProjectedNodes', [literal(node.ngContentIndex), cb, ctx])
	                        .toStmt());
	                    break;
	            }
	        });
	        return stmts;
	    }
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    function generateCreateEmbeddedViewsMethod(view) {
	        var /** @type {?} */ nodeIndexVar = variable('nodeIndex');
	        var /** @type {?} */ stmts = [];
	        view.nodes.forEach(function (node) {
	            if (node instanceof CompileElement) {
	                if (node.embeddedView) {
	                    stmts.push(new IfStmt(nodeIndexVar.equals(literal(node.nodeIndex)), [new ReturnStatement(node.embeddedView.classExpr.instantiate([
	                            ViewProperties.viewUtils, THIS_EXPR, literal(node.nodeIndex), node.renderNode,
	                            node.viewContainer
	                        ]))]));
	                }
	            }
	        });
	        if (stmts.length > 0) {
	            stmts.push(new ReturnStatement(NULL_EXPR));
	        }
	        return new ClassMethod('createEmbeddedViewInternal', [new FnParam(nodeIndexVar.name, NUMBER_TYPE)], stmts, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE]));
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$16 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$16 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var ViewCompileResult = (function () {
	        /**
	         * @param {?} statements
	         * @param {?} viewClassVar
	         * @param {?} dependencies
	         */
	        function ViewCompileResult(statements, viewClassVar, dependencies) {
	            this.statements = statements;
	            this.viewClassVar = viewClassVar;
	            this.dependencies = dependencies;
	        }
	        return ViewCompileResult;
	    }());
	    var ViewCompiler = (function () {
	        /**
	         * @param {?} _genConfig
	         * @param {?} _schemaRegistry
	         */
	        function ViewCompiler(_genConfig, _schemaRegistry) {
	            this._genConfig = _genConfig;
	            this._schemaRegistry = _schemaRegistry;
	        }
	        /**
	         * @param {?} component
	         * @param {?} template
	         * @param {?} styles
	         * @param {?} pipes
	         * @param {?} compiledAnimations
	         * @return {?}
	         */
	        ViewCompiler.prototype.compileComponent = function (component, template, styles, pipes, compiledAnimations) {
	            var /** @type {?} */ dependencies = [];
	            var /** @type {?} */ view = new CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, CompileElement.createNull(), [], dependencies);
	            var /** @type {?} */ statements = [];
	            buildView(view, template, dependencies);
	            // Need to separate binding from creation to be able to refer to
	            // variables that have been declared after usage.
	            bindView(view, template, this._schemaRegistry);
	            finishView(view, statements);
	            return new ViewCompileResult(statements, view.classExpr.name, dependencies);
	        };
	        ViewCompiler = __decorate$16([
	            CompilerInjectable(), 
	            __metadata$16('design:paramtypes', [CompilerConfig, ElementSchemaRegistry])
	        ], ViewCompiler);
	        return ViewCompiler;
	    }());

	    var AnimationEntryCompileResult = (function () {
	        /**
	         * @param {?} name
	         * @param {?} statements
	         * @param {?} fnExp
	         */
	        function AnimationEntryCompileResult(name, statements, fnExp) {
	            this.name = name;
	            this.statements = statements;
	            this.fnExp = fnExp;
	        }
	        return AnimationEntryCompileResult;
	    }());
	    var AnimationCompiler = (function () {
	        function AnimationCompiler() {
	        }
	        /**
	         * @param {?} factoryNamePrefix
	         * @param {?} parsedAnimations
	         * @return {?}
	         */
	        AnimationCompiler.prototype.compile = function (factoryNamePrefix, parsedAnimations) {
	            return parsedAnimations.map(function (entry) {
	                var /** @type {?} */ factoryName = factoryNamePrefix + "_" + entry.name;
	                var /** @type {?} */ visitor = new _AnimationBuilder(entry.name, factoryName);
	                return visitor.build(entry);
	            });
	        };
	        return AnimationCompiler;
	    }());
	    var /** @type {?} */ _ANIMATION_FACTORY_ELEMENT_VAR = variable('element');
	    var /** @type {?} */ _ANIMATION_DEFAULT_STATE_VAR = variable('defaultStateStyles');
	    var /** @type {?} */ _ANIMATION_FACTORY_VIEW_VAR = variable('view');
	    var /** @type {?} */ _ANIMATION_FACTORY_VIEW_CONTEXT = _ANIMATION_FACTORY_VIEW_VAR.prop('animationContext');
	    var /** @type {?} */ _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');
	    var /** @type {?} */ _ANIMATION_CURRENT_STATE_VAR = variable('currentState');
	    var /** @type {?} */ _ANIMATION_NEXT_STATE_VAR = variable('nextState');
	    var /** @type {?} */ _ANIMATION_PLAYER_VAR = variable('player');
	    var /** @type {?} */ _ANIMATION_TIME_VAR = variable('totalTime');
	    var /** @type {?} */ _ANIMATION_START_STATE_STYLES_VAR = variable('startStateStyles');
	    var /** @type {?} */ _ANIMATION_END_STATE_STYLES_VAR = variable('endStateStyles');
	    var /** @type {?} */ _ANIMATION_COLLECTED_STYLES = variable('collectedStyles');
	    var /** @type {?} */ _PREVIOUS_ANIMATION_PLAYERS = variable('previousPlayers');
	    var /** @type {?} */ _EMPTY_MAP = literalMap([]);
	    var /** @type {?} */ _EMPTY_ARRAY = literalArr([]);
	    var _AnimationBuilder = (function () {
	        /**
	         * @param {?} animationName
	         * @param {?} factoryName
	         */
	        function _AnimationBuilder(animationName, factoryName) {
	            this.animationName = animationName;
	            this._fnVarName = factoryName + '_factory';
	            this._statesMapVarName = factoryName + '_states';
	            this._statesMapVar = variable(this._statesMapVarName);
	        }
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationStyles = function (ast, context) {
	            var /** @type {?} */ stylesArr = [];
	            if (context.isExpectingFirstStyleStep) {
	                stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);
	                context.isExpectingFirstStyleStep = false;
	            }
	            ast.styles.forEach(function (entry) {
	                var /** @type {?} */ entries = Object.keys(entry).map(function (key) { return [key, literal(entry[key])]; });
	                stylesArr.push(literalMap(entries, null, true));
	            });
	            return importExpr(createIdentifier(Identifiers.AnimationStyles)).instantiate([
	                importExpr(createIdentifier(Identifiers.collectAndResolveStyles)).callFn([
	                    _ANIMATION_COLLECTED_STYLES, literalArr(stylesArr)
	                ])
	            ]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationKeyframe = function (ast, context) {
	            return importExpr(createIdentifier(Identifiers.AnimationKeyframe)).instantiate([
	                literal(ast.offset), ast.styles.visit(this, context)
	            ]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationStep = function (ast, context) {
	            var _this = this;
	            if (context.endStateAnimateStep === ast) {
	                return this._visitEndStateAnimation(ast, context);
	            }
	            var /** @type {?} */ startingStylesExpr = ast.startingStyles.visit(this, context);
	            var /** @type {?} */ keyframeExpressions = ast.keyframes.map(function (keyframeEntry) { return keyframeEntry.visit(_this, context); });
	            return this._callAnimateMethod(ast, startingStylesExpr, literalArr(keyframeExpressions), context);
	        };
	        /**
	         * \@internal
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype._visitEndStateAnimation = function (ast, context) {
	            var _this = this;
	            var /** @type {?} */ startingStylesExpr = ast.startingStyles.visit(this, context);
	            var /** @type {?} */ keyframeExpressions = ast.keyframes.map(function (keyframe) { return keyframe.visit(_this, context); });
	            var /** @type {?} */ keyframesExpr = importExpr(createIdentifier(Identifiers.balanceAnimationKeyframes)).callFn([
	                _ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR,
	                literalArr(keyframeExpressions)
	            ]);
	            return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr, context);
	        };
	        /**
	         * \@internal
	         * @param {?} ast
	         * @param {?} startingStylesExpr
	         * @param {?} keyframesExpr
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype._callAnimateMethod = function (ast, startingStylesExpr, keyframesExpr, context) {
	            var /** @type {?} */ previousStylesValue = _EMPTY_ARRAY;
	            if (context.isExpectingFirstAnimateStep) {
	                previousStylesValue = _PREVIOUS_ANIMATION_PLAYERS;
	                context.isExpectingFirstAnimateStep = false;
	            }
	            context.totalTransitionTime += ast.duration + ast.delay;
	            return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [
	                _ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, literal(ast.duration),
	                literal(ast.delay), literal(ast.easing), previousStylesValue
	            ]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationSequence = function (ast, context) {
	            var _this = this;
	            var /** @type {?} */ playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
	            return importExpr(createIdentifier(Identifiers.AnimationSequencePlayer)).instantiate([
	                literalArr(playerExprs)
	            ]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationGroup = function (ast, context) {
	            var _this = this;
	            var /** @type {?} */ playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
	            return importExpr(createIdentifier(Identifiers.AnimationGroupPlayer)).instantiate([
	                literalArr(playerExprs)
	            ]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationStateDeclaration = function (ast, context) {
	            var /** @type {?} */ flatStyles = {};
	            _getStylesArray(ast).forEach(function (entry) { Object.keys(entry).forEach(function (key) { flatStyles[key] = entry[key]; }); });
	            context.stateMap.registerState(ast.stateName, flatStyles);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationStateTransition = function (ast, context) {
	            var /** @type {?} */ steps = ast.animation.steps;
	            var /** @type {?} */ lastStep = steps[steps.length - 1];
	            if (_isEndStateAnimateStep(lastStep)) {
	                context.endStateAnimateStep = (lastStep);
	            }
	            context.totalTransitionTime = 0;
	            context.isExpectingFirstStyleStep = true;
	            context.isExpectingFirstAnimateStep = true;
	            var /** @type {?} */ stateChangePreconditions = [];
	            ast.stateChanges.forEach(function (stateChange) {
	                stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState)
	                    .and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));
	                if (stateChange.fromState != ANY_STATE) {
	                    context.stateMap.registerState(stateChange.fromState);
	                }
	                if (stateChange.toState != ANY_STATE) {
	                    context.stateMap.registerState(stateChange.toState);
	                }
	            });
	            var /** @type {?} */ animationPlayerExpr = ast.animation.visit(this, context);
	            var /** @type {?} */ reducedStateChangesPrecondition = stateChangePreconditions.reduce(function (a, b) { return a.or(b); });
	            var /** @type {?} */ precondition = _ANIMATION_PLAYER_VAR.equals(NULL_EXPR).and(reducedStateChangesPrecondition);
	            var /** @type {?} */ animationStmt = _ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt();
	            var /** @type {?} */ totalTimeStmt = _ANIMATION_TIME_VAR.set(literal(context.totalTransitionTime)).toStmt();
	            return new IfStmt(precondition, [animationStmt, totalTimeStmt]);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} context
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.visitAnimationEntry = function (ast, context) {
	            var _this = this;
	            // visit each of the declarations first to build the context state map
	            ast.stateDeclarations.forEach(function (def) { return def.visit(_this, context); });
	            // this should always be defined even if the user overrides it
	            context.stateMap.registerState(DEFAULT_STATE, {});
	            var /** @type {?} */ statements = [];
	            statements.push(_PREVIOUS_ANIMATION_PLAYERS
	                .set(_ANIMATION_FACTORY_VIEW_CONTEXT.callMethod('getAnimationPlayers', [
	                _ANIMATION_FACTORY_ELEMENT_VAR,
	                _ANIMATION_NEXT_STATE_VAR.equals(literal(EMPTY_STATE))
	                    .conditional(NULL_EXPR, literal(this.animationName))
	            ]))
	                .toDeclStmt());
	            statements.push(_ANIMATION_COLLECTED_STYLES.set(_EMPTY_MAP).toDeclStmt());
	            statements.push(_ANIMATION_PLAYER_VAR.set(NULL_EXPR).toDeclStmt());
	            statements.push(_ANIMATION_TIME_VAR.set(literal(0)).toDeclStmt());
	            statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(literal(DEFAULT_STATE)))
	                .toDeclStmt());
	            statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR))
	                .toDeclStmt());
	            statements.push(new IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
	            statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR))
	                .toDeclStmt());
	            statements.push(new IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
	            var /** @type {?} */ RENDER_STYLES_FN = importExpr(createIdentifier(Identifiers.renderStyles));
	            ast.stateTransitions.forEach(function (transAst) { return statements.push(transAst.visit(_this, context)); });
	            // this check ensures that the animation factory always returns a player
	            // so that the onDone callback can be used for tracking
	            statements.push(new IfStmt(_ANIMATION_PLAYER_VAR.equals(NULL_EXPR), [_ANIMATION_PLAYER_VAR
	                    .set(importExpr(createIdentifier(Identifiers.NoOpAnimationPlayer)).instantiate([]))
	                    .toStmt()]));
	            // once complete we want to apply the styles on the element
	            // since the destination state's values should persist once
	            // the animation sequence has completed.
	            statements.push(_ANIMATION_PLAYER_VAR
	                .callMethod('onDone', [fn([], [
	                    _ANIMATION_PLAYER_VAR.callMethod('destroy', []).toStmt(),
	                    RENDER_STYLES_FN
	                        .callFn([
	                        _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
	                        importExpr(createIdentifier(Identifiers.prepareFinalAnimationStyles))
	                            .callFn([
	                            _ANIMATION_START_STATE_STYLES_VAR,
	                            _ANIMATION_END_STATE_STYLES_VAR
	                        ])
	                    ])
	                        .toStmt()
	                ])])
	                .toStmt());
	            statements.push(importExpr(createIdentifier(Identifiers.AnimationSequencePlayer))
	                .instantiate([_PREVIOUS_ANIMATION_PLAYERS])
	                .callMethod('destroy', [])
	                .toStmt());
	            // before we start any animation we want to clear out the starting
	            // styles from the element's style property (since they were placed
	            // there at the end of the last animation
	            statements.push(RENDER_STYLES_FN
	                .callFn([
	                _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
	                importExpr(createIdentifier(Identifiers.clearStyles))
	                    .callFn([_ANIMATION_START_STATE_STYLES_VAR])
	            ])
	                .toStmt());
	            statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT
	                .callMethod('queueAnimation', [
	                _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
	                _ANIMATION_PLAYER_VAR
	            ])
	                .toStmt());
	            statements.push(new ReturnStatement(importExpr(createIdentifier(Identifiers.AnimationTransition)).instantiate([
	                _ANIMATION_PLAYER_VAR, _ANIMATION_CURRENT_STATE_VAR, _ANIMATION_NEXT_STATE_VAR,
	                _ANIMATION_TIME_VAR
	            ])));
	            return fn([
	                new FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, importType(createIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
	                new FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, DYNAMIC_TYPE),
	                new FnParam(_ANIMATION_CURRENT_STATE_VAR.name, DYNAMIC_TYPE),
	                new FnParam(_ANIMATION_NEXT_STATE_VAR.name, DYNAMIC_TYPE)
	            ], statements, importType(createIdentifier(Identifiers.AnimationTransition)));
	        };
	        /**
	         * @param {?} ast
	         * @return {?}
	         */
	        _AnimationBuilder.prototype.build = function (ast) {
	            var /** @type {?} */ context = new _AnimationBuilderContext();
	            var /** @type {?} */ fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);
	            var /** @type {?} */ fnVariable = variable(this._fnVarName);
	            var /** @type {?} */ lookupMap = [];
	            Object.keys(context.stateMap.states).forEach(function (stateName) {
	                var /** @type {?} */ value = context.stateMap.states[stateName];
	                var /** @type {?} */ variableValue = _EMPTY_MAP;
	                if (isPresent(value)) {
	                    var /** @type {?} */ styleMap_1 = [];
	                    Object.keys(value).forEach(function (key) { styleMap_1.push([key, literal(value[key])]); });
	                    variableValue = literalMap(styleMap_1, null, true);
	                }
	                lookupMap.push([stateName, variableValue]);
	            });
	            var /** @type {?} */ compiledStatesMapStmt = this._statesMapVar.set(literalMap(lookupMap, null, true)).toDeclStmt();
	            var /** @type {?} */ statements = [compiledStatesMapStmt, fnStatement];
	            return new AnimationEntryCompileResult(this.animationName, statements, fnVariable);
	        };
	        return _AnimationBuilder;
	    }());
	    var _AnimationBuilderContext = (function () {
	        function _AnimationBuilderContext() {
	            this.stateMap = new _AnimationBuilderStateMap();
	            this.endStateAnimateStep = null;
	            this.isExpectingFirstStyleStep = false;
	            this.isExpectingFirstAnimateStep = false;
	            this.totalTransitionTime = 0;
	        }
	        return _AnimationBuilderContext;
	    }());
	    var _AnimationBuilderStateMap = (function () {
	        function _AnimationBuilderStateMap() {
	            this._states = {};
	        }
	        Object.defineProperty(_AnimationBuilderStateMap.prototype, "states", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._states; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} name
	         * @param {?=} value
	         * @return {?}
	         */
	        _AnimationBuilderStateMap.prototype.registerState = function (name, value) {
	            if (value === void 0) { value = null; }
	            var /** @type {?} */ existingEntry = this._states[name];
	            if (!existingEntry) {
	                this._states[name] = value;
	            }
	        };
	        return _AnimationBuilderStateMap;
	    }());
	    /**
	     * @param {?} value
	     * @param {?} animationState
	     * @return {?}
	     */
	    function _compareToAnimationStateExpr(value, animationState) {
	        var /** @type {?} */ emptyStateLiteral = literal(EMPTY_STATE);
	        switch (animationState) {
	            case EMPTY_STATE:
	                return value.equals(emptyStateLiteral);
	            case ANY_STATE:
	                return literal(true);
	            default:
	                return value.equals(literal(animationState));
	        }
	    }
	    /**
	     * @param {?} step
	     * @return {?}
	     */
	    function _isEndStateAnimateStep(step) {
	        // the final animation step is characterized by having only TWO
	        // keyframe values and it must have zero styles for both keyframes
	        if (step instanceof AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {
	            var /** @type {?} */ styles1 = _getStylesArray(step.keyframes[0])[0];
	            var /** @type {?} */ styles2 = _getStylesArray(step.keyframes[1])[0];
	            return Object.keys(styles1).length === 0 && Object.keys(styles2).length === 0;
	        }
	        return false;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function _getStylesArray(obj) {
	        return obj.styles.styles;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var GeneratedFile = (function () {
	        /**
	         * @param {?} srcFileUrl
	         * @param {?} genFileUrl
	         * @param {?} source
	         */
	        function GeneratedFile(srcFileUrl, genFileUrl, source) {
	            this.srcFileUrl = srcFileUrl;
	            this.genFileUrl = genFileUrl;
	            this.source = source;
	        }
	        return GeneratedFile;
	    }());

	    var __extends$26 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ STRIP_SRC_FILE_SUFFIXES = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
	    /**
	     * @param {?} host
	     * @param {?} summaryResolver
	     * @param {?} symbolResolver
	     * @param {?} symbols
	     * @param {?} types
	     * @return {?}
	     */
	    function serializeSummaries(host, summaryResolver, symbolResolver, symbols, types) {
	        var /** @type {?} */ serializer = new Serializer$1(host);
	        // for symbols, we use everything except for the class metadata itself
	        // (we keep the statics though), as the class metadata is contained in the
	        // CompileTypeSummary.
	        symbols.forEach(function (resolvedSymbol) { return serializer.addOrMergeSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });
	        // Add summaries that are referenced by the given symbols (transitively)
	        // Note: the serializer.symbols array might be growing while
	        // we execute the loop!
	        for (var /** @type {?} */ processedIndex = 0; processedIndex < serializer.symbols.length; processedIndex++) {
	            var /** @type {?} */ symbol = serializer.symbols[processedIndex];
	            if (!host.isSourceFile(symbol.filePath)) {
	                var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);
	                if (!summary) {
	                    // some symbols might originate from a plain typescript library
	                    // that just exported .d.ts and .metadata.json files, i.e. where no summary
	                    // files were created.
	                    var /** @type {?} */ resolvedSymbol = symbolResolver.resolveSymbol(symbol);
	                    if (resolvedSymbol) {
	                        summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };
	                    }
	                }
	                if (summary) {
	                    serializer.addOrMergeSummary(summary);
	                }
	            }
	        }
	        // Add type summaries.
	        // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,
	        // as the type summaries already contain the transitive data that they require
	        // (in a minimal way).
	        types.forEach(function (typeSummary) {
	            serializer.addOrMergeSummary({ symbol: typeSummary.type.reference, metadata: { __symbolic: 'class' }, type: typeSummary });
	            if (typeSummary.summaryKind === CompileSummaryKind.NgModule) {
	                var /** @type {?} */ ngModuleSummary = (typeSummary);
	                ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {
	                    var /** @type {?} */ symbol = id.reference;
	                    if (!host.isSourceFile(symbol.filePath)) {
	                        serializer.addOrMergeSummary(summaryResolver.resolveSummary(symbol));
	                    }
	                });
	            }
	        });
	        return serializer.serialize();
	    }
	    /**
	     * @param {?} symbolCache
	     * @param {?} json
	     * @return {?}
	     */
	    function deserializeSummaries(symbolCache, json) {
	        var /** @type {?} */ deserializer = new Deserializer(symbolCache);
	        return deserializer.deserialize(json);
	    }
	    /**
	     * @param {?} fileName
	     * @return {?}
	     */
	    function summaryFileName(fileName) {
	        var /** @type {?} */ fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');
	        return fileNameWithoutSuffix + ".ngsummary.json";
	    }
	    var Serializer$1 = (function (_super) {
	        __extends$26(Serializer, _super);
	        /**
	         * @param {?} host
	         */
	        function Serializer(host) {
	            _super.call(this);
	            this.host = host;
	            this.symbols = [];
	            this.indexBySymbol = new Map();
	            this.processedSummaryBySymbol = new Map();
	            this.processedSummaries = [];
	        }
	        /**
	         * @param {?} summary
	         * @return {?}
	         */
	        Serializer.prototype.addOrMergeSummary = function (summary) {
	            var /** @type {?} */ symbolMeta = summary.metadata;
	            if (symbolMeta && symbolMeta.__symbolic === 'class') {
	                // For classes, we only keep their statics, but not the metadata
	                // of the class itself as that has been captured already via other summaries
	                // (e.g. DirectiveSummary, ...).
	                symbolMeta = { __symbolic: 'class', statics: symbolMeta.statics };
	            }
	            var /** @type {?} */ processedSummary = this.processedSummaryBySymbol.get(summary.symbol);
	            if (!processedSummary) {
	                processedSummary = this.processValue({ symbol: summary.symbol });
	                this.processedSummaries.push(processedSummary);
	                this.processedSummaryBySymbol.set(summary.symbol, processedSummary);
	            }
	            // Note: == by purpose to compare with undefined!
	            if (processedSummary.metadata == null && symbolMeta != null) {
	                processedSummary.metadata = this.processValue(symbolMeta);
	            }
	            // Note: == by purpose to compare with undefined!
	            if (processedSummary.type == null && summary.type != null) {
	                processedSummary.type = this.processValue(summary.type);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        Serializer.prototype.serialize = function () {
	            var _this = this;
	            return JSON.stringify({
	                summaries: this.processedSummaries,
	                symbols: this.symbols.map(function (symbol, index) {
	                    return {
	                        __symbol: index,
	                        name: symbol.name,
	                        // We convert the source filenames tinto output filenames,
	                        // as the generated summary file will be used when teh current
	                        // compilation unit is used as a library
	                        filePath: _this.host.getOutputFileName(symbol.filePath)
	                    };
	                })
	            });
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        Serializer.prototype.processValue = function (value) { return visitValue(value, this, null); };
	        /**
	         * @param {?} value
	         * @param {?} context
	         * @return {?}
	         */
	        Serializer.prototype.visitOther = function (value, context) {
	            if (value instanceof StaticSymbol) {
	                var /** @type {?} */ index = this.indexBySymbol.get(value);
	                // Note: == by purpose to compare with undefined!
	                if (index == null) {
	                    index = this.indexBySymbol.size;
	                    this.indexBySymbol.set(value, index);
	                    this.symbols.push(value);
	                }
	                return { __symbol: index };
	            }
	        };
	        return Serializer;
	    }(ValueTransformer));
	    var Deserializer = (function (_super) {
	        __extends$26(Deserializer, _super);
	        /**
	         * @param {?} symbolCache
	         */
	        function Deserializer(symbolCache) {
	            _super.call(this);
	            this.symbolCache = symbolCache;
	        }
	        /**
	         * @param {?} json
	         * @return {?}
	         */
	        Deserializer.prototype.deserialize = function (json) {
	            var _this = this;
	            var /** @type {?} */ data = JSON.parse(json);
	            this.symbols = data.symbols.map(function (serializedSymbol) { return _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name); });
	            return visitValue(data.summaries, this, null);
	        };
	        /**
	         * @param {?} map
	         * @param {?} context
	         * @return {?}
	         */
	        Deserializer.prototype.visitStringMap = function (map, context) {
	            if ('__symbol' in map) {
	                return this.symbols[map['__symbol']];
	            }
	            else {
	                return _super.prototype.visitStringMap.call(this, map, context);
	            }
	        };
	        return Deserializer;
	    }(ValueTransformer));

	    var AotCompiler = (function () {
	        /**
	         * @param {?} _host
	         * @param {?} _metadataResolver
	         * @param {?} _templateParser
	         * @param {?} _styleCompiler
	         * @param {?} _viewCompiler
	         * @param {?} _dirWrapperCompiler
	         * @param {?} _ngModuleCompiler
	         * @param {?} _outputEmitter
	         * @param {?} _summaryResolver
	         * @param {?} _localeId
	         * @param {?} _translationFormat
	         * @param {?} _animationParser
	         * @param {?} _symbolResolver
	         */
	        function AotCompiler(_host, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _dirWrapperCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _localeId, _translationFormat, _animationParser, _symbolResolver) {
	            this._host = _host;
	            this._metadataResolver = _metadataResolver;
	            this._templateParser = _templateParser;
	            this._styleCompiler = _styleCompiler;
	            this._viewCompiler = _viewCompiler;
	            this._dirWrapperCompiler = _dirWrapperCompiler;
	            this._ngModuleCompiler = _ngModuleCompiler;
	            this._outputEmitter = _outputEmitter;
	            this._summaryResolver = _summaryResolver;
	            this._localeId = _localeId;
	            this._translationFormat = _translationFormat;
	            this._animationParser = _animationParser;
	            this._symbolResolver = _symbolResolver;
	            this._animationCompiler = new AnimationCompiler();
	        }
	        /**
	         * @return {?}
	         */
	        AotCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };
	        /**
	         * @param {?} rootFiles
	         * @return {?}
	         */
	        AotCompiler.prototype.compileAll = function (rootFiles) {
	            var _this = this;
	            var /** @type {?} */ programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);
	            var _a = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver), ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files, ngModules = _a.ngModules;
	            return Promise
	                .all(ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))
	                .then(function () {
	                var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileSrcFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });
	                return ListWrapper.flatten(sourceModules);
	            });
	        };
	        /**
	         * @param {?} srcFileUrl
	         * @param {?} ngModuleByPipeOrDirective
	         * @param {?} directives
	         * @param {?} pipes
	         * @param {?} ngModules
	         * @param {?} injectables
	         * @return {?}
	         */
	        AotCompiler.prototype._compileSrcFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {
	            var _this = this;
	            var /** @type {?} */ fileSuffix = _splitTypescriptSuffix(srcFileUrl)[1];
	            var /** @type {?} */ statements = [];
	            var /** @type {?} */ exportedVars = [];
	            var /** @type {?} */ generatedFiles = [];
	            generatedFiles.push(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables));
	            // compile all ng modules
	            exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));
	            // compile directive wrappers
	            exportedVars.push.apply(exportedVars, directives.map(function (directiveType) { return _this._compileDirectiveWrapper(directiveType, statements); }));
	            // compile components
	            directives.forEach(function (dirType) {
	                var /** @type {?} */ compMeta = _this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));
	                if (!compMeta.isComponent) {
	                    return Promise.resolve(null);
	                }
	                var /** @type {?} */ ngModule = ngModuleByPipeOrDirective.get(dirType);
	                if (!ngModule) {
	                    throw new Error("Internal Error: cannot determine the module for component " + identifierName(compMeta.type) + "!");
	                }
	                _assertComponent(compMeta);
	                // compile styles
	                var /** @type {?} */ stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);
	                stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {
	                    generatedFiles.push(_this._codgenStyles(srcFileUrl, compiledStyleSheet, fileSuffix));
	                });
	                // compile components
	                exportedVars.push(_this._compileComponentFactory(compMeta, ngModule, fileSuffix, statements), _this._compileComponent(compMeta, ngModule, ngModule.transitiveModule.directives, stylesCompileResults.componentStylesheet, fileSuffix, statements));
	            });
	            if (statements.length > 0) {
	                var /** @type {?} */ srcModule = this._codegenSourceModule(srcFileUrl, _ngfactoryModuleUrl(srcFileUrl), statements, exportedVars);
	                generatedFiles.unshift(srcModule);
	            }
	            return generatedFiles;
	        };
	        /**
	         * @param {?} srcFileUrl
	         * @param {?} directives
	         * @param {?} pipes
	         * @param {?} ngModules
	         * @param {?} injectables
	         * @return {?}
	         */
	        AotCompiler.prototype._createSummary = function (srcFileUrl, directives, pipes, ngModules, injectables) {
	            var _this = this;
	            var /** @type {?} */ symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileUrl)
	                .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });
	            var /** @type {?} */ typeSummaries = ngModules.map(function (ref) { return _this._metadataResolver.getNgModuleSummary(ref); }).concat(directives.map(function (ref) { return _this._metadataResolver.getDirectiveSummary(ref); }), pipes.map(function (ref) { return _this._metadataResolver.getPipeSummary(ref); }), injectables.map(function (ref) { return _this._metadataResolver.getInjectableSummary(ref); }));
	            var /** @type {?} */ json = serializeSummaries(this._host, this._summaryResolver, this._symbolResolver, symbolSummaries, typeSummaries);
	            return new GeneratedFile(srcFileUrl, summaryFileName(srcFileUrl), json);
	        };
	        /**
	         * @param {?} ngModuleType
	         * @param {?} targetStatements
	         * @return {?}
	         */
	        AotCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {
	            var _this = this;
	            var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);
	            var /** @type {?} */ providers = [];
	            if (this._localeId) {
	                providers.push({
	                    token: createIdentifierToken(Identifiers.LOCALE_ID),
	                    useValue: this._localeId,
	                });
	            }
	            if (this._translationFormat) {
	                providers.push({
	                    token: createIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),
	                    useValue: this._translationFormat
	                });
	            }
	            var /** @type {?} */ appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);
	            appCompileResult.dependencies.forEach(function (dep) {
	                dep.placeholder.reference = _this._symbolResolver.getStaticSymbol(_ngfactoryModuleUrl(identifierModuleUrl(dep.comp)), _componentFactoryName(dep.comp));
	            });
	            targetStatements.push.apply(targetStatements, appCompileResult.statements);
	            return appCompileResult.ngModuleFactoryVar;
	        };
	        /**
	         * @param {?} directiveType
	         * @param {?} targetStatements
	         * @return {?}
	         */
	        AotCompiler.prototype._compileDirectiveWrapper = function (directiveType, targetStatements) {
	            var /** @type {?} */ dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);
	            var /** @type {?} */ dirCompileResult = this._dirWrapperCompiler.compile(dirMeta);
	            targetStatements.push.apply(targetStatements, dirCompileResult.statements);
	            return dirCompileResult.dirWrapperClassVar;
	        };
	        /**
	         * @param {?} compMeta
	         * @param {?} ngModule
	         * @param {?} fileSuffix
	         * @param {?} targetStatements
	         * @return {?}
	         */
	        AotCompiler.prototype._compileComponentFactory = function (compMeta, ngModule, fileSuffix, targetStatements) {
	            var /** @type {?} */ hostMeta = createHostComponentMeta(this._symbolResolver.getStaticSymbol(identifierModuleUrl(compMeta.type), identifierName(compMeta.type) + "_Host"), compMeta);
	            var /** @type {?} */ hostViewFactoryVar = this._compileComponent(hostMeta, ngModule, [compMeta.type], null, fileSuffix, targetStatements);
	            var /** @type {?} */ compFactoryVar = _componentFactoryName(compMeta.type);
	            targetStatements.push(variable(compFactoryVar)
	                .set(importExpr(createIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)])
	                .instantiate([
	                literal(compMeta.selector),
	                variable(hostViewFactoryVar),
	                importExpr(compMeta.type),
	            ], importType(createIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const])))
	                .toDeclStmt(null, [StmtModifier.Final]));
	            return compFactoryVar;
	        };
	        /**
	         * @param {?} compMeta
	         * @param {?} ngModule
	         * @param {?} directiveIdentifiers
	         * @param {?} componentStyles
	         * @param {?} fileSuffix
	         * @param {?} targetStatements
	         * @return {?}
	         */
	        AotCompiler.prototype._compileComponent = function (compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements) {
	            var _this = this;
	            var /** @type {?} */ parsedAnimations = this._animationParser.parseComponent(compMeta);
	            var /** @type {?} */ directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });
	            var /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });
	            var /** @type {?} */ parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, ngModule.schemas, identifierName(compMeta.type));
	            var /** @type {?} */ stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);
	            var /** @type {?} */ compiledAnimations = this._animationCompiler.compile(identifierName(compMeta.type), parsedAnimations);
	            var /** @type {?} */ viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes, compiledAnimations);
	            if (componentStyles) {
	                targetStatements.push.apply(targetStatements, _resolveStyleStatements(this._symbolResolver, componentStyles, fileSuffix));
	            }
	            compiledAnimations.forEach(function (entry) { return targetStatements.push.apply(targetStatements, entry.statements); });
	            targetStatements.push.apply(targetStatements, _resolveViewStatements(this._symbolResolver, viewResult));
	            return viewResult.viewClassVar;
	        };
	        /**
	         * @param {?} fileUrl
	         * @param {?} stylesCompileResult
	         * @param {?} fileSuffix
	         * @return {?}
	         */
	        AotCompiler.prototype._codgenStyles = function (fileUrl, stylesCompileResult, fileSuffix) {
	            _resolveStyleStatements(this._symbolResolver, stylesCompileResult, fileSuffix);
	            return this._codegenSourceModule(fileUrl, _stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
	        };
	        /**
	         * @param {?} srcFileUrl
	         * @param {?} genFileUrl
	         * @param {?} statements
	         * @param {?} exportedVars
	         * @return {?}
	         */
	        AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, genFileUrl, statements, exportedVars) {
	            return new GeneratedFile(srcFileUrl, genFileUrl, this._outputEmitter.emitStatements(genFileUrl, statements, exportedVars));
	        };
	        return AotCompiler;
	    }());
	    /**
	     * @param {?} reflector
	     * @param {?} compileResult
	     * @return {?}
	     */
	    function _resolveViewStatements(reflector, compileResult) {
	        compileResult.dependencies.forEach(function (dep) {
	            if (dep instanceof ViewClassDependency) {
	                var /** @type {?} */ vfd = (dep);
	                vfd.placeholder.reference =
	                    reflector.getStaticSymbol(_ngfactoryModuleUrl(identifierModuleUrl(vfd.comp)), dep.name);
	            }
	            else if (dep instanceof ComponentFactoryDependency$1) {
	                var /** @type {?} */ cfd = (dep);
	                cfd.placeholder.reference = reflector.getStaticSymbol(_ngfactoryModuleUrl(identifierModuleUrl(cfd.comp)), _componentFactoryName(cfd.comp));
	            }
	            else if (dep instanceof DirectiveWrapperDependency) {
	                var /** @type {?} */ dwd = (dep);
	                dwd.placeholder.reference =
	                    reflector.getStaticSymbol(_ngfactoryModuleUrl(identifierModuleUrl(dwd.dir)), dwd.name);
	            }
	        });
	        return compileResult.statements;
	    }
	    /**
	     * @param {?} reflector
	     * @param {?} compileResult
	     * @param {?} fileSuffix
	     * @return {?}
	     */
	    function _resolveStyleStatements(reflector, compileResult, fileSuffix) {
	        compileResult.dependencies.forEach(function (dep) {
	            dep.valuePlaceholder.reference = reflector.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix), dep.name);
	        });
	        return compileResult.statements;
	    }
	    /**
	     * @param {?} dirUrl
	     * @return {?}
	     */
	    function _ngfactoryModuleUrl(dirUrl) {
	        var /** @type {?} */ urlWithSuffix = _splitTypescriptSuffix(dirUrl);
	        return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
	    }
	    /**
	     * @param {?} comp
	     * @return {?}
	     */
	    function _componentFactoryName(comp) {
	        return identifierName(comp) + "NgFactory";
	    }
	    /**
	     * @param {?} stylesheetUrl
	     * @param {?} shim
	     * @param {?} suffix
	     * @return {?}
	     */
	    function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
	        return "" + stylesheetUrl + (shim ? '.shim' : '') + ".ngstyle" + suffix;
	    }
	    /**
	     * @param {?} meta
	     * @return {?}
	     */
	    function _assertComponent(meta) {
	        if (!meta.isComponent) {
	            throw new Error("Could not compile '" + identifierName(meta.type) + "' because it is not a component.");
	        }
	    }
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    function _splitTypescriptSuffix(path) {
	        if (path.endsWith('.d.ts')) {
	            return [path.slice(0, -5), '.ts'];
	        }
	        var /** @type {?} */ lastDot = path.lastIndexOf('.');
	        if (lastDot !== -1) {
	            return [path.substring(0, lastDot), path.substring(lastDot)];
	        }
	        return [path, ''];
	    }
	    /**
	     * @param {?} programStaticSymbols
	     * @param {?} host
	     * @param {?} metadataResolver
	     * @return {?}
	     */
	    function analyzeNgModules(programStaticSymbols, host, metadataResolver) {
	        var _a = _createNgModules(programStaticSymbols, host, metadataResolver), ngModules = _a.ngModules, symbolsMissingModule = _a.symbolsMissingModule;
	        return _analyzeNgModules(programStaticSymbols, ngModules, symbolsMissingModule, metadataResolver);
	    }
	    /**
	     * @param {?} programStaticSymbols
	     * @param {?} host
	     * @param {?} metadataResolver
	     * @return {?}
	     */
	    function analyzeAndValidateNgModules(programStaticSymbols, host, metadataResolver) {
	        var /** @type {?} */ result = analyzeNgModules(programStaticSymbols, host, metadataResolver);
	        if (result.symbolsMissingModule && result.symbolsMissingModule.length) {
	            var /** @type {?} */ messages = result.symbolsMissingModule.map(function (s) { return ("Cannot determine the module for class " + s.name + " in " + s.filePath + "!"); });
	            throw new Error(messages.join('\n'));
	        }
	        return result;
	    }
	    /**
	     * @param {?} programSymbols
	     * @param {?} ngModuleMetas
	     * @param {?} symbolsMissingModule
	     * @param {?} metadataResolver
	     * @return {?}
	     */
	    function _analyzeNgModules(programSymbols, ngModuleMetas, symbolsMissingModule, metadataResolver) {
	        var /** @type {?} */ moduleMetasByRef = new Map();
	        ngModuleMetas.forEach(function (ngModule) { return moduleMetasByRef.set(ngModule.type.reference, ngModule); });
	        var /** @type {?} */ ngModuleByPipeOrDirective = new Map();
	        var /** @type {?} */ ngModulesByFile = new Map();
	        var /** @type {?} */ ngDirectivesByFile = new Map();
	        var /** @type {?} */ ngPipesByFile = new Map();
	        var /** @type {?} */ ngInjectablesByFile = new Map();
	        var /** @type {?} */ filePaths = new Set();
	        // Make sure we produce an analyzed file for each input file
	        programSymbols.forEach(function (symbol) {
	            var /** @type {?} */ filePath = symbol.filePath;
	            filePaths.add(filePath);
	            if (metadataResolver.isInjectable(symbol)) {
	                ngInjectablesByFile.set(filePath, (ngInjectablesByFile.get(filePath) || []).concat(symbol));
	            }
	        });
	        // Looping over all modules to construct:
	        // - a map from file to modules `ngModulesByFile`,
	        // - a map from file to directives `ngDirectivesByFile`,
	        // - a map from file to pipes `ngPipesByFile`,
	        // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.
	        ngModuleMetas.forEach(function (ngModuleMeta) {
	            var /** @type {?} */ srcFileUrl = ngModuleMeta.type.reference.filePath;
	            filePaths.add(srcFileUrl);
	            ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));
	            ngModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {
	                var /** @type {?} */ fileUrl = dirIdentifier.reference.filePath;
	                filePaths.add(fileUrl);
	                ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));
	                ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);
	            });
	            ngModuleMeta.declaredPipes.forEach(function (pipeIdentifier) {
	                var /** @type {?} */ fileUrl = pipeIdentifier.reference.filePath;
	                filePaths.add(fileUrl);
	                ngPipesByFile.set(fileUrl, (ngPipesByFile.get(fileUrl) || []).concat(pipeIdentifier.reference));
	                ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);
	            });
	        });
	        var /** @type {?} */ files = [];
	        filePaths.forEach(function (srcUrl) {
	            var /** @type {?} */ directives = ngDirectivesByFile.get(srcUrl) || [];
	            var /** @type {?} */ pipes = ngPipesByFile.get(srcUrl) || [];
	            var /** @type {?} */ ngModules = ngModulesByFile.get(srcUrl) || [];
	            var /** @type {?} */ injectables = ngInjectablesByFile.get(srcUrl) || [];
	            files.push({ srcUrl: srcUrl, directives: directives, pipes: pipes, ngModules: ngModules, injectables: injectables });
	        });
	        return {
	            // map directive/pipe to module
	            ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,
	            // list modules and directives for every source file
	            files: files,
	            ngModules: ngModuleMetas, symbolsMissingModule: symbolsMissingModule
	        };
	    }
	    /**
	     * @param {?} staticSymbolResolver
	     * @param {?} files
	     * @param {?} host
	     * @return {?}
	     */
	    function extractProgramSymbols(staticSymbolResolver, files, host) {
	        var /** @type {?} */ staticSymbols = [];
	        files.filter(function (fileName) { return host.isSourceFile(fileName); }).forEach(function (sourceFile) {
	            staticSymbolResolver.getSymbolsOf(sourceFile).forEach(function (symbol) {
	                var /** @type {?} */ resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);
	                var /** @type {?} */ symbolMeta = resolvedSymbol.metadata;
	                if (symbolMeta) {
	                    if (symbolMeta.__symbolic != 'error') {
	                        // Ignore symbols that are only included to record error information.
	                        staticSymbols.push(resolvedSymbol.symbol);
	                    }
	                }
	            });
	        });
	        return staticSymbols;
	    }
	    /**
	     * @param {?} programStaticSymbols
	     * @param {?} host
	     * @param {?} metadataResolver
	     * @return {?}
	     */
	    function _createNgModules(programStaticSymbols, host, metadataResolver) {
	        var /** @type {?} */ ngModules = new Map();
	        var /** @type {?} */ programPipesAndDirectives = [];
	        var /** @type {?} */ ngModulePipesAndDirective = new Set();
	        var /** @type {?} */ addNgModule = function (staticSymbol) {
	            if (ngModules.has(staticSymbol) || !host.isSourceFile(staticSymbol.filePath)) {
	                return false;
	            }
	            var /** @type {?} */ ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);
	            if (ngModule) {
	                ngModules.set(ngModule.type.reference, ngModule);
	                ngModule.declaredDirectives.forEach(function (dir) { return ngModulePipesAndDirective.add(dir.reference); });
	                ngModule.declaredPipes.forEach(function (pipe) { return ngModulePipesAndDirective.add(pipe.reference); });
	                // For every input module add the list of transitively included modules
	                ngModule.transitiveModule.modules.forEach(function (modMeta) { return addNgModule(modMeta.reference); });
	            }
	            return !!ngModule;
	        };
	        programStaticSymbols.forEach(function (staticSymbol) {
	            if (!addNgModule(staticSymbol) &&
	                (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {
	                programPipesAndDirectives.push(staticSymbol);
	            }
	        });
	        // Throw an error if any of the program pipe or directives is not declared by a module
	        var /** @type {?} */ symbolsMissingModule = programPipesAndDirectives.filter(function (s) { return !ngModulePipesAndDirective.has(s); });
	        return { ngModules: Array.from(ngModules.values()), symbolsMissingModule: symbolsMissingModule };
	    }

	    var StaticAndDynamicReflectionCapabilities = (function () {
	        /**
	         * @param {?} staticDelegate
	         */
	        function StaticAndDynamicReflectionCapabilities(staticDelegate) {
	            this.staticDelegate = staticDelegate;
	            this.dynamicDelegate = new ReflectionCapabilities();
	        }
	        /**
	         * @param {?} staticDelegate
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.install = function (staticDelegate) {
	            reflector.updateCapabilities(new StaticAndDynamicReflectionCapabilities(staticDelegate));
	        };
	        /**
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.factory = function (type) { return this.dynamicDelegate.factory(type); };
	        /**
	         * @param {?} type
	         * @param {?} lcProperty
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return isStaticType(type) ? this.staticDelegate.hasLifecycleHook(type, lcProperty) :
	                this.dynamicDelegate.hasLifecycleHook(type, lcProperty);
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.parameters = function (type) {
	            return isStaticType(type) ? this.staticDelegate.parameters(type) :
	                this.dynamicDelegate.parameters(type);
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.annotations = function (type) {
	            return isStaticType(type) ? this.staticDelegate.annotations(type) :
	                this.dynamicDelegate.annotations(type);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	            return isStaticType(typeOrFunc) ? this.staticDelegate.propMetadata(typeOrFunc) :
	                this.dynamicDelegate.propMetadata(typeOrFunc);
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.getter = function (name) { return this.dynamicDelegate.getter(name); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.setter = function (name) { return this.dynamicDelegate.setter(name); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.method = function (name) { return this.dynamicDelegate.method(name); };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.importUri = function (type) { return this.staticDelegate.importUri(type); };
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
	            return this.staticDelegate.resolveIdentifier(name, moduleUrl);
	        };
	        /**
	         * @param {?} enumIdentifier
	         * @param {?} name
	         * @return {?}
	         */
	        StaticAndDynamicReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) {
	            if (isStaticType(enumIdentifier)) {
	                return this.staticDelegate.resolveEnum(enumIdentifier, name);
	            }
	            else {
	                return null;
	            }
	        };
	        return StaticAndDynamicReflectionCapabilities;
	    }());
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function isStaticType(type) {
	        return typeof type === 'object' && type.name && type.filePath;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$27 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ ANGULAR_IMPORT_LOCATIONS = {
	        coreDecorators: '@angular/core/src/metadata',
	        diDecorators: '@angular/core/src/di/metadata',
	        diMetadata: '@angular/core/src/di/metadata',
	        diOpaqueToken: '@angular/core/src/di/opaque_token',
	        animationMetadata: '@angular/core/src/animation/metadata',
	        provider: '@angular/core/src/di/provider'
	    };
	    var /** @type {?} */ HIDDEN_KEY = /^\$.*\$$/;
	    /**
	     * A static reflector implements enough of the Reflector API that is necessary to compile
	     * templates statically.
	     */
	    var StaticReflector = (function () {
	        /**
	         * @param {?} symbolResolver
	         * @param {?=} knownMetadataClasses
	         * @param {?=} knownMetadataFunctions
	         * @param {?=} errorRecorder
	         */
	        function StaticReflector(symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {
	            var _this = this;
	            if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }
	            if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }
	            this.symbolResolver = symbolResolver;
	            this.errorRecorder = errorRecorder;
	            this.annotationCache = new Map();
	            this.propertyCache = new Map();
	            this.parameterCache = new Map();
	            this.methodCache = new Map();
	            this.conversionMap = new Map();
	            this.initializeConversionMap();
	            knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });
	            knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });
	        }
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        StaticReflector.prototype.importUri = function (typeOrFunc) {
	            var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);
	            return staticSymbol ? staticSymbol.filePath : null;
	        };
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @return {?}
	         */
	        StaticReflector.prototype.resolveIdentifier = function (name, moduleUrl) {
	            return this.findDeclaration(moduleUrl, name);
	        };
	        /**
	         * @param {?} moduleUrl
	         * @param {?} name
	         * @param {?=} containingFile
	         * @return {?}
	         */
	        StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {
	            return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));
	        };
	        /**
	         * @param {?} symbol
	         * @return {?}
	         */
	        StaticReflector.prototype.findSymbolDeclaration = function (symbol) {
	            var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);
	            if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {
	                return this.findSymbolDeclaration(resolvedSymbol.metadata);
	            }
	            else {
	                return symbol;
	            }
	        };
	        /**
	         * @param {?} enumIdentifier
	         * @param {?} name
	         * @return {?}
	         */
	        StaticReflector.prototype.resolveEnum = function (enumIdentifier, name) {
	            var /** @type {?} */ staticSymbol = enumIdentifier;
	            return this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name, [name]);
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticReflector.prototype.annotations = function (type) {
	            var /** @type {?} */ annotations = this.annotationCache.get(type);
	            if (!annotations) {
	                annotations = [];
	                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);
	                if (classMetadata['extends']) {
	                    var /** @type {?} */ parentAnnotations = this.annotations(this.simplify(type, classMetadata['extends']));
	                    annotations.push.apply(annotations, parentAnnotations);
	                }
	                if (classMetadata['decorators']) {
	                    var /** @type {?} */ ownAnnotations = this.simplify(type, classMetadata['decorators']);
	                    annotations.push.apply(annotations, ownAnnotations);
	                }
	                this.annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));
	            }
	            return annotations;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticReflector.prototype.propMetadata = function (type) {
	            var _this = this;
	            var /** @type {?} */ propMetadata = this.propertyCache.get(type);
	            if (!propMetadata) {
	                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);
	                propMetadata = {};
	                if (classMetadata['extends']) {
	                    var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(this.simplify(type, classMetadata['extends']));
	                    Object.keys(parentPropMetadata_1).forEach(function (parentProp) {
	                        propMetadata[parentProp] = parentPropMetadata_1[parentProp];
	                    });
	                }
	                var /** @type {?} */ members_1 = classMetadata['members'] || {};
	                Object.keys(members_1).forEach(function (propName) {
	                    var /** @type {?} */ propData = members_1[propName];
	                    var /** @type {?} */ prop = ((propData))
	                        .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });
	                    var /** @type {?} */ decorators = [];
	                    if (propMetadata[propName]) {
	                        decorators.push.apply(decorators, propMetadata[propName]);
	                    }
	                    propMetadata[propName] = decorators;
	                    if (prop && prop['decorators']) {
	                        decorators.push.apply(decorators, _this.simplify(type, prop['decorators']));
	                    }
	                });
	                this.propertyCache.set(type, propMetadata);
	            }
	            return propMetadata;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticReflector.prototype.parameters = function (type) {
	            if (!(type instanceof StaticSymbol)) {
	                this.reportError(new Error("parameters received " + JSON.stringify(type) + " which is not a StaticSymbol"), type);
	                return [];
	            }
	            try {
	                var /** @type {?} */ parameters_1 = this.parameterCache.get(type);
	                if (!parameters_1) {
	                    var /** @type {?} */ classMetadata = this.getTypeMetadata(type);
	                    var /** @type {?} */ members = classMetadata ? classMetadata['members'] : null;
	                    var /** @type {?} */ ctorData = members ? members['__ctor__'] : null;
	                    if (ctorData) {
	                        var /** @type {?} */ ctor = ((ctorData)).find(function (a) { return a['__symbolic'] == 'constructor'; });
	                        var /** @type {?} */ parameterTypes = (this.simplify(type, ctor['parameters'] || []));
	                        var /** @type {?} */ parameterDecorators_1 = (this.simplify(type, ctor['parameterDecorators'] || []));
	                        parameters_1 = [];
	                        parameterTypes.forEach(function (paramType, index) {
	                            var /** @type {?} */ nestedResult = [];
	                            if (paramType) {
	                                nestedResult.push(paramType);
	                            }
	                            var /** @type {?} */ decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;
	                            if (decorators) {
	                                nestedResult.push.apply(nestedResult, decorators);
	                            }
	                            parameters_1.push(nestedResult);
	                        });
	                    }
	                    else if (classMetadata['extends']) {
	                        parameters_1 = this.parameters(this.simplify(type, classMetadata['extends']));
	                    }
	                    if (!parameters_1) {
	                        parameters_1 = [];
	                    }
	                    this.parameterCache.set(type, parameters_1);
	                }
	                return parameters_1;
	            }
	            catch (e) {
	                console.error("Failed on type " + JSON.stringify(type) + " with error " + e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticReflector.prototype._methodNames = function (type) {
	            var /** @type {?} */ methodNames = this.methodCache.get(type);
	            if (!methodNames) {
	                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);
	                methodNames = {};
	                if (classMetadata['extends']) {
	                    var /** @type {?} */ parentMethodNames_1 = this._methodNames(this.simplify(type, classMetadata['extends']));
	                    Object.keys(parentMethodNames_1).forEach(function (parentProp) {
	                        methodNames[parentProp] = parentMethodNames_1[parentProp];
	                    });
	                }
	                var /** @type {?} */ members_2 = classMetadata['members'] || {};
	                Object.keys(members_2).forEach(function (propName) {
	                    var /** @type {?} */ propData = members_2[propName];
	                    var /** @type {?} */ isMethod = ((propData)).some(function (a) { return a['__symbolic'] == 'method'; });
	                    methodNames[propName] = methodNames[propName] || isMethod;
	                });
	                this.methodCache.set(type, methodNames);
	            }
	            return methodNames;
	        };
	        /**
	         * @param {?} type
	         * @param {?} lcProperty
	         * @return {?}
	         */
	        StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {
	            if (!(type instanceof StaticSymbol)) {
	                this.reportError(new Error("hasLifecycleHook received " + JSON.stringify(type) + " which is not a StaticSymbol"), type);
	            }
	            try {
	                return !!this._methodNames(type)[lcProperty];
	            }
	            catch (e) {
	                console.error("Failed on type " + JSON.stringify(type) + " with error " + e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} type
	         * @param {?} ctor
	         * @return {?}
	         */
	        StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {
	            this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, [void 0].concat(args)))(); });
	        };
	        /**
	         * @param {?} type
	         * @param {?} fn
	         * @return {?}
	         */
	        StaticReflector.prototype._registerFunction = function (type, fn) {
	            this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });
	        };
	        /**
	         * @return {?}
	         */
	        StaticReflector.prototype.initializeConversionMap = function () {
	            var coreDecorators = ANGULAR_IMPORT_LOCATIONS.coreDecorators, diDecorators = ANGULAR_IMPORT_LOCATIONS.diDecorators, diMetadata = ANGULAR_IMPORT_LOCATIONS.diMetadata, diOpaqueToken = ANGULAR_IMPORT_LOCATIONS.diOpaqueToken, animationMetadata = ANGULAR_IMPORT_LOCATIONS.animationMetadata, provider = ANGULAR_IMPORT_LOCATIONS.provider;
	            this.opaqueToken = this.findDeclaration(diOpaqueToken, 'OpaqueToken');
	            this._registerDecoratorOrConstructor(this.findDeclaration(diDecorators, 'Host'), _angular_core.Host);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diDecorators, 'Injectable'), _angular_core.Injectable);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diDecorators, 'Self'), _angular_core.Self);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diDecorators, 'SkipSelf'), _angular_core.SkipSelf);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diDecorators, 'Inject'), _angular_core.Inject);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diDecorators, 'Optional'), _angular_core.Optional);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'Attribute'), _angular_core.Attribute);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'ContentChild'), _angular_core.ContentChild);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'ContentChildren'), _angular_core.ContentChildren);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'ViewChild'), _angular_core.ViewChild);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'ViewChildren'), _angular_core.ViewChildren);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'Input'), _angular_core.Input);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'Output'), _angular_core.Output);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'Pipe'), _angular_core.Pipe);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'HostBinding'), _angular_core.HostBinding);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'HostListener'), _angular_core.HostListener);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'Directive'), _angular_core.Directive);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'Component'), _angular_core.Component);
	            this._registerDecoratorOrConstructor(this.findDeclaration(coreDecorators, 'NgModule'), _angular_core.NgModule);
	            // Note: Some metadata classes can be used directly with Provider.deps.
	            this._registerDecoratorOrConstructor(this.findDeclaration(diMetadata, 'Host'), _angular_core.Host);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diMetadata, 'Self'), _angular_core.Self);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diMetadata, 'SkipSelf'), _angular_core.SkipSelf);
	            this._registerDecoratorOrConstructor(this.findDeclaration(diMetadata, 'Optional'), _angular_core.Optional);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'trigger'), _angular_core.trigger);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'state'), _angular_core.state);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'transition'), _angular_core.transition);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'style'), _angular_core.style);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'animate'), _angular_core.animate);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'keyframes'), _angular_core.keyframes);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'sequence'), _angular_core.sequence);
	            this._registerFunction(this.findDeclaration(animationMetadata, 'group'), _angular_core.group);
	        };
	        /**
	         * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
	         * All types passed to the StaticResolver should be pseudo-types returned by this method.
	         *
	         * @param {?} declarationFile the absolute path of the file where the symbol is declared
	         * @param {?} name the name of the type.
	         * @param {?=} members
	         * @return {?}
	         */
	        StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {
	            return this.symbolResolver.getStaticSymbol(declarationFile, name, members);
	        };
	        /**
	         * @param {?} error
	         * @param {?} context
	         * @param {?=} path
	         * @return {?}
	         */
	        StaticReflector.prototype.reportError = function (error, context, path) {
	            if (this.errorRecorder) {
	                this.errorRecorder(error, (context && context.filePath) || path);
	            }
	            else {
	                throw error;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} context
	         * @param {?} value
	         * @return {?}
	         */
	        StaticReflector.prototype.simplify = function (context, value) {
	            var _this = this;
	            var /** @type {?} */ self = this;
	            var /** @type {?} */ scope = BindingScope.empty;
	            var /** @type {?} */ calling = new Map();
	            /**
	             * @param {?} context
	             * @param {?} value
	             * @param {?} depth
	             * @return {?}
	             */
	            function simplifyInContext(context, value, depth) {
	                /**
	                 * @param {?} staticSymbol
	                 * @return {?}
	                 */
	                function resolveReferenceValue(staticSymbol) {
	                    var /** @type {?} */ resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);
	                    return resolvedSymbol ? resolvedSymbol.metadata : null;
	                }
	                /**
	                 * @param {?} functionSymbol
	                 * @param {?} targetFunction
	                 * @param {?} args
	                 * @return {?}
	                 */
	                function simplifyCall(functionSymbol, targetFunction, args) {
	                    if (targetFunction && targetFunction['__symbolic'] == 'function') {
	                        if (calling.get(functionSymbol)) {
	                            throw new Error('Recursion not supported');
	                        }
	                        calling.set(functionSymbol, true);
	                        try {
	                            var /** @type {?} */ value_1 = targetFunction['value'];
	                            if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {
	                                var /** @type {?} */ parameters = targetFunction['parameters'];
	                                var /** @type {?} */ defaults = targetFunction.defaults;
	                                args = args.map(function (arg) { return simplifyInContext(context, arg, depth + 1); });
	                                if (defaults && defaults.length > args.length) {
	                                    args.push.apply(args, defaults.slice(args.length).map(function (value) { return simplify(value); }));
	                                }
	                                var /** @type {?} */ functionScope = BindingScope.build();
	                                for (var /** @type {?} */ i = 0; i < parameters.length; i++) {
	                                    functionScope.define(parameters[i], args[i]);
	                                }
	                                var /** @type {?} */ oldScope = scope;
	                                var /** @type {?} */ result_1;
	                                try {
	                                    scope = functionScope.done();
	                                    result_1 = simplifyInContext(functionSymbol, value_1, depth + 1);
	                                }
	                                finally {
	                                    scope = oldScope;
	                                }
	                                return result_1;
	                            }
	                        }
	                        finally {
	                            calling.delete(functionSymbol);
	                        }
	                    }
	                    if (depth === 0) {
	                        // If depth is 0 we are evaluating the top level expression that is describing element
	                        // decorator. In this case, it is a decorator we don't understand, such as a custom
	                        // non-angular decorator, and we should just ignore it.
	                        return { __symbolic: 'ignore' };
	                    }
	                    return simplify({ __symbolic: 'error', message: 'Function call not supported', context: functionSymbol });
	                }
	                /**
	                 * @param {?} expression
	                 * @return {?}
	                 */
	                function simplify(expression) {
	                    if (isPrimitive$1(expression)) {
	                        return expression;
	                    }
	                    if (expression instanceof Array) {
	                        var /** @type {?} */ result_2 = [];
	                        for (var _i = 0, _a = ((expression)); _i < _a.length; _i++) {
	                            var item = _a[_i];
	                            // Check for a spread expression
	                            if (item && item.__symbolic === 'spread') {
	                                var /** @type {?} */ spreadArray = simplify(item.expression);
	                                if (Array.isArray(spreadArray)) {
	                                    for (var _b = 0, spreadArray_1 = spreadArray; _b < spreadArray_1.length; _b++) {
	                                        var spreadItem = spreadArray_1[_b];
	                                        result_2.push(spreadItem);
	                                    }
	                                    continue;
	                                }
	                            }
	                            var /** @type {?} */ value_2 = simplify(item);
	                            if (shouldIgnore(value_2)) {
	                                continue;
	                            }
	                            result_2.push(value_2);
	                        }
	                        return result_2;
	                    }
	                    if (expression instanceof StaticSymbol) {
	                        // Stop simplification at builtin symbols
	                        if (expression === self.opaqueToken || self.conversionMap.has(expression)) {
	                            return expression;
	                        }
	                        else {
	                            var /** @type {?} */ staticSymbol = expression;
	                            var /** @type {?} */ declarationValue = resolveReferenceValue(staticSymbol);
	                            if (declarationValue) {
	                                return simplifyInContext(staticSymbol, declarationValue, depth + 1);
	                            }
	                            else {
	                                return staticSymbol;
	                            }
	                        }
	                    }
	                    if (expression) {
	                        if (expression['__symbolic']) {
	                            var /** @type {?} */ staticSymbol = void 0;
	                            switch (expression['__symbolic']) {
	                                case 'binop':
	                                    var /** @type {?} */ left = simplify(expression['left']);
	                                    if (shouldIgnore(left))
	                                        return left;
	                                    var /** @type {?} */ right = simplify(expression['right']);
	                                    if (shouldIgnore(right))
	                                        return right;
	                                    switch (expression['operator']) {
	                                        case '&&':
	                                            return left && right;
	                                        case '||':
	                                            return left || right;
	                                        case '|':
	                                            return left | right;
	                                        case '^':
	                                            return left ^ right;
	                                        case '&':
	                                            return left & right;
	                                        case '==':
	                                            return left == right;
	                                        case '!=':
	                                            return left != right;
	                                        case '===':
	                                            return left === right;
	                                        case '!==':
	                                            return left !== right;
	                                        case '<':
	                                            return left < right;
	                                        case '>':
	                                            return left > right;
	                                        case '<=':
	                                            return left <= right;
	                                        case '>=':
	                                            return left >= right;
	                                        case '<<':
	                                            return left << right;
	                                        case '>>':
	                                            return left >> right;
	                                        case '+':
	                                            return left + right;
	                                        case '-':
	                                            return left - right;
	                                        case '*':
	                                            return left * right;
	                                        case '/':
	                                            return left / right;
	                                        case '%':
	                                            return left % right;
	                                    }
	                                    return null;
	                                case 'if':
	                                    var /** @type {?} */ condition = simplify(expression['condition']);
	                                    return condition ? simplify(expression['thenExpression']) :
	                                        simplify(expression['elseExpression']);
	                                case 'pre':
	                                    var /** @type {?} */ operand = simplify(expression['operand']);
	                                    if (shouldIgnore(operand))
	                                        return operand;
	                                    switch (expression['operator']) {
	                                        case '+':
	                                            return operand;
	                                        case '-':
	                                            return -operand;
	                                        case '!':
	                                            return !operand;
	                                        case '~':
	                                            return ~operand;
	                                    }
	                                    return null;
	                                case 'index':
	                                    var /** @type {?} */ indexTarget = simplify(expression['expression']);
	                                    var /** @type {?} */ index = simplify(expression['index']);
	                                    if (indexTarget && isPrimitive$1(index))
	                                        return indexTarget[index];
	                                    return null;
	                                case 'select':
	                                    var /** @type {?} */ member = expression['member'];
	                                    var /** @type {?} */ selectContext = context;
	                                    var /** @type {?} */ selectTarget = simplify(expression['expression']);
	                                    if (selectTarget instanceof StaticSymbol) {
	                                        var /** @type {?} */ members = selectTarget.members.concat(member);
	                                        selectContext =
	                                            self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);
	                                        var /** @type {?} */ declarationValue = resolveReferenceValue(selectContext);
	                                        if (declarationValue) {
	                                            return simplifyInContext(selectContext, declarationValue, depth + 1);
	                                        }
	                                        else {
	                                            return selectContext;
	                                        }
	                                    }
	                                    if (selectTarget && isPrimitive$1(member))
	                                        return simplifyInContext(selectContext, selectTarget[member], depth + 1);
	                                    return null;
	                                case 'reference':
	                                    // Note: This only has to deal with variable references,
	                                    // as symbol references have been converted into StaticSymbols already
	                                    // in the StaticSymbolResolver!
	                                    var /** @type {?} */ name_1 = expression['name'];
	                                    var /** @type {?} */ localValue = scope.resolve(name_1);
	                                    if (localValue != BindingScope.missing) {
	                                        return localValue;
	                                    }
	                                    break;
	                                case 'class':
	                                    return context;
	                                case 'function':
	                                    return context;
	                                case 'new':
	                                case 'call':
	                                    // Determine if the function is a built-in conversion
	                                    staticSymbol = simplifyInContext(context, expression['expression'], depth + 1);
	                                    if (staticSymbol instanceof StaticSymbol) {
	                                        if (staticSymbol === self.opaqueToken) {
	                                            // if somebody calls new OpaqueToken, don't create an OpaqueToken,
	                                            // but rather return the symbol to which the OpaqueToken is assigned to.
	                                            return context;
	                                        }
	                                        var /** @type {?} */ argExpressions = expression['arguments'] || [];
	                                        var /** @type {?} */ converter = self.conversionMap.get(staticSymbol);
	                                        if (converter) {
	                                            var /** @type {?} */ args = argExpressions.map(function (arg) { return simplifyInContext(context, arg, depth + 1); });
	                                            return converter(context, args);
	                                        }
	                                        else {
	                                            // Determine if the function is one we can simplify.
	                                            var /** @type {?} */ targetFunction = resolveReferenceValue(staticSymbol);
	                                            return simplifyCall(staticSymbol, targetFunction, argExpressions);
	                                        }
	                                    }
	                                    break;
	                                case 'error':
	                                    var /** @type {?} */ message = produceErrorMessage(expression);
	                                    if (expression['line']) {
	                                        message =
	                                            message + " (position " + (expression['line'] + 1) + ":" + (expression['character'] + 1) + " in the original .ts file)";
	                                        throw positionalError(message, context.filePath, expression['line'], expression['character']);
	                                    }
	                                    throw new Error(message);
	                            }
	                            return null;
	                        }
	                        return mapStringMap(expression, function (value, name) { return simplify(value); });
	                    }
	                    return null;
	                }
	                try {
	                    return simplify(value);
	                }
	                catch (e) {
	                    var /** @type {?} */ members = context.members.length ? "." + context.members.join('.') : '';
	                    var /** @type {?} */ message = e.message + ", resolving symbol " + context.name + members + " in " + context.filePath;
	                    if (e.fileName) {
	                        throw positionalError(message, e.fileName, e.line, e.column);
	                    }
	                    throw new SyntaxError(message);
	                }
	            }
	            var /** @type {?} */ recordedSimplifyInContext = function (context, value, depth) {
	                try {
	                    return simplifyInContext(context, value, depth);
	                }
	                catch (e) {
	                    _this.reportError(e, context);
	                }
	            };
	            var /** @type {?} */ result = this.errorRecorder ? recordedSimplifyInContext(context, value, 0) :
	                simplifyInContext(context, value, 0);
	            if (shouldIgnore(result)) {
	                return undefined;
	            }
	            return result;
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        StaticReflector.prototype.getTypeMetadata = function (type) {
	            var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(type);
	            return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :
	                { __symbolic: 'class' };
	        };
	        return StaticReflector;
	    }());
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    function expandedMessage(error) {
	        switch (error.message) {
	            case 'Reference to non-exported class':
	                if (error.context && error.context.className) {
	                    return "Reference to a non-exported class " + error.context.className + ". Consider exporting the class";
	                }
	                break;
	            case 'Variable not initialized':
	                return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';
	            case 'Destructuring not supported':
	                return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';
	            case 'Could not resolve type':
	                if (error.context && error.context.typeName) {
	                    return "Could not resolve type " + error.context.typeName;
	                }
	                break;
	            case 'Function call not supported':
	                var /** @type {?} */ prefix = error.context && error.context.name ? "Calling function '" + error.context.name + "', f" : 'F';
	                return prefix +
	                    'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';
	            case 'Reference to a local symbol':
	                if (error.context && error.context.name) {
	                    return "Reference to a local (non-exported) symbol '" + error.context.name + "'. Consider exporting the symbol";
	                }
	                break;
	        }
	        return error.message;
	    }
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    function produceErrorMessage(error) {
	        return "Error encountered resolving symbol values statically. " + expandedMessage(error);
	    }
	    /**
	     * @param {?} input
	     * @param {?} transform
	     * @return {?}
	     */
	    function mapStringMap(input, transform) {
	        if (!input)
	            return {};
	        var /** @type {?} */ result = {};
	        Object.keys(input).forEach(function (key) {
	            var /** @type {?} */ value = transform(input[key], key);
	            if (!shouldIgnore(value)) {
	                if (HIDDEN_KEY.test(key)) {
	                    Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });
	                }
	                else {
	                    result[key] = value;
	                }
	            }
	        });
	        return result;
	    }
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isPrimitive$1(o) {
	        return o === null || (typeof o !== 'function' && typeof o !== 'object');
	    }
	    /**
	     * @abstract
	     */
	    var BindingScope = (function () {
	        function BindingScope() {
	        }
	        /**
	         * @abstract
	         * @param {?} name
	         * @return {?}
	         */
	        BindingScope.prototype.resolve = function (name) { };
	        /**
	         * @return {?}
	         */
	        BindingScope.build = function () {
	            var /** @type {?} */ current = new Map();
	            return {
	                define: function (name, value) {
	                    current.set(name, value);
	                    return this;
	                },
	                done: function () {
	                    return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;
	                }
	            };
	        };
	        BindingScope.missing = {};
	        BindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };
	        return BindingScope;
	    }());
	    var PopulatedScope = (function (_super) {
	        __extends$27(PopulatedScope, _super);
	        /**
	         * @param {?} bindings
	         */
	        function PopulatedScope(bindings) {
	            _super.call(this);
	            this.bindings = bindings;
	        }
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        PopulatedScope.prototype.resolve = function (name) {
	            return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;
	        };
	        return PopulatedScope;
	    }(BindingScope));
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function shouldIgnore(value) {
	        return value && value.__symbolic == 'ignore';
	    }
	    /**
	     * @param {?} message
	     * @param {?} fileName
	     * @param {?} line
	     * @param {?} column
	     * @return {?}
	     */
	    function positionalError(message, fileName, line, column) {
	        var /** @type {?} */ result = new Error(message);
	        ((result)).fileName = fileName;
	        ((result)).line = line;
	        ((result)).column = column;
	        return result;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$28 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ResolvedStaticSymbol = (function () {
	        /**
	         * @param {?} symbol
	         * @param {?} metadata
	         */
	        function ResolvedStaticSymbol(symbol, metadata) {
	            this.symbol = symbol;
	            this.metadata = metadata;
	        }
	        return ResolvedStaticSymbol;
	    }());
	    var /** @type {?} */ SUPPORTED_SCHEMA_VERSION = 3;
	    /**
	     * This class is responsible for loading metadata per symbol,
	     * and normalizing references between symbols.
	     */
	    var StaticSymbolResolver = (function () {
	        /**
	         * @param {?} host
	         * @param {?} staticSymbolCache
	         * @param {?} summaryResolver
	         * @param {?=} errorRecorder
	         */
	        function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {
	            this.host = host;
	            this.staticSymbolCache = staticSymbolCache;
	            this.summaryResolver = summaryResolver;
	            this.errorRecorder = errorRecorder;
	            this.metadataCache = new Map();
	            this.resolvedSymbols = new Map();
	            this.resolvedFilePaths = new Set();
	        }
	        /**
	         * @param {?} staticSymbol
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {
	            if (staticSymbol.members.length > 0) {
	                return this._resolveSymbolMembers(staticSymbol);
	            }
	            var /** @type {?} */ result = this._resolveSymbolFromSummary(staticSymbol);
	            if (!result) {
	                // Note: Some users use libraries that were not compiled with ngc, i.e. they don't
	                // have summaries, only .d.ts files. So we always need to check both, the summary
	                // and metadata.
	                this._createSymbolsOf(staticSymbol.filePath);
	                result = this.resolvedSymbols.get(staticSymbol);
	            }
	            return result;
	        };
	        /**
	         * @param {?} staticSymbol
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {
	            var /** @type {?} */ members = staticSymbol.members;
	            var /** @type {?} */ baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));
	            if (!baseResolvedSymbol) {
	                return null;
	            }
	            var /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;
	            if (baseMetadata instanceof StaticSymbol) {
	                return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));
	            }
	            else if (baseMetadata && baseMetadata.__symbolic === 'class') {
	                if (baseMetadata.statics && members.length === 1) {
	                    return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);
	                }
	            }
	            else {
	                var /** @type {?} */ value = baseMetadata;
	                for (var /** @type {?} */ i = 0; i < members.length && value; i++) {
	                    value = value[members[i]];
	                }
	                return new ResolvedStaticSymbol(staticSymbol, value);
	            }
	            return null;
	        };
	        /**
	         * @param {?} staticSymbol
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {
	            var /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);
	            return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;
	        };
	        /**
	         * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
	         * All types passed to the StaticResolver should be pseudo-types returned by this method.
	         *
	         * @param {?} declarationFile the absolute path of the file where the symbol is declared
	         * @param {?} name the name of the type.
	         * @param {?=} members
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {
	            return this.staticSymbolCache.get(declarationFile, name, members);
	        };
	        /**
	         * @param {?} filePath
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {
	            // Note: Some users use libraries that were not compiled with ngc, i.e. they don't
	            // have summaries, only .d.ts files. So we always need to check both, the summary
	            // and metadata.
	            var /** @type {?} */ symbols = new Set(this.summaryResolver.getSymbolsOf(filePath));
	            this._createSymbolsOf(filePath);
	            this.resolvedSymbols.forEach(function (resolvedSymbol) {
	                if (resolvedSymbol.symbol.filePath === filePath) {
	                    symbols.add(resolvedSymbol.symbol);
	                }
	            });
	            return Array.from(symbols);
	        };
	        /**
	         * @param {?} filePath
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {
	            var _this = this;
	            if (this.resolvedFilePaths.has(filePath)) {
	                return;
	            }
	            this.resolvedFilePaths.add(filePath);
	            var /** @type {?} */ resolvedSymbols = [];
	            var /** @type {?} */ metadata = this.getModuleMetadata(filePath);
	            if (metadata['metadata']) {
	                // handle direct declarations of the symbol
	                Object.keys(metadata['metadata']).forEach(function (symbolName) {
	                    var /** @type {?} */ symbolMeta = metadata['metadata'][symbolName];
	                    resolvedSymbols.push(_this.createResolvedSymbol(_this.getStaticSymbol(filePath, symbolName), symbolMeta));
	                });
	            }
	            // handle the symbols in one of the re-export location
	            if (metadata['exports']) {
	                var _loop_1 = function(moduleExport) {
	                    // handle the symbols in the list of explicitly re-exported symbols.
	                    if (moduleExport.export) {
	                        moduleExport.export.forEach(function (exportSymbol) {
	                            var /** @type {?} */ symbolName;
	                            if (typeof exportSymbol === 'string') {
	                                symbolName = exportSymbol;
	                            }
	                            else {
	                                symbolName = exportSymbol.as;
	                            }
	                            var /** @type {?} */ symName = symbolName;
	                            if (typeof exportSymbol !== 'string') {
	                                symName = exportSymbol.name;
	                            }
	                            var /** @type {?} */ resolvedModule = _this.resolveModule(moduleExport.from, filePath);
	                            if (resolvedModule) {
	                                var /** @type {?} */ targetSymbol = _this.getStaticSymbol(resolvedModule, symName);
	                                var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, symbolName);
	                                resolvedSymbols.push(new ResolvedStaticSymbol(sourceSymbol, targetSymbol));
	                            }
	                        });
	                    }
	                    else {
	                        // handle the symbols via export * directives.
	                        var /** @type {?} */ resolvedModule = this_1.resolveModule(moduleExport.from, filePath);
	                        if (resolvedModule) {
	                            var /** @type {?} */ nestedExports = this_1.getSymbolsOf(resolvedModule);
	                            nestedExports.forEach(function (targetSymbol) {
	                                var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);
	                                resolvedSymbols.push(new ResolvedStaticSymbol(sourceSymbol, targetSymbol));
	                            });
	                        }
	                    }
	                };
	                var this_1 = this;
	                for (var _i = 0, _a = metadata['exports']; _i < _a.length; _i++) {
	                    var moduleExport = _a[_i];
	                    _loop_1(moduleExport);
	                }
	            }
	            resolvedSymbols.forEach(function (resolvedSymbol) { return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol); });
	        };
	        /**
	         * @param {?} sourceSymbol
	         * @param {?} metadata
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, metadata) {
	            var /** @type {?} */ self = this;
	            var ReferenceTransformer = (function (_super) {
	                __extends$28(ReferenceTransformer, _super);
	                function ReferenceTransformer() {
	                    _super.apply(this, arguments);
	                }
	                /**
	                 * @param {?} map
	                 * @param {?} functionParams
	                 * @return {?}
	                 */
	                ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {
	                    var /** @type {?} */ symbolic = map['__symbolic'];
	                    if (symbolic === 'function') {
	                        var /** @type {?} */ oldLen = functionParams.length;
	                        functionParams.push.apply(functionParams, (map['parameters'] || []));
	                        var /** @type {?} */ result = _super.prototype.visitStringMap.call(this, map, functionParams);
	                        functionParams.length = oldLen;
	                        return result;
	                    }
	                    else if (symbolic === 'reference') {
	                        var /** @type {?} */ module_1 = map['module'];
	                        var /** @type {?} */ name_1 = map['name'];
	                        if (!name_1) {
	                            return null;
	                        }
	                        var /** @type {?} */ filePath = void 0;
	                        if (module_1) {
	                            filePath = self.resolveModule(module_1, sourceSymbol.filePath);
	                            if (!filePath) {
	                                return {
	                                    __symbolic: 'error',
	                                    message: "Could not resolve " + module_1 + " relative to " + sourceSymbol.filePath + "."
	                                };
	                            }
	                        }
	                        else {
	                            var /** @type {?} */ isFunctionParam = functionParams.indexOf(name_1) >= 0;
	                            if (!isFunctionParam) {
	                                filePath = sourceSymbol.filePath;
	                            }
	                        }
	                        if (filePath) {
	                            return self.getStaticSymbol(filePath, name_1);
	                        }
	                        else {
	                            // reference to a function parameter
	                            return { __symbolic: 'reference', name: name_1 };
	                        }
	                    }
	                    else {
	                        return _super.prototype.visitStringMap.call(this, map, functionParams);
	                    }
	                };
	                return ReferenceTransformer;
	            }(ValueTransformer));
	            var /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);
	            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);
	        };
	        /**
	         * @param {?} error
	         * @param {?} context
	         * @param {?=} path
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.reportError = function (error, context, path) {
	            if (this.errorRecorder) {
	                this.errorRecorder(error, (context && context.filePath) || path);
	            }
	            else {
	                throw error;
	            }
	        };
	        /**
	         * @param {?} module an absolute path to a module file.
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.getModuleMetadata = function (module) {
	            var /** @type {?} */ moduleMetadata = this.metadataCache.get(module);
	            if (!moduleMetadata) {
	                var /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);
	                if (moduleMetadatas) {
	                    var /** @type {?} */ maxVersion_1 = -1;
	                    moduleMetadatas.forEach(function (md) {
	                        if (md['version'] > maxVersion_1) {
	                            maxVersion_1 = md['version'];
	                            moduleMetadata = md;
	                        }
	                    });
	                }
	                if (!moduleMetadata) {
	                    moduleMetadata =
	                        { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };
	                }
	                if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {
	                    var /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?
	                        "Unsupported metadata version " + moduleMetadata['version'] + " for module " + module + ". This module should be compiled with a newer version of ngc" :
	                        "Metadata version mismatch for module " + module + ", found version " + moduleMetadata['version'] + ", expected " + SUPPORTED_SCHEMA_VERSION;
	                    this.reportError(new Error(errorMessage), null);
	                }
	                this.metadataCache.set(module, moduleMetadata);
	            }
	            return moduleMetadata;
	        };
	        /**
	         * @param {?} module
	         * @param {?} symbolName
	         * @param {?=} containingFile
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {
	            var /** @type {?} */ filePath = this.resolveModule(module, containingFile);
	            if (!filePath) {
	                this.reportError(new Error("Could not resolve module " + module + (containingFile ? " relative to $ {\n            containingFile\n          } " : '')), null);
	                return this.getStaticSymbol("ERROR:" + module, symbolName);
	            }
	            return this.getStaticSymbol(filePath, symbolName);
	        };
	        /**
	         * @param {?} module
	         * @param {?} containingFile
	         * @return {?}
	         */
	        StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {
	            try {
	                return this.host.moduleNameToFileName(module, containingFile);
	            }
	            catch (e) {
	                console.error("Could not resolve module '" + module + "' relative to file " + containingFile);
	                this.reportError(new e, null, containingFile);
	            }
	        };
	        return StaticSymbolResolver;
	    }());

	    var AotSummaryResolver = (function () {
	        /**
	         * @param {?} host
	         * @param {?} staticSymbolCache
	         */
	        function AotSummaryResolver(host, staticSymbolCache) {
	            this.host = host;
	            this.staticSymbolCache = staticSymbolCache;
	            this.summaryCache = new Map();
	            this.loadedFilePaths = new Set();
	        }
	        /**
	         * @param {?} symbol
	         * @return {?}
	         */
	        AotSummaryResolver.prototype._assertNoMembers = function (symbol) {
	            if (symbol.members.length) {
	                throw new Error("Internal state: StaticSymbols in summaries can't have members! " + JSON.stringify(symbol));
	            }
	        };
	        /**
	         * @param {?} staticSymbol
	         * @return {?}
	         */
	        AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {
	            this._assertNoMembers(staticSymbol);
	            var /** @type {?} */ summary = this.summaryCache.get(staticSymbol);
	            if (!summary) {
	                this._loadSummaryFile(staticSymbol.filePath);
	                summary = this.summaryCache.get(staticSymbol);
	            }
	            return summary;
	        };
	        /**
	         * @param {?} filePath
	         * @return {?}
	         */
	        AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {
	            this._loadSummaryFile(filePath);
	            return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });
	        };
	        /**
	         * @param {?} filePath
	         * @return {?}
	         */
	        AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {
	            var _this = this;
	            if (this.loadedFilePaths.has(filePath)) {
	                return;
	            }
	            this.loadedFilePaths.add(filePath);
	            if (!this.host.isSourceFile(filePath)) {
	                var /** @type {?} */ summaryFilePath = summaryFileName(filePath);
	                var /** @type {?} */ json = void 0;
	                try {
	                    json = this.host.loadSummary(summaryFilePath);
	                }
	                catch (e) {
	                    console.error("Error loading summary file " + summaryFilePath);
	                    throw e;
	                }
	                if (json) {
	                    var /** @type {?} */ readSummaries = deserializeSummaries(this.staticSymbolCache, json);
	                    readSummaries.forEach(function (summary) { _this.summaryCache.set(summary.symbol, summary); });
	                }
	            }
	        };
	        return AotSummaryResolver;
	    }());

	    /**
	     * Creates a new AotCompiler based on options and a host.
	     * @param {?} compilerHost
	     * @param {?} options
	     * @return {?}
	     */
	    function createAotCompiler(compilerHost, options) {
	        var /** @type {?} */ translations = options.translations || '';
	        var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();
	        var /** @type {?} */ symbolCache = new StaticSymbolCache();
	        var /** @type {?} */ summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);
	        var /** @type {?} */ symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);
	        var /** @type {?} */ staticReflector = new StaticReflector(symbolResolver);
	        StaticAndDynamicReflectionCapabilities.install(staticReflector);
	        var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat);
	        var /** @type {?} */ config = new CompilerConfig({
	            genDebugInfo: options.debug === true,
	            defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated,
	            logBindingUpdate: false,
	            useJit: false
	        });
	        var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);
	        var /** @type {?} */ expressionParser = new Parser(new Lexer());
	        var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();
	        var /** @type {?} */ console = new Console();
	        var /** @type {?} */ tmplParser = new TemplateParser(expressionParser, elementSchemaRegistry, htmlParser, console, []);
	        var /** @type {?} */ resolver = new CompileMetadataResolver(new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, staticReflector);
	        // TODO(vicb): do not pass options.i18nFormat here
	        var /** @type {?} */ compiler = new AotCompiler(compilerHost, resolver, tmplParser, new StyleCompiler(urlResolver), new ViewCompiler(config, elementSchemaRegistry), new DirectiveWrapperCompiler(config, expressionParser, elementSchemaRegistry, console), new NgModuleCompiler(), new TypeScriptEmitter(compilerHost), summaryResolver, options.locale, options.i18nFormat, new AnimationParser(elementSchemaRegistry), symbolResolver);
	        return { compiler: compiler, reflector: staticReflector };
	    }

	    /**
	     * @param {?} statements
	     * @param {?} resultVar
	     * @return {?}
	     */
	    function interpretStatements(statements, resultVar) {
	        var /** @type {?} */ stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);
	        var /** @type {?} */ ctx = new _ExecutionContext(null, null, null, new Map());
	        var /** @type {?} */ visitor = new StatementInterpreter();
	        var /** @type {?} */ result = visitor.visitAllStatements(stmtsWithReturn, ctx);
	        return isPresent(result) ? result.value : null;
	    }
	    /**
	     * @param {?} varNames
	     * @param {?} varValues
	     * @param {?} statements
	     * @param {?} ctx
	     * @param {?} visitor
	     * @return {?}
	     */
	    function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
	        var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();
	        for (var /** @type {?} */ i = 0; i < varNames.length; i++) {
	            childCtx.vars.set(varNames[i], varValues[i]);
	        }
	        var /** @type {?} */ result = visitor.visitAllStatements(statements, childCtx);
	        return isPresent(result) ? result.value : null;
	    }
	    var _ExecutionContext = (function () {
	        /**
	         * @param {?} parent
	         * @param {?} instance
	         * @param {?} className
	         * @param {?} vars
	         */
	        function _ExecutionContext(parent, instance, className, vars) {
	            this.parent = parent;
	            this.instance = instance;
	            this.className = className;
	            this.vars = vars;
	        }
	        /**
	         * @return {?}
	         */
	        _ExecutionContext.prototype.createChildWihtLocalVars = function () {
	            return new _ExecutionContext(this, this.instance, this.className, new Map());
	        };
	        return _ExecutionContext;
	    }());
	    var ReturnValue = (function () {
	        /**
	         * @param {?} value
	         */
	        function ReturnValue(value) {
	            this.value = value;
	        }
	        return ReturnValue;
	    }());
	    /**
	     * @param {?} _classStmt
	     * @param {?} _ctx
	     * @param {?} _visitor
	     * @return {?}
	     */
	    function createDynamicClass(_classStmt, _ctx, _visitor) {
	        var /** @type {?} */ propertyDescriptors = {};
	        _classStmt.getters.forEach(function (getter) {
	            // Note: use `function` instead of arrow function to capture `this`
	            propertyDescriptors[getter.name] = {
	                configurable: false,
	                get: function () {
	                    var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
	                    return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
	                }
	            };
	        });
	        _classStmt.methods.forEach(function (method) {
	            var /** @type {?} */ paramNames = method.params.map(function (param) { return param.name; });
	            // Note: use `function` instead of arrow function to capture `this`
	            propertyDescriptors[method.name] = {
	                writable: false,
	                configurable: false,
	                value: function () {
	                    var args = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        args[_i - 0] = arguments[_i];
	                    }
	                    var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
	                    return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
	                }
	            };
	        });
	        var /** @type {?} */ ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });
	        // Note: use `function` instead of arrow function to capture `this`
	        var /** @type {?} */ ctor = function () {
	            var _this = this;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
	            _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });
	            _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
	        };
	        var /** @type {?} */ superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;
	        ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
	        return ctor;
	    }
	    var StatementInterpreter = (function () {
	        function StatementInterpreter() {
	        }
	        /**
	         * @param {?} ast
	         * @return {?}
	         */
	        StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {
	            ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
	            return null;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {
	            var /** @type {?} */ value = expr.value.visitExpression(this, ctx);
	            var /** @type {?} */ currCtx = ctx;
	            while (currCtx != null) {
	                if (currCtx.vars.has(expr.name)) {
	                    currCtx.vars.set(expr.name, value);
	                    return value;
	                }
	                currCtx = currCtx.parent;
	            }
	            throw new Error("Not declared variable " + expr.name);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {
	            var /** @type {?} */ varName = ast.name;
	            if (isPresent(ast.builtin)) {
	                switch (ast.builtin) {
	                    case BuiltinVar.Super:
	                        return ctx.instance.__proto__;
	                    case BuiltinVar.This:
	                        return ctx.instance;
	                    case BuiltinVar.CatchError:
	                        varName = CATCH_ERROR_VAR$2;
	                        break;
	                    case BuiltinVar.CatchStack:
	                        varName = CATCH_STACK_VAR$2;
	                        break;
	                    default:
	                        throw new Error("Unknown builtin variable " + ast.builtin);
	                }
	            }
	            var /** @type {?} */ currCtx = ctx;
	            while (currCtx != null) {
	                if (currCtx.vars.has(varName)) {
	                    return currCtx.vars.get(varName);
	                }
	                currCtx = currCtx.parent;
	            }
	            throw new Error("Not declared variable " + varName);
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {
	            var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);
	            var /** @type {?} */ index = expr.index.visitExpression(this, ctx);
	            var /** @type {?} */ value = expr.value.visitExpression(this, ctx);
	            receiver[index] = value;
	            return value;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {
	            var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);
	            var /** @type {?} */ value = expr.value.visitExpression(this, ctx);
	            receiver[expr.name] = value;
	            return value;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {
	            var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);
	            var /** @type {?} */ args = this.visitAllExpressions(expr.args, ctx);
	            var /** @type {?} */ result;
	            if (isPresent(expr.builtin)) {
	                switch (expr.builtin) {
	                    case BuiltinMethod.ConcatArray:
	                        result = receiver.concat.apply(receiver, args);
	                        break;
	                    case BuiltinMethod.SubscribeObservable:
	                        result = receiver.subscribe({ next: args[0] });
	                        break;
	                    case BuiltinMethod.Bind:
	                        result = receiver.bind.apply(receiver, args);
	                        break;
	                    default:
	                        throw new Error("Unknown builtin method " + expr.builtin);
	                }
	            }
	            else {
	                result = receiver[expr.name].apply(receiver, args);
	            }
	            return result;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {
	            var /** @type {?} */ args = this.visitAllExpressions(stmt.args, ctx);
	            var /** @type {?} */ fnExpr = stmt.fn;
	            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
	                ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
	                return null;
	            }
	            else {
	                var /** @type {?} */ fn = stmt.fn.visitExpression(this, ctx);
	                return fn.apply(null, args);
	            }
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {
	            return new ReturnValue(stmt.value.visitExpression(this, ctx));
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {
	            var /** @type {?} */ clazz = createDynamicClass(stmt, ctx, this);
	            ctx.vars.set(stmt.name, clazz);
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {
	            return stmt.expr.visitExpression(this, ctx);
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {
	            var /** @type {?} */ condition = stmt.condition.visitExpression(this, ctx);
	            if (condition) {
	                return this.visitAllStatements(stmt.trueCase, ctx);
	            }
	            else if (isPresent(stmt.falseCase)) {
	                return this.visitAllStatements(stmt.falseCase, ctx);
	            }
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {
	            try {
	                return this.visitAllStatements(stmt.bodyStmts, ctx);
	            }
	            catch (e) {
	                var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();
	                childCtx.vars.set(CATCH_ERROR_VAR$2, e);
	                childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);
	                return this.visitAllStatements(stmt.catchStmts, childCtx);
	            }
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {
	            throw stmt.error.visitExpression(this, ctx);
	        };
	        /**
	         * @param {?} stmt
	         * @param {?=} context
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {
	            var /** @type {?} */ args = this.visitAllExpressions(ast.args, ctx);
	            var /** @type {?} */ clazz = ast.classExpr.visitExpression(this, ctx);
	            return new (clazz.bind.apply(clazz, [void 0].concat(args)))();
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {
	            return ast.value.reference;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {
	            if (ast.condition.visitExpression(this, ctx)) {
	                return ast.trueCase.visitExpression(this, ctx);
	            }
	            else if (isPresent(ast.falseCase)) {
	                return ast.falseCase.visitExpression(this, ctx);
	            }
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {
	            return !ast.condition.visitExpression(this, ctx);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {
	            return ast.value.visitExpression(this, ctx);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {
	            var /** @type {?} */ paramNames = ast.params.map(function (param) { return param.name; });
	            return _declareFn(paramNames, ast.statements, ctx, this);
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
	            var /** @type {?} */ paramNames = stmt.params.map(function (param) { return param.name; });
	            ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
	            var _this = this;
	            var /** @type {?} */ lhs = function () { return ast.lhs.visitExpression(_this, ctx); };
	            var /** @type {?} */ rhs = function () { return ast.rhs.visitExpression(_this, ctx); };
	            switch (ast.operator) {
	                case BinaryOperator.Equals:
	                    return lhs() == rhs();
	                case BinaryOperator.Identical:
	                    return lhs() === rhs();
	                case BinaryOperator.NotEquals:
	                    return lhs() != rhs();
	                case BinaryOperator.NotIdentical:
	                    return lhs() !== rhs();
	                case BinaryOperator.And:
	                    return lhs() && rhs();
	                case BinaryOperator.Or:
	                    return lhs() || rhs();
	                case BinaryOperator.Plus:
	                    return lhs() + rhs();
	                case BinaryOperator.Minus:
	                    return lhs() - rhs();
	                case BinaryOperator.Divide:
	                    return lhs() / rhs();
	                case BinaryOperator.Multiply:
	                    return lhs() * rhs();
	                case BinaryOperator.Modulo:
	                    return lhs() % rhs();
	                case BinaryOperator.Lower:
	                    return lhs() < rhs();
	                case BinaryOperator.LowerEquals:
	                    return lhs() <= rhs();
	                case BinaryOperator.Bigger:
	                    return lhs() > rhs();
	                case BinaryOperator.BiggerEquals:
	                    return lhs() >= rhs();
	                default:
	                    throw new Error("Unknown operator " + ast.operator);
	            }
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {
	            var /** @type {?} */ result;
	            var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);
	            result = receiver[ast.name];
	            return result;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {
	            var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);
	            var /** @type {?} */ prop = ast.index.visitExpression(this, ctx);
	            return receiver[prop];
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {
	            return this.visitAllExpressions(ast.entries, ctx);
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {
	            var _this = this;
	            var /** @type {?} */ result = {};
	            ast.entries.forEach(function (entry) { return ((result))[entry.key] = entry.value.visitExpression(_this, ctx); });
	            return result;
	        };
	        /**
	         * @param {?} expressions
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {
	            var _this = this;
	            return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });
	        };
	        /**
	         * @param {?} statements
	         * @param {?} ctx
	         * @return {?}
	         */
	        StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {
	            for (var /** @type {?} */ i = 0; i < statements.length; i++) {
	                var /** @type {?} */ stmt = statements[i];
	                var /** @type {?} */ val = stmt.visitStatement(this, ctx);
	                if (val instanceof ReturnValue) {
	                    return val;
	                }
	            }
	            return null;
	        };
	        return StatementInterpreter;
	    }());
	    /**
	     * @param {?} varNames
	     * @param {?} statements
	     * @param {?} ctx
	     * @param {?} visitor
	     * @return {?}
	     */
	    function _declareFn(varNames, statements, ctx, visitor) {
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
	        };
	    }
	    var /** @type {?} */ CATCH_ERROR_VAR$2 = 'error';
	    var /** @type {?} */ CATCH_STACK_VAR$2 = 'stack';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$30 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @abstract
	     */
	    var AbstractJsEmitterVisitor = (function (_super) {
	        __extends$30(AbstractJsEmitterVisitor, _super);
	        function AbstractJsEmitterVisitor() {
	            _super.call(this, false);
	        }
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
	            var _this = this;
	            ctx.pushClass(stmt);
	            this._visitClassConstructor(stmt, ctx);
	            if (isPresent(stmt.parent)) {
	                ctx.print(stmt.name + ".prototype = Object.create(");
	                stmt.parent.visitExpression(this, ctx);
	                ctx.println(".prototype);");
	            }
	            stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });
	            stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });
	            ctx.popClass();
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
	            ctx.print("function " + stmt.name + "(");
	            if (isPresent(stmt.constructorMethod)) {
	                this._visitParams(stmt.constructorMethod.params, ctx);
	            }
	            ctx.println(") {");
	            ctx.incIndent();
	            if (isPresent(stmt.constructorMethod)) {
	                if (stmt.constructorMethod.body.length > 0) {
	                    ctx.println("var self = this;");
	                    this.visitAllStatements(stmt.constructorMethod.body, ctx);
	                }
	            }
	            ctx.decIndent();
	            ctx.println("}");
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} getter
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {
	            ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
	            ctx.incIndent();
	            if (getter.body.length > 0) {
	                ctx.println("var self = this;");
	                this.visitAllStatements(getter.body, ctx);
	            }
	            ctx.decIndent();
	            ctx.println("}});");
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} method
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {
	            ctx.print(stmt.name + ".prototype." + method.name + " = function(");
	            this._visitParams(method.params, ctx);
	            ctx.println(") {");
	            ctx.incIndent();
	            if (method.body.length > 0) {
	                ctx.println("var self = this;");
	                this.visitAllStatements(method.body, ctx);
	            }
	            ctx.decIndent();
	            ctx.println("};");
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
	            if (ast.builtin === BuiltinVar.This) {
	                ctx.print('self');
	            }
	            else if (ast.builtin === BuiltinVar.Super) {
	                throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
	            }
	            else {
	                _super.prototype.visitReadVarExpr.call(this, ast, ctx);
	            }
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
	            ctx.print("var " + stmt.name + " = ");
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(";");
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
	            ast.value.visitExpression(this, ctx);
	            return null;
	        };
	        /**
	         * @param {?} expr
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
	            var /** @type {?} */ fnExpr = expr.fn;
	            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
	                ctx.currentClass.parent.visitExpression(this, ctx);
	                ctx.print(".call(this");
	                if (expr.args.length > 0) {
	                    ctx.print(", ");
	                    this.visitAllExpressions(expr.args, ctx, ',');
	                }
	                ctx.print(")");
	            }
	            else {
	                _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
	            }
	            return null;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
	            ctx.print("function(");
	            this._visitParams(ast.params, ctx);
	            ctx.println(") {");
	            ctx.incIndent();
	            this.visitAllStatements(ast.statements, ctx);
	            ctx.decIndent();
	            ctx.print("}");
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
	            ctx.print("function " + stmt.name + "(");
	            this._visitParams(stmt.params, ctx);
	            ctx.println(") {");
	            ctx.incIndent();
	            this.visitAllStatements(stmt.statements, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	            return null;
	        };
	        /**
	         * @param {?} stmt
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
	            ctx.println("try {");
	            ctx.incIndent();
	            this.visitAllStatements(stmt.bodyStmts, ctx);
	            ctx.decIndent();
	            ctx.println("} catch (" + CATCH_ERROR_VAR$1.name + ") {");
	            ctx.incIndent();
	            var /** @type {?} */ catchStmts = [(CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [
	                    StmtModifier.Final
	                ]))].concat(stmt.catchStmts);
	            this.visitAllStatements(catchStmts, ctx);
	            ctx.decIndent();
	            ctx.println("}");
	            return null;
	        };
	        /**
	         * @param {?} params
	         * @param {?} ctx
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {
	            this.visitAllObjects(function (param) { return ctx.print(param.name); }, params, ctx, ',');
	        };
	        /**
	         * @param {?} method
	         * @return {?}
	         */
	        AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
	            var /** @type {?} */ name;
	            switch (method) {
	                case BuiltinMethod.ConcatArray:
	                    name = 'concat';
	                    break;
	                case BuiltinMethod.SubscribeObservable:
	                    name = 'subscribe';
	                    break;
	                case BuiltinMethod.Bind:
	                    name = 'bind';
	                    break;
	                default:
	                    throw new Error("Unknown builtin method: " + method);
	            }
	            return name;
	        };
	        return AbstractJsEmitterVisitor;
	    }(AbstractEmitterVisitor));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$29 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @param {?} sourceUrl
	     * @param {?} expr
	     * @param {?} declarations
	     * @param {?} vars
	     * @return {?}
	     */
	    function evalExpression(sourceUrl, expr, declarations, vars) {
	        var /** @type {?} */ fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
	        var /** @type {?} */ fnArgNames = [];
	        var /** @type {?} */ fnArgValues = [];
	        for (var argName in vars) {
	            fnArgNames.push(argName);
	            fnArgValues.push(vars[argName]);
	        }
	        return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
	    }
	    /**
	     * @param {?} sourceUrl
	     * @param {?} statements
	     * @param {?} resultVar
	     * @return {?}
	     */
	    function jitStatements(sourceUrl, statements, resultVar) {
	        var /** @type {?} */ converter = new JitEmitterVisitor();
	        var /** @type {?} */ ctx = EmitterVisitorContext.createRoot([resultVar]);
	        converter.visitAllStatements(statements, ctx);
	        return evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
	    }
	    var JitEmitterVisitor = (function (_super) {
	        __extends$29(JitEmitterVisitor, _super);
	        function JitEmitterVisitor() {
	            _super.apply(this, arguments);
	            this._evalArgNames = [];
	            this._evalArgValues = [];
	        }
	        /**
	         * @return {?}
	         */
	        JitEmitterVisitor.prototype.getArgs = function () {
	            var /** @type {?} */ result = {};
	            for (var /** @type {?} */ i = 0; i < this._evalArgNames.length; i++) {
	                result[this._evalArgNames[i]] = this._evalArgValues[i];
	            }
	            return result;
	        };
	        /**
	         * @param {?} ast
	         * @param {?} ctx
	         * @return {?}
	         */
	        JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
	            var /** @type {?} */ value = ast.value.reference;
	            var /** @type {?} */ id = this._evalArgValues.indexOf(value);
	            if (id === -1) {
	                id = this._evalArgValues.length;
	                this._evalArgValues.push(value);
	                var /** @type {?} */ name_1 = identifierName(ast.value) || 'val';
	                this._evalArgNames.push("jit_" + name_1 + id);
	            }
	            ctx.print(this._evalArgNames[id]);
	            return null;
	        };
	        return JitEmitterVisitor;
	    }(AbstractJsEmitterVisitor));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$17 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$17 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    /**
	     * An internal module of the Angular compiler that begins with component types,
	     * extracts templates, and eventually produces a compiled version of the component
	     * ready for linking into an application.
	     *
	     * \@security When compiling templates at runtime, you must ensure that the entire template comes
	     * from a trusted source. Attacker-controlled data introduced by a template could expose your
	     * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
	     */
	    var JitCompiler = (function () {
	        /**
	         * @param {?} _injector
	         * @param {?} _metadataResolver
	         * @param {?} _templateParser
	         * @param {?} _styleCompiler
	         * @param {?} _viewCompiler
	         * @param {?} _ngModuleCompiler
	         * @param {?} _directiveWrapperCompiler
	         * @param {?} _compilerConfig
	         * @param {?} _animationParser
	         */
	        function JitCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _directiveWrapperCompiler, _compilerConfig, _animationParser) {
	            this._injector = _injector;
	            this._metadataResolver = _metadataResolver;
	            this._templateParser = _templateParser;
	            this._styleCompiler = _styleCompiler;
	            this._viewCompiler = _viewCompiler;
	            this._ngModuleCompiler = _ngModuleCompiler;
	            this._directiveWrapperCompiler = _directiveWrapperCompiler;
	            this._compilerConfig = _compilerConfig;
	            this._animationParser = _animationParser;
	            this._compiledTemplateCache = new Map();
	            this._compiledHostTemplateCache = new Map();
	            this._compiledDirectiveWrapperCache = new Map();
	            this._compiledNgModuleCache = new Map();
	            this._animationCompiler = new AnimationCompiler();
	        }
	        Object.defineProperty(JitCompiler.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._injector; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        JitCompiler.prototype.compileModuleSync = function (moduleType) {
	            return this._compileModuleAndComponents(moduleType, true).syncResult;
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        JitCompiler.prototype.compileModuleAsync = function (moduleType) {
	            return this._compileModuleAndComponents(moduleType, false).asyncResult;
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	            return this._compileModuleAndAllComponents(moduleType, true).syncResult;
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	            return this._compileModuleAndAllComponents(moduleType, false).asyncResult;
	        };
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        JitCompiler.prototype.getNgContentSelectors = function (component) {
	            var /** @type {?} */ template = this._compiledTemplateCache.get(component);
	            if (!template) {
	                throw new Error("The component " + stringify(component) + " is not yet compiled!");
	            }
	            return template.compMeta.template.ngContentSelectors;
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?} isSync
	         * @return {?}
	         */
	        JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {
	            var _this = this;
	            var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);
	            var /** @type {?} */ createResult = function () {
	                _this._compileComponents(moduleType, null);
	                return _this._compileModule(moduleType);
	            };
	            if (isSync) {
	                return new SyncAsyncResult(createResult());
	            }
	            else {
	                return new SyncAsyncResult(null, loadingPromise.then(createResult));
	            }
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?} isSync
	         * @return {?}
	         */
	        JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {
	            var _this = this;
	            var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);
	            var /** @type {?} */ createResult = function () {
	                var /** @type {?} */ componentFactories = [];
	                _this._compileComponents(moduleType, componentFactories);
	                return new _angular_core.ModuleWithComponentFactories(_this._compileModule(moduleType), componentFactories);
	            };
	            if (isSync) {
	                return new SyncAsyncResult(createResult());
	            }
	            else {
	                return new SyncAsyncResult(null, loadingPromise.then(createResult));
	            }
	        };
	        /**
	         * @param {?} mainModule
	         * @param {?} isSync
	         * @return {?}
	         */
	        JitCompiler.prototype._loadModules = function (mainModule, isSync) {
	            var _this = this;
	            var /** @type {?} */ loadingPromises = [];
	            var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
	            // Note: the loadingPromise for a module only includes the loading of the exported directives
	            // of imported modules.
	            // However, for runtime compilation, we want to transitively compile all modules,
	            // so we also need to call loadNgModuleDirectiveAndPipeMetadata for all nested modules.
	            ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {
	                loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(localModuleMeta.reference, isSync));
	            });
	            return Promise.all(loadingPromises);
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        JitCompiler.prototype._compileModule = function (moduleType) {
	            var _this = this;
	            var /** @type {?} */ ngModuleFactory = this._compiledNgModuleCache.get(moduleType);
	            if (!ngModuleFactory) {
	                var /** @type {?} */ moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);
	                // Always provide a bound Compiler
	                var /** @type {?} */ extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(_angular_core.Compiler, { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];
	                var /** @type {?} */ compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);
	                compileResult.dependencies.forEach(function (dep) {
	                    dep.placeholder.reference =
	                        _this._assertComponentKnown(dep.comp.reference, true).proxyComponentFactory;
	                });
	                if (!this._compilerConfig.useJit) {
	                    ngModuleFactory =
	                        interpretStatements(compileResult.statements, compileResult.ngModuleFactoryVar);
	                }
	                else {
	                    ngModuleFactory = jitStatements("/" + identifierName(moduleMeta_1.type) + "/module.ngfactory.js", compileResult.statements, compileResult.ngModuleFactoryVar);
	                }
	                this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);
	            }
	            return ngModuleFactory;
	        };
	        /**
	         * \@internal
	         * @param {?} mainModule
	         * @param {?} allComponentFactories
	         * @return {?}
	         */
	        JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {
	            var _this = this;
	            var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
	            var /** @type {?} */ moduleByDirective = new Map();
	            var /** @type {?} */ templates = new Set();
	            ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {
	                var /** @type {?} */ localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference);
	                localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {
	                    moduleByDirective.set(dirIdentifier.reference, localModuleMeta);
	                    var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);
	                    _this._compileDirectiveWrapper(dirMeta, localModuleMeta);
	                    if (dirMeta.isComponent) {
	                        templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));
	                        if (allComponentFactories) {
	                            var /** @type {?} */ template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);
	                            templates.add(template);
	                            allComponentFactories.push(template.proxyComponentFactory);
	                        }
	                    }
	                });
	            });
	            ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {
	                var /** @type {?} */ localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference);
	                localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {
	                    var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);
	                    if (dirMeta.isComponent) {
	                        dirMeta.entryComponents.forEach(function (entryComponentType) {
	                            var /** @type {?} */ moduleMeta = moduleByDirective.get(entryComponentType.reference);
	                            templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));
	                        });
	                    }
	                });
	                localModuleMeta.entryComponents.forEach(function (entryComponentType) {
	                    var /** @type {?} */ moduleMeta = moduleByDirective.get(entryComponentType.reference);
	                    templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));
	                });
	            });
	            templates.forEach(function (template) { return _this._compileTemplate(template); });
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        JitCompiler.prototype.clearCacheFor = function (type) {
	            this._compiledNgModuleCache.delete(type);
	            this._metadataResolver.clearCacheFor(type);
	            this._compiledHostTemplateCache.delete(type);
	            var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(type);
	            if (compiledTemplate) {
	                this._compiledTemplateCache.delete(type);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        JitCompiler.prototype.clearCache = function () {
	            this._metadataResolver.clearCache();
	            this._compiledTemplateCache.clear();
	            this._compiledHostTemplateCache.clear();
	            this._compiledNgModuleCache.clear();
	        };
	        /**
	         * @param {?} compType
	         * @param {?} ngModule
	         * @return {?}
	         */
	        JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {
	            if (!ngModule) {
	                throw new Error("Component " + stringify(compType) + " is not part of any NgModule or the module has not been imported into your module.");
	            }
	            var /** @type {?} */ compiledTemplate = this._compiledHostTemplateCache.get(compType);
	            if (!compiledTemplate) {
	                var /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(compType);
	                assertComponent(compMeta);
	                var /** @type {?} */ HostClass = function HostClass() { };
	                ((HostClass)).overriddenName = identifierName(compMeta.type) + "_Host";
	                var /** @type {?} */ hostMeta = createHostComponentMeta(HostClass, compMeta);
	                compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, hostMeta, ngModule, [compMeta.type]);
	                this._compiledHostTemplateCache.set(compType, compiledTemplate);
	            }
	            return compiledTemplate;
	        };
	        /**
	         * @param {?} compMeta
	         * @param {?} ngModule
	         * @return {?}
	         */
	        JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {
	            var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);
	            if (!compiledTemplate) {
	                assertComponent(compMeta);
	                compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);
	                this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
	            }
	            return compiledTemplate;
	        };
	        /**
	         * @param {?} compType
	         * @param {?} isHost
	         * @return {?}
	         */
	        JitCompiler.prototype._assertComponentKnown = function (compType, isHost) {
	            var /** @type {?} */ compiledTemplate = isHost ? this._compiledHostTemplateCache.get(compType) :
	                this._compiledTemplateCache.get(compType);
	            if (!compiledTemplate) {
	                throw new Error("Illegal state: Compiled view for component " + stringify(compType) + " (host: " + isHost + ") does not exist!");
	            }
	            return compiledTemplate;
	        };
	        /**
	         * @param {?} dirType
	         * @return {?}
	         */
	        JitCompiler.prototype._assertDirectiveWrapper = function (dirType) {
	            var /** @type {?} */ dirWrapper = this._compiledDirectiveWrapperCache.get(dirType);
	            if (!dirWrapper) {
	                throw new Error("Illegal state: Directive wrapper for " + stringify(dirType) + " has not been compiled!");
	            }
	            return dirWrapper;
	        };
	        /**
	         * @param {?} dirMeta
	         * @param {?} moduleMeta
	         * @return {?}
	         */
	        JitCompiler.prototype._compileDirectiveWrapper = function (dirMeta, moduleMeta) {
	            var /** @type {?} */ compileResult = this._directiveWrapperCompiler.compile(dirMeta);
	            var /** @type {?} */ statements = compileResult.statements;
	            var /** @type {?} */ directiveWrapperClass;
	            if (!this._compilerConfig.useJit) {
	                directiveWrapperClass = interpretStatements(statements, compileResult.dirWrapperClassVar);
	            }
	            else {
	                directiveWrapperClass = jitStatements("/" + identifierName(moduleMeta.type) + "/" + identifierName(dirMeta.type) + "/wrapper.ngfactory.js", statements, compileResult.dirWrapperClassVar);
	            }
	            this._compiledDirectiveWrapperCache.set(dirMeta.type.reference, directiveWrapperClass);
	        };
	        /**
	         * @param {?} template
	         * @return {?}
	         */
	        JitCompiler.prototype._compileTemplate = function (template) {
	            var _this = this;
	            if (template.isCompiled) {
	                return;
	            }
	            var /** @type {?} */ compMeta = template.compMeta;
	            var /** @type {?} */ externalStylesheetsByModuleUrl = new Map();
	            var /** @type {?} */ stylesCompileResult = this._styleCompiler.compileComponent(compMeta);
	            stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });
	            this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);
	            var /** @type {?} */ parsedAnimations = this._animationParser.parseComponent(compMeta);
	            var /** @type {?} */ directives = template.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });
	            var /** @type {?} */ pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });
	            var /** @type {?} */ parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, template.ngModule.schemas, identifierName(compMeta.type));
	            var /** @type {?} */ compiledAnimations = this._animationCompiler.compile(identifierName(compMeta.type), parsedAnimations);
	            var /** @type {?} */ compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), pipes, compiledAnimations);
	            compileResult.dependencies.forEach(function (dep) {
	                var /** @type {?} */ depTemplate;
	                if (dep instanceof ViewClassDependency) {
	                    var /** @type {?} */ vfd = (dep);
	                    depTemplate = _this._assertComponentKnown(vfd.comp.reference, false);
	                    vfd.placeholder.reference = depTemplate.proxyViewClass;
	                }
	                else if (dep instanceof ComponentFactoryDependency$1) {
	                    var /** @type {?} */ cfd = (dep);
	                    depTemplate = _this._assertComponentKnown(cfd.comp.reference, true);
	                    cfd.placeholder.reference = depTemplate.proxyComponentFactory;
	                }
	                else if (dep instanceof DirectiveWrapperDependency) {
	                    var /** @type {?} */ dwd = (dep);
	                    dwd.placeholder.reference = _this._assertDirectiveWrapper(dwd.dir.reference);
	                }
	            });
	            var /** @type {?} */ statements = (_a = stylesCompileResult.componentStylesheet.statements).concat.apply(_a, compiledAnimations.map(function (ca) { return ca.statements; }))
	                .concat(compileResult.statements);
	            var /** @type {?} */ viewClass;
	            if (!this._compilerConfig.useJit) {
	                viewClass = interpretStatements(statements, compileResult.viewClassVar);
	            }
	            else {
	                viewClass = jitStatements("/" + identifierName(template.ngModule.type) + "/" + identifierName(template.compType) + "/" + (template.isHost ? 'host' : 'component') + ".ngfactory.js", statements, compileResult.viewClassVar);
	            }
	            template.compiled(viewClass);
	            var _a;
	        };
	        /**
	         * @param {?} result
	         * @param {?} externalStylesheetsByModuleUrl
	         * @return {?}
	         */
	        JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
	            var _this = this;
	            result.dependencies.forEach(function (dep, i) {
	                var /** @type {?} */ nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
	                var /** @type {?} */ nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
	                dep.valuePlaceholder.reference = nestedStylesArr;
	            });
	        };
	        /**
	         * @param {?} result
	         * @param {?} externalStylesheetsByModuleUrl
	         * @return {?}
	         */
	        JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
	            this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
	            if (!this._compilerConfig.useJit) {
	                return interpretStatements(result.statements, result.stylesVar);
	            }
	            else {
	                return jitStatements("/" + result.meta.moduleUrl + ".ngstyle.js", result.statements, result.stylesVar);
	            }
	        };
	        JitCompiler = __decorate$17([
	            CompilerInjectable(), 
	            __metadata$17('design:paramtypes', [_angular_core.Injector, CompileMetadataResolver, TemplateParser, StyleCompiler, ViewCompiler, NgModuleCompiler, DirectiveWrapperCompiler, CompilerConfig, AnimationParser])
	        ], JitCompiler);
	        return JitCompiler;
	    }());
	    var CompiledTemplate = (function () {
	        /**
	         * @param {?} isHost
	         * @param {?} selector
	         * @param {?} compType
	         * @param {?} compMeta
	         * @param {?} ngModule
	         * @param {?} directives
	         */
	        function CompiledTemplate(isHost, selector, compType, compMeta, ngModule, directives) {
	            this.isHost = isHost;
	            this.compType = compType;
	            this.compMeta = compMeta;
	            this.ngModule = ngModule;
	            this.directives = directives;
	            this._viewClass = null;
	            this.isCompiled = false;
	            var self = this;
	            this.proxyViewClass = function () {
	                if (!self._viewClass) {
	                    throw new Error("Illegal state: CompiledTemplate for " + stringify(self.compType) + " is not compiled yet!");
	                }
	                return self._viewClass.apply(this, arguments);
	            };
	            this.proxyComponentFactory = isHost ?
	                new _angular_core.ComponentFactory(selector, this.proxyViewClass, compType.reference) :
	                null;
	        }
	        /**
	         * @param {?} viewClass
	         * @return {?}
	         */
	        CompiledTemplate.prototype.compiled = function (viewClass) {
	            this._viewClass = viewClass;
	            this.proxyViewClass.prototype = viewClass.prototype;
	            this.isCompiled = true;
	        };
	        return CompiledTemplate;
	    }());
	    /**
	     * @param {?} meta
	     * @return {?}
	     */
	    function assertComponent(meta) {
	        if (!meta.isComponent) {
	            throw new Error("Could not compile '" + identifierName(meta.type) + "' because it is not a component.");
	        }
	    }
	    /**
	     * Implements `Compiler` by delegating to the JitCompiler using a known module.
	     */
	    var ModuleBoundCompiler = (function () {
	        /**
	         * @param {?} _delegate
	         * @param {?} _ngModule
	         */
	        function ModuleBoundCompiler(_delegate, _ngModule) {
	            this._delegate = _delegate;
	            this._ngModule = _ngModule;
	        }
	        Object.defineProperty(ModuleBoundCompiler.prototype, "_injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._delegate.injector; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {
	            return this._delegate.compileModuleSync(moduleType);
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {
	            return this._delegate.compileModuleAsync(moduleType);
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	            return this._delegate.compileModuleAndAllComponentsSync(moduleType);
	        };
	        /**
	         * @param {?} moduleType
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	            return this._delegate.compileModuleAndAllComponentsAsync(moduleType);
	        };
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.getNgContentSelectors = function (component) {
	            return this._delegate.getNgContentSelectors(component);
	        };
	        /**
	         * Clears all caches
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };
	        /**
	         * Clears the cache for the given component/ngModule.
	         * @param {?} type
	         * @return {?}
	         */
	        ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };
	        return ModuleBoundCompiler;
	    }());

	    /**
	     * A container for message extracted from the templates.
	     */
	    var MessageBundle = (function () {
	        /**
	         * @param {?} _htmlParser
	         * @param {?} _implicitTags
	         * @param {?} _implicitAttrs
	         */
	        function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
	            this._htmlParser = _htmlParser;
	            this._implicitTags = _implicitTags;
	            this._implicitAttrs = _implicitAttrs;
	            this._messages = [];
	        }
	        /**
	         * @param {?} html
	         * @param {?} url
	         * @param {?} interpolationConfig
	         * @return {?}
	         */
	        MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {
	            var /** @type {?} */ htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);
	            if (htmlParserResult.errors.length) {
	                return htmlParserResult.errors;
	            }
	            var /** @type {?} */ i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);
	            if (i18nParserResult.errors.length) {
	                return i18nParserResult.errors;
	            }
	            (_a = this._messages).push.apply(_a, i18nParserResult.messages);
	            var _a;
	        };
	        /**
	         * @return {?}
	         */
	        MessageBundle.prototype.getMessages = function () { return this._messages; };
	        /**
	         * @param {?} serializer
	         * @return {?}
	         */
	        MessageBundle.prototype.write = function (serializer) { return serializer.write(this._messages); };
	        return MessageBundle;
	    }());

	    var Extractor = (function () {
	        /**
	         * @param {?} host
	         * @param {?} staticSymbolResolver
	         * @param {?} messageBundle
	         * @param {?} metadataResolver
	         */
	        function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {
	            this.host = host;
	            this.staticSymbolResolver = staticSymbolResolver;
	            this.messageBundle = messageBundle;
	            this.metadataResolver = metadataResolver;
	        }
	        /**
	         * @param {?} rootFiles
	         * @return {?}
	         */
	        Extractor.prototype.extract = function (rootFiles) {
	            var _this = this;
	            var /** @type {?} */ programSymbols = extractProgramSymbols(this.staticSymbolResolver, rootFiles, this.host);
	            var _a = analyzeAndValidateNgModules(programSymbols, this.host, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;
	            return Promise
	                .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))
	                .then(function () {
	                var /** @type {?} */ errors = [];
	                files.forEach(function (file) {
	                    var /** @type {?} */ compMetas = [];
	                    file.directives.forEach(function (directiveType) {
	                        var /** @type {?} */ dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);
	                        if (dirMeta && dirMeta.isComponent) {
	                            compMetas.push(dirMeta);
	                        }
	                    });
	                    compMetas.forEach(function (compMeta) {
	                        var /** @type {?} */ html = compMeta.template.template;
	                        var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);
	                        errors.push.apply(errors, _this.messageBundle.updateFromTemplate(html, file.srcUrl, interpolationConfig));
	                    });
	                });
	                if (errors.length) {
	                    throw new Error(errors.map(function (e) { return e.toString(); }).join('\n'));
	                }
	                return _this.messageBundle;
	            });
	        };
	        /**
	         * @param {?} host
	         * @return {?}
	         */
	        Extractor.create = function (host) {
	            var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser());
	            var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();
	            var /** @type {?} */ symbolCache = new StaticSymbolCache();
	            var /** @type {?} */ summaryResolver = new AotSummaryResolver(host, symbolCache);
	            var /** @type {?} */ staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);
	            var /** @type {?} */ staticReflector = new StaticReflector(staticSymbolResolver);
	            StaticAndDynamicReflectionCapabilities.install(staticReflector);
	            var /** @type {?} */ config = new CompilerConfig({
	                genDebugInfo: false,
	                defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated,
	                logBindingUpdate: false,
	                useJit: false
	            });
	            var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);
	            var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();
	            var /** @type {?} */ resolver = new CompileMetadataResolver(new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, staticReflector);
	            // TODO(vicb): implicit tags & attributes
	            var /** @type {?} */ messageBundle = new MessageBundle(htmlParser, [], {});
	            var /** @type {?} */ extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);
	            return { extractor: extractor, staticReflector: staticReflector };
	        };
	        return Extractor;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __decorate$18 = (this && this.__decorate) || function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var __metadata$18 = (this && this.__metadata) || function (k, v) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	    };
	    var /** @type {?} */ _NO_RESOURCE_LOADER = {
	        /**
	         * @param {?} url
	         * @return {?}
	         */
	        get: function (url) {
	            throw new Error("No ResourceLoader implementation has been provided. Can't read the url \"" + url + "\"");
	        }
	    };
	    var /** @type {?} */ baseHtmlParser = new _angular_core.OpaqueToken('HtmlParser');
	    /**
	     * A set of providers that provide `JitCompiler` and its dependencies to use for
	     * template compilation.
	     */
	    var /** @type {?} */ COMPILER_PROVIDERS = [
	        { provide: Reflector, useValue: reflector },
	        { provide: ReflectorReader, useExisting: Reflector },
	        { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },
	        SummaryResolver,
	        Console,
	        Lexer,
	        Parser,
	        {
	            provide: baseHtmlParser,
	            useClass: HtmlParser,
	        },
	        {
	            provide: I18NHtmlParser,
	            useFactory: function (parser, translations, format) {
	                return new I18NHtmlParser(parser, translations, format);
	            },
	            deps: [
	                baseHtmlParser,
	                [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS)],
	                [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS_FORMAT)],
	            ]
	        },
	        {
	            provide: HtmlParser,
	            useExisting: I18NHtmlParser,
	        },
	        TemplateParser,
	        DirectiveNormalizer,
	        CompileMetadataResolver,
	        DEFAULT_PACKAGE_URL_PROVIDER,
	        StyleCompiler,
	        ViewCompiler,
	        NgModuleCompiler,
	        DirectiveWrapperCompiler,
	        { provide: CompilerConfig, useValue: new CompilerConfig() },
	        JitCompiler,
	        { provide: _angular_core.Compiler, useExisting: JitCompiler },
	        DomElementSchemaRegistry,
	        { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },
	        UrlResolver,
	        DirectiveResolver,
	        PipeResolver,
	        NgModuleResolver,
	        AnimationParser
	    ];
	    var JitCompilerFactory = (function () {
	        /**
	         * @param {?} defaultOptions
	         */
	        function JitCompilerFactory(defaultOptions) {
	            this._defaultOptions = [{
	                    useDebug: _angular_core.isDevMode(),
	                    useJit: true,
	                    defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated
	                }].concat(defaultOptions);
	        }
	        /**
	         * @param {?=} options
	         * @return {?}
	         */
	        JitCompilerFactory.prototype.createCompiler = function (options) {
	            if (options === void 0) { options = []; }
	            var /** @type {?} */ mergedOptions = _mergeOptions(this._defaultOptions.concat(options));
	            var /** @type {?} */ injector = _angular_core.ReflectiveInjector.resolveAndCreate([
	                COMPILER_PROVIDERS, {
	                    provide: CompilerConfig,
	                    useFactory: function () {
	                        return new CompilerConfig({
	                            // let explicit values from the compiler options overwrite options
	                            // from the app providers. E.g. important for the testing platform.
	                            genDebugInfo: mergedOptions.useDebug,
	                            // let explicit values from the compiler options overwrite options
	                            // from the app providers
	                            useJit: mergedOptions.useJit,
	                            // let explicit values from the compiler options overwrite options
	                            // from the app providers
	                            defaultEncapsulation: mergedOptions.defaultEncapsulation,
	                            logBindingUpdate: mergedOptions.useDebug
	                        });
	                    },
	                    deps: []
	                },
	                mergedOptions.providers
	            ]);
	            return injector.get(_angular_core.Compiler);
	        };
	        /** @nocollapse */
	        JitCompilerFactory.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Inject, args: [_angular_core.COMPILER_OPTIONS,] },] },
	        ]; };
	        JitCompilerFactory = __decorate$18([
	            CompilerInjectable(), 
	            __metadata$18('design:paramtypes', [Array])
	        ], JitCompilerFactory);
	        return JitCompilerFactory;
	    }());
	    /**
	     * @return {?}
	     */
	    function _initReflector() {
	        reflector.reflectionCapabilities = new ReflectionCapabilities();
	    }
	    /**
	     * A platform that included corePlatform and the compiler.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ platformCoreDynamic = _angular_core.createPlatformFactory(_angular_core.platformCore, 'coreDynamic', [
	        { provide: _angular_core.COMPILER_OPTIONS, useValue: {}, multi: true },
	        { provide: _angular_core.CompilerFactory, useClass: JitCompilerFactory },
	        { provide: _angular_core.PLATFORM_INITIALIZER, useValue: _initReflector, multi: true },
	    ]);
	    /**
	     * @param {?} optionsArr
	     * @return {?}
	     */
	    function _mergeOptions(optionsArr) {
	        return {
	            useDebug: _lastDefined(optionsArr.map(function (options) { return options.useDebug; })),
	            useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),
	            defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),
	            providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; }))
	        };
	    }
	    /**
	     * @param {?} args
	     * @return {?}
	     */
	    function _lastDefined(args) {
	        for (var /** @type {?} */ i = args.length - 1; i >= 0; i--) {
	            if (args[i] !== undefined) {
	                return args[i];
	            }
	        }
	        return undefined;
	    }
	    /**
	     * @param {?} parts
	     * @return {?}
	     */
	    function _mergeArrays(parts) {
	        var /** @type {?} */ result = [];
	        parts.forEach(function (part) { return part && result.push.apply(result, part); });
	        return result;
	    }

	    /**
	     * Interface that defines how import statements should be generated.
	     * @abstract
	     */
	    var ImportResolver = (function () {
	        function ImportResolver() {
	        }
	        /**
	         * Converts a file path to a module name that can be used as an `import.
	         * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.
	         * @abstract
	         * @param {?} importedFilePath
	         * @param {?} containingFilePath
	         * @return {?}
	         */
	        ImportResolver.prototype.fileNameToModuleName = function (importedFilePath, containingFilePath) { };
	        return ImportResolver;
	    }());

	    exports.VERSION = VERSION;
	    exports.TextAst = TextAst;
	    exports.BoundTextAst = BoundTextAst;
	    exports.AttrAst = AttrAst;
	    exports.BoundElementPropertyAst = BoundElementPropertyAst;
	    exports.BoundEventAst = BoundEventAst;
	    exports.ReferenceAst = ReferenceAst;
	    exports.VariableAst = VariableAst;
	    exports.ElementAst = ElementAst;
	    exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
	    exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
	    exports.DirectiveAst = DirectiveAst;
	    exports.ProviderAst = ProviderAst;
	    exports.ProviderAstType = ProviderAstType;
	    exports.NgContentAst = NgContentAst;
	    exports.PropertyBindingType = PropertyBindingType;
	    exports.templateVisitAll = templateVisitAll;
	    exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;
	    exports.CompilerConfig = CompilerConfig;
	    exports.RenderTypes = RenderTypes;
	    exports.CompileAnimationEntryMetadata = CompileAnimationEntryMetadata;
	    exports.CompileAnimationStateMetadata = CompileAnimationStateMetadata;
	    exports.CompileAnimationStateDeclarationMetadata = CompileAnimationStateDeclarationMetadata;
	    exports.CompileAnimationStateTransitionMetadata = CompileAnimationStateTransitionMetadata;
	    exports.CompileAnimationMetadata = CompileAnimationMetadata;
	    exports.CompileAnimationKeyframesSequenceMetadata = CompileAnimationKeyframesSequenceMetadata;
	    exports.CompileAnimationStyleMetadata = CompileAnimationStyleMetadata;
	    exports.CompileAnimationAnimateMetadata = CompileAnimationAnimateMetadata;
	    exports.CompileAnimationWithStepsMetadata = CompileAnimationWithStepsMetadata;
	    exports.CompileAnimationSequenceMetadata = CompileAnimationSequenceMetadata;
	    exports.CompileAnimationGroupMetadata = CompileAnimationGroupMetadata;
	    exports.identifierName = identifierName;
	    exports.identifierModuleUrl = identifierModuleUrl;
	    exports.CompileSummaryKind = CompileSummaryKind;
	    exports.tokenName = tokenName;
	    exports.tokenReference = tokenReference;
	    exports.CompileStylesheetMetadata = CompileStylesheetMetadata;
	    exports.CompileTemplateMetadata = CompileTemplateMetadata;
	    exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
	    exports.createHostComponentMeta = createHostComponentMeta;
	    exports.CompilePipeMetadata = CompilePipeMetadata;
	    exports.CompileNgModuleMetadata = CompileNgModuleMetadata;
	    exports.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;
	    exports.ProviderMeta = ProviderMeta;
	    exports.createAotCompiler = createAotCompiler;
	    exports.AotCompiler = AotCompiler;
	    exports.analyzeNgModules = analyzeNgModules;
	    exports.analyzeAndValidateNgModules = analyzeAndValidateNgModules;
	    exports.extractProgramSymbols = extractProgramSymbols;
	    exports.StaticReflector = StaticReflector;
	    exports.StaticAndDynamicReflectionCapabilities = StaticAndDynamicReflectionCapabilities;
	    exports.StaticSymbol = StaticSymbol;
	    exports.StaticSymbolCache = StaticSymbolCache;
	    exports.ResolvedStaticSymbol = ResolvedStaticSymbol;
	    exports.StaticSymbolResolver = StaticSymbolResolver;
	    exports.AotSummaryResolver = AotSummaryResolver;
	    exports.SummaryResolver = SummaryResolver;
	    exports.JitCompiler = JitCompiler;
	    exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;
	    exports.JitCompilerFactory = JitCompilerFactory;
	    exports.platformCoreDynamic = platformCoreDynamic;
	    exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;
	    exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
	    exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;
	    exports.UrlResolver = UrlResolver;
	    exports.getUrlScheme = getUrlScheme;
	    exports.ResourceLoader = ResourceLoader;
	    exports.DirectiveResolver = DirectiveResolver;
	    exports.PipeResolver = PipeResolver;
	    exports.NgModuleResolver = NgModuleResolver;
	    exports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;
	    exports.InterpolationConfig = InterpolationConfig;
	    exports.ElementSchemaRegistry = ElementSchemaRegistry;
	    exports.Extractor = Extractor;
	    exports.I18NHtmlParser = I18NHtmlParser;
	    exports.MessageBundle = MessageBundle;
	    exports.Serializer = Serializer;
	    exports.Xliff = Xliff;
	    exports.Xmb = Xmb;
	    exports.Xtb = Xtb;
	    exports.DirectiveNormalizer = DirectiveNormalizer;
	    exports.TokenType = TokenType;
	    exports.Lexer = Lexer;
	    exports.Token = Token;
	    exports.EOF = EOF;
	    exports.isIdentifier = isIdentifier;
	    exports.isQuote = isQuote;
	    exports.SplitInterpolation = SplitInterpolation;
	    exports.TemplateBindingParseResult = TemplateBindingParseResult;
	    exports.Parser = Parser;
	    exports._ParseAST = _ParseAST;
	    exports.ERROR_COLLECTOR_TOKEN = ERROR_COLLECTOR_TOKEN;
	    exports.CompileMetadataResolver = CompileMetadataResolver;
	    exports.componentModuleUrl = componentModuleUrl;
	    exports.ParseTreeResult = ParseTreeResult;
	    exports.TreeError = TreeError;
	    exports.HtmlParser = HtmlParser;
	    exports.NgModuleCompiler = NgModuleCompiler;
	    exports.DirectiveWrapperCompiler = DirectiveWrapperCompiler;
	    exports.ImportResolver = ImportResolver;
	    exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;
	    exports.TypeScriptEmitter = TypeScriptEmitter;
	    exports.ParseLocation = ParseLocation;
	    exports.ParseSourceFile = ParseSourceFile;
	    exports.ParseSourceSpan = ParseSourceSpan;
	    exports.ParseErrorLevel = ParseErrorLevel;
	    exports.ParseError = ParseError;
	    exports.DomElementSchemaRegistry = DomElementSchemaRegistry;
	    exports.CssSelector = CssSelector;
	    exports.SelectorMatcher = SelectorMatcher;
	    exports.SelectorListContext = SelectorListContext;
	    exports.SelectorContext = SelectorContext;
	    exports.StylesCompileDependency = StylesCompileDependency;
	    exports.StylesCompileResult = StylesCompileResult;
	    exports.CompiledStylesheet = CompiledStylesheet;
	    exports.StyleCompiler = StyleCompiler;
	    exports.TemplateParseError = TemplateParseError;
	    exports.TemplateParseResult = TemplateParseResult;
	    exports.TemplateParser = TemplateParser;
	    exports.splitClasses = splitClasses;
	    exports.createElementCssSelector = createElementCssSelector;
	    exports.removeSummaryDuplicates = removeSummaryDuplicates;
	    exports.ViewCompiler = ViewCompiler;
	    exports.AnimationParser = AnimationParser;
	    exports.SyntaxError = SyntaxError;

	}));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(4), __webpack_require__(6), __webpack_require__(7)) :
	    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/symbol/observable', 'rxjs/Subject', 'rxjs/Observable'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.rxjs_symbol_observable,global.Rx,global.Rx));
	}(this, function (exports,rxjs_symbol_observable,rxjs_Subject,rxjs_Observable) { 'use strict';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = (self);
	        }
	        else {
	            globalScope = (global);
	        }
	    }
	    else {
	        globalScope = (window);
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function scheduleMicroTask(fn) {
	        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var /** @type {?} */ global$1 = globalScope;
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function getTypeNameForDebugging(type) {
	        return type['name'] || typeof type;
	    }
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    global$1.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function print(obj) {
	        // tslint:disable-next-line:no-console
	        console.log(obj);
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function warn(obj) {
	        console.warn(obj);
	    }
	    var /** @type {?} */ _symbolIterator = null;
	    /**
	     * @return {?}
	     */
	    function getSymbolIterator() {
	        if (!_symbolIterator) {
	            if (((globalScope)).Symbol && Symbol.iterator) {
	                _symbolIterator = Symbol.iterator;
	            }
	            else {
	                // es6-shim specific logic
	                var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
	                for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	                    var /** @type {?} */ key = keys[i];
	                    if (key !== 'entries' && key !== 'size' &&
	                        ((Map)).prototype[key] === Map.prototype['entries']) {
	                        _symbolIterator = key;
	                    }
	                }
	            }
	        }
	        return _symbolIterator;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }

	    var /** @type {?} */ _nextClassId = 0;
	    var /** @type {?} */ Reflect = global$1.Reflect;
	    /**
	     * @param {?} annotation
	     * @return {?}
	     */
	    function extractAnnotation(annotation) {
	        if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
	            // it is a decorator, extract annotation
	            annotation = annotation.annotation;
	        }
	        return annotation;
	    }
	    /**
	     * @param {?} fnOrArray
	     * @param {?} key
	     * @return {?}
	     */
	    function applyParams(fnOrArray, key) {
	        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	            fnOrArray === Number || fnOrArray === Array) {
	            throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
	        }
	        if (typeof fnOrArray === 'function') {
	            return fnOrArray;
	        }
	        if (Array.isArray(fnOrArray)) {
	            var /** @type {?} */ annotations = fnOrArray;
	            var /** @type {?} */ annoLength = annotations.length - 1;
	            var /** @type {?} */ fn = fnOrArray[annoLength];
	            if (typeof fn !== 'function') {
	                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
	            }
	            if (annoLength != fn.length) {
	                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
	            }
	            var /** @type {?} */ paramsAnnotations = [];
	            for (var /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {
	                var /** @type {?} */ paramAnnotations = [];
	                paramsAnnotations.push(paramAnnotations);
	                var /** @type {?} */ annotation = annotations[i];
	                if (Array.isArray(annotation)) {
	                    for (var /** @type {?} */ j = 0; j < annotation.length; j++) {
	                        paramAnnotations.push(extractAnnotation(annotation[j]));
	                    }
	                }
	                else if (typeof annotation === 'function') {
	                    paramAnnotations.push(extractAnnotation(annotation));
	                }
	                else {
	                    paramAnnotations.push(annotation);
	                }
	            }
	            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	            return fn;
	        }
	        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
	    }
	    /**
	     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	     *
	     * ## Basic Example
	     *
	     * ```
	     * var Greeter = ng.Class({
	     *   constructor: function(name) {
	     *     this.name = name;
	     *   },
	     *
	     *   greet: function() {
	     *     alert('Hello ' + this.name + '!');
	     *   }
	     * });
	     * ```
	     *
	     * is equivalent to ES6:
	     *
	     * ```
	     * class Greeter {
	     *   constructor(name) {
	     *     this.name = name;
	     *   }
	     *
	     *   greet() {
	     *     alert('Hello ' + this.name + '!');
	     *   }
	     * }
	     * ```
	     *
	     * or equivalent to ES5:
	     *
	     * ```
	     * var Greeter = function (name) {
	     *   this.name = name;
	     * }
	     *
	     * Greeter.prototype.greet = function () {
	     *   alert('Hello ' + this.name + '!');
	     * }
	     * ```
	     *
	     * ### Example with parameter annotations
	     *
	     * ```
	     * var MyService = ng.Class({
	     *   constructor: [String, [new Optional(), Service], function(name, myService) {
	     *     ...
	     *   }]
	     * });
	     * ```
	     *
	     * is equivalent to ES6:
	     *
	     * ```
	     * class MyService {
	     *   constructor(name: string, \@Optional() myService: Service) {
	     *     ...
	     *   }
	     * }
	     * ```
	     *
	     * ### Example with inheritance
	     *
	     * ```
	     * var Shape = ng.Class({
	     *   constructor: (color) {
	     *     this.color = color;
	     *   }
	     * });
	     *
	     * var Square = ng.Class({
	     *   extends: Shape,
	     *   constructor: function(color, size) {
	     *     Shape.call(this, color);
	     *     this.size = size;
	     *   }
	     * });
	     * ```
	     * \@stable
	     * @param {?} clsDef
	     * @return {?}
	     */
	    function Class(clsDef) {
	        var /** @type {?} */ constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	        var /** @type {?} */ proto = constructor.prototype;
	        if (clsDef.hasOwnProperty('extends')) {
	            if (typeof clsDef.extends === 'function') {
	                ((constructor)).prototype = proto =
	                    Object.create(((clsDef.extends)).prototype);
	            }
	            else {
	                throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
	            }
	        }
	        for (var key in clsDef) {
	            if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
	                proto[key] = applyParams(clsDef[key], key);
	            }
	        }
	        if (this && this.annotations instanceof Array) {
	            Reflect.defineMetadata('annotations', this.annotations, constructor);
	        }
	        var /** @type {?} */ constructorName = constructor['name'];
	        if (!constructorName || constructorName === 'constructor') {
	            ((constructor))['overriddenName'] = "class" + _nextClassId++;
	        }
	        return (constructor);
	    }
	    /**
	     * @param {?} name
	     * @param {?} props
	     * @param {?=} parentClass
	     * @param {?=} chainFn
	     * @return {?}
	     */
	    function makeDecorator(name, props, parentClass, chainFn) {
	        if (chainFn === void 0) { chainFn = null; }
	        var /** @type {?} */ metaCtor = makeMetadataCtor([props]);
	        /**
	         * @param {?} objOrType
	         * @return {?}
	         */
	        function DecoratorFactory(objOrType) {
	            if (!(Reflect && Reflect.getOwnMetadata)) {
	                throw 'reflect-metadata shim is required when using class decorators';
	            }
	            if (this instanceof DecoratorFactory) {
	                metaCtor.call(this, objOrType);
	                return this;
	            }
	            var /** @type {?} */ annotationInstance = new ((DecoratorFactory))(objOrType);
	            var /** @type {?} */ chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var /** @type {?} */ TypeDecorator = (function TypeDecorator(cls) {
	                var /** @type {?} */ annotations = Reflect.getOwnMetadata('annotations', cls) || [];
	                annotations.push(annotationInstance);
	                Reflect.defineMetadata('annotations', annotations, cls);
	                return cls;
	            });
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn)
	                chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	        if (parentClass) {
	            DecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        DecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ((DecoratorFactory)).annotationCls = DecoratorFactory;
	        return DecoratorFactory;
	    }
	    /**
	     * @param {?} props
	     * @return {?}
	     */
	    function makeMetadataCtor(props) {
	        return function ctor() {
	            var _this = this;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            props.forEach(function (prop, i) {
	                var /** @type {?} */ argVal = args[i];
	                if (Array.isArray(prop)) {
	                    // plain parameter
	                    _this[prop[0]] = argVal === undefined ? prop[1] : argVal;
	                }
	                else {
	                    for (var propName in prop) {
	                        _this[propName] =
	                            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];
	                    }
	                }
	            });
	        };
	    }
	    /**
	     * @param {?} name
	     * @param {?} props
	     * @param {?=} parentClass
	     * @return {?}
	     */
	    function makeParamDecorator(name, props, parentClass) {
	        var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	        /**
	         * @param {...?} args
	         * @return {?}
	         */
	        function ParamDecoratorFactory() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            if (this instanceof ParamDecoratorFactory) {
	                metaCtor.apply(this, args);
	                return this;
	            }
	            var /** @type {?} */ annotationInstance = new ((_a = ((ParamDecoratorFactory))).bind.apply(_a, [void 0].concat(args)))();
	            ((ParamDecorator)).annotation = annotationInstance;
	            return ParamDecorator;
	            /**
	             * @param {?} cls
	             * @param {?} unusedKey
	             * @param {?} index
	             * @return {?}
	             */
	            function ParamDecorator(cls, unusedKey, index) {
	                var /** @type {?} */ parameters = Reflect.getOwnMetadata('parameters', cls) || [];
	                // there might be gaps if some in between parameters do not have annotations.
	                // we pad with nulls.
	                while (parameters.length <= index) {
	                    parameters.push(null);
	                }
	                parameters[index] = parameters[index] || [];
	                parameters[index].push(annotationInstance);
	                Reflect.defineMetadata('parameters', parameters, cls);
	                return cls;
	            }
	            var _a;
	        }
	        if (parentClass) {
	            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        ParamDecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ((ParamDecoratorFactory)).annotationCls = ParamDecoratorFactory;
	        return ParamDecoratorFactory;
	    }
	    /**
	     * @param {?} name
	     * @param {?} props
	     * @param {?=} parentClass
	     * @return {?}
	     */
	    function makePropDecorator(name, props, parentClass) {
	        var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	        /**
	         * @param {...?} args
	         * @return {?}
	         */
	        function PropDecoratorFactory() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            if (this instanceof PropDecoratorFactory) {
	                metaCtor.apply(this, args);
	                return this;
	            }
	            var /** @type {?} */ decoratorInstance = new ((_a = ((PropDecoratorFactory))).bind.apply(_a, [void 0].concat(args)))();
	            return function PropDecorator(target, name) {
	                var /** @type {?} */ meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
	                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect.defineMetadata('propMetadata', meta, target.constructor);
	            };
	            var _a;
	        }
	        if (parentClass) {
	            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        PropDecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ((PropDecoratorFactory)).annotationCls = PropDecoratorFactory;
	        return PropDecoratorFactory;
	    }

	    /**
	     * Inject decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Inject = makeParamDecorator('Inject', [['token', undefined]]);
	    /**
	     * Optional decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Optional = makeParamDecorator('Optional', []);
	    /**
	     * Injectable decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Injectable = (makeDecorator('Injectable', []));
	    /**
	     * Self decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Self = makeParamDecorator('Self', []);
	    /**
	     * SkipSelf decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ SkipSelf = makeParamDecorator('SkipSelf', []);
	    /**
	     * Host decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Host = makeParamDecorator('Host', []);

	    var OpaqueToken = (function () {
	        /**
	         * @param {?} _desc
	         */
	        function OpaqueToken(_desc) {
	            this._desc = _desc;
	        }
	        /**
	         * @return {?}
	         */
	        OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	        OpaqueToken.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        OpaqueToken.ctorParameters = function () { return [
	            null,
	        ]; };
	        return OpaqueToken;
	    }());

	    /**
	     * This token can be used to create a virtual provider that will populate the
	     * `entryComponents` fields of components and ng modules based on its `useValue`.
	     * All components that are referenced in the `useValue` value (either directly
	     * or in a nested array or map) will be added to the `entryComponents` property.
	     *
	     * ### Example
	     * The following example shows how the router can populate the `entryComponents`
	     * field of an NgModule based on the router configuration which refers
	     * to components.
	     *
	     * ```typescript
	     * // helper function inside the router
	     * function provideRoutes(routes) {
	     *   return [
	     *     {provide: ROUTES, useValue: routes},
	     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	     *   ];
	     * }
	     *
	     * // user code
	     * let routes = [
	     *   {path: '/root', component: RootComp},
	     *   {path: '/teams', component: TeamsComp}
	     * ];
	     *
	     * @NgModule({
	     *   providers: [provideRoutes(routes)]
	     * })
	     * class ModuleWithRoutes {}
	     * ```
	     *
	     * @experimental
	     */
	    var /** @type {?} */ ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');
	    /**
	     * Attribute decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
	    /**
	     * Base class for query metadata.
	     *
	     * See {\@link ContentChildren}, {\@link ContentChild}, {\@link ViewChildren}, {\@link ViewChild} for
	     * more information.
	     *
	     * \@stable
	     * @abstract
	     */
	    var Query = (function () {
	        function Query() {
	        }
	        return Query;
	    }());
	    /**
	     * ContentChildren decorator and metadata.
	     *
	     *  @stable
	     *  @Annotation
	     */
	    var /** @type {?} */ ContentChildren = (makePropDecorator('ContentChildren', [
	        ['selector', undefined], {
	            first: false,
	            isViewQuery: false,
	            descendants: false,
	            read: undefined,
	        }
	    ], Query));
	    /**
	     * ContentChild decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ ContentChild = makePropDecorator('ContentChild', [
	        ['selector', undefined], {
	            first: true,
	            isViewQuery: false,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * ViewChildren decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ ViewChildren = makePropDecorator('ViewChildren', [
	        ['selector', undefined], {
	            first: false,
	            isViewQuery: true,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * ViewChild decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ ViewChild = makePropDecorator('ViewChild', [
	        ['selector', undefined], {
	            first: true,
	            isViewQuery: true,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);

	    var ChangeDetectionStrategy = {};
	    ChangeDetectionStrategy.OnPush = 0;
	    ChangeDetectionStrategy.Default = 1;
	    ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush";
	    ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default";
	    var ChangeDetectorStatus = {};
	    ChangeDetectorStatus.CheckOnce = 0;
	    ChangeDetectorStatus.Checked = 1;
	    ChangeDetectorStatus.CheckAlways = 2;
	    ChangeDetectorStatus.Detached = 3;
	    ChangeDetectorStatus.Errored = 4;
	    ChangeDetectorStatus.Destroyed = 5;
	    ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = "CheckOnce";
	    ChangeDetectorStatus[ChangeDetectorStatus.Checked] = "Checked";
	    ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = "CheckAlways";
	    ChangeDetectorStatus[ChangeDetectorStatus.Detached] = "Detached";
	    ChangeDetectorStatus[ChangeDetectorStatus.Errored] = "Errored";
	    ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = "Destroyed";
	    /**
	     * @param {?} changeDetectionStrategy
	     * @return {?}
	     */
	    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	        return isBlank(changeDetectionStrategy) ||
	            changeDetectionStrategy === ChangeDetectionStrategy.Default;
	    }

	    /**
	     * Directive decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Directive = (makeDecorator('Directive', {
	        selector: undefined,
	        inputs: undefined,
	        outputs: undefined,
	        host: undefined,
	        providers: undefined,
	        exportAs: undefined,
	        queries: undefined
	    }));
	    /**
	     * Component decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Component = (makeDecorator('Component', {
	        selector: undefined,
	        inputs: undefined,
	        outputs: undefined,
	        host: undefined,
	        exportAs: undefined,
	        moduleId: undefined,
	        providers: undefined,
	        viewProviders: undefined,
	        changeDetection: ChangeDetectionStrategy.Default,
	        queries: undefined,
	        templateUrl: undefined,
	        template: undefined,
	        styleUrls: undefined,
	        styles: undefined,
	        animations: undefined,
	        encapsulation: undefined,
	        interpolation: undefined,
	        entryComponents: undefined
	    }, Directive));
	    /**
	     * Pipe decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Pipe = (makeDecorator('Pipe', {
	        name: undefined,
	        pure: true,
	    }));
	    /**
	     * Input decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
	    /**
	     * Output decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
	    /**
	     * HostBinding decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
	    /**
	     * HostListener decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var LifecycleHooks = {};
	    LifecycleHooks.OnInit = 0;
	    LifecycleHooks.OnDestroy = 1;
	    LifecycleHooks.DoCheck = 2;
	    LifecycleHooks.OnChanges = 3;
	    LifecycleHooks.AfterContentInit = 4;
	    LifecycleHooks.AfterContentChecked = 5;
	    LifecycleHooks.AfterViewInit = 6;
	    LifecycleHooks.AfterViewChecked = 7;
	    LifecycleHooks[LifecycleHooks.OnInit] = "OnInit";
	    LifecycleHooks[LifecycleHooks.OnDestroy] = "OnDestroy";
	    LifecycleHooks[LifecycleHooks.DoCheck] = "DoCheck";
	    LifecycleHooks[LifecycleHooks.OnChanges] = "OnChanges";
	    LifecycleHooks[LifecycleHooks.AfterContentInit] = "AfterContentInit";
	    LifecycleHooks[LifecycleHooks.AfterContentChecked] = "AfterContentChecked";
	    LifecycleHooks[LifecycleHooks.AfterViewInit] = "AfterViewInit";
	    LifecycleHooks[LifecycleHooks.AfterViewChecked] = "AfterViewChecked";
	    var /** @type {?} */ LIFECYCLE_HOOKS_VALUES = [
	        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
	        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
	        LifecycleHooks.AfterViewChecked
	    ];
	    /**
	     * \@whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
	     *
	     * \@description
	     * `ngOnChanges` is called right after the data-bound properties have been checked and before view
	     * and content children are checked if at least one of them has changed.
	     * The `changes` parameter contains the changed properties.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var OnChanges = (function () {
	        function OnChanges() {
	        }
	        /**
	         * @abstract
	         * @param {?} changes
	         * @return {?}
	         */
	        OnChanges.prototype.ngOnChanges = function (changes) { };
	        return OnChanges;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
	     * initialized.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
	     *
	     * \@description
	     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
	     * first time, and before any of its children have been checked. It is invoked only once when the
	     * directive is instantiated.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var OnInit = (function () {
	        function OnInit() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        OnInit.prototype.ngOnInit = function () { };
	        return OnInit;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
	     *
	     * \@description
	     * `ngDoCheck` gets called to check the changes in the directives in addition to the default
	     * algorithm. The default change detection algorithm looks for differences by comparing
	     * bound-property values by reference across change detection runs.
	     *
	     * Note that a directive typically should not use both `DoCheck` and {\@link OnChanges} to respond to
	     * changes on the same input, as `ngOnChanges` will continue to be called when the default change
	     * detector detects changes.
	     *
	     * See {\@link KeyValueDiffers} and {\@link IterableDiffers} for implementing custom dirty checking
	     * for collections.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var DoCheck = (function () {
	        function DoCheck() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DoCheck.prototype.ngDoCheck = function () { };
	        return DoCheck;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called when a directive, pipe or service is destroyed.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
	     *
	     * \@description
	     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
	     * instance is destroyed.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var OnDestroy = (function () {
	        function OnDestroy() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        OnDestroy.prototype.ngOnDestroy = function () { };
	        return OnDestroy;
	    }());
	    /**
	     *
	     * \@whatItDoes Lifecycle hook that is called after a directive's content has been fully
	     * initialized.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterContentInit = (function () {
	        function AfterContentInit() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterContentInit.prototype.ngAfterContentInit = function () { };
	        return AfterContentInit;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after every check of a directive's content.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterContentChecked = (function () {
	        function AfterContentChecked() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterContentChecked.prototype.ngAfterContentChecked = function () { };
	        return AfterContentChecked;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after a component's view has been fully
	     * initialized.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterViewInit = (function () {
	        function AfterViewInit() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterViewInit.prototype.ngAfterViewInit = function () { };
	        return AfterViewInit;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after every check of a component's view.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterViewChecked = (function () {
	        function AfterViewChecked() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterViewChecked.prototype.ngAfterViewChecked = function () { };
	        return AfterViewChecked;
	    }());

	    /**
	     * Defines a schema that will allow:
	     * - any non-Angular elements with a `-` in their name,
	     * - any properties on elements with a `-` in their name which is the common rule for custom
	     * elements.
	     *
	     * @stable
	     */
	    var /** @type {?} */ CUSTOM_ELEMENTS_SCHEMA = {
	        name: 'custom-elements'
	    };
	    /**
	     * Defines a schema that will allow any property on any element.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ NO_ERRORS_SCHEMA = {
	        name: 'no-errors-schema'
	    };
	    /**
	     * NgModule decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ NgModule = (makeDecorator('NgModule', {
	        providers: undefined,
	        declarations: undefined,
	        imports: undefined,
	        exports: undefined,
	        entryComponents: undefined,
	        bootstrap: undefined,
	        schemas: undefined,
	        id: undefined,
	    }));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var ViewEncapsulation = {};
	    ViewEncapsulation.Emulated = 0;
	    ViewEncapsulation.Native = 1;
	    ViewEncapsulation.None = 2;
	    ViewEncapsulation[ViewEncapsulation.Emulated] = "Emulated";
	    ViewEncapsulation[ViewEncapsulation.Native] = "Native";
	    ViewEncapsulation[ViewEncapsulation.None] = "None";
	    /**
	     * Metadata properties available for configuring Views.
	     *
	     * For details on the `\@Component` annotation, see {\@link Component}.
	     *
	     * ### Example
	     *
	     * ```
	     * \@Component({
	     *   selector: 'greet',
	     *   template: 'Hello {{name}}!',
	     * })
	     * class Greet {
	     *   name: string;
	     *
	     *   constructor() {
	     *     this.name = 'World';
	     *   }
	     * }
	     * ```
	     *
	     * @deprecated Use Component instead.
	     *
	     * {\@link Component}
	     */
	    var ViewMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function ViewMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
	            this.templateUrl = templateUrl;
	            this.template = template;
	            this.styleUrls = styleUrls;
	            this.styles = styles;
	            this.encapsulation = encapsulation;
	            this.animations = animations;
	            this.interpolation = interpolation;
	        }
	        return ViewMetadata;
	    }());

	    /**
	     * \@whatItDoes Represents the version of Angular
	     *
	     * \@stable
	     */
	    var Version = (function () {
	        /**
	         * @param {?} full
	         */
	        function Version(full) {
	            this.full = full;
	        }
	        Object.defineProperty(Version.prototype, "major", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.full.split('.')[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Version.prototype, "minor", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.full.split('.')[1]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Version.prototype, "patch", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.full.split('.').slice(2).join('.'); },
	            enumerable: true,
	            configurable: true
	        });
	        return Version;
	    }());
	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new Version('2.4.10');

	    /**
	     * Allows to refer to references which are not yet defined.
	     *
	     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	     * DI is declared,
	     * but not yet defined. It is also used when the `token` which we use when creating a query is not
	     * yet defined.
	     *
	     * ### Example
	     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
	     * \@experimental
	     * @param {?} forwardRefFn
	     * @return {?}
	     */
	    function forwardRef(forwardRefFn) {
	        ((forwardRefFn)).__forward_ref__ = forwardRef;
	        ((forwardRefFn)).toString = function () { return stringify(this()); };
	        return (((forwardRefFn)));
	    }
	    /**
	     * Lazily retrieves the reference value from a forwardRef.
	     *
	     * Acts as the identity function when given a non-forward-ref value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	     *
	     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
	     *
	     * See: {\@link forwardRef}
	     * \@experimental
	     * @param {?} type
	     * @return {?}
	     */
	    function resolveForwardRef(type) {
	        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
	            type.__forward_ref__ === forwardRef) {
	            return ((type))();
	        }
	        else {
	            return type;
	        }
	    }

	    var /** @type {?} */ _THROW_IF_NOT_FOUND = new Object();
	    var /** @type {?} */ THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	    var _NullInjector = (function () {
	        function _NullInjector() {
	        }
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        _NullInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
	            if (notFoundValue === _THROW_IF_NOT_FOUND) {
	                throw new Error("No provider for " + stringify(token) + "!");
	            }
	            return notFoundValue;
	        };
	        return _NullInjector;
	    }());
	    /**
	     * \@whatItDoes Injector interface
	     * \@howToUse
	     * ```
	     * const injector: Injector = ...;
	     * injector.get(...);
	     * ```
	     *
	     * \@description
	     * For more details, see the {\@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
	     *
	     * ### Example
	     *
	     * {\@example core/di/ts/injector_spec.ts region='Injector'}
	     *
	     * `Injector` returns itself when given `Injector` as a token:
	     * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
	     *
	     * \@stable
	     * @abstract
	     */
	    var Injector = (function () {
	        function Injector() {
	        }
	        /**
	         * Retrieves an instance from the injector based on the provided token.
	         * If not found:
	         * - Throws {\@link NoProviderError} if no `notFoundValue` that is not equal to
	         * Injector.THROW_IF_NOT_FOUND is given
	         * - Returns the `notFoundValue` otherwise
	         * @abstract
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        Injector.prototype.get = function (token, notFoundValue) { };
	        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	        Injector.NULL = new _NullInjector();
	        return Injector;
	    }());

	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     */
	    var BaseError = (function (_super) {
	        __extends$1(BaseError, _super);
	        /**
	         * @param {?} message
	         */
	        function BaseError(message) {
	            _super.call(this, message);
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            // TODO(bradfordcsmith): Remove this hack when
	            //     google/closure-compiler/issues/2102 is fixed.
	            var nativeError = new Error(message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.message; },
	            /**
	             * @param {?} message
	             * @return {?}
	             */
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () { return ((this._nativeError)).stack; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { ((this._nativeError)).stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * \@stable
	     */
	    var WrappedError = (function (_super) {
	        __extends$1(WrappedError, _super);
	        /**
	         * @param {?} message
	         * @param {?} error
	         */
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (((this.originalError instanceof Error ? this.originalError : this._nativeError)))
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @param {?} keys
	     * @return {?}
	     */
	    function findFirstClosedCycle(keys) {
	        var /** @type {?} */ res = [];
	        for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	            if (res.indexOf(keys[i]) > -1) {
	                res.push(keys[i]);
	                return res;
	            }
	            res.push(keys[i]);
	        }
	        return res;
	    }
	    /**
	     * @param {?} keys
	     * @return {?}
	     */
	    function constructResolvingPath(keys) {
	        if (keys.length > 1) {
	            var /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());
	            var /** @type {?} */ tokenStrs = reversed.map(function (k) { return stringify(k.token); });
	            return ' (' + tokenStrs.join(' -> ') + ')';
	        }
	        return '';
	    }
	    /**
	     * Base class for all errors arising from misconfigured providers.
	     * \@stable
	     */
	    var AbstractProviderError = (function (_super) {
	        __extends(AbstractProviderError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} key
	         * @param {?} constructResolvingMessage
	         */
	        function AbstractProviderError(injector, key, constructResolvingMessage) {
	            _super.call(this, 'DI Error');
	            this.keys = [key];
	            this.injectors = [injector];
	            this.constructResolvingMessage = constructResolvingMessage;
	            this.message = this.constructResolvingMessage(this.keys);
	        }
	        /**
	         * @param {?} injector
	         * @param {?} key
	         * @return {?}
	         */
	        AbstractProviderError.prototype.addKey = function (injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	            this.message = this.constructResolvingMessage(this.keys);
	        };
	        return AbstractProviderError;
	    }(BaseError));
	    /**
	     * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
	     * {\@link Injector} does not have a {\@link Provider} for the given key.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor(b:B) {}
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	     * ```
	     * \@stable
	     */
	    var NoProviderError = (function (_super) {
	        __extends(NoProviderError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} key
	         */
	        function NoProviderError(injector, key) {
	            _super.call(this, injector, key, function (keys) {
	                var first = stringify(keys[0].token);
	                return "No provider for " + first + "!" + constructResolvingPath(keys);
	            });
	        }
	        return NoProviderError;
	    }(AbstractProviderError));
	    /**
	     * Thrown when dependencies form a cycle.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	     * ]);
	     *
	     * expect(() => injector.get("one")).toThrowError();
	     * ```
	     *
	     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	     * \@stable
	     */
	    var CyclicDependencyError = (function (_super) {
	        __extends(CyclicDependencyError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} key
	         */
	        function CyclicDependencyError(injector, key) {
	            _super.call(this, injector, key, function (keys) {
	                return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	            });
	        }
	        return CyclicDependencyError;
	    }(AbstractProviderError));
	    /**
	     * Thrown when a constructing type returns with an Error.
	     *
	     * The `InstantiationError` class contains the original error plus the dependency graph which caused
	     * this object to be instantiated.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor() {
	     *     throw new Error('message');
	     *   }
	     * }
	     *
	     * var injector = Injector.resolveAndCreate([A]);
	     * try {
	     *   injector.get(A);
	     * } catch (e) {
	     *   expect(e instanceof InstantiationError).toBe(true);
	     *   expect(e.originalException.message).toEqual("message");
	     *   expect(e.originalStack).toBeDefined();
	     * }
	     * ```
	     * \@stable
	     */
	    var InstantiationError = (function (_super) {
	        __extends(InstantiationError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} originalException
	         * @param {?} originalStack
	         * @param {?} key
	         */
	        function InstantiationError(injector, originalException, originalStack, key) {
	            _super.call(this, 'DI Error', originalException);
	            this.keys = [key];
	            this.injectors = [injector];
	        }
	        /**
	         * @param {?} injector
	         * @param {?} key
	         * @return {?}
	         */
	        InstantiationError.prototype.addKey = function (injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	        };
	        Object.defineProperty(InstantiationError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ first = stringify(this.keys[0].token);
	                return this.originalError.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(InstantiationError.prototype, "causeKey", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.keys[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        return InstantiationError;
	    }(WrappedError));
	    /**
	     * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
	     * creation.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	     *
	     * ```typescript
	     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	     * ```
	     * \@stable
	     */
	    var InvalidProviderError = (function (_super) {
	        __extends(InvalidProviderError, _super);
	        /**
	         * @param {?} provider
	         */
	        function InvalidProviderError(provider) {
	            _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	        }
	        return InvalidProviderError;
	    }(BaseError));
	    /**
	     * Thrown when the class has no annotation information.
	     *
	     * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
	     * need to be injected into the constructor.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor(b) {}
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	     * ```
	     *
	     * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
	     *
	     * ```typescript
	     * class B {}
	     *
	     * class A {
	     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	     * ```
	     * \@stable
	     */
	    var NoAnnotationError = (function (_super) {
	        __extends(NoAnnotationError, _super);
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} params
	         */
	        function NoAnnotationError(typeOrFunc, params) {
	            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
	        }
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} params
	         * @return {?}
	         */
	        NoAnnotationError._genMessage = function (typeOrFunc, params) {
	            var /** @type {?} */ signature = [];
	            for (var /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {
	                var /** @type {?} */ parameter = params[i];
	                if (!parameter || parameter.length == 0) {
	                    signature.push('?');
	                }
	                else {
	                    signature.push(parameter.map(stringify).join(' '));
	                }
	            }
	            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
	                signature.join(', ') + '). ' +
	                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	                stringify(typeOrFunc) + '\' is decorated with Injectable.';
	        };
	        return NoAnnotationError;
	    }(BaseError));
	    /**
	     * Thrown when getting an object by index.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	     *
	     * ```typescript
	     * class A {}
	     *
	     * var injector = Injector.resolveAndCreate([A]);
	     *
	     * expect(() => injector.getAt(100)).toThrowError();
	     * ```
	     * \@stable
	     */
	    var OutOfBoundsError = (function (_super) {
	        __extends(OutOfBoundsError, _super);
	        /**
	         * @param {?} index
	         */
	        function OutOfBoundsError(index) {
	            _super.call(this, "Index " + index + " is out-of-bounds.");
	        }
	        return OutOfBoundsError;
	    }(BaseError));
	    /**
	     * Thrown when a multi provider and a regular provider are bound to the same token.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * expect(() => Injector.resolveAndCreate([
	     *   { provide: "Strings", useValue: "string1", multi: true},
	     *   { provide: "Strings", useValue: "string2", multi: false}
	     * ])).toThrowError();
	     * ```
	     */
	    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
	        __extends(MixingMultiProvidersWithRegularProvidersError, _super);
	        /**
	         * @param {?} provider1
	         * @param {?} provider2
	         */
	        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
	                provider2.toString());
	        }
	        return MixingMultiProvidersWithRegularProvidersError;
	    }(BaseError));

	    /**
	     * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
	     *
	     * Keys have:
	     * - a system-wide unique `id`.
	     * - a `token`.
	     *
	     * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
	     * the
	     * injector to store created objects in a more efficient way.
	     *
	     * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
	     * resolving
	     * providers.
	     * \@experimental
	     */
	    var ReflectiveKey = (function () {
	        /**
	         * Private
	         * @param {?} token
	         * @param {?} id
	         */
	        function ReflectiveKey(token, id) {
	            this.token = token;
	            this.id = id;
	            if (!token) {
	                throw new Error('Token must be defined!');
	            }
	        }
	        Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	            /**
	             * Returns a stringified token.
	             * @return {?}
	             */
	            get: function () { return stringify(this.token); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Retrieves a `Key` for a token.
	         * @param {?} token
	         * @return {?}
	         */
	        ReflectiveKey.get = function (token) {
	            return _globalKeyRegistry.get(resolveForwardRef(token));
	        };
	        Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	            /**
	             * @return {?} the number of keys registered in the system.
	             */
	            get: function () { return _globalKeyRegistry.numberOfKeys; },
	            enumerable: true,
	            configurable: true
	        });
	        return ReflectiveKey;
	    }());
	    /**
	     * \@internal
	     */
	    var KeyRegistry = (function () {
	        function KeyRegistry() {
	            this._allKeys = new Map();
	        }
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        KeyRegistry.prototype.get = function (token) {
	            if (token instanceof ReflectiveKey)
	                return token;
	            if (this._allKeys.has(token)) {
	                return this._allKeys.get(token);
	            }
	            var /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	            this._allKeys.set(token, newKey);
	            return newKey;
	        };
	        Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._allKeys.size; },
	            enumerable: true,
	            configurable: true
	        });
	        return KeyRegistry;
	    }());
	    var /** @type {?} */ _globalKeyRegistry = new KeyRegistry();

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @whatItDoes Represents a type that a Component or other object is instances of.
	     *
	     * @description
	     *
	     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	     * the `MyCustomComponent` constructor function.
	     *
	     * @stable
	     */
	    var /** @type {?} */ Type = Function;
	    /**
	     * @param {?} v
	     * @return {?}
	     */
	    function isType(v) {
	        return typeof v === 'function';
	    }

	    /**
	     * Attention: This regex has to hold even if the code is minified!
	     */
	    var /** @type {?} */ DELEGATE_CTOR = /^function\s+\S+\(\)\s*{\s*("use strict";)?\s*(return\s+)?\S+\.apply\(this,\s*arguments\)/;
	    var ReflectionCapabilities = (function () {
	        /**
	         * @param {?=} reflect
	         */
	        function ReflectionCapabilities(reflect) {
	            this._reflect = reflect || global$1.Reflect;
	        }
	        /**
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	        /**
	         * @param {?} t
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.factory = function (t) { return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new (t.bind.apply(t, [void 0].concat(args)))();
	        }; };
	        /**
	         * \@internal
	         * @param {?} paramTypes
	         * @param {?} paramAnnotations
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
	            var /** @type {?} */ result;
	            if (typeof paramTypes === 'undefined') {
	                result = new Array(paramAnnotations.length);
	            }
	            else {
	                result = new Array(paramTypes.length);
	            }
	            for (var /** @type {?} */ i = 0; i < result.length; i++) {
	                // TS outputs Object for parameters without types, while Traceur omits
	                // the annotations. For now we preserve the Traceur behavior to aid
	                // migration, but this can be revisited.
	                if (typeof paramTypes === 'undefined') {
	                    result[i] = [];
	                }
	                else if (paramTypes[i] != Object) {
	                    result[i] = [paramTypes[i]];
	                }
	                else {
	                    result[i] = [];
	                }
	                if (paramAnnotations && isPresent(paramAnnotations[i])) {
	                    result[i] = result[i].concat(paramAnnotations[i]);
	                }
	            }
	            return result;
	        };
	        /**
	         * @param {?} type
	         * @param {?} parentCtor
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {
	            // If we have no decorators, we only have function.length as metadata.
	            // In that case, to detect whether a child class declared an own constructor or not,
	            // we need to look inside of that constructor to check whether it is
	            // just calling the parent.
	            // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
	            // that sets 'design:paramtypes' to []
	            // if a class inherits from another class but has no ctor declared itself.
	            if (DELEGATE_CTOR.exec(type.toString())) {
	                return null;
	            }
	            // Prefer the direct API.
	            if (((type)).parameters && ((type)).parameters !== parentCtor.parameters) {
	                return ((type)).parameters;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            var /** @type {?} */ tsickleCtorParams = ((type)).ctorParameters;
	            if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
	                // Newer tsickle uses a function closure
	                // Retain the non-function case for compatibility with older tsickle
	                var /** @type {?} */ ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
	                var /** @type {?} */ paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
	                var /** @type {?} */ paramAnnotations = ctorParameters.map(function (ctorParam) {
	                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
	                });
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	            // API for metadata created by invoking the decorators.
	            if (isPresent(this._reflect) && isPresent(this._reflect.getOwnMetadata)) {
	                var /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);
	                var /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);
	                if (paramTypes || paramAnnotations) {
	                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	                }
	            }
	            // If a class has no decorators, at least create metadata
	            // based on function.length.
	            // Note: We know that this is a real constructor as we checked
	            // the content of the constructor above.
	            return new Array(((type.length))).fill(undefined);
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.parameters = function (type) {
	            // Note: only report metadata if we have at least one class decorator
	            // to stay in sync with the static reflector.
	            if (!isType(type)) {
	                return [];
	            }
	            var /** @type {?} */ parentCtor = getParentCtor(type);
	            var /** @type {?} */ parameters = this._ownParameters(type, parentCtor);
	            if (!parameters && parentCtor !== Object) {
	                parameters = this.parameters(parentCtor);
	            }
	            return parameters || [];
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} parentCtor
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {
	            // Prefer the direct API.
	            if (((typeOrFunc)).annotations && ((typeOrFunc)).annotations !== parentCtor.annotations) {
	                var /** @type {?} */ annotations = ((typeOrFunc)).annotations;
	                if (typeof annotations === 'function' && annotations.annotations) {
	                    annotations = annotations.annotations;
	                }
	                return annotations;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (((typeOrFunc)).decorators && ((typeOrFunc)).decorators !== parentCtor.decorators) {
	                return convertTsickleDecoratorIntoMetadata(((typeOrFunc)).decorators);
	            }
	            // API for metadata created by invoking the decorators.
	            if (this._reflect && this._reflect.getOwnMetadata) {
	                return this._reflect.getOwnMetadata('annotations', typeOrFunc);
	            }
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	            if (!isType(typeOrFunc)) {
	                return [];
	            }
	            var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	            var /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
	            var /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
	            return parentAnnotations.concat(ownAnnotations);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} parentCtor
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {
	            // Prefer the direct API.
	            if (((typeOrFunc)).propMetadata &&
	                ((typeOrFunc)).propMetadata !== parentCtor.propMetadata) {
	                var /** @type {?} */ propMetadata = ((typeOrFunc)).propMetadata;
	                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
	                    propMetadata = propMetadata.propMetadata;
	                }
	                return propMetadata;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (((typeOrFunc)).propDecorators &&
	                ((typeOrFunc)).propDecorators !== parentCtor.propDecorators) {
	                var /** @type {?} */ propDecorators_1 = ((typeOrFunc)).propDecorators;
	                var /** @type {?} */ propMetadata_1 = ({});
	                Object.keys(propDecorators_1).forEach(function (prop) {
	                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	                });
	                return propMetadata_1;
	            }
	            // API for metadata created by invoking the decorators.
	            if (this._reflect && this._reflect.getOwnMetadata) {
	                return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);
	            }
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	            if (!isType(typeOrFunc)) {
	                return {};
	            }
	            var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	            var /** @type {?} */ propMetadata = {};
	            if (parentCtor !== Object) {
	                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentCtor);
	                Object.keys(parentPropMetadata_1).forEach(function (propName) {
	                    propMetadata[propName] = parentPropMetadata_1[propName];
	                });
	            }
	            var /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
	            if (ownPropMetadata) {
	                Object.keys(ownPropMetadata).forEach(function (propName) {
	                    var /** @type {?} */ decorators = [];
	                    if (propMetadata.hasOwnProperty(propName)) {
	                        decorators.push.apply(decorators, propMetadata[propName]);
	                    }
	                    decorators.push.apply(decorators, ownPropMetadata[propName]);
	                    propMetadata[propName] = decorators;
	                });
	            }
	            return propMetadata;
	        };
	        /**
	         * @param {?} type
	         * @param {?} lcProperty
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return type instanceof Type && lcProperty in type.prototype;
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.getter = function (name) { return ((new Function('o', 'return o.' + name + ';'))); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.setter = function (name) {
	            return ((new Function('o', 'v', 'return o.' + name + ' = v;')));
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.method = function (name) {
	            var /** @type {?} */ functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	            return ((new Function('o', 'args', functionBody)));
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.importUri = function (type) {
	            // StaticSymbol
	            if (typeof type === 'object' && type['filePath']) {
	                return type['filePath'];
	            }
	            // Runtime type
	            return "./" + stringify(type);
	        };
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };
	        /**
	         * @param {?} enumIdentifier
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
	        return ReflectionCapabilities;
	    }());
	    /**
	     * @param {?} decoratorInvocations
	     * @return {?}
	     */
	    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	        if (!decoratorInvocations) {
	            return [];
	        }
	        return decoratorInvocations.map(function (decoratorInvocation) {
	            var /** @type {?} */ decoratorType = decoratorInvocation.type;
	            var /** @type {?} */ annotationCls = decoratorType.annotationCls;
	            var /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
	        });
	    }
	    /**
	     * @param {?} ctor
	     * @return {?}
	     */
	    function getParentCtor(ctor) {
	        var /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);
	        var /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;
	        // Note: We always use `Object` as the null value
	        // to simplify checking later on.
	        return parentCtor || Object;
	    }

	    /**
	     * Provides read-only access to reflection data about symbols. Used internally by Angular
	     * to power dependency injection and compilation.
	     * @abstract
	     */
	    var ReflectorReader = (function () {
	        function ReflectorReader() {
	        }
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.parameters = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.annotations = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.propMetadata = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.importUri = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        ReflectorReader.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { };
	        /**
	         * @abstract
	         * @param {?} identifier
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectorReader.prototype.resolveEnum = function (identifier, name) { };
	        return ReflectorReader;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Provides access to reflection data about symbols. Used internally by Angular
	     * to power dependency injection and compilation.
	     */
	    var Reflector = (function (_super) {
	        __extends$2(Reflector, _super);
	        /**
	         * @param {?} reflectionCapabilities
	         */
	        function Reflector(reflectionCapabilities) {
	            _super.call(this);
	            this.reflectionCapabilities = reflectionCapabilities;
	        }
	        /**
	         * @param {?} caps
	         * @return {?}
	         */
	        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        Reflector.prototype.parameters = function (typeOrFunc) {
	            return this.reflectionCapabilities.parameters(typeOrFunc);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        Reflector.prototype.annotations = function (typeOrFunc) {
	            return this.reflectionCapabilities.annotations(typeOrFunc);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        Reflector.prototype.propMetadata = function (typeOrFunc) {
	            return this.reflectionCapabilities.propMetadata(typeOrFunc);
	        };
	        /**
	         * @param {?} type
	         * @param {?} lcProperty
	         * @return {?}
	         */
	        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
	            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);
	        };
	        /**
	         * @param {?} identifier
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.resolveEnum = function (identifier, name) {
	            return this.reflectionCapabilities.resolveEnum(identifier, name);
	        };
	        return Reflector;
	    }(ReflectorReader));

	    /**
	     * The {@link Reflector} used internally in Angular to access metadata
	     * about symbols.
	     */
	    var /** @type {?} */ reflector = new Reflector(new ReflectionCapabilities());

	    /**
	     * `Dependency` is used by the framework to extend DI.
	     * This is internal to Angular and should not be used directly.
	     */
	    var ReflectiveDependency = (function () {
	        /**
	         * @param {?} key
	         * @param {?} optional
	         * @param {?} visibility
	         */
	        function ReflectiveDependency(key, optional, visibility) {
	            this.key = key;
	            this.optional = optional;
	            this.visibility = visibility;
	        }
	        /**
	         * @param {?} key
	         * @return {?}
	         */
	        ReflectiveDependency.fromKey = function (key) {
	            return new ReflectiveDependency(key, false, null);
	        };
	        return ReflectiveDependency;
	    }());
	    var /** @type {?} */ _EMPTY_LIST = [];
	    var ResolvedReflectiveProvider_ = (function () {
	        /**
	         * @param {?} key
	         * @param {?} resolvedFactories
	         * @param {?} multiProvider
	         */
	        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	            this.key = key;
	            this.resolvedFactories = resolvedFactories;
	            this.multiProvider = multiProvider;
	        }
	        Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.resolvedFactories[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        return ResolvedReflectiveProvider_;
	    }());
	    /**
	     * An internal resolved representation of a factory function created by resolving {\@link
	     * Provider}.
	     * \@experimental
	     */
	    var ResolvedReflectiveFactory = (function () {
	        /**
	         * @param {?} factory
	         * @param {?} dependencies
	         */
	        function ResolvedReflectiveFactory(factory, dependencies) {
	            this.factory = factory;
	            this.dependencies = dependencies;
	        }
	        return ResolvedReflectiveFactory;
	    }());
	    /**
	     * Resolve a single provider.
	     * @param {?} provider
	     * @return {?}
	     */
	    function resolveReflectiveFactory(provider) {
	        var /** @type {?} */ factoryFn;
	        var /** @type {?} */ resolvedDeps;
	        if (provider.useClass) {
	            var /** @type {?} */ useClass = resolveForwardRef(provider.useClass);
	            factoryFn = reflector.factory(useClass);
	            resolvedDeps = _dependenciesFor(useClass);
	        }
	        else if (provider.useExisting) {
	            factoryFn = function (aliasInstance) { return aliasInstance; };
	            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
	        }
	        else if (provider.useFactory) {
	            factoryFn = provider.useFactory;
	            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
	        }
	        else {
	            factoryFn = function () { return provider.useValue; };
	            resolvedDeps = _EMPTY_LIST;
	        }
	        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	    }
	    /**
	     * Converts the {\@link Provider} into {\@link ResolvedProvider}.
	     *
	     * {\@link Injector} internally only uses {\@link ResolvedProvider}, {\@link Provider} contains
	     * convenience provider syntax.
	     * @param {?} provider
	     * @return {?}
	     */
	    function resolveReflectiveProvider(provider) {
	        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);
	    }
	    /**
	     * Resolve a list of Providers.
	     * @param {?} providers
	     * @return {?}
	     */
	    function resolveReflectiveProviders(providers) {
	        var /** @type {?} */ normalized = _normalizeProviders(providers, []);
	        var /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);
	        var /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
	        return Array.from(resolvedProviderMap.values());
	    }
	    /**
	     * Merges a list of ResolvedProviders into a list where
	     * each key is contained exactly once and multi providers
	     * have been merged.
	     * @param {?} providers
	     * @param {?} normalizedProvidersMap
	     * @return {?}
	     */
	    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	        for (var /** @type {?} */ i = 0; i < providers.length; i++) {
	            var /** @type {?} */ provider = providers[i];
	            var /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);
	            if (existing) {
	                if (provider.multiProvider !== existing.multiProvider) {
	                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
	                }
	                if (provider.multiProvider) {
	                    for (var /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {
	                        existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                    }
	                }
	                else {
	                    normalizedProvidersMap.set(provider.key.id, provider);
	                }
	            }
	            else {
	                var /** @type {?} */ resolvedProvider = void 0;
	                if (provider.multiProvider) {
	                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
	                }
	                else {
	                    resolvedProvider = provider;
	                }
	                normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	            }
	        }
	        return normalizedProvidersMap;
	    }
	    /**
	     * @param {?} providers
	     * @param {?} res
	     * @return {?}
	     */
	    function _normalizeProviders(providers, res) {
	        providers.forEach(function (b) {
	            if (b instanceof Type) {
	                res.push({ provide: b, useClass: b });
	            }
	            else if (b && typeof b == 'object' && ((b)).provide !== undefined) {
	                res.push(/** @type {?} */ (b));
	            }
	            else if (b instanceof Array) {
	                _normalizeProviders(b, res);
	            }
	            else {
	                throw new InvalidProviderError(b);
	            }
	        });
	        return res;
	    }
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} dependencies
	     * @return {?}
	     */
	    function constructDependencies(typeOrFunc, dependencies) {
	        if (!dependencies) {
	            return _dependenciesFor(typeOrFunc);
	        }
	        else {
	            var /** @type {?} */ params_1 = dependencies.map(function (t) { return [t]; });
	            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });
	        }
	    }
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    function _dependenciesFor(typeOrFunc) {
	        var /** @type {?} */ params = reflector.parameters(typeOrFunc);
	        if (!params)
	            return [];
	        if (params.some(function (p) { return p == null; })) {
	            throw new NoAnnotationError(typeOrFunc, params);
	        }
	        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	    }
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} metadata
	     * @param {?} params
	     * @return {?}
	     */
	    function _extractToken(typeOrFunc, metadata, params) {
	        var /** @type {?} */ token = null;
	        var /** @type {?} */ optional = false;
	        if (!Array.isArray(metadata)) {
	            if (metadata instanceof Inject) {
	                return _createDependency(metadata.token, optional, null);
	            }
	            else {
	                return _createDependency(metadata, optional, null);
	            }
	        }
	        var /** @type {?} */ visibility = null;
	        for (var /** @type {?} */ i = 0; i < metadata.length; ++i) {
	            var /** @type {?} */ paramMetadata = metadata[i];
	            if (paramMetadata instanceof Type) {
	                token = paramMetadata;
	            }
	            else if (paramMetadata instanceof Inject) {
	                token = paramMetadata.token;
	            }
	            else if (paramMetadata instanceof Optional) {
	                optional = true;
	            }
	            else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
	                visibility = paramMetadata;
	            }
	        }
	        token = resolveForwardRef(token);
	        if (token != null) {
	            return _createDependency(token, optional, visibility);
	        }
	        else {
	            throw new NoAnnotationError(typeOrFunc, params);
	        }
	    }
	    /**
	     * @param {?} token
	     * @param {?} optional
	     * @param {?} visibility
	     * @return {?}
	     */
	    function _createDependency(token, optional, visibility) {
	        return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
	    }

	    // Threshold for the dynamic version
	    var /** @type {?} */ UNDEFINED = new Object();
	    /**
	     * A ReflectiveDependency injection container used for instantiating objects and resolving
	     * dependencies.
	     *
	     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	     * constructor dependencies.
	     *
	     * In typical use, application code asks for the dependencies in the constructor and they are
	     * resolved by the `Injector`.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	     *
	     * The following example creates an `Injector` configured to create `Engine` and `Car`.
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * var car = injector.get(Car);
	     * expect(car instanceof Car).toBe(true);
	     * expect(car.engine instanceof Engine).toBe(true);
	     * ```
	     *
	     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	     * resolve all of the object's dependencies automatically.
	     *
	     * \@stable
	     * @abstract
	     */
	    var ReflectiveInjector = (function () {
	        function ReflectiveInjector() {
	        }
	        /**
	         * Turns an array of provider definitions into an array of resolved providers.
	         *
	         * A resolution is a process of flattening multiple nested arrays and converting individual
	         * providers into an array of {\@link ResolvedReflectiveProvider}s.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	         *
	         * expect(providers.length).toEqual(2);
	         *
	         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	         * expect(providers[0].key.displayName).toBe("Car");
	         * expect(providers[0].dependencies.length).toEqual(1);
	         * expect(providers[0].factory).toBeDefined();
	         *
	         * expect(providers[1].key.displayName).toBe("Engine");
	         * });
	         * ```
	         *
	         * See {\@link ReflectiveInjector#fromResolvedProviders} for more info.
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector.resolve = function (providers) {
	            return resolveReflectiveProviders(providers);
	        };
	        /**
	         * Resolves an array of providers and creates an injector from those providers.
	         *
	         * The passed-in providers can be an array of `Type`, {\@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         *
	         * This function is slower than the corresponding `fromResolvedProviders`
	         * because it needs to resolve the passed-in providers first.
	         * See {\@link Injector#resolve} and {\@link Injector#fromResolvedProviders}.
	         * @param {?} providers
	         * @param {?=} parent
	         * @return {?}
	         */
	        ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	            if (parent === void 0) { parent = null; }
	            var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	        };
	        /**
	         * Creates an injector from previously resolved providers.
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, Engine]);
	         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         * \@experimental
	         * @param {?} providers
	         * @param {?=} parent
	         * @return {?}
	         */
	        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	            if (parent === void 0) { parent = null; }
	            return new ReflectiveInjector_(providers, parent);
	        };
	        /**
	         * Parent of this injector.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	         *
	         * ```typescript
	         * var parent = ReflectiveInjector.resolveAndCreate([]);
	         * var child = parent.resolveAndCreateChild([]);
	         * expect(child.parent).toBe(parent);
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.parent = function () { };
	        /**
	         * Resolves an array of providers and creates a child injector from those providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * The passed-in providers can be an array of `Type`, {\@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	         * var child = parent.resolveAndCreateChild([ChildProvider]);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         *
	         * This function is slower than the corresponding `createChildFromResolved`
	         * because it needs to resolve the passed-in providers first.
	         * See {\@link Injector#resolve} and {\@link Injector#createChildFromResolved}.
	         * @abstract
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { };
	        /**
	         * Creates a child injector from previously resolved providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	         *
	         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	         * var child = parent.createChildFromResolved(childProviders);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         * @abstract
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.createChildFromResolved = function (providers) { };
	        /**
	         * Resolves a provider and instantiates an object in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         *
	         * var car = injector.resolveAndInstantiate(Car);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	         * ```
	         * @abstract
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { };
	        /**
	         * Instantiates an object using a resolved provider in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         * var carProvider = ReflectiveInjector.resolve([Car])[0];
	         * var car = injector.instantiateResolved(carProvider);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	         * ```
	         * @abstract
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.instantiateResolved = function (provider) { };
	        /**
	         * @abstract
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.get = function (token, notFoundValue) { };
	        return ReflectiveInjector;
	    }());
	    var ReflectiveInjector_ = (function () {
	        /**
	         * Private
	         * @param {?} _providers
	         * @param {?=} _parent
	         */
	        function ReflectiveInjector_(_providers, _parent) {
	            if (_parent === void 0) { _parent = null; }
	            /** @internal */
	            this._constructionCounter = 0;
	            this._providers = _providers;
	            this._parent = _parent;
	            var len = _providers.length;
	            this.keyIds = new Array(len);
	            this.objs = new Array(len);
	            for (var i = 0; i < len; i++) {
	                this.keyIds[i] = _providers[i].key.id;
	                this.objs[i] = UNDEFINED;
	            }
	        }
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
	        };
	        Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	            var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return this.createChildFromResolved(ResolvedReflectiveProviders);
	        };
	        /**
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	            var /** @type {?} */ inj = new ReflectiveInjector_(providers);
	            inj._parent = this;
	            return inj;
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	            return this._instantiateProvider(provider);
	        };
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.getProviderAtIndex = function (index) {
	            if (index < 0 || index >= this._providers.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this._providers[index];
	        };
	        /**
	         * \@internal
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._new = function (provider) {
	            if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
	                throw new CyclicDependencyError(this, provider.key);
	            }
	            return this._instantiateProvider(provider);
	        };
	        /**
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getMaxNumberOfObjects = function () { return this.objs.length; };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	            if (provider.multiProvider) {
	                var /** @type {?} */ res = new Array(provider.resolvedFactories.length);
	                for (var /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {
	                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	                }
	                return res;
	            }
	            else {
	                return this._instantiate(provider, provider.resolvedFactories[0]);
	            }
	        };
	        /**
	         * @param {?} provider
	         * @param {?} ResolvedReflectiveFactory
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
	            var _this = this;
	            var /** @type {?} */ factory = ResolvedReflectiveFactory.factory;
	            var /** @type {?} */ deps;
	            try {
	                deps =
	                    ResolvedReflectiveFactory.dependencies.map(function (dep) { return _this._getByReflectiveDependency(dep); });
	            }
	            catch (e) {
	                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
	                    e.addKey(this, provider.key);
	                }
	                throw e;
	            }
	            var /** @type {?} */ obj;
	            try {
	                obj = factory.apply(void 0, deps);
	            }
	            catch (e) {
	                throw new InstantiationError(this, e, e.stack, provider.key);
	            }
	            return obj;
	        };
	        /**
	         * @param {?} dep
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByReflectiveDependency = function (dep) {
	            return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
	        };
	        /**
	         * @param {?} key
	         * @param {?} visibility
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByKey = function (key, visibility, notFoundValue) {
	            if (key === INJECTOR_KEY) {
	                return this;
	            }
	            if (visibility instanceof Self) {
	                return this._getByKeySelf(key, notFoundValue);
	            }
	            else {
	                return this._getByKeyDefault(key, notFoundValue, visibility);
	            }
	        };
	        /**
	         * @param {?} keyId
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getObjByKeyId = function (keyId) {
	            for (var /** @type {?} */ i = 0; i < this.keyIds.length; i++) {
	                if (this.keyIds[i] === keyId) {
	                    if (this.objs[i] === UNDEFINED) {
	                        this.objs[i] = this._new(this._providers[i]);
	                    }
	                    return this.objs[i];
	                }
	            }
	            return UNDEFINED;
	        };
	        /**
	         * \@internal
	         * @param {?} key
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	            if (notFoundValue !== THROW_IF_NOT_FOUND) {
	                return notFoundValue;
	            }
	            else {
	                throw new NoProviderError(this, key);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} key
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	            var /** @type {?} */ obj = this._getObjByKeyId(key.id);
	            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	        };
	        /**
	         * \@internal
	         * @param {?} key
	         * @param {?} notFoundValue
	         * @param {?} visibility
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, visibility) {
	            var /** @type {?} */ inj;
	            if (visibility instanceof SkipSelf) {
	                inj = this._parent;
	            }
	            else {
	                inj = this;
	            }
	            while (inj instanceof ReflectiveInjector_) {
	                var /** @type {?} */ inj_ = (inj);
	                var /** @type {?} */ obj = inj_._getObjByKeyId(key.id);
	                if (obj !== UNDEFINED)
	                    return obj;
	                inj = inj_._parent;
	            }
	            if (inj !== null) {
	                return inj.get(key.token, notFoundValue);
	            }
	            else {
	                return this._throwOrNull(key, notFoundValue);
	            }
	        };
	        Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                    .join(', ');
	                return "ReflectiveInjector(providers: [" + providers + "])";
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	        return ReflectiveInjector_;
	    }());
	    var /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);
	    /**
	     * @param {?} injector
	     * @param {?} fn
	     * @return {?}
	     */
	    function _mapProviders(injector, fn) {
	        var /** @type {?} */ res = new Array(injector._providers.length);
	        for (var /** @type {?} */ i = 0; i < injector._providers.length; ++i) {
	            res[i] = fn(injector.getProviderAtIndex(i));
	        }
	        return res;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * \@whatItDoes Provides a hook for centralized exception handling.
	     *
	     * \@description
	     *
	     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
	     * intercept error handling, write a custom exception handler that replaces this default as
	     * appropriate for your app.
	     *
	     * ### Example
	     *
	     * ```
	     * class MyErrorHandler implements ErrorHandler {
	     *   handleError(error) {
	     *     // do something with the exception
	     *   }
	     * }
	     *
	     * \@NgModule({
	     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
	     * })
	     * class MyModule {}
	     * ```
	     *
	     * \@stable
	     */
	    var ErrorHandler = (function () {
	        /**
	         * @param {?=} rethrowError
	         */
	        function ErrorHandler(rethrowError) {
	            if (rethrowError === void 0) { rethrowError = true; }
	            /**
	             * @internal
	             */
	            this._console = console;
	            this.rethrowError = rethrowError;
	        }
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype.handleError = function (error) {
	            var /** @type {?} */ originalError = this._findOriginalError(error);
	            var /** @type {?} */ originalStack = this._findOriginalStack(error);
	            var /** @type {?} */ context = this._findContext(error);
	            this._console.error("EXCEPTION: " + this._extractMessage(error));
	            if (originalError) {
	                this._console.error("ORIGINAL EXCEPTION: " + this._extractMessage(originalError));
	            }
	            if (originalStack) {
	                this._console.error('ORIGINAL STACKTRACE:');
	                this._console.error(originalStack);
	            }
	            if (context) {
	                this._console.error('ERROR CONTEXT:');
	                this._console.error(context);
	            }
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an error happens. If we do not rethrow, bootstrap will always succeed.
	            if (this.rethrowError)
	                throw error;
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._extractMessage = function (error) {
	            return error instanceof Error ? error.message : error.toString();
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._findContext = function (error) {
	            if (error) {
	                return error.context ? error.context :
	                    this._findContext(((error)).originalError);
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._findOriginalError = function (error) {
	            var /** @type {?} */ e = ((error)).originalError;
	            while (e && ((e)).originalError) {
	                e = ((e)).originalError;
	            }
	            return e;
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._findOriginalStack = function (error) {
	            if (!(error instanceof Error))
	                return null;
	            var /** @type {?} */ e = error;
	            var /** @type {?} */ stack = e.stack;
	            while (e instanceof Error && ((e)).originalError) {
	                e = ((e)).originalError;
	                if (e instanceof Error && e.stack) {
	                    stack = e.stack;
	                }
	            }
	            return stack;
	        };
	        return ErrorHandler;
	    }());

	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} condition
	         * @return {?}
	         */
	        ListWrapper.findLast = function (arr, condition) {
	            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
	                if (condition(arr[i])) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} list
	         * @param {?} items
	         * @return {?}
	         */
	        ListWrapper.removeAll = function (list, items) {
	            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
	                var /** @type {?} */ index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        /**
	         * @param {?} list
	         * @param {?} el
	         * @return {?}
	         */
	        ListWrapper.remove = function (list, el) {
	            var /** @type {?} */ index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} a
	         * @param {?} b
	         * @return {?}
	         */
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        /**
	         * @param {?} list
	         * @return {?}
	         */
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return ((flat)).concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isListLikeIterable(obj) {
	        if (!isJsObject(obj))
	            return false;
	        return Array.isArray(obj) ||
	            (!(obj instanceof Map) &&
	                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @param {?} comparator
	     * @return {?}
	     */
	    function areIterablesEqual(a, b, comparator) {
	        var /** @type {?} */ iterator1 = a[getSymbolIterator()]();
	        var /** @type {?} */ iterator2 = b[getSymbolIterator()]();
	        while (true) {
	            var /** @type {?} */ item1 = iterator1.next();
	            var /** @type {?} */ item2 = iterator2.next();
	            if (item1.done && item2.done)
	                return true;
	            if (item1.done || item2.done)
	                return false;
	            if (!comparator(item1.value, item2.value))
	                return false;
	        }
	    }
	    /**
	     * @param {?} obj
	     * @param {?} fn
	     * @return {?}
	     */
	    function iterateListLike(obj, fn) {
	        if (Array.isArray(obj)) {
	            for (var /** @type {?} */ i = 0; i < obj.length; i++) {
	                fn(obj[i]);
	            }
	        }
	        else {
	            var /** @type {?} */ iterator = obj[getSymbolIterator()]();
	            var /** @type {?} */ item = void 0;
	            while (!((item = iterator.next()).done)) {
	                fn(item.value);
	            }
	        }
	    }

	    /**
	     * Determine if the argument is shaped like a Promise
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPromise(obj) {
	        // allow any Promise/A+ compliant thenable.
	        // It's up to the caller to ensure that obj.then conforms to the spec
	        return !!obj && typeof obj.then === 'function';
	    }
	    /**
	     * Determine if the argument is an Observable
	     * @param {?} obj
	     * @return {?}
	     */
	    function isObservable(obj) {
	        return !!(obj && obj[rxjs_symbol_observable.$$observable]);
	    }

	    /**
	     * A function that will be executed when an application is initialized.
	     * @experimental
	     */
	    var /** @type {?} */ APP_INITIALIZER = new OpaqueToken('Application Initializer');
	    /**
	     * A class that reflects the state of running {\@link APP_INITIALIZER}s.
	     *
	     * \@experimental
	     */
	    var ApplicationInitStatus = (function () {
	        /**
	         * @param {?} appInits
	         */
	        function ApplicationInitStatus(appInits) {
	            var _this = this;
	            this._done = false;
	            var asyncInitPromises = [];
	            if (appInits) {
	                for (var i = 0; i < appInits.length; i++) {
	                    var initResult = appInits[i]();
	                    if (isPromise(initResult)) {
	                        asyncInitPromises.push(initResult);
	                    }
	                }
	            }
	            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
	            if (asyncInitPromises.length === 0) {
	                this._done = true;
	            }
	        }
	        Object.defineProperty(ApplicationInitStatus.prototype, "done", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._done; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._donePromise; },
	            enumerable: true,
	            configurable: true
	        });
	        ApplicationInitStatus.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ApplicationInitStatus.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
	        ]; };
	        return ApplicationInitStatus;
	    }());

	    /**
	     * A DI Token representing a unique string id assigned to the application by Angular and used
	     * primarily for prefixing application attributes and CSS styles when
	     * {@link ViewEncapsulation#Emulated} is being used.
	     *
	     * If you need to avoid randomly generated value to be used as an application id, you can provide
	     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	     * using this token.
	     * @experimental
	     */
	    var /** @type {?} */ APP_ID = new OpaqueToken('AppId');
	    /**
	     * @return {?}
	     */
	    function _appIdRandomProviderFactory() {
	        return "" + _randomChar() + _randomChar() + _randomChar();
	    }
	    /**
	     * Providers that will generate a random APP_ID_TOKEN.
	     * @experimental
	     */
	    var /** @type {?} */ APP_ID_RANDOM_PROVIDER = {
	        provide: APP_ID,
	        useFactory: _appIdRandomProviderFactory,
	        deps: /** @type {?} */ ([]),
	    };
	    /**
	     * @return {?}
	     */
	    function _randomChar() {
	        return String.fromCharCode(97 + Math.floor(Math.random() * 25));
	    }
	    /**
	     * A function that will be executed when a platform is initialized.
	     * @experimental
	     */
	    var /** @type {?} */ PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');
	    /**
	     * All callbacks provided via this token will be called for every component that is bootstrapped.
	     * Signature of the callback:
	     *
	     * `(componentRef: ComponentRef) => void`.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');
	    /**
	     * A token which indicates the root directory of the application
	     * @experimental
	     */
	    var /** @type {?} */ PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');

	    var Console = (function () {
	        function Console() {
	        }
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Console.prototype.log = function (message) { print(message); };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Console.prototype.warn = function (message) { warn(message); };
	        Console.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Console.ctorParameters = function () { return []; };
	        return Console;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a component is still being loaded in a synchronous compile.
	     *
	     * \@stable
	     */
	    var ComponentStillLoadingError = (function (_super) {
	        __extends$4(ComponentStillLoadingError, _super);
	        /**
	         * @param {?} compType
	         */
	        function ComponentStillLoadingError(compType) {
	            _super.call(this, "Can't compile synchronously as " + stringify(compType) + " is still being loaded!");
	            this.compType = compType;
	        }
	        return ComponentStillLoadingError;
	    }(BaseError));
	    /**
	     * Combination of NgModuleFactory and ComponentFactorys.
	     *
	     * \@experimental
	     */
	    var ModuleWithComponentFactories = (function () {
	        /**
	         * @param {?} ngModuleFactory
	         * @param {?} componentFactories
	         */
	        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
	            this.ngModuleFactory = ngModuleFactory;
	            this.componentFactories = componentFactories;
	        }
	        return ModuleWithComponentFactories;
	    }());
	    /**
	     * @return {?}
	     */
	    function _throwError() {
	        throw new Error("Runtime compiler is not loaded");
	    }
	    /**
	     * Low-level service for running the angular compiler during runtime
	     * to create {\@link ComponentFactory}s, which
	     * can later be used to create and render a Component instance.
	     *
	     * Each `\@NgModule` provides an own `Compiler` to its injector,
	     * that will use the directives/pipes of the ng module for compilation
	     * of components.
	     * \@stable
	     */
	    var Compiler = (function () {
	        function Compiler() {
	        }
	        /**
	         * Compiles the given NgModule and all of its components. All templates of the components listed
	         * in `entryComponents`
	         * have to be inlined. Otherwise throws a {\@link ComponentStillLoadingError}.
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
	        /**
	         * Compiles the given NgModule and all of its components
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
	        /**
	         * Same as {\@link compileModuleSync} but also creates ComponentFactories for all components.
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	            throw _throwError();
	        };
	        /**
	         * Same as {\@link compileModuleAsync} but also creates ComponentFactories for all components.
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	            throw _throwError();
	        };
	        /**
	         * Exposes the CSS-style selectors that have been used in `ngContent` directives within
	         * the template of the given component.
	         * This is used by the `upgrade` library to compile the appropriate transclude content
	         * in the Angular 1 wrapper component.
	         * @param {?} component
	         * @return {?}
	         */
	        Compiler.prototype.getNgContentSelectors = function (component) { throw _throwError(); };
	        /**
	         * Clears all caches.
	         * @return {?}
	         */
	        Compiler.prototype.clearCache = function () { };
	        /**
	         * Clears the cache for the given component/ngModule.
	         * @param {?} type
	         * @return {?}
	         */
	        Compiler.prototype.clearCacheFor = function (type) { };
	        Compiler.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Compiler.ctorParameters = function () { return []; };
	        return Compiler;
	    }());
	    /**
	     * Token to provide CompilerOptions in the platform injector.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ COMPILER_OPTIONS = new OpaqueToken('compilerOptions');
	    /**
	     * A factory for creating a Compiler
	     *
	     * \@experimental
	     * @abstract
	     */
	    var CompilerFactory = (function () {
	        function CompilerFactory() {
	        }
	        /**
	         * @abstract
	         * @param {?=} options
	         * @return {?}
	         */
	        CompilerFactory.prototype.createCompiler = function (options) { };
	        return CompilerFactory;
	    }());

	    var ElementRef = (function () {
	        /**
	         * @param {?} nativeElement
	         */
	        function ElementRef(nativeElement) {
	            this.nativeElement = nativeElement;
	        }
	        return ElementRef;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * \@Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   \@Output() open: EventEmitter<any> = new EventEmitter();
	     *   \@Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * \@stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$6(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         * @param {?=} isAsync
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        /**
	         * @param {?=} generatorOrNext
	         * @param {?=} error
	         * @param {?=} complete
	         * @return {?}
	         */
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var /** @type {?} */ schedulerFn;
	            var /** @type {?} */ errorFn = function (err) { return null; };
	            var /** @type {?} */ completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));

	    /**
	     * An injectable service for executing work inside or outside of the Angular zone.
	     *
	     * The most common use of this service is to optimize performance when starting a work consisting of
	     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	     * Angular. Such tasks can be kicked off via {\@link runOutsideAngular} and if needed, these tasks
	     * can reenter the Angular zone via {\@link run}.
	     *
	     * <!-- TODO: add/fix links to:
	     *   - docs explaining zones and the use of zones in Angular and change-detection
	     *   - link to runOutsideAngular/run (throughout this file!)
	     *   -->
	     *
	     * ### Example
	     *
	     * ```
	     * import {Component, NgZone} from '\@angular/core';
	     * import {NgIf} from '\@angular/common';
	     *
	     * \@Component({
	     *   selector: 'ng-zone-demo'.
	     *   template: `
	     *     <h2>Demo: NgZone</h2>
	     *
	     *     <p>Progress: {{progress}}%</p>
	     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	     *
	     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	     *   `,
	     * })
	     * export class NgZoneDemo {
	     *   progress: number = 0;
	     *   label: string;
	     *
	     *   constructor(private _ngZone: NgZone) {}
	     *
	     *   // Loop inside the Angular zone
	     *   // so the UI DOES refresh after each setTimeout cycle
	     *   processWithinAngularZone() {
	     *     this.label = 'inside';
	     *     this.progress = 0;
	     *     this._increaseProgress(() => console.log('Inside Done!'));
	     *   }
	     *
	     *   // Loop outside of the Angular zone
	     *   // so the UI DOES NOT refresh after each setTimeout cycle
	     *   processOutsideOfAngularZone() {
	     *     this.label = 'outside';
	     *     this.progress = 0;
	     *     this._ngZone.runOutsideAngular(() => {
	     *       this._increaseProgress(() => {
	     *       // reenter the Angular zone and display done
	     *       this._ngZone.run(() => {console.log('Outside Done!') });
	     *     }}));
	     *   }
	     *
	     *   _increaseProgress(doneCallback: () => void) {
	     *     this.progress += 1;
	     *     console.log(`Current progress: ${this.progress}%`);
	     *
	     *     if (this.progress < 100) {
	     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	     *     } else {
	     *       doneCallback();
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * \@experimental
	     */
	    var NgZone = (function () {
	        /**
	         * @param {?} __0
	         */
	        function NgZone(_a) {
	            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	            this._hasPendingMicrotasks = false;
	            this._hasPendingMacrotasks = false;
	            this._isStable = true;
	            this._nesting = 0;
	            this._onUnstable = new EventEmitter(false);
	            this._onMicrotaskEmpty = new EventEmitter(false);
	            this._onStable = new EventEmitter(false);
	            this._onErrorEvents = new EventEmitter(false);
	            if (typeof Zone == 'undefined') {
	                throw new Error('Angular requires Zone.js prolyfill.');
	            }
	            Zone.assertZonePatched();
	            this.outer = this.inner = Zone.current;
	            if (Zone['wtfZoneSpec']) {
	                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	            }
	            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
	                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	            }
	            this.forkInnerZoneWithAngularBehavior();
	        }
	        /**
	         * @return {?}
	         */
	        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	        /**
	         * @return {?}
	         */
	        NgZone.assertInAngularZone = function () {
	            if (!NgZone.isInAngularZone()) {
	                throw new Error('Expected to be in Angular Zone, but it is not!');
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.assertNotInAngularZone = function () {
	            if (NgZone.isInAngularZone()) {
	                throw new Error('Expected to not be in Angular Zone, but it is!');
	            }
	        };
	        /**
	         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	         * outside of the Angular zone (typically started via {\@link runOutsideAngular}).
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * within the Angular zone.
	         *
	         * If a synchronous error happens it will be rethrown and not reported via `onError`.
	         * @param {?} fn
	         * @return {?}
	         */
	        NgZone.prototype.run = function (fn) { return this.inner.run(fn); };
	        /**
	         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
	         * rethrown.
	         * @param {?} fn
	         * @return {?}
	         */
	        NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };
	        /**
	         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * outside of the Angular zone.
	         *
	         * Use {\@link run} to reenter the Angular zone and do work that updates the application model.
	         * @param {?} fn
	         * @return {?}
	         */
	        NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };
	        Object.defineProperty(NgZone.prototype, "onUnstable", {
	            /**
	             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	             * @return {?}
	             */
	            get: function () { return this._onUnstable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
	            /**
	             * Notifies when there is no more microtasks enqueue in the current VM Turn.
	             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	             * For this reason this event can fire multiple times per VM Turn.
	             * @return {?}
	             */
	            get: function () { return this._onMicrotaskEmpty; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onStable", {
	            /**
	             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	             * implies we are about to relinquish VM turn.
	             * This event gets called just once.
	             * @return {?}
	             */
	            get: function () { return this._onStable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onError", {
	            /**
	             * Notify that an error has been delivered.
	             * @return {?}
	             */
	            get: function () { return this._onErrorEvents; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "isStable", {
	            /**
	             * Whether there are no outstanding microtasks or macrotasks.
	             * @return {?}
	             */
	            get: function () { return this._isStable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._hasPendingMicrotasks; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._hasPendingMacrotasks; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.checkStable = function () {
	            var _this = this;
	            if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {
	                try {
	                    this._nesting++;
	                    this._onMicrotaskEmpty.emit(null);
	                }
	                finally {
	                    this._nesting--;
	                    if (!this._hasPendingMicrotasks) {
	                        try {
	                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
	                        }
	                        finally {
	                            this._isStable = true;
	                        }
	                    }
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {
	            var _this = this;
	            this.inner = this.inner.fork({
	                name: 'angular',
	                properties: /** @type {?} */ ({ 'isAngularZone': true }),
	                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invokeTask(target, task, applyThis, applyArgs);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onHasTask: function (delegate, current, target, hasTaskState) {
	                    delegate.hasTask(target, hasTaskState);
	                    if (current === target) {
	                        // We are only interested in hasTask events which originate from our zone
	                        // (A child hasTask event is not interesting to us)
	                        if (hasTaskState.change == 'microTask') {
	                            _this.setHasMicrotask(hasTaskState.microTask);
	                        }
	                        else if (hasTaskState.change == 'macroTask') {
	                            _this.setHasMacrotask(hasTaskState.macroTask);
	                        }
	                    }
	                },
	                onHandleError: function (delegate, current, target, error) {
	                    delegate.handleError(target, error);
	                    _this.triggerError(error);
	                    return false;
	                }
	            });
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.onEnter = function () {
	            this._nesting++;
	            if (this._isStable) {
	                this._isStable = false;
	                this._onUnstable.emit(null);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.onLeave = function () {
	            this._nesting--;
	            this.checkStable();
	        };
	        /**
	         * @param {?} hasMicrotasks
	         * @return {?}
	         */
	        NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
	            this._hasPendingMicrotasks = hasMicrotasks;
	            this.checkStable();
	        };
	        /**
	         * @param {?} hasMacrotasks
	         * @return {?}
	         */
	        NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
	        return NgZone;
	    }());

	    var AnimationQueue = (function () {
	        /**
	         * @param {?} _zone
	         */
	        function AnimationQueue(_zone) {
	            this._zone = _zone;
	            this.entries = [];
	        }
	        /**
	         * @param {?} player
	         * @return {?}
	         */
	        AnimationQueue.prototype.enqueue = function (player) { this.entries.push(player); };
	        /**
	         * @return {?}
	         */
	        AnimationQueue.prototype.flush = function () {
	            var _this = this;
	            // given that each animation player may set aside
	            // microtasks and rely on DOM-based events, this
	            // will cause Angular to run change detection after
	            // each request. This sidesteps the issue. If a user
	            // hooks into an animation via (@anim.start) or (@anim.done)
	            // then those methods will automatically trigger change
	            // detection by wrapping themselves inside of a zone
	            if (this.entries.length) {
	                this._zone.runOutsideAngular(function () {
	                    // this code is wrapped into a single promise such that the
	                    // onStart and onDone player callbacks are triggered outside
	                    // of the digest cycle of animations
	                    Promise.resolve(null).then(function () { return _this._triggerAnimations(); });
	                });
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationQueue.prototype._triggerAnimations = function () {
	            NgZone.assertNotInAngularZone();
	            while (this.entries.length) {
	                var /** @type {?} */ player = this.entries.shift();
	                // in the event that an animation throws an error then we do
	                // not want to re-run animations on any previous animations
	                // if they have already been kicked off beforehand
	                if (!player.hasStarted()) {
	                    player.play();
	                }
	            }
	        };
	        AnimationQueue.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        AnimationQueue.ctorParameters = function () { return [
	            { type: NgZone, },
	        ]; };
	        return AnimationQueue;
	    }());

	    var DefaultIterableDifferFactory = (function () {
	        function DefaultIterableDifferFactory() {
	        }
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
	        /**
	         * @param {?} cdRef
	         * @param {?=} trackByFn
	         * @return {?}
	         */
	        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
	            return new DefaultIterableDiffer(trackByFn);
	        };
	        return DefaultIterableDifferFactory;
	    }());
	    var /** @type {?} */ trackByIdentity = function (index, item) { return item; };
	    /**
	     * \@stable
	     */
	    var DefaultIterableDiffer = (function () {
	        /**
	         * @param {?=} _trackByFn
	         */
	        function DefaultIterableDiffer(_trackByFn) {
	            this._trackByFn = _trackByFn;
	            this._length = null;
	            this._collection = null;
	            this._linkedRecords = null;
	            this._unlinkedRecords = null;
	            this._previousItHead = null;
	            this._itHead = null;
	            this._itTail = null;
	            this._additionsHead = null;
	            this._additionsTail = null;
	            this._movesHead = null;
	            this._movesTail = null;
	            this._removalsHead = null;
	            this._removalsTail = null;
	            this._identityChangesHead = null;
	            this._identityChangesTail = null;
	            this._trackByFn = this._trackByFn || trackByIdentity;
	        }
	        Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._collection; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._itHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
	            var /** @type {?} */ nextIt = this._itHead;
	            var /** @type {?} */ nextRemove = this._removalsHead;
	            var /** @type {?} */ addRemoveOffset = 0;
	            var /** @type {?} */ moveOffsets = null;
	            while (nextIt || nextRemove) {
	                // Figure out which is the next record to process
	                // Order: remove, add, move
	                var /** @type {?} */ record = !nextRemove ||
	                    nextIt &&
	                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
	                    nextIt :
	                    nextRemove;
	                var /** @type {?} */ adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
	                var /** @type {?} */ currentIndex = record.currentIndex;
	                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	                if (record === nextRemove) {
	                    addRemoveOffset--;
	                    nextRemove = nextRemove._nextRemoved;
	                }
	                else {
	                    nextIt = nextIt._next;
	                    if (record.previousIndex == null) {
	                        addRemoveOffset++;
	                    }
	                    else {
	                        // INVARIANT:  currentIndex < previousIndex
	                        if (!moveOffsets)
	                            moveOffsets = [];
	                        var /** @type {?} */ localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
	                        var /** @type {?} */ localCurrentIndex = currentIndex - addRemoveOffset;
	                        if (localMovePreviousIndex != localCurrentIndex) {
	                            for (var /** @type {?} */ i = 0; i < localMovePreviousIndex; i++) {
	                                var /** @type {?} */ offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
	                                var /** @type {?} */ index = offset + i;
	                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
	                                    moveOffsets[i] = offset + 1;
	                                }
	                            }
	                            var /** @type {?} */ previousIndex = record.previousIndex;
	                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
	                        }
	                    }
	                }
	                if (adjPreviousIndex !== currentIndex) {
	                    fn(record, adjPreviousIndex, currentIndex);
	                }
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._movesHead; record !== null; record = record._nextMoved) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} collection
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.diff = function (collection) {
	            if (isBlank(collection))
	                collection = [];
	            if (!isListLikeIterable(collection)) {
	                throw new Error("Error trying to diff '" + collection + "'");
	            }
	            if (this.check(collection)) {
	                return this;
	            }
	            else {
	                return null;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.onDestroy = function () { };
	        /**
	         * @param {?} collection
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.check = function (collection) {
	            var _this = this;
	            this._reset();
	            var /** @type {?} */ record = this._itHead;
	            var /** @type {?} */ mayBeDirty = false;
	            var /** @type {?} */ index;
	            var /** @type {?} */ item;
	            var /** @type {?} */ itemTrackBy;
	            if (Array.isArray(collection)) {
	                var /** @type {?} */ list = collection;
	                this._length = collection.length;
	                for (var /** @type {?} */ index_1 = 0; index_1 < this._length; index_1++) {
	                    item = list[index_1];
	                    itemTrackBy = this._trackByFn(index_1, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = this._mismatch(record, item, itemTrackBy, index_1);
	                        mayBeDirty = true;
	                    }
	                    else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
	                        }
	                        if (!looseIdentical(record.item, item))
	                            this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                }
	            }
	            else {
	                index = 0;
	                iterateListLike(collection, function (item /** TODO #9100 */) {
	                    itemTrackBy = _this._trackByFn(index, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = _this._mismatch(record, item, itemTrackBy, index);
	                        mayBeDirty = true;
	                    }
	                    else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                        }
	                        if (!looseIdentical(record.item, item))
	                            _this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                    index++;
	                });
	                this._length = index;
	            }
	            this._truncate(record);
	            this._collection = collection;
	            return this.isDirty;
	        };
	        Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._additionsHead !== null || this._movesHead !== null ||
	                    this._removalsHead !== null || this._identityChangesHead !== null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Reset the state of the change objects to show no changes. This means set previousKey to
	         * currentKey, and clear all of the queues (additions, moves, removals).
	         * Set the previousIndexes of moved and added items to their currentIndexes
	         * Reset the list of additions, moves and removals
	         *
	         * \@internal
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._reset = function () {
	            if (this.isDirty) {
	                var /** @type {?} */ record = void 0;
	                var /** @type {?} */ nextRecord = void 0;
	                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                    record.previousIndex = record.currentIndex;
	                }
	                this._additionsHead = this._additionsTail = null;
	                for (record = this._movesHead; record !== null; record = nextRecord) {
	                    record.previousIndex = record.currentIndex;
	                    nextRecord = record._nextMoved;
	                }
	                this._movesHead = this._movesTail = null;
	                this._removalsHead = this._removalsTail = null;
	                this._identityChangesHead = this._identityChangesTail = null;
	            }
	        };
	        /**
	         * This is the core function which handles differences between collections.
	         *
	         * - `record` is the record which we saw at this position last time. If null then it is a new
	         *   item.
	         * - `item` is the current item in the collection
	         * - `index` is the position of the item in the collection
	         *
	         * \@internal
	         * @param {?} record
	         * @param {?} item
	         * @param {?} itemTrackBy
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	            // The previous record after which we will append the current one.
	            var /** @type {?} */ previousRecord;
	            if (record === null) {
	                previousRecord = this._itTail;
	            }
	            else {
	                previousRecord = record._prev;
	                // Remove the record from the collection since we know it does not match the item.
	                this._remove(record);
	            }
	            // Attempt to see if we have seen the item before.
	            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	            if (record !== null) {
	                // We have seen this before, we need to move it forward in the collection.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._moveAfter(record, previousRecord, index);
	            }
	            else {
	                // Never seen it, check evicted list.
	                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	                if (record !== null) {
	                    // It is an item which we have evicted earlier: reinsert it back into the list.
	                    // But first we need to check if identity changed, so we can update in view if necessary
	                    if (!looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                    this._reinsertAfter(record, previousRecord, index);
	                }
	                else {
	                    // It is a new item: add it.
	                    record =
	                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
	                }
	            }
	            return record;
	        };
	        /**
	         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	         *
	         * Use case: `[a, a]` => `[b, a, a]`
	         *
	         * If we did not have this check then the insertion of `b` would:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) leave `a` at index `1` as is. <-- this is wrong!
	         *   3) reinsert `a` at index 2. <-- this is wrong!
	         *
	         * The correct behavior is:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) reinsert `a` at index 1.
	         *   3) move `a` at from `1` to `2`.
	         *
	         *
	         * Double check that we have not evicted a duplicate item. We need to check if the item type may
	         * have already been removed:
	         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	         * at the end.
	         *
	         * \@internal
	         * @param {?} record
	         * @param {?} item
	         * @param {?} itemTrackBy
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	            var /** @type {?} */ reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	            if (reinsertRecord !== null) {
	                record = this._reinsertAfter(reinsertRecord, record._prev, index);
	            }
	            else if (record.currentIndex != index) {
	                record.currentIndex = index;
	                this._addToMoves(record, index);
	            }
	            return record;
	        };
	        /**
	         * Get rid of any excess {\@link CollectionChangeRecord}s from the previous collection
	         *
	         * - `record` The first excess {\@link CollectionChangeRecord}.
	         *
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._truncate = function (record) {
	            // Anything after that needs to be removed;
	            while (record !== null) {
	                var /** @type {?} */ nextRecord = record._next;
	                this._addToRemovals(this._unlink(record));
	                record = nextRecord;
	            }
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.clear();
	            }
	            if (this._additionsTail !== null) {
	                this._additionsTail._nextAdded = null;
	            }
	            if (this._movesTail !== null) {
	                this._movesTail._nextMoved = null;
	            }
	            if (this._itTail !== null) {
	                this._itTail._next = null;
	            }
	            if (this._removalsTail !== null) {
	                this._removalsTail._nextRemoved = null;
	            }
	            if (this._identityChangesTail !== null) {
	                this._identityChangesTail._nextIdentityChange = null;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.remove(record);
	            }
	            var /** @type {?} */ prev = record._prevRemoved;
	            var /** @type {?} */ next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            }
	            else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            }
	            else {
	                next._prevRemoved = prev;
	            }
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	            this._unlink(record);
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	            this._insertAfter(record, prevRecord, index);
	            if (this._additionsTail === null) {
	                // todo(vicb)
	                // assert(this._additionsHead === null);
	                this._additionsTail = this._additionsHead = record;
	            }
	            else {
	                // todo(vicb)
	                // assert(_additionsTail._nextAdded === null);
	                // assert(record._nextAdded === null);
	                this._additionsTail = this._additionsTail._nextAdded = record;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	            // todo(vicb)
	            // assert(record != prevRecord);
	            // assert(record._next === null);
	            // assert(record._prev === null);
	            var /** @type {?} */ next = prevRecord === null ? this._itHead : prevRecord._next;
	            // todo(vicb)
	            // assert(next != record);
	            // assert(prevRecord != record);
	            record._next = next;
	            record._prev = prevRecord;
	            if (next === null) {
	                this._itTail = record;
	            }
	            else {
	                next._prev = record;
	            }
	            if (prevRecord === null) {
	                this._itHead = record;
	            }
	            else {
	                prevRecord._next = record;
	            }
	            if (this._linkedRecords === null) {
	                this._linkedRecords = new _DuplicateMap();
	            }
	            this._linkedRecords.put(record);
	            record.currentIndex = index;
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._remove = function (record) {
	            return this._addToRemovals(this._unlink(record));
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._unlink = function (record) {
	            if (this._linkedRecords !== null) {
	                this._linkedRecords.remove(record);
	            }
	            var /** @type {?} */ prev = record._prev;
	            var /** @type {?} */ next = record._next;
	            // todo(vicb)
	            // assert((record._prev = null) === null);
	            // assert((record._next = null) === null);
	            if (prev === null) {
	                this._itHead = next;
	            }
	            else {
	                prev._next = next;
	            }
	            if (next === null) {
	                this._itTail = prev;
	            }
	            else {
	                next._prev = prev;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} toIndex
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	            // todo(vicb)
	            // assert(record._nextMoved === null);
	            if (record.previousIndex === toIndex) {
	                return record;
	            }
	            if (this._movesTail === null) {
	                // todo(vicb)
	                // assert(_movesHead === null);
	                this._movesTail = this._movesHead = record;
	            }
	            else {
	                // todo(vicb)
	                // assert(_movesTail._nextMoved === null);
	                this._movesTail = this._movesTail._nextMoved = record;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	            if (this._unlinkedRecords === null) {
	                this._unlinkedRecords = new _DuplicateMap();
	            }
	            this._unlinkedRecords.put(record);
	            record.currentIndex = null;
	            record._nextRemoved = null;
	            if (this._removalsTail === null) {
	                // todo(vicb)
	                // assert(_removalsHead === null);
	                this._removalsTail = this._removalsHead = record;
	                record._prevRemoved = null;
	            }
	            else {
	                // todo(vicb)
	                // assert(_removalsTail._nextRemoved === null);
	                // assert(record._nextRemoved === null);
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = this._removalsTail._nextRemoved = record;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} item
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	            record.item = item;
	            if (this._identityChangesTail === null) {
	                this._identityChangesTail = this._identityChangesHead = record;
	            }
	            else {
	                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	            }
	            return record;
	        };
	        /**
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.toString = function () {
	            var /** @type {?} */ list = [];
	            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
	            var /** @type {?} */ previous = [];
	            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
	            var /** @type {?} */ additions = [];
	            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
	            var /** @type {?} */ moves = [];
	            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
	            var /** @type {?} */ removals = [];
	            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
	            var /** @type {?} */ identityChanges = [];
	            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
	            return 'collection: ' + list.join(', ') + '\n' +
	                'previous: ' + previous.join(', ') + '\n' +
	                'additions: ' + additions.join(', ') + '\n' +
	                'moves: ' + moves.join(', ') + '\n' +
	                'removals: ' + removals.join(', ') + '\n' +
	                'identityChanges: ' + identityChanges.join(', ') + '\n';
	        };
	        return DefaultIterableDiffer;
	    }());
	    /**
	     * \@stable
	     */
	    var CollectionChangeRecord = (function () {
	        /**
	         * @param {?} item
	         * @param {?} trackById
	         */
	        function CollectionChangeRecord(item, trackById) {
	            this.item = item;
	            this.trackById = trackById;
	            this.currentIndex = null;
	            this.previousIndex = null;
	            /** @internal */
	            this._nextPrevious = null;
	            /** @internal */
	            this._prev = null;
	            /** @internal */
	            this._next = null;
	            /** @internal */
	            this._prevDup = null;
	            /** @internal */
	            this._nextDup = null;
	            /** @internal */
	            this._prevRemoved = null;
	            /** @internal */
	            this._nextRemoved = null;
	            /** @internal */
	            this._nextAdded = null;
	            /** @internal */
	            this._nextMoved = null;
	            /** @internal */
	            this._nextIdentityChange = null;
	        }
	        /**
	         * @return {?}
	         */
	        CollectionChangeRecord.prototype.toString = function () {
	            return this.previousIndex === this.currentIndex ? stringify(this.item) :
	                stringify(this.item) + '[' +
	                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
	        };
	        return CollectionChangeRecord;
	    }());
	    var _DuplicateItemRecordList = (function () {
	        function _DuplicateItemRecordList() {
	            /** @internal */
	            this._head = null;
	            /** @internal */
	            this._tail = null;
	        }
	        /**
	         * Append the record to the list of duplicates.
	         *
	         * Note: by design all records in the list of duplicates hold the same value in record.item.
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateItemRecordList.prototype.add = function (record) {
	            if (this._head === null) {
	                this._head = this._tail = record;
	                record._nextDup = null;
	                record._prevDup = null;
	            }
	            else {
	                // todo(vicb)
	                // assert(record.item ==  _head.item ||
	                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	                this._tail._nextDup = record;
	                record._prevDup = this._tail;
	                record._nextDup = null;
	                this._tail = record;
	            }
	        };
	        /**
	         * @param {?} trackById
	         * @param {?} afterIndex
	         * @return {?}
	         */
	        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
	            var /** @type {?} */ record;
	            for (record = this._head; record !== null; record = record._nextDup) {
	                if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                    looseIdentical(record.trackById, trackById)) {
	                    return record;
	                }
	            }
	            return null;
	        };
	        /**
	         * Remove one {\@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * Returns whether the list of duplicates is empty.
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateItemRecordList.prototype.remove = function (record) {
	            // todo(vicb)
	            // assert(() {
	            //  // verify that the record being removed is in the list.
	            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	            //    if (identical(cursor, record)) return true;
	            //  }
	            //  return false;
	            //});
	            var /** @type {?} */ prev = record._prevDup;
	            var /** @type {?} */ next = record._nextDup;
	            if (prev === null) {
	                this._head = next;
	            }
	            else {
	                prev._nextDup = next;
	            }
	            if (next === null) {
	                this._tail = prev;
	            }
	            else {
	                next._prevDup = prev;
	            }
	            return this._head === null;
	        };
	        return _DuplicateItemRecordList;
	    }());
	    var _DuplicateMap = (function () {
	        function _DuplicateMap() {
	            this.map = new Map();
	        }
	        /**
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateMap.prototype.put = function (record) {
	            var /** @type {?} */ key = record.trackById;
	            var /** @type {?} */ duplicates = this.map.get(key);
	            if (!duplicates) {
	                duplicates = new _DuplicateItemRecordList();
	                this.map.set(key, duplicates);
	            }
	            duplicates.add(record);
	        };
	        /**
	         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
	         * have already iterated over, we use the afterIndex to pretend it is not there.
	         *
	         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	         * have any more `a`s needs to return the last `a` not the first or second.
	         * @param {?} trackById
	         * @param {?=} afterIndex
	         * @return {?}
	         */
	        _DuplicateMap.prototype.get = function (trackById, afterIndex) {
	            if (afterIndex === void 0) { afterIndex = null; }
	            var /** @type {?} */ key = trackById;
	            var /** @type {?} */ recordList = this.map.get(key);
	            return recordList ? recordList.get(trackById, afterIndex) : null;
	        };
	        /**
	         * Removes a {\@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * The list of duplicates also is removed from the map if it gets empty.
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateMap.prototype.remove = function (record) {
	            var /** @type {?} */ key = record.trackById;
	            var /** @type {?} */ recordList = this.map.get(key);
	            // Remove the list of duplicates when it gets empty
	            if (recordList.remove(record)) {
	                this.map.delete(key);
	            }
	            return record;
	        };
	        Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.map.size === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	        /**
	         * @return {?}
	         */
	        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
	        return _DuplicateMap;
	    }());
	    /**
	     * @param {?} item
	     * @param {?} addRemoveOffset
	     * @param {?} moveOffsets
	     * @return {?}
	     */
	    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
	        var /** @type {?} */ previousIndex = item.previousIndex;
	        if (previousIndex === null)
	            return previousIndex;
	        var /** @type {?} */ moveOffset = 0;
	        if (moveOffsets && previousIndex < moveOffsets.length) {
	            moveOffset = moveOffsets[previousIndex];
	        }
	        return previousIndex + addRemoveOffset + moveOffset;
	    }

	    var DefaultKeyValueDifferFactory = (function () {
	        function DefaultKeyValueDifferFactory() {
	        }
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
	        /**
	         * @param {?} cdRef
	         * @return {?}
	         */
	        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
	        return DefaultKeyValueDifferFactory;
	    }());
	    var DefaultKeyValueDiffer = (function () {
	        function DefaultKeyValueDiffer() {
	            this._records = new Map();
	            this._mapHead = null;
	            this._previousMapHead = null;
	            this._changesHead = null;
	            this._changesTail = null;
	            this._additionsHead = null;
	            this._additionsTail = null;
	            this._removalsHead = null;
	            this._removalsTail = null;
	        }
	        Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._additionsHead !== null || this._changesHead !== null ||
	                    this._removalsHead !== null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} map
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.diff = function (map) {
	            if (!map) {
	                map = new Map();
	            }
	            else if (!(map instanceof Map || isJsObject(map))) {
	                throw new Error("Error trying to diff '" + map + "'");
	            }
	            return this.check(map) ? this : null;
	        };
	        /**
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	        /**
	         * @param {?} map
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.check = function (map) {
	            var _this = this;
	            this._reset();
	            var /** @type {?} */ records = this._records;
	            var /** @type {?} */ oldSeqRecord = this._mapHead;
	            var /** @type {?} */ lastOldSeqRecord = null;
	            var /** @type {?} */ lastNewSeqRecord = null;
	            var /** @type {?} */ seqChanged = false;
	            this._forEach(map, function (value, key) {
	                var /** @type {?} */ newSeqRecord;
	                if (oldSeqRecord && key === oldSeqRecord.key) {
	                    newSeqRecord = oldSeqRecord;
	                    _this._maybeAddToChanges(newSeqRecord, value);
	                }
	                else {
	                    seqChanged = true;
	                    if (oldSeqRecord !== null) {
	                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                        _this._addToRemovals(oldSeqRecord);
	                    }
	                    if (records.has(key)) {
	                        newSeqRecord = records.get(key);
	                        _this._maybeAddToChanges(newSeqRecord, value);
	                    }
	                    else {
	                        newSeqRecord = new KeyValueChangeRecord(key);
	                        records.set(key, newSeqRecord);
	                        newSeqRecord.currentValue = value;
	                        _this._addToAdditions(newSeqRecord);
	                    }
	                }
	                if (seqChanged) {
	                    if (_this._isInRemovals(newSeqRecord)) {
	                        _this._removeFromRemovals(newSeqRecord);
	                    }
	                    if (lastNewSeqRecord == null) {
	                        _this._mapHead = newSeqRecord;
	                    }
	                    else {
	                        lastNewSeqRecord._next = newSeqRecord;
	                    }
	                }
	                lastOldSeqRecord = oldSeqRecord;
	                lastNewSeqRecord = newSeqRecord;
	                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
	            });
	            this._truncate(lastOldSeqRecord, oldSeqRecord);
	            return this.isDirty;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._reset = function () {
	            if (this.isDirty) {
	                var /** @type {?} */ record = void 0;
	                // Record the state of the mapping
	                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                    record.previousValue = record.currentValue;
	                }
	                for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                    record.previousValue = record.currentValue;
	                }
	                this._changesHead = this._changesTail = null;
	                this._additionsHead = this._additionsTail = null;
	                this._removalsHead = this._removalsTail = null;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} lastRecord
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
	            while (record !== null) {
	                if (lastRecord === null) {
	                    this._mapHead = null;
	                }
	                else {
	                    lastRecord._next = null;
	                }
	                var /** @type {?} */ nextRecord = record._next;
	                this._addToRemovals(record);
	                lastRecord = record;
	                record = nextRecord;
	            }
	            for (var /** @type {?} */ rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	                rec.previousValue = rec.currentValue;
	                rec.currentValue = null;
	                this._records.delete(rec.key);
	            }
	        };
	        /**
	         * @param {?} record
	         * @param {?} newValue
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
	            if (!looseIdentical(newValue, record.currentValue)) {
	                record.previousValue = record.currentValue;
	                record.currentValue = newValue;
	                this._addToChanges(record);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
	            return record === this._removalsHead || record._nextRemoved !== null ||
	                record._prevRemoved !== null;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
	            if (this._removalsHead === null) {
	                this._removalsHead = this._removalsTail = record;
	            }
	            else {
	                this._removalsTail._nextRemoved = record;
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = record;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} prev
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
	            var /** @type {?} */ next = record._next;
	            if (prev === null) {
	                this._mapHead = next;
	            }
	            else {
	                prev._next = next;
	            }
	            record._next = null;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
	            var /** @type {?} */ prev = record._prevRemoved;
	            var /** @type {?} */ next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            }
	            else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            }
	            else {
	                next._prevRemoved = prev;
	            }
	            record._prevRemoved = record._nextRemoved = null;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	            if (this._additionsHead === null) {
	                this._additionsHead = this._additionsTail = record;
	            }
	            else {
	                this._additionsTail._nextAdded = record;
	                this._additionsTail = record;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	            if (this._changesHead === null) {
	                this._changesHead = this._changesTail = record;
	            }
	            else {
	                this._changesTail._nextChanged = record;
	                this._changesTail = record;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.toString = function () {
	            var /** @type {?} */ items = [];
	            var /** @type {?} */ previous = [];
	            var /** @type {?} */ changes = [];
	            var /** @type {?} */ additions = [];
	            var /** @type {?} */ removals = [];
	            var /** @type {?} */ record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                items.push(stringify(record));
	            }
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                previous.push(stringify(record));
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                changes.push(stringify(record));
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                additions.push(stringify(record));
	            }
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                removals.push(stringify(record));
	            }
	            return 'map: ' + items.join(', ') + '\n' +
	                'previous: ' + previous.join(', ') + '\n' +
	                'additions: ' + additions.join(', ') + '\n' +
	                'changes: ' + changes.join(', ') + '\n' +
	                'removals: ' + removals.join(', ') + '\n';
	        };
	        /**
	         * \@internal
	         * @param {?} obj
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	            if (obj instanceof Map) {
	                obj.forEach(fn);
	            }
	            else {
	                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
	            }
	        };
	        return DefaultKeyValueDiffer;
	    }());
	    /**
	     * \@stable
	     */
	    var KeyValueChangeRecord = (function () {
	        /**
	         * @param {?} key
	         */
	        function KeyValueChangeRecord(key) {
	            this.key = key;
	            this.previousValue = null;
	            this.currentValue = null;
	            /** @internal */
	            this._nextPrevious = null;
	            /** @internal */
	            this._next = null;
	            /** @internal */
	            this._nextAdded = null;
	            /** @internal */
	            this._nextRemoved = null;
	            /** @internal */
	            this._prevRemoved = null;
	            /** @internal */
	            this._nextChanged = null;
	        }
	        /**
	         * @return {?}
	         */
	        KeyValueChangeRecord.prototype.toString = function () {
	            return looseIdentical(this.previousValue, this.currentValue) ?
	                stringify(this.key) :
	                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
	                    stringify(this.currentValue) + ']');
	        };
	        return KeyValueChangeRecord;
	    }());

	    /**
	     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	     * \@stable
	     */
	    var IterableDiffers = (function () {
	        /**
	         * @param {?} factories
	         */
	        function IterableDiffers(factories) {
	            this.factories = factories;
	        }
	        /**
	         * @param {?} factories
	         * @param {?=} parent
	         * @return {?}
	         */
	        IterableDiffers.create = function (factories, parent) {
	            if (isPresent(parent)) {
	                var /** @type {?} */ copied = parent.factories.slice();
	                factories = factories.concat(copied);
	                return new IterableDiffers(factories);
	            }
	            else {
	                return new IterableDiffers(factories);
	            }
	        };
	        /**
	         * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
	         * inherited {\@link IterableDiffers} instance with the provided factories and return a new
	         * {\@link IterableDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	         * which will only be applied to the injector for this component and its children.
	         * This step is all that's required to make a new {\@link IterableDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * \@Component({
	         *   viewProviders: [
	         *     IterableDiffers.extend([new ImmutableListDiffer()])
	         *   ]
	         * })
	         * ```
	         * @param {?} factories
	         * @return {?}
	         */
	        IterableDiffers.extend = function (factories) {
	            return {
	                provide: IterableDiffers,
	                useFactory: function (parent) {
	                    if (!parent) {
	                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new Error('Cannot extend IterableDiffers without a parent injector');
	                    }
	                    return IterableDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
	            };
	        };
	        /**
	         * @param {?} iterable
	         * @return {?}
	         */
	        IterableDiffers.prototype.find = function (iterable) {
	            var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(iterable); });
	            if (isPresent(factory)) {
	                return factory;
	            }
	            else {
	                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
	            }
	        };
	        return IterableDiffers;
	    }());

	    /**
	     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	     * \@stable
	     */
	    var KeyValueDiffers = (function () {
	        /**
	         * @param {?} factories
	         */
	        function KeyValueDiffers(factories) {
	            this.factories = factories;
	        }
	        /**
	         * @param {?} factories
	         * @param {?=} parent
	         * @return {?}
	         */
	        KeyValueDiffers.create = function (factories, parent) {
	            if (isPresent(parent)) {
	                var /** @type {?} */ copied = parent.factories.slice();
	                factories = factories.concat(copied);
	                return new KeyValueDiffers(factories);
	            }
	            else {
	                return new KeyValueDiffers(factories);
	            }
	        };
	        /**
	         * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
	         * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
	         * {\@link KeyValueDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	         * which will only be applied to the injector for this component and its children.
	         * This step is all that's required to make a new {\@link KeyValueDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * \@Component({
	         *   viewProviders: [
	         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	         *   ]
	         * })
	         * ```
	         * @param {?} factories
	         * @return {?}
	         */
	        KeyValueDiffers.extend = function (factories) {
	            return {
	                provide: KeyValueDiffers,
	                useFactory: function (parent) {
	                    if (!parent) {
	                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');
	                    }
	                    return KeyValueDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
	            };
	        };
	        /**
	         * @param {?} kv
	         * @return {?}
	         */
	        KeyValueDiffers.prototype.find = function (kv) {
	            var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(kv); });
	            if (isPresent(factory)) {
	                return factory;
	            }
	            else {
	                throw new Error("Cannot find a differ supporting object '" + kv + "'");
	            }
	        };
	        return KeyValueDiffers;
	    }());

	    var /** @type {?} */ UNINITIALIZED = {
	        toString: function () { return 'CD_INIT_VALUE'; }
	    };
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function devModeEqual(a, b) {
	        if (isListLikeIterable(a) && isListLikeIterable(b)) {
	            return areIterablesEqual(a, b, devModeEqual);
	        }
	        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
	            return true;
	        }
	        else {
	            return looseIdentical(a, b);
	        }
	    }
	    /**
	     * Indicates that the result of a {\@link Pipe} transformation has changed even though the
	     * reference
	     * has not changed.
	     *
	     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	     *
	     * Example:
	     *
	     * ```
	     * if (this._latestValue === this._latestReturnedValue) {
	     *    return this._latestReturnedValue;
	     *  } else {
	     *    this._latestReturnedValue = this._latestValue;
	     *    return WrappedValue.wrap(this._latestValue); // this will force update
	     *  }
	     * ```
	     * \@stable
	     */
	    var WrappedValue = (function () {
	        /**
	         * @param {?} wrapped
	         */
	        function WrappedValue(wrapped) {
	            this.wrapped = wrapped;
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	        return WrappedValue;
	    }());
	    /**
	     * Helper class for unwrapping WrappedValue s
	     */
	    var ValueUnwrapper = (function () {
	        function ValueUnwrapper() {
	            this.hasWrappedValue = false;
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ValueUnwrapper.prototype.unwrap = function (value) {
	            if (value instanceof WrappedValue) {
	                this.hasWrappedValue = true;
	                return value.wrapped;
	            }
	            return value;
	        };
	        /**
	         * @return {?}
	         */
	        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	        return ValueUnwrapper;
	    }());
	    /**
	     * Represents a basic change from a previous to a new value.
	     * \@stable
	     */
	    var SimpleChange = (function () {
	        /**
	         * @param {?} previousValue
	         * @param {?} currentValue
	         */
	        function SimpleChange(previousValue, currentValue) {
	            this.previousValue = previousValue;
	            this.currentValue = currentValue;
	        }
	        /**
	         * Check whether the new value is the first value assigned.
	         * @return {?}
	         */
	        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };
	        return SimpleChange;
	    }());

	    /**
	     * \@stable
	     * @abstract
	     */
	    var ChangeDetectorRef = (function () {
	        function ChangeDetectorRef() {
	        }
	        /**
	         * Marks all {\@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
	         *
	         * <!-- TODO: Add a link to a chapter on OnPush components -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
	         *
	         * ```typescript
	         * \@Component({
	         *   selector: 'cmp',
	         *   changeDetection: ChangeDetectionStrategy.OnPush,
	         *   template: `Number of ticks: {{numberOfTicks}}`
	         * })
	         * class Cmp {
	         *   numberOfTicks = 0;
	         *
	         *   constructor(ref: ChangeDetectorRef) {
	         *     setInterval(() => {
	         *       this.numberOfTicks ++
	         *       // the following is required, otherwise the view will not be updated
	         *       this.ref.markForCheck();
	         *     }, 1000);
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'app',
	         *   changeDetection: ChangeDetectionStrategy.OnPush,
	         *   template: `
	         *     <cmp><cmp>
	         *   `,
	         * })
	         * class App {
	         * }
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.markForCheck = function () { };
	        /**
	         * Detaches the change detector from the change detector tree.
	         *
	         * The detached change detector will not be checked until it is reattached.
	         *
	         * This can also be used in combination with {\@link ChangeDetectorRef#detectChanges} to implement
	         * local change
	         * detection checks.
	         *
	         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	         *
	         * ### Example
	         *
	         * The following example defines a component with a large list of readonly data.
	         * Imagine the data changes constantly, many times per second. For performance reasons,
	         * we want to check and update the list every five seconds. We can do that by detaching
	         * the component's change detector and doing a local check every five seconds.
	         *
	         * ```typescript
	         * class DataProvider {
	         *   // in a real application the returned data will be different every time
	         *   get data() {
	         *     return [1,2,3,4,5];
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'giant-list',
	         *   template: `
	         *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
	         *   `,
	         * })
	         * class GiantList {
	         *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
	         *     ref.detach();
	         *     setInterval(() => {
	         *       this.ref.detectChanges();
	         *     }, 5000);
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'app',
	         *   providers: [DataProvider],
	         *   template: `
	         *     <giant-list><giant-list>
	         *   `,
	         * })
	         * class App {
	         * }
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.detach = function () { };
	        /**
	         * Checks the change detector and its children.
	         *
	         * This can also be used in combination with {\@link ChangeDetectorRef#detach} to implement local
	         * change detection
	         * checks.
	         *
	         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	         *
	         * ### Example
	         *
	         * The following example defines a component with a large list of readonly data.
	         * Imagine, the data changes constantly, many times per second. For performance reasons,
	         * we want to check and update the list every five seconds.
	         *
	         * We can do that by detaching the component's change detector and doing a local change detection
	         * check
	         * every five seconds.
	         *
	         * See {\@link ChangeDetectorRef#detach} for more information.
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.detectChanges = function () { };
	        /**
	         * Checks the change detector and its children, and throws if any changes are detected.
	         *
	         * This is used in development mode to verify that running change detection doesn't introduce
	         * other changes.
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.checkNoChanges = function () { };
	        /**
	         * Reattach the change detector to the change detector tree.
	         *
	         * This also marks OnPush ancestors as to be checked. This reattached change detector will be
	         * checked during the next change detection run.
	         *
	         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
	         *
	         * The following example creates a component displaying `live` data. The component will detach
	         * its change detector from the main change detector tree when the component's live property
	         * is set to false.
	         *
	         * ```typescript
	         * class DataProvider {
	         *   data = 1;
	         *
	         *   constructor() {
	         *     setInterval(() => {
	         *       this.data = this.data * 2;
	         *     }, 500);
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'live-data',
	         *   inputs: ['live'],
	         *   template: 'Data: {{dataProvider.data}}'
	         * })
	         * class LiveData {
	         *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
	         *
	         *   set live(value) {
	         *     if (value)
	         *       this.ref.reattach();
	         *     else
	         *       this.ref.detach();
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'app',
	         *   providers: [DataProvider],
	         *   template: `
	         *     Live Update: <input type="checkbox" [(ngModel)]="live">
	         *     <live-data [live]="live"><live-data>
	         *   `,
	         * })
	         * class App {
	         *   live = true;
	         * }
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.reattach = function () { };
	        return ChangeDetectorRef;
	    }());

	    /**
	     * Structural diffing for `Object`s and `Map`s.
	     */
	    var /** @type {?} */ keyValDiff = [new DefaultKeyValueDifferFactory()];
	    /**
	     * Structural diffing for `Iterable` types such as `Array`s.
	     */
	    var /** @type {?} */ iterableDiff = [new DefaultIterableDifferFactory()];
	    var /** @type {?} */ defaultIterableDiffers = new IterableDiffers(iterableDiff);
	    var /** @type {?} */ defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var RenderComponentType = (function () {
	        /**
	         * @param {?} id
	         * @param {?} templateUrl
	         * @param {?} slotCount
	         * @param {?} encapsulation
	         * @param {?} styles
	         * @param {?} animations
	         */
	        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
	            this.id = id;
	            this.templateUrl = templateUrl;
	            this.slotCount = slotCount;
	            this.encapsulation = encapsulation;
	            this.styles = styles;
	            this.animations = animations;
	        }
	        return RenderComponentType;
	    }());
	    /**
	     * @abstract
	     */
	    var RenderDebugInfo = (function () {
	        function RenderDebugInfo() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderDebugInfo.prototype.injector = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderDebugInfo.prototype.component = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderDebugInfo.prototype.providerTokens = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderDebugInfo.prototype.references = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderDebugInfo.prototype.context = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        RenderDebugInfo.prototype.source = function () { };
	        return RenderDebugInfo;
	    }());
	    /**
	     * \@experimental
	     * @abstract
	     */
	    var Renderer = (function () {
	        function Renderer() {
	        }
	        /**
	         * @abstract
	         * @param {?} selectorOrNode
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?} name
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.createElement = function (parentElement, name, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} hostElement
	         * @return {?}
	         */
	        Renderer.prototype.createViewRoot = function (hostElement) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?} value
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.createText = function (parentElement, value, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?} nodes
	         * @return {?}
	         */
	        Renderer.prototype.projectNodes = function (parentElement, nodes) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        Renderer.prototype.attachViewAfter = function (node, viewRootNodes) { };
	        /**
	         * @abstract
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        Renderer.prototype.detachView = function (viewRootNodes) { };
	        /**
	         * @abstract
	         * @param {?} hostElement
	         * @param {?} viewAllNodes
	         * @return {?}
	         */
	        Renderer.prototype.destroyView = function (hostElement, viewAllNodes) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        Renderer.prototype.listen = function (renderElement, name, callback) { };
	        /**
	         * @abstract
	         * @param {?} target
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        Renderer.prototype.listenGlobal = function (target, name, callback) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        Renderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} attributeName
	         * @param {?} attributeValue
	         * @return {?}
	         */
	        Renderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) { };
	        /**
	         * Used only in debug mode to serialize property changes to dom nodes as attributes.
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        Renderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} className
	         * @param {?} isAdd
	         * @return {?}
	         */
	        Renderer.prototype.setElementClass = function (renderElement, className, isAdd) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        Renderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} methodName
	         * @param {?=} args
	         * @return {?}
	         */
	        Renderer.prototype.invokeElementMethod = function (renderElement, methodName, args) { };
	        /**
	         * @abstract
	         * @param {?} renderNode
	         * @param {?} text
	         * @return {?}
	         */
	        Renderer.prototype.setText = function (renderNode, text) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        Renderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
	        return Renderer;
	    }());
	    /**
	     * Injectable service that provides a low-level interface for modifying the UI.
	     *
	     * Use this service to bypass Angular's templating and make custom UI changes that can't be
	     * expressed declaratively. For example if you need to set a property or an attribute whose name is
	     * not statically known, use {\@link #setElementProperty} or {\@link #setElementAttribute}
	     * respectively.
	     *
	     * If you are implementing a custom renderer, you must implement this interface.
	     *
	     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	     * \@experimental
	     * @abstract
	     */
	    var RootRenderer = (function () {
	        function RootRenderer() {
	        }
	        /**
	         * @abstract
	         * @param {?} componentType
	         * @return {?}
	         */
	        RootRenderer.prototype.renderComponent = function (componentType) { };
	        return RootRenderer;
	    }());

	    var SecurityContext = {};
	    SecurityContext.NONE = 0;
	    SecurityContext.HTML = 1;
	    SecurityContext.STYLE = 2;
	    SecurityContext.SCRIPT = 3;
	    SecurityContext.URL = 4;
	    SecurityContext.RESOURCE_URL = 5;
	    SecurityContext[SecurityContext.NONE] = "NONE";
	    SecurityContext[SecurityContext.HTML] = "HTML";
	    SecurityContext[SecurityContext.STYLE] = "STYLE";
	    SecurityContext[SecurityContext.SCRIPT] = "SCRIPT";
	    SecurityContext[SecurityContext.URL] = "URL";
	    SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL";
	    /**
	     * Sanitizer is used by the views to sanitize potentially dangerous values.
	     *
	     * \@stable
	     * @abstract
	     */
	    var Sanitizer = (function () {
	        function Sanitizer() {
	        }
	        /**
	         * @abstract
	         * @param {?} context
	         * @param {?} value
	         * @return {?}
	         */
	        Sanitizer.prototype.sanitize = function (context, value) { };
	        return Sanitizer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * An error thrown if application changes model breaking the top-down data flow.
	     *
	     * This exception is only thrown in dev mode.
	     *
	     * <!-- TODO: Add a link once the dev mode option is configurable -->
	     *
	     * ### Example
	     *
	     * ```typescript
	     * \@Component({
	     *   selector: 'parent',
	     *   template: '<child [prop]="parentProp"></child>',
	     * })
	     * class Parent {
	     *   parentProp = 'init';
	     * }
	     *
	     * \@Directive({selector: 'child', inputs: ['prop']})
	     * class Child {
	     *   constructor(public parent: Parent) {}
	     *
	     *   set prop(v) {
	     *     // this updates the parent property, which is disallowed during change detection
	     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError
	     *     this.parent.parentProp = 'updated';
	     *   }
	     * }
	     * ```
	     * \@stable
	     */
	    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {
	        __extends$7(ExpressionChangedAfterItHasBeenCheckedError, _super);
	        /**
	         * @param {?} oldValue
	         * @param {?} currValue
	         */
	        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {
	            var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
	            if (oldValue === UNINITIALIZED) {
	                msg +=
	                    " It seems like the view has been created after its parent and its children have been dirty checked." +
	                        " Has it been created in a change detection hook ?";
	            }
	            _super.call(this, msg);
	        }
	        return ExpressionChangedAfterItHasBeenCheckedError;
	    }(BaseError));
	    /**
	     * Thrown when an exception was raised during view creation, change detection or destruction.
	     *
	     * This error wraps the original exception to attach additional contextual information that can
	     * be useful for debugging.
	     * \@stable
	     */
	    var ViewWrappedError = (function (_super) {
	        __extends$7(ViewWrappedError, _super);
	        /**
	         * @param {?} originalError
	         * @param {?} context
	         */
	        function ViewWrappedError(originalError, context) {
	            _super.call(this, "Error in " + context.source, originalError);
	            this.context = context;
	        }
	        return ViewWrappedError;
	    }(WrappedError));
	    /**
	     * Thrown when a destroyed view is used.
	     *
	     * This error indicates a bug in the framework.
	     *
	     * This is an internal Angular error.
	     * \@stable
	     */
	    var ViewDestroyedError = (function (_super) {
	        __extends$7(ViewDestroyedError, _super);
	        /**
	         * @param {?} details
	         */
	        function ViewDestroyedError(details) {
	            _super.call(this, "Attempt to use a destroyed view: " + details);
	        }
	        return ViewDestroyedError;
	    }(BaseError));

	    var ViewUtils = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} sanitizer
	         * @param {?} animationQueue
	         */
	        function ViewUtils(_renderer, sanitizer, animationQueue) {
	            this._renderer = _renderer;
	            this.animationQueue = animationQueue;
	            this.sanitizer = sanitizer;
	        }
	        /**
	         * \@internal
	         * @param {?} renderComponentType
	         * @return {?}
	         */
	        ViewUtils.prototype.renderComponent = function (renderComponentType) {
	            return this._renderer.renderComponent(renderComponentType);
	        };
	        ViewUtils.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ViewUtils.ctorParameters = function () { return [
	            { type: RootRenderer, },
	            { type: Sanitizer, },
	            { type: AnimationQueue, },
	        ]; };
	        return ViewUtils;
	    }());
	    var /** @type {?} */ nextRenderComponentTypeId = 0;
	    /**
	     * @param {?} templateUrl
	     * @param {?} slotCount
	     * @param {?} encapsulation
	     * @param {?} styles
	     * @param {?} animations
	     * @return {?}
	     */
	    function createRenderComponentType(templateUrl, slotCount, encapsulation, styles, animations) {
	        return new RenderComponentType("" + nextRenderComponentTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
	    }
	    /**
	     * @param {?} e
	     * @param {?} array
	     * @return {?}
	     */
	    function addToArray(e, array) {
	        array.push(e);
	    }
	    /**
	     * @param {?} valueCount
	     * @param {?} constAndInterp
	     * @return {?}
	     */
	    function interpolate(valueCount, constAndInterp) {
	        var /** @type {?} */ result = '';
	        for (var /** @type {?} */ i = 0; i < valueCount * 2; i = i + 2) {
	            result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
	        }
	        return result + constAndInterp[valueCount * 2];
	    }
	    /**
	     * @param {?} valueCount
	     * @param {?} c0
	     * @param {?} a1
	     * @param {?} c1
	     * @param {?=} a2
	     * @param {?=} c2
	     * @param {?=} a3
	     * @param {?=} c3
	     * @param {?=} a4
	     * @param {?=} c4
	     * @param {?=} a5
	     * @param {?=} c5
	     * @param {?=} a6
	     * @param {?=} c6
	     * @param {?=} a7
	     * @param {?=} c7
	     * @param {?=} a8
	     * @param {?=} c8
	     * @param {?=} a9
	     * @param {?=} c9
	     * @return {?}
	     */
	    function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	        switch (valueCount) {
	            case 1:
	                return c0 + _toStringWithNull(a1) + c1;
	            case 2:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	            case 3:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3;
	            case 4:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4;
	            case 5:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	            case 6:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	            case 7:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7;
	            case 8:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	            case 9:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	            default:
	                throw new Error("Does not support more than 9 expressions");
	        }
	    }
	    /**
	     * @param {?} v
	     * @return {?}
	     */
	    function _toStringWithNull(v) {
	        return v != null ? v.toString() : '';
	    }
	    /**
	     * @param {?} throwOnChange
	     * @param {?} oldValue
	     * @param {?} newValue
	     * @return {?}
	     */
	    function checkBinding(throwOnChange, oldValue, newValue) {
	        if (throwOnChange) {
	            if (!devModeEqual(oldValue, newValue)) {
	                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);
	            }
	            return false;
	        }
	        else {
	            return !looseIdentical(oldValue, newValue);
	        }
	    }
	    /**
	     * @param {?} input
	     * @param {?} value
	     * @return {?}
	     */
	    function castByValue(input, value) {
	        return (input);
	    }
	    var /** @type {?} */ EMPTY_ARRAY = [];
	    var /** @type {?} */ EMPTY_MAP = {};
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy1(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0 = UNINITIALIZED;
	        return function (p0) {
	            if (!looseIdentical(v0, p0)) {
	                v0 = p0;
	                result = fn(p0);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy2(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0 = UNINITIALIZED;
	        var /** @type {?} */ v1 = UNINITIALIZED;
	        return function (p0, p1) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
	                v0 = p0;
	                v1 = p1;
	                result = fn(p0, p1);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy3(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0 = UNINITIALIZED;
	        var /** @type {?} */ v1 = UNINITIALIZED;
	        var /** @type {?} */ v2 = UNINITIALIZED;
	        return function (p0, p1, p2) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                result = fn(p0, p1, p2);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy4(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3;
	        v0 = v1 = v2 = v3 = UNINITIALIZED;
	        return function (p0, p1, p2, p3) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                result = fn(p0, p1, p2, p3);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy5(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4;
	        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                result = fn(p0, p1, p2, p3, p4);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy6(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5;
	        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                result = fn(p0, p1, p2, p3, p4, p5);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy7(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                result = fn(p0, p1, p2, p3, p4, p5, p6);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy8(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy9(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7, /** @type {?} */ v8;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                v8 = p8;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy10(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7, /** @type {?} */ v8, /** @type {?} */ v9;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||
	                !looseIdentical(v9, p9)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                v8 = p8;
	                v9 = p9;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} el
	     * @param {?} changes
	     * @return {?}
	     */
	    function setBindingDebugInfoForChanges(renderer, el, changes) {
	        Object.keys(changes).forEach(function (propName) {
	            setBindingDebugInfo(renderer, el, propName, changes[propName].currentValue);
	        });
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} el
	     * @param {?} propName
	     * @param {?} value
	     * @return {?}
	     */
	    function setBindingDebugInfo(renderer, el, propName, value) {
	        try {
	            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), value ? value.toString() : null);
	        }
	        catch (e) {
	            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), '[ERROR] Exception while trying to serialize the value');
	        }
	    }
	    var /** @type {?} */ CAMEL_CASE_REGEXP = /([A-Z])/g;
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function camelCaseToDashCase(input) {
	        return input.replace(CAMEL_CASE_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            return '-' + m[1].toLowerCase();
	        });
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} parentElement
	     * @param {?} name
	     * @param {?} attrs
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    function createRenderElement(renderer, parentElement, name, attrs, debugInfo) {
	        var /** @type {?} */ el = renderer.createElement(parentElement, name, debugInfo);
	        for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
	            renderer.setElementAttribute(el, attrs.get(i), attrs.get(i + 1));
	        }
	        return el;
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} elementName
	     * @param {?} attrs
	     * @param {?} rootSelectorOrNode
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    function selectOrCreateRenderHostElement(renderer, elementName, attrs, rootSelectorOrNode, debugInfo) {
	        var /** @type {?} */ hostElement;
	        if (isPresent(rootSelectorOrNode)) {
	            hostElement = renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
	                renderer.setElementAttribute(hostElement, attrs.get(i), attrs.get(i + 1));
	            }
	            renderer.setElementAttribute(hostElement, 'ng-version', VERSION.full);
	        }
	        else {
	            hostElement = createRenderElement(renderer, null, elementName, attrs, debugInfo);
	        }
	        return hostElement;
	    }
	    /**
	     * @param {?} view
	     * @param {?} element
	     * @param {?} eventNamesAndTargets
	     * @param {?} listener
	     * @return {?}
	     */
	    function subscribeToRenderElement(view, element, eventNamesAndTargets, listener) {
	        var /** @type {?} */ disposables = createEmptyInlineArray(eventNamesAndTargets.length / 2);
	        for (var /** @type {?} */ i = 0; i < eventNamesAndTargets.length; i += 2) {
	            var /** @type {?} */ eventName = eventNamesAndTargets.get(i);
	            var /** @type {?} */ eventTarget = eventNamesAndTargets.get(i + 1);
	            var /** @type {?} */ disposable = void 0;
	            if (eventTarget) {
	                disposable = view.renderer.listenGlobal(eventTarget, eventName, listener.bind(view, eventTarget + ":" + eventName));
	            }
	            else {
	                disposable = view.renderer.listen(element, eventName, listener.bind(view, eventName));
	            }
	            disposables.set(i / 2, disposable);
	        }
	        return disposeInlineArray.bind(null, disposables);
	    }
	    /**
	     * @param {?} disposables
	     * @return {?}
	     */
	    function disposeInlineArray(disposables) {
	        for (var /** @type {?} */ i = 0; i < disposables.length; i++) {
	            disposables.get(i)();
	        }
	    }
	    /**
	     * @return {?}
	     */
	    function noop() { }
	    /**
	     * @param {?} length
	     * @return {?}
	     */
	    function createEmptyInlineArray(length) {
	        var /** @type {?} */ ctor;
	        if (length <= 2) {
	            ctor = InlineArray2;
	        }
	        else if (length <= 4) {
	            ctor = InlineArray4;
	        }
	        else if (length <= 8) {
	            ctor = InlineArray8;
	        }
	        else if (length <= 16) {
	            ctor = InlineArray16;
	        }
	        else {
	            ctor = InlineArrayDynamic;
	        }
	        return new ctor(length);
	    }
	    var InlineArray0 = (function () {
	        function InlineArray0() {
	            this.length = 0;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray0.prototype.get = function (index) { return undefined; };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray0.prototype.set = function (index, value) { };
	        return InlineArray0;
	    }());
	    var InlineArray2 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         */
	        function InlineArray2(length, _v0, _v1) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray2.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray2.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	            }
	        };
	        return InlineArray2;
	    }());
	    var InlineArray4 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         * @param {?=} _v2
	         * @param {?=} _v3
	         */
	        function InlineArray4(length, _v0, _v1, _v2, _v3) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray4.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray4.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	                case 2:
	                    this._v2 = value;
	                    break;
	                case 3:
	                    this._v3 = value;
	                    break;
	            }
	        };
	        return InlineArray4;
	    }());
	    var InlineArray8 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         * @param {?=} _v2
	         * @param {?=} _v3
	         * @param {?=} _v4
	         * @param {?=} _v5
	         * @param {?=} _v6
	         * @param {?=} _v7
	         */
	        function InlineArray8(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	            this._v4 = _v4;
	            this._v5 = _v5;
	            this._v6 = _v6;
	            this._v7 = _v7;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray8.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                case 4:
	                    return this._v4;
	                case 5:
	                    return this._v5;
	                case 6:
	                    return this._v6;
	                case 7:
	                    return this._v7;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray8.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	                case 2:
	                    this._v2 = value;
	                    break;
	                case 3:
	                    this._v3 = value;
	                    break;
	                case 4:
	                    this._v4 = value;
	                    break;
	                case 5:
	                    this._v5 = value;
	                    break;
	                case 6:
	                    this._v6 = value;
	                    break;
	                case 7:
	                    this._v7 = value;
	                    break;
	            }
	        };
	        return InlineArray8;
	    }());
	    var InlineArray16 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         * @param {?=} _v2
	         * @param {?=} _v3
	         * @param {?=} _v4
	         * @param {?=} _v5
	         * @param {?=} _v6
	         * @param {?=} _v7
	         * @param {?=} _v8
	         * @param {?=} _v9
	         * @param {?=} _v10
	         * @param {?=} _v11
	         * @param {?=} _v12
	         * @param {?=} _v13
	         * @param {?=} _v14
	         * @param {?=} _v15
	         */
	        function InlineArray16(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7, _v8, _v9, _v10, _v11, _v12, _v13, _v14, _v15) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	            this._v4 = _v4;
	            this._v5 = _v5;
	            this._v6 = _v6;
	            this._v7 = _v7;
	            this._v8 = _v8;
	            this._v9 = _v9;
	            this._v10 = _v10;
	            this._v11 = _v11;
	            this._v12 = _v12;
	            this._v13 = _v13;
	            this._v14 = _v14;
	            this._v15 = _v15;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray16.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                case 4:
	                    return this._v4;
	                case 5:
	                    return this._v5;
	                case 6:
	                    return this._v6;
	                case 7:
	                    return this._v7;
	                case 8:
	                    return this._v8;
	                case 9:
	                    return this._v9;
	                case 10:
	                    return this._v10;
	                case 11:
	                    return this._v11;
	                case 12:
	                    return this._v12;
	                case 13:
	                    return this._v13;
	                case 14:
	                    return this._v14;
	                case 15:
	                    return this._v15;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray16.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	                case 2:
	                    this._v2 = value;
	                    break;
	                case 3:
	                    this._v3 = value;
	                    break;
	                case 4:
	                    this._v4 = value;
	                    break;
	                case 5:
	                    this._v5 = value;
	                    break;
	                case 6:
	                    this._v6 = value;
	                    break;
	                case 7:
	                    this._v7 = value;
	                    break;
	                case 8:
	                    this._v8 = value;
	                    break;
	                case 9:
	                    this._v9 = value;
	                    break;
	                case 10:
	                    this._v10 = value;
	                    break;
	                case 11:
	                    this._v11 = value;
	                    break;
	                case 12:
	                    this._v12 = value;
	                    break;
	                case 13:
	                    this._v13 = value;
	                    break;
	                case 14:
	                    this._v14 = value;
	                    break;
	                case 15:
	                    this._v15 = value;
	                    break;
	            }
	        };
	        return InlineArray16;
	    }());
	    var InlineArrayDynamic = (function () {
	        /**
	         * @param {?} length
	         * @param {...?} values
	         */
	        function InlineArrayDynamic(length) {
	            var values = [];
	            for (var _i = 1; _i < arguments.length; _i++) {
	                values[_i - 1] = arguments[_i];
	            }
	            this.length = length;
	            this._values = values;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArrayDynamic.prototype.get = function (index) { return this._values[index]; };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArrayDynamic.prototype.set = function (index, value) { this._values[index] = value; };
	        return InlineArrayDynamic;
	    }());
	    var /** @type {?} */ EMPTY_INLINE_ARRAY = new InlineArray0();


	    var view_utils = Object.freeze({
	        ViewUtils: ViewUtils,
	        createRenderComponentType: createRenderComponentType,
	        addToArray: addToArray,
	        interpolate: interpolate,
	        inlineInterpolate: inlineInterpolate,
	        checkBinding: checkBinding,
	        castByValue: castByValue,
	        EMPTY_ARRAY: EMPTY_ARRAY,
	        EMPTY_MAP: EMPTY_MAP,
	        pureProxy1: pureProxy1,
	        pureProxy2: pureProxy2,
	        pureProxy3: pureProxy3,
	        pureProxy4: pureProxy4,
	        pureProxy5: pureProxy5,
	        pureProxy6: pureProxy6,
	        pureProxy7: pureProxy7,
	        pureProxy8: pureProxy8,
	        pureProxy9: pureProxy9,
	        pureProxy10: pureProxy10,
	        setBindingDebugInfoForChanges: setBindingDebugInfoForChanges,
	        setBindingDebugInfo: setBindingDebugInfo,
	        createRenderElement: createRenderElement,
	        selectOrCreateRenderHostElement: selectOrCreateRenderHostElement,
	        subscribeToRenderElement: subscribeToRenderElement,
	        noop: noop,
	        InlineArray2: InlineArray2,
	        InlineArray4: InlineArray4,
	        InlineArray8: InlineArray8,
	        InlineArray16: InlineArray16,
	        InlineArrayDynamic: InlineArrayDynamic,
	        EMPTY_INLINE_ARRAY: EMPTY_INLINE_ARRAY
	    });

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an instance of a Component created via a {\@link ComponentFactory}.
	     *
	     * `ComponentRef` provides access to the Component Instance as well other objects related to this
	     * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
	     * method.
	     * \@stable
	     * @abstract
	     */
	    var ComponentRef = (function () {
	        function ComponentRef() {
	        }
	        /**
	         * Location of the Host Element of this Component Instance.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.location = function () { };
	        /**
	         * The injector on which the component instance exists.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.injector = function () { };
	        /**
	         * The instance of the Component.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.instance = function () { };
	        /**
	         * The {\@link ViewRef} of the Host View of this Component instance.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.hostView = function () { };
	        /**
	         * The {\@link ChangeDetectorRef} of the Component instance.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.changeDetectorRef = function () { };
	        /**
	         * The component type.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.componentType = function () { };
	        /**
	         * Destroys the component instance and all of the data structures associated with it.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.destroy = function () { };
	        /**
	         * Allows to register a callback that will be called when the component is destroyed.
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        ComponentRef.prototype.onDestroy = function (callback) { };
	        return ComponentRef;
	    }());
	    var ComponentRef_ = (function (_super) {
	        __extends$5(ComponentRef_, _super);
	        /**
	         * @param {?} _index
	         * @param {?} _parentView
	         * @param {?} _nativeElement
	         * @param {?} _component
	         */
	        function ComponentRef_(_index, _parentView, _nativeElement, _component) {
	            _super.call(this);
	            this._index = _index;
	            this._parentView = _parentView;
	            this._nativeElement = _nativeElement;
	            this._component = _component;
	        }
	        Object.defineProperty(ComponentRef_.prototype, "location", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ElementRef(this._nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef_.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parentView.injector(this._index); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef_.prototype, "instance", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._component; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "hostView", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parentView.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parentView.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "componentType", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (this._component.constructor); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ComponentRef_.prototype.destroy = function () { this._parentView.detachAndDestroy(); };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
	        return ComponentRef_;
	    }(ComponentRef));
	    /**
	     * \@stable
	     */
	    var ComponentFactory = (function () {
	        /**
	         * @param {?} selector
	         * @param {?} _viewClass
	         * @param {?} _componentType
	         */
	        function ComponentFactory(selector, _viewClass, _componentType) {
	            this.selector = selector;
	            this._viewClass = _viewClass;
	            this._componentType = _componentType;
	        }
	        Object.defineProperty(ComponentFactory.prototype, "componentType", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._componentType; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Creates a new component.
	         * @param {?} injector
	         * @param {?=} projectableNodes
	         * @param {?=} rootSelectorOrNode
	         * @return {?}
	         */
	        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
	            var /** @type {?} */ vu = injector.get(ViewUtils);
	            if (!projectableNodes) {
	                projectableNodes = [];
	            }
	            var /** @type {?} */ hostView = new this._viewClass(vu, null, null, null);
	            return hostView.createHostView(rootSelectorOrNode, injector, projectableNodes);
	        };
	        return ComponentFactory;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     */
	    var NoComponentFactoryError = (function (_super) {
	        __extends$8(NoComponentFactoryError, _super);
	        /**
	         * @param {?} component
	         */
	        function NoComponentFactoryError(component) {
	            _super.call(this, "No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
	            this.component = component;
	        }
	        return NoComponentFactoryError;
	    }(BaseError));
	    var _NullComponentFactoryResolver = (function () {
	        function _NullComponentFactoryResolver() {
	        }
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	            throw new NoComponentFactoryError(component);
	        };
	        return _NullComponentFactoryResolver;
	    }());
	    /**
	     * \@stable
	     * @abstract
	     */
	    var ComponentFactoryResolver = (function () {
	        function ComponentFactoryResolver() {
	        }
	        /**
	         * @abstract
	         * @param {?} component
	         * @return {?}
	         */
	        ComponentFactoryResolver.prototype.resolveComponentFactory = function (component) { };
	        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	        return ComponentFactoryResolver;
	    }());
	    var CodegenComponentFactoryResolver = (function () {
	        /**
	         * @param {?} factories
	         * @param {?} _parent
	         */
	        function CodegenComponentFactoryResolver(factories, _parent) {
	            this._parent = _parent;
	            this._factories = new Map();
	            for (var i = 0; i < factories.length; i++) {
	                var factory = factories[i];
	                this._factories.set(factory.componentType, factory);
	            }
	        }
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	            var /** @type {?} */ result = this._factories.get(component);
	            if (!result) {
	                result = this._parent.resolveComponentFactory(component);
	            }
	            return result;
	        };
	        return CodegenComponentFactoryResolver;
	    }());

	    var /** @type {?} */ trace;
	    var /** @type {?} */ events;
	    /**
	     * @return {?}
	     */
	    function detectWTF() {
	        var /** @type {?} */ wtf = ((global$1) /** TODO #9100 */)['wtf'];
	        if (wtf) {
	            trace = wtf['trace'];
	            if (trace) {
	                events = trace['events'];
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * @param {?} signature
	     * @param {?=} flags
	     * @return {?}
	     */
	    function createScope(signature, flags) {
	        if (flags === void 0) { flags = null; }
	        return events.createScope(signature, flags);
	    }
	    /**
	     * @param {?} scope
	     * @param {?=} returnValue
	     * @return {?}
	     */
	    function leave(scope, returnValue) {
	        trace.leaveScope(scope, returnValue);
	        return returnValue;
	    }
	    /**
	     * @param {?} rangeType
	     * @param {?} action
	     * @return {?}
	     */
	    function startTimeRange(rangeType, action) {
	        return trace.beginTimeRange(rangeType, action);
	    }
	    /**
	     * @param {?} range
	     * @return {?}
	     */
	    function endTimeRange(range) {
	        trace.endTimeRange(range);
	    }

	    /**
	     * True if WTF is enabled.
	     */
	    var /** @type {?} */ wtfEnabled = detectWTF();
	    /**
	     * @param {?=} arg0
	     * @param {?=} arg1
	     * @return {?}
	     */
	    function noopScope(arg0, arg1) {
	        return null;
	    }
	    /**
	     * Create trace scope.
	     *
	     * Scopes must be strictly nested and are analogous to stack frames, but
	     * do not have to follow the stack frames. Instead it is recommended that they follow logical
	     * nesting. You may want to use
	     * [Event
	     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	     * as they are defined in WTF.
	     *
	     * Used to mark scope entry. The return value is used to leave the scope.
	     *
	     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	     *
	     *     someMethod() {
	     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	     *        // DO SOME WORK HERE
	     *        return wtfLeave(s, 123); // Return value 123
	     *     }
	     *
	     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	     * negatively impact the performance of your application. For this reason we recommend that
	     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	     * exception, will produce incorrect trace, but presence of exception signifies logic error which
	     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	     * an exception is expected during normal execution while profiling.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };
	    /**
	     * Used to mark end of Scope.
	     *
	     * - `scope` to end.
	     * - `returnValue` (optional) to be passed to the WTF.
	     *
	     * Returns the `returnValue for easy chaining.
	     * @experimental
	     */
	    var /** @type {?} */ wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
	    /**
	     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	     * enabled.
	     *
	     *     someMethod() {
	     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	     *        var future = new Future.delay(5).then((_) {
	     *          wtfEndTimeRange(s);
	     *        });
	     *     }
	     * @experimental
	     */
	    var /** @type {?} */ wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
	    /**
	     * Ends a async time range operation.
	     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	     * enabled.
	     * @experimental
	     */
	    var /** @type {?} */ wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };

	    /**
	     * The Testability service provides testing hooks that can be accessed from
	     * the browser and by services such as Protractor. Each bootstrapped Angular
	     * application on the page will have an instance of Testability.
	     * \@experimental
	     */
	    var Testability = (function () {
	        /**
	         * @param {?} _ngZone
	         */
	        function Testability(_ngZone) {
	            this._ngZone = _ngZone;
	            /** @internal */
	            this._pendingCount = 0;
	            /** @internal */
	            this._isZoneStable = true;
	            /**
	             * Whether any work was done since the last 'whenStable' callback. This is
	             * useful to detect if this could have potentially destabilized another
	             * component while it is stabilizing.
	             * @internal
	             */
	            this._didWork = false;
	            /** @internal */
	            this._callbacks = [];
	            this._watchAngularEvents();
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        Testability.prototype._watchAngularEvents = function () {
	            var _this = this;
	            this._ngZone.onUnstable.subscribe({
	                next: function () {
	                    _this._didWork = true;
	                    _this._isZoneStable = false;
	                }
	            });
	            this._ngZone.runOutsideAngular(function () {
	                _this._ngZone.onStable.subscribe({
	                    next: function () {
	                        NgZone.assertNotInAngularZone();
	                        scheduleMicroTask(function () {
	                            _this._isZoneStable = true;
	                            _this._runCallbacksIfReady();
	                        });
	                    }
	                });
	            });
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.increasePendingRequestCount = function () {
	            this._pendingCount += 1;
	            this._didWork = true;
	            return this._pendingCount;
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.decreasePendingRequestCount = function () {
	            this._pendingCount -= 1;
	            if (this._pendingCount < 0) {
	                throw new Error('pending async requests below zero');
	            }
	            this._runCallbacksIfReady();
	            return this._pendingCount;
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.isStable = function () {
	            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        Testability.prototype._runCallbacksIfReady = function () {
	            var _this = this;
	            if (this.isStable()) {
	                // Schedules the call backs in a new frame so that it is always async.
	                scheduleMicroTask(function () {
	                    while (_this._callbacks.length !== 0) {
	                        (_this._callbacks.pop())(_this._didWork);
	                    }
	                    _this._didWork = false;
	                });
	            }
	            else {
	                // Not Ready
	                this._didWork = true;
	            }
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        Testability.prototype.whenStable = function (callback) {
	            this._callbacks.push(callback);
	            this._runCallbacksIfReady();
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	        /**
	         * @deprecated use findProviders
	         * @param {?} using
	         * @param {?} provider
	         * @param {?} exactMatch
	         * @return {?}
	         */
	        Testability.prototype.findBindings = function (using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        };
	        /**
	         * @param {?} using
	         * @param {?} provider
	         * @param {?} exactMatch
	         * @return {?}
	         */
	        Testability.prototype.findProviders = function (using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        };
	        Testability.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Testability.ctorParameters = function () { return [
	            { type: NgZone, },
	        ]; };
	        return Testability;
	    }());
	    /**
	     * A global registry of {\@link Testability} instances for specific elements.
	     * \@experimental
	     */
	    var TestabilityRegistry = (function () {
	        function TestabilityRegistry() {
	            /** @internal */
	            this._applications = new Map();
	            _testabilityGetter.addToWindow(this);
	        }
	        /**
	         * @param {?} token
	         * @param {?} testability
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	            this._applications.set(token, testability);
	        };
	        /**
	         * @param {?} elem
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
	        /**
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };
	        /**
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };
	        /**
	         * @param {?} elem
	         * @param {?=} findInAncestors
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	            if (findInAncestors === void 0) { findInAncestors = true; }
	            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	        };
	        TestabilityRegistry.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        TestabilityRegistry.ctorParameters = function () { return []; };
	        return TestabilityRegistry;
	    }());
	    var _NoopGetTestability = (function () {
	        function _NoopGetTestability() {
	        }
	        /**
	         * @param {?} registry
	         * @return {?}
	         */
	        _NoopGetTestability.prototype.addToWindow = function (registry) { };
	        /**
	         * @param {?} registry
	         * @param {?} elem
	         * @param {?} findInAncestors
	         * @return {?}
	         */
	        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	            return null;
	        };
	        return _NoopGetTestability;
	    }());
	    /**
	     * Set the {\@link GetTestability} implementation used by the Angular testing framework.
	     * \@experimental
	     * @param {?} getter
	     * @return {?}
	     */
	    function setTestabilityGetter(getter) {
	        _testabilityGetter = getter;
	    }
	    var /** @type {?} */ _testabilityGetter = new _NoopGetTestability();

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _devMode = true;
	    var /** @type {?} */ _runModeLocked = false;
	    var /** @type {?} */ _platform;
	    /**
	     * Disable Angular's development mode, which turns off assertions and other
	     * checks within the framework.
	     *
	     * One important assertion this disables verifies that a change detection pass
	     * does not result in additional changes to any bindings (also known as
	     * unidirectional data flow).
	     *
	     * \@stable
	     * @return {?}
	     */
	    function enableProdMode() {
	        if (_runModeLocked) {
	            throw new Error('Cannot enable prod mode after platform setup.');
	        }
	        _devMode = false;
	    }
	    /**
	     * Returns whether Angular is in development mode. After called once,
	     * the value is locked and won't change any more.
	     *
	     * By default, this is true, unless a user calls `enableProdMode` before calling this.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @return {?}
	     */
	    function isDevMode() {
	        _runModeLocked = true;
	        return _devMode;
	    }
	    /**
	     * A token for third-party components that can register themselves with NgProbe.
	     *
	     * \@experimental
	     */
	    var NgProbeToken = (function () {
	        /**
	         * @param {?} name
	         * @param {?} token
	         */
	        function NgProbeToken(name, token) {
	            this.name = name;
	            this.token = token;
	        }
	        return NgProbeToken;
	    }());
	    /**
	     * Creates a platform.
	     * Platforms have to be eagerly created via this function.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @param {?} injector
	     * @return {?}
	     */
	    function createPlatform(injector) {
	        if (_platform && !_platform.destroyed) {
	            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
	        }
	        _platform = injector.get(PlatformRef);
	        var /** @type {?} */ inits = (injector.get(PLATFORM_INITIALIZER, null));
	        if (inits)
	            inits.forEach(function (init) { return init(); });
	        return _platform;
	    }
	    /**
	     * Creates a factory for a platform
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @param {?} parentPlatformFactory
	     * @param {?} name
	     * @param {?=} providers
	     * @return {?}
	     */
	    function createPlatformFactory(parentPlatformFactory, name, providers) {
	        if (providers === void 0) { providers = []; }
	        var /** @type {?} */ marker = new OpaqueToken("Platform: " + name);
	        return function (extraProviders) {
	            if (extraProviders === void 0) { extraProviders = []; }
	            if (!getPlatform()) {
	                if (parentPlatformFactory) {
	                    parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
	                }
	                else {
	                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
	                }
	            }
	            return assertPlatform(marker);
	        };
	    }
	    /**
	     * Checks that there currently is a platform
	     * which contains the given token as a provider.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @param {?} requiredToken
	     * @return {?}
	     */
	    function assertPlatform(requiredToken) {
	        var /** @type {?} */ platform = getPlatform();
	        if (!platform) {
	            throw new Error('No platform exists!');
	        }
	        if (!platform.injector.get(requiredToken, null)) {
	            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
	        }
	        return platform;
	    }
	    /**
	     * Destroy the existing platform.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @return {?}
	     */
	    function destroyPlatform() {
	        if (_platform && !_platform.destroyed) {
	            _platform.destroy();
	        }
	    }
	    /**
	     * Returns the current platform.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @return {?}
	     */
	    function getPlatform() {
	        return _platform && !_platform.destroyed ? _platform : null;
	    }
	    /**
	     * The Angular platform is the entry point for Angular on a web page. Each page
	     * has exactly one platform, and services (such as reflection) which are common
	     * to every Angular application running on the page are bound in its scope.
	     *
	     * A page's platform is initialized implicitly when {\@link bootstrap}() is called, or
	     * explicitly by calling {\@link createPlatform}().
	     *
	     * \@stable
	     * @abstract
	     */
	    var PlatformRef = (function () {
	        function PlatformRef() {
	        }
	        /**
	         * Creates an instance of an `\@NgModule` for the given platform
	         * for offline compilation.
	         *
	         * ## Simple Example
	         *
	         * ```typescript
	         * my_module.ts:
	         *
	         * \@NgModule({
	         *   imports: [BrowserModule]
	         * })
	         * class MyModule {}
	         *
	         * main.ts:
	         * import {MyModuleNgFactory} from './my_module.ngfactory';
	         * import {platformBrowser} from '\@angular/platform-browser';
	         *
	         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
	         * ```
	         *
	         * \@experimental APIs related to application bootstrap are currently under review.
	         * @abstract
	         * @param {?} moduleFactory
	         * @return {?}
	         */
	        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) { };
	        /**
	         * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
	         *
	         * ## Simple Example
	         *
	         * ```typescript
	         * \@NgModule({
	         *   imports: [BrowserModule]
	         * })
	         * class MyModule {}
	         *
	         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
	         * ```
	         * \@stable
	         * @abstract
	         * @param {?} moduleType
	         * @param {?=} compilerOptions
	         * @return {?}
	         */
	        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) { };
	        /**
	         * Register a listener to be called when the platform is disposed.
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        PlatformRef.prototype.onDestroy = function (callback) { };
	        /**
	         * Retrieve the platform {\@link Injector}, which is the parent injector for
	         * every Angular application on the page and provides singleton providers.
	         * @abstract
	         * @return {?}
	         */
	        PlatformRef.prototype.injector = function () { };
	        /**
	         * Destroy the Angular platform and all Angular applications on the page.
	         * @abstract
	         * @return {?}
	         */
	        PlatformRef.prototype.destroy = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformRef.prototype.destroyed = function () { };
	        return PlatformRef;
	    }());
	    /**
	     * @param {?} errorHandler
	     * @param {?} callback
	     * @return {?}
	     */
	    function _callAndReportToErrorHandler(errorHandler, callback) {
	        try {
	            var /** @type {?} */ result = callback();
	            if (isPromise(result)) {
	                return result.catch(function (e) {
	                    errorHandler.handleError(e);
	                    // rethrow as the exception handler might not do it
	                    throw e;
	                });
	            }
	            return result;
	        }
	        catch (e) {
	            errorHandler.handleError(e);
	            // rethrow as the exception handler might not do it
	            throw e;
	        }
	    }
	    var PlatformRef_ = (function (_super) {
	        __extends$3(PlatformRef_, _super);
	        /**
	         * @param {?} _injector
	         */
	        function PlatformRef_(_injector) {
	            _super.call(this);
	            this._injector = _injector;
	            this._modules = [];
	            this._destroyListeners = [];
	            this._destroyed = false;
	        }
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	        Object.defineProperty(PlatformRef_.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformRef_.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        PlatformRef_.prototype.destroy = function () {
	            if (this._destroyed) {
	                throw new Error('The platform has already been destroyed!');
	            }
	            this._modules.slice().forEach(function (module) { return module.destroy(); });
	            this._destroyListeners.forEach(function (listener) { return listener(); });
	            this._destroyed = true;
	        };
	        /**
	         * @param {?} moduleFactory
	         * @return {?}
	         */
	        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
	            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
	        };
	        /**
	         * @param {?} moduleFactory
	         * @param {?} ngZone
	         * @return {?}
	         */
	        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
	            var _this = this;
	            // Note: We need to create the NgZone _before_ we instantiate the module,
	            // as instantiating the module creates some providers eagerly.
	            // So we create a mini parent injector that just contains the new NgZone and
	            // pass that as parent to the NgModuleFactory.
	            if (!ngZone)
	                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
	            // Attention: Don't use ApplicationRef.run here,
	            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	            return ngZone.run(function () {
	                var /** @type {?} */ ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
	                var /** @type {?} */ moduleRef = (moduleFactory.create(ngZoneInjector));
	                var /** @type {?} */ exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
	                if (!exceptionHandler) {
	                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
	                }
	                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });
	                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
	                return _callAndReportToErrorHandler(exceptionHandler, function () {
	                    var /** @type {?} */ initStatus = moduleRef.injector.get(ApplicationInitStatus);
	                    return initStatus.donePromise.then(function () {
	                        _this._moduleDoBootstrap(moduleRef);
	                        return moduleRef;
	                    });
	                });
	            });
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?=} compilerOptions
	         * @return {?}
	         */
	        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?=} compilerOptions
	         * @param {?} ngZone
	         * @param {?=} componentFactoryCallback
	         * @return {?}
	         */
	        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {
	            var _this = this;
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            var /** @type {?} */ compilerFactory = this.injector.get(CompilerFactory);
	            var /** @type {?} */ compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
	            // ugly internal api hack: generate host component factories for all declared components and
	            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all
	            // factories.
	            if (componentFactoryCallback) {
	                return compiler.compileModuleAndAllComponentsAsync(moduleType)
	                    .then(function (_a) {
	                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;
	                    componentFactoryCallback(componentFactories);
	                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);
	                });
	            }
	            return compiler.compileModuleAsync(moduleType)
	                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
	        };
	        /**
	         * @param {?} moduleRef
	         * @return {?}
	         */
	        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
	            var /** @type {?} */ appRef = moduleRef.injector.get(ApplicationRef);
	            if (moduleRef.bootstrapFactories.length > 0) {
	                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
	            }
	            else if (moduleRef.instance.ngDoBootstrap) {
	                moduleRef.instance.ngDoBootstrap(appRef);
	            }
	            else {
	                throw new Error(("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
	                    "Please define one of these.");
	            }
	            this._modules.push(moduleRef);
	        };
	        PlatformRef_.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        PlatformRef_.ctorParameters = function () { return [
	            { type: Injector, },
	        ]; };
	        return PlatformRef_;
	    }(PlatformRef));
	    /**
	     * A reference to an Angular application running on a page.
	     *
	     * For more about Angular applications, see the documentation for {\@link bootstrap}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var ApplicationRef = (function () {
	        function ApplicationRef() {
	        }
	        /**
	         * Bootstrap a new component at the root level of the application.
	         *
	         * ### Bootstrap process
	         *
	         * When bootstrapping a new root component into an application, Angular mounts the
	         * specified application component onto DOM elements identified by the [componentType]'s
	         * selector and kicks off automatic change detection to finish initializing the component.
	         *
	         * ### Example
	         * {\@example core/ts/platform/platform.ts region='longform'}
	         * @abstract
	         * @param {?} componentFactory
	         * @return {?}
	         */
	        ApplicationRef.prototype.bootstrap = function (componentFactory) { };
	        /**
	         * Invoke this method to explicitly process change detection and its side-effects.
	         *
	         * In development mode, `tick()` also performs a second change detection cycle to ensure that no
	         * further changes are detected. If additional changes are picked up during this second cycle,
	         * bindings in the app have side-effects that cannot be resolved in a single change detection
	         * pass.
	         * In this case, Angular throws an error, since an Angular application can only have one change
	         * detection pass during which all change detection must complete.
	         * @abstract
	         * @return {?}
	         */
	        ApplicationRef.prototype.tick = function () { };
	        /**
	         * Get a list of component types registered to this application.
	         * This list is populated even before the component is created.
	         * @abstract
	         * @return {?}
	         */
	        ApplicationRef.prototype.componentTypes = function () { };
	        /**
	         * Get a list of components registered to this application.
	         * @abstract
	         * @return {?}
	         */
	        ApplicationRef.prototype.components = function () { };
	        /**
	         * Attaches a view so that it will be dirty checked.
	         * The view will be automatically detached when it is destroyed.
	         * This will throw if the view is already attached to a ViewContainer.
	         * @abstract
	         * @param {?} view
	         * @return {?}
	         */
	        ApplicationRef.prototype.attachView = function (view) { };
	        /**
	         * Detaches a view from dirty checking again.
	         * @abstract
	         * @param {?} view
	         * @return {?}
	         */
	        ApplicationRef.prototype.detachView = function (view) { };
	        /**
	         * Returns the number of attached views.
	         * @abstract
	         * @return {?}
	         */
	        ApplicationRef.prototype.viewCount = function () { };
	        return ApplicationRef;
	    }());
	    var ApplicationRef_ = (function (_super) {
	        __extends$3(ApplicationRef_, _super);
	        /**
	         * @param {?} _zone
	         * @param {?} _console
	         * @param {?} _injector
	         * @param {?} _exceptionHandler
	         * @param {?} _componentFactoryResolver
	         * @param {?} _initStatus
	         * @param {?} _testabilityRegistry
	         * @param {?} _testability
	         */
	        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
	            var _this = this;
	            _super.call(this);
	            this._zone = _zone;
	            this._console = _console;
	            this._injector = _injector;
	            this._exceptionHandler = _exceptionHandler;
	            this._componentFactoryResolver = _componentFactoryResolver;
	            this._initStatus = _initStatus;
	            this._testabilityRegistry = _testabilityRegistry;
	            this._testability = _testability;
	            this._bootstrapListeners = [];
	            this._rootComponents = [];
	            this._rootComponentTypes = [];
	            this._views = [];
	            this._runningTick = false;
	            this._enforceNoNewChanges = false;
	            this._enforceNoNewChanges = isDevMode();
	            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
	        }
	        /**
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype.attachView = function (viewRef) {
	            var /** @type {?} */ view = ((viewRef)).internalView;
	            this._views.push(view);
	            view.attachToAppRef(this);
	        };
	        /**
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype.detachView = function (viewRef) {
	            var /** @type {?} */ view = ((viewRef)).internalView;
	            ListWrapper.remove(this._views, view);
	            view.detach();
	        };
	        /**
	         * @param {?} componentOrFactory
	         * @return {?}
	         */
	        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
	            var _this = this;
	            if (!this._initStatus.done) {
	                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
	            }
	            var /** @type {?} */ componentFactory;
	            if (componentOrFactory instanceof ComponentFactory) {
	                componentFactory = componentOrFactory;
	            }
	            else {
	                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
	            }
	            this._rootComponentTypes.push(componentFactory.componentType);
	            var /** @type {?} */ compRef = componentFactory.create(this._injector, [], componentFactory.selector);
	            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	            var /** @type {?} */ testability = compRef.injector.get(Testability, null);
	            if (testability) {
	                compRef.injector.get(TestabilityRegistry)
	                    .registerApplication(compRef.location.nativeElement, testability);
	            }
	            this._loadComponent(compRef);
	            if (isDevMode()) {
	                this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
	            }
	            return compRef;
	        };
	        /**
	         * @param {?} componentRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype._loadComponent = function (componentRef) {
	            this.attachView(componentRef.hostView);
	            this.tick();
	            this._rootComponents.push(componentRef);
	            // Get the listeners lazily to prevent DI cycles.
	            var /** @type {?} */ listeners = (this._injector.get(APP_BOOTSTRAP_LISTENER, [])
	                .concat(this._bootstrapListeners));
	            listeners.forEach(function (listener) { return listener(componentRef); });
	        };
	        /**
	         * @param {?} componentRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	            this.detachView(componentRef.hostView);
	            ListWrapper.remove(this._rootComponents, componentRef);
	        };
	        /**
	         * @return {?}
	         */
	        ApplicationRef_.prototype.tick = function () {
	            if (this._runningTick) {
	                throw new Error('ApplicationRef.tick is called recursively');
	            }
	            var /** @type {?} */ scope = ApplicationRef_._tickScope();
	            try {
	                this._runningTick = true;
	                this._views.forEach(function (view) { return view.ref.detectChanges(); });
	                if (this._enforceNoNewChanges) {
	                    this._views.forEach(function (view) { return view.ref.checkNoChanges(); });
	                }
	            }
	            finally {
	                this._runningTick = false;
	                wtfLeave(scope);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        ApplicationRef_.prototype.ngOnDestroy = function () {
	            // TODO(alxhub): Dispose of the NgZone.
	            this._views.slice().forEach(function (view) { return view.destroy(); });
	        };
	        Object.defineProperty(ApplicationRef_.prototype, "viewCount", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._views.length; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._rootComponentTypes; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationRef_.prototype, "components", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._rootComponents; },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
	        ApplicationRef_.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ApplicationRef_.ctorParameters = function () { return [
	            { type: NgZone, },
	            { type: Console, },
	            { type: Injector, },
	            { type: ErrorHandler, },
	            { type: ComponentFactoryResolver, },
	            { type: ApplicationInitStatus, },
	            { type: TestabilityRegistry, decorators: [{ type: Optional },] },
	            { type: Testability, decorators: [{ type: Optional },] },
	        ]; };
	        return ApplicationRef_;
	    }(ApplicationRef));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
	     *
	     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	     * NgModule Instance.
	     *
	     * \@stable
	     * @abstract
	     */
	    var NgModuleRef = (function () {
	        function NgModuleRef() {
	        }
	        /**
	         * The injector that contains all of the providers of the NgModule.
	         * @abstract
	         * @return {?}
	         */
	        NgModuleRef.prototype.injector = function () { };
	        /**
	         * The ComponentFactoryResolver to get hold of the ComponentFactories
	         * declared in the `entryComponents` property of the module.
	         * @abstract
	         * @return {?}
	         */
	        NgModuleRef.prototype.componentFactoryResolver = function () { };
	        /**
	         * The NgModule instance.
	         * @abstract
	         * @return {?}
	         */
	        NgModuleRef.prototype.instance = function () { };
	        /**
	         * Destroys the module instance and all of the data structures associated with it.
	         * @abstract
	         * @return {?}
	         */
	        NgModuleRef.prototype.destroy = function () { };
	        /**
	         * Allows to register a callback that will be called when the module is destroyed.
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        NgModuleRef.prototype.onDestroy = function (callback) { };
	        return NgModuleRef;
	    }());
	    /**
	     * \@experimental
	     */
	    var NgModuleFactory = (function () {
	        /**
	         * @param {?} _injectorClass
	         * @param {?} _moduleType
	         */
	        function NgModuleFactory(_injectorClass, _moduleType) {
	            this._injectorClass = _injectorClass;
	            this._moduleType = _moduleType;
	        }
	        Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._moduleType; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} parentInjector
	         * @return {?}
	         */
	        NgModuleFactory.prototype.create = function (parentInjector) {
	            if (!parentInjector) {
	                parentInjector = Injector.NULL;
	            }
	            var /** @type {?} */ instance = new this._injectorClass(parentInjector);
	            instance.create();
	            return instance;
	        };
	        return NgModuleFactory;
	    }());
	    var /** @type {?} */ _UNDEFINED = new Object();
	    /**
	     * @abstract
	     */
	    var NgModuleInjector = (function (_super) {
	        __extends$9(NgModuleInjector, _super);
	        /**
	         * @param {?} parent
	         * @param {?} factories
	         * @param {?} bootstrapFactories
	         */
	        function NgModuleInjector(parent, factories, bootstrapFactories) {
	            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));
	            this.parent = parent;
	            this.bootstrapFactories = bootstrapFactories;
	            this._destroyListeners = [];
	            this._destroyed = false;
	        }
	        /**
	         * @return {?}
	         */
	        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        NgModuleInjector.prototype.createInternal = function () { };
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        NgModuleInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            if (token === Injector || token === ComponentFactoryResolver) {
	                return this;
	            }
	            var /** @type {?} */ result = this.getInternal(token, _UNDEFINED);
	            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
	        };
	        /**
	         * @abstract
	         * @param {?} token
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        NgModuleInjector.prototype.getInternal = function (token, notFoundValue) { };
	        Object.defineProperty(NgModuleInjector.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgModuleInjector.prototype.destroy = function () {
	            if (this._destroyed) {
	                throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
	            }
	            this._destroyed = true;
	            this.destroyInternal();
	            this._destroyListeners.forEach(function (listener) { return listener(); });
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        NgModuleInjector.prototype.destroyInternal = function () { };
	        return NgModuleInjector;
	    }(CodegenComponentFactoryResolver));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Used to load ng module factories.
	     * \@stable
	     * @abstract
	     */
	    var NgModuleFactoryLoader = (function () {
	        function NgModuleFactoryLoader() {
	        }
	        /**
	         * @abstract
	         * @param {?} path
	         * @return {?}
	         */
	        NgModuleFactoryLoader.prototype.load = function (path) { };
	        return NgModuleFactoryLoader;
	    }());
	    var /** @type {?} */ moduleFactories = new Map();
	    /**
	     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
	     * \@experimental
	     * @param {?} id
	     * @param {?} factory
	     * @return {?}
	     */
	    function registerModuleFactory(id, factory) {
	        var /** @type {?} */ existing = moduleFactories.get(id);
	        if (existing) {
	            throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
	        }
	        moduleFactories.set(id, factory);
	    }
	    /**
	     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
	     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
	     * cannot be found.
	     * \@experimental
	     * @param {?} id
	     * @return {?}
	     */
	    function getModuleFactory(id) {
	        var /** @type {?} */ factory = moduleFactories.get(id);
	        if (!factory)
	            throw new Error("No module with ID " + id + " loaded");
	        return factory;
	    }

	    /**
	     * An unmodifiable list of items that Angular keeps up to date when the state
	     * of the application changes.
	     *
	     * The type of object that {\@link Query} and {\@link ViewQueryMetadata} provide.
	     *
	     * Implements an iterable interface, therefore it can be used in both ES6
	     * javascript `for (var i of items)` loops as well as in Angular templates with
	     * `*ngFor="let i of myList"`.
	     *
	     * Changes can be observed by subscribing to the changes `Observable`.
	     *
	     * NOTE: In the future this class will implement an `Observable` interface.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	     * ```typescript
	     * \@Component({...})
	     * class Container {
	     *   \@ViewChildren(Item) items:QueryList<Item>;
	     * }
	     * ```
	     * \@stable
	     */
	    var QueryList = (function () {
	        function QueryList() {
	            this._dirty = true;
	            this._results = [];
	            this._emitter = new EventEmitter();
	        }
	        Object.defineProperty(QueryList.prototype, "changes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._emitter; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "length", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._results.length; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "first", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._results[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "last", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._results[this.length - 1]; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * See
	         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	        /**
	         * See
	         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.filter = function (fn) {
	            return this._results.filter(fn);
	        };
	        /**
	         * See
	         * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.find = function (fn) { return this._results.find(fn); };
	        /**
	         * See
	         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	         * @param {?} fn
	         * @param {?} init
	         * @return {?}
	         */
	        QueryList.prototype.reduce = function (fn, init) {
	            return this._results.reduce(fn, init);
	        };
	        /**
	         * See
	         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	        /**
	         * See
	         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.some = function (fn) {
	            return this._results.some(fn);
	        };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype.toArray = function () { return this._results.slice(); };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype[getSymbolIterator()] = function () { return ((this._results))[getSymbolIterator()](); };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype.toString = function () { return this._results.toString(); };
	        /**
	         * @param {?} res
	         * @return {?}
	         */
	        QueryList.prototype.reset = function (res) {
	            this._results = ListWrapper.flatten(res);
	            this._dirty = false;
	        };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	        /**
	         * internal
	         * @return {?}
	         */
	        QueryList.prototype.setDirty = function () { this._dirty = true; };
	        Object.defineProperty(QueryList.prototype, "dirty", {
	            /**
	             * internal
	             * @return {?}
	             */
	            get: function () { return this._dirty; },
	            enumerable: true,
	            configurable: true
	        });
	        return QueryList;
	    }());

	    var /** @type {?} */ _SEPARATOR = '#';
	    var /** @type {?} */ FACTORY_CLASS_SUFFIX = 'NgFactory';
	    /**
	     * Configuration for SystemJsNgModuleLoader.
	     * token.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var SystemJsNgModuleLoaderConfig = (function () {
	        function SystemJsNgModuleLoaderConfig() {
	        }
	        return SystemJsNgModuleLoaderConfig;
	    }());
	    var /** @type {?} */ DEFAULT_CONFIG = {
	        factoryPathPrefix: '',
	        factoryPathSuffix: '.ngfactory',
	    };
	    /**
	     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
	     * \@experimental
	     */
	    var SystemJsNgModuleLoader = (function () {
	        /**
	         * @param {?} _compiler
	         * @param {?=} config
	         */
	        function SystemJsNgModuleLoader(_compiler, config) {
	            this._compiler = _compiler;
	            this._config = config || DEFAULT_CONFIG;
	        }
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        SystemJsNgModuleLoader.prototype.load = function (path) {
	            var /** @type {?} */ offlineMode = this._compiler instanceof Compiler;
	            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
	        };
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
	            var _this = this;
	            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	            if (exportName === undefined) {
	                exportName = 'default';
	            }
	            return System.import(module)
	                .then(function (module) { return module[exportName]; })
	                .then(function (type) { return checkNotEmpty(type, module, exportName); })
	                .then(function (type) { return _this._compiler.compileModuleAsync(type); });
	        };
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
	            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	            var /** @type {?} */ factoryClassSuffix = FACTORY_CLASS_SUFFIX;
	            if (exportName === undefined) {
	                exportName = 'default';
	                factoryClassSuffix = '';
	            }
	            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
	                .then(function (module) { return module[exportName + factoryClassSuffix]; })
	                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
	        };
	        SystemJsNgModuleLoader.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        SystemJsNgModuleLoader.ctorParameters = function () { return [
	            { type: Compiler, },
	            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
	        ]; };
	        return SystemJsNgModuleLoader;
	    }());
	    /**
	     * @param {?} value
	     * @param {?} modulePath
	     * @param {?} exportName
	     * @return {?}
	     */
	    function checkNotEmpty(value, modulePath, exportName) {
	        if (!value) {
	            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
	        }
	        return value;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an Embedded Template that can be used to instantiate Embedded Views.
	     *
	     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
	     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
	     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
	     * `TemplateRef` from a Component or a Directive via {\@link Query}.
	     *
	     * To instantiate Embedded Views based on a Template, use
	     * {\@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	     * View Container.
	     * \@stable
	     * @abstract
	     */
	    var TemplateRef = (function () {
	        function TemplateRef() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        TemplateRef.prototype.elementRef = function () { };
	        /**
	         * @abstract
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateRef.prototype.createEmbeddedView = function (context) { };
	        return TemplateRef;
	    }());
	    var TemplateRef_ = (function (_super) {
	        __extends$10(TemplateRef_, _super);
	        /**
	         * @param {?} _parentView
	         * @param {?} _nodeIndex
	         * @param {?} _nativeElement
	         */
	        function TemplateRef_(_parentView, _nodeIndex, _nativeElement) {
	            _super.call(this);
	            this._parentView = _parentView;
	            this._nodeIndex = _nodeIndex;
	            this._nativeElement = _nativeElement;
	        }
	        /**
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateRef_.prototype.createEmbeddedView = function (context) {
	            var /** @type {?} */ view = this._parentView.createEmbeddedViewInternal(this._nodeIndex);
	            view.create(context || ({}));
	            return view.ref;
	        };
	        Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ElementRef(this._nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        return TemplateRef_;
	    }(TemplateRef));

	    /**
	     * Represents a container where one or more Views can be attached.
	     *
	     * The container can contain two kinds of Views. Host Views, created by instantiating a
	     * {\@link Component} via {\@link #createComponent}, and Embedded Views, created by instantiating an
	     * {\@link TemplateRef Embedded Template} via {\@link #createEmbeddedView}.
	     *
	     * The location of the View Container within the containing View is specified by the Anchor
	     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	     * have a single View Container.
	     *
	     * Root elements of Views attached to this container become siblings of the Anchor Element in
	     * the Rendered View.
	     *
	     * To access a `ViewContainerRef` of an Element, you can either place a {\@link Directive} injected
	     * with `ViewContainerRef` on the Element, or you obtain it via a {\@link ViewChild} query.
	     * \@stable
	     * @abstract
	     */
	    var ViewContainerRef = (function () {
	        function ViewContainerRef() {
	        }
	        /**
	         * Anchor element that specifies the location of this container in the containing View.
	         * <!-- TODO: rename to anchorElement -->
	         * @abstract
	         * @return {?}
	         */
	        ViewContainerRef.prototype.element = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        ViewContainerRef.prototype.injector = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        ViewContainerRef.prototype.parentInjector = function () { };
	        /**
	         * Destroys all Views in this container.
	         * @abstract
	         * @return {?}
	         */
	        ViewContainerRef.prototype.clear = function () { };
	        /**
	         * Returns the {\@link ViewRef} for the View located in this container at the specified index.
	         * @abstract
	         * @param {?} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.get = function (index) { };
	        /**
	         * Returns the number of Views currently attached to this container.
	         * @abstract
	         * @return {?}
	         */
	        ViewContainerRef.prototype.length = function () { };
	        /**
	         * Instantiates an Embedded View based on the {\@link TemplateRef `templateRef`} and inserts it
	         * into this container at the specified `index`.
	         *
	         * If `index` is not specified, the new View will be inserted as the last View in the container.
	         *
	         * Returns the {\@link ViewRef} for the newly created View.
	         * @abstract
	         * @param {?} templateRef
	         * @param {?=} context
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.createEmbeddedView = function (templateRef, context, index) { };
	        /**
	         * Instantiates a single {\@link Component} and inserts its Host View into this container at the
	         * specified `index`.
	         *
	         * The component is instantiated using its {\@link ComponentFactory} which can be
	         * obtained via {\@link ComponentFactoryResolver#resolveComponentFactory}.
	         *
	         * If `index` is not specified, the new View will be inserted as the last View in the container.
	         *
	         * You can optionally specify the {\@link Injector} that will be used as parent for the Component.
	         *
	         * Returns the {\@link ComponentRef} of the Host View created for the newly instantiated Component.
	         * @abstract
	         * @param {?} componentFactory
	         * @param {?=} index
	         * @param {?=} injector
	         * @param {?=} projectableNodes
	         * @return {?}
	         */
	        ViewContainerRef.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) { };
	        /**
	         * Inserts a View identified by a {\@link ViewRef} into the container at the specified `index`.
	         *
	         * If `index` is not specified, the new View will be inserted as the last View in the container.
	         *
	         * Returns the inserted {\@link ViewRef}.
	         * @abstract
	         * @param {?} viewRef
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.insert = function (viewRef, index) { };
	        /**
	         * Moves a View identified by a {\@link ViewRef} into the container at the specified `index`.
	         *
	         * Returns the inserted {\@link ViewRef}.
	         * @abstract
	         * @param {?} viewRef
	         * @param {?} currentIndex
	         * @return {?}
	         */
	        ViewContainerRef.prototype.move = function (viewRef, currentIndex) { };
	        /**
	         * Returns the index of the View, specified via {\@link ViewRef}, within the current container or
	         * `-1` if this container doesn't contain the View.
	         * @abstract
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ViewContainerRef.prototype.indexOf = function (viewRef) { };
	        /**
	         * Destroys a View attached to this container at the specified `index`.
	         *
	         * If `index` is not specified, the last View in the container will be removed.
	         * @abstract
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.remove = function (index) { };
	        /**
	         * Use along with {\@link #insert} to move a View within the current container.
	         *
	         * If the `index` param is omitted, the last {\@link ViewRef} is detached.
	         * @abstract
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.detach = function (index) { };
	        return ViewContainerRef;
	    }());
	    var ViewContainerRef_ = (function () {
	        /**
	         * @param {?} _element
	         */
	        function ViewContainerRef_(_element) {
	            this._element = _element;
	            /** @internal */
	            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
	            /** @internal */
	            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
	            /** @internal */
	            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
	            /** @internal */
	            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
	        Object.defineProperty(ViewContainerRef_.prototype, "length", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ views = this._element.nestedViews;
	                return isPresent(views) ? views.length : 0;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "element", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._element.elementRef; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._element.injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._element.parentInjector; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} templateRef
	         * @param {?=} context
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	            if (context === void 0) { context = null; }
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ viewRef = templateRef.createEmbeddedView(context);
	            this.insert(viewRef, index);
	            return viewRef;
	        };
	        /**
	         * @param {?} componentFactory
	         * @param {?=} index
	         * @param {?=} injector
	         * @param {?=} projectableNodes
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
	            if (index === void 0) { index = -1; }
	            if (injector === void 0) { injector = null; }
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            var /** @type {?} */ s = this._createComponentInContainerScope();
	            var /** @type {?} */ contextInjector = injector || this._element.parentInjector;
	            var /** @type {?} */ componentRef = componentFactory.create(contextInjector, projectableNodes);
	            this.insert(componentRef.hostView, index);
	            return wtfLeave(s, componentRef);
	        };
	        /**
	         * @param {?} viewRef
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.insert = function (viewRef, index) {
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ s = this._insertScope();
	            if (index == -1)
	                index = this.length;
	            var /** @type {?} */ viewRef_ = (viewRef);
	            this._element.attachView(viewRef_.internalView, index);
	            return wtfLeave(s, viewRef_);
	        };
	        /**
	         * @param {?} viewRef
	         * @param {?} currentIndex
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
	            var /** @type {?} */ s = this._insertScope();
	            if (currentIndex == -1)
	                return;
	            var /** @type {?} */ viewRef_ = (viewRef);
	            this._element.moveView(viewRef_.internalView, currentIndex);
	            return wtfLeave(s, viewRef_);
	        };
	        /**
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.indexOf = function (viewRef) {
	            return this.length ? this._element.nestedViews.indexOf(((viewRef)).internalView) :
	                -1;
	        };
	        /**
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.remove = function (index) {
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ s = this._removeScope();
	            if (index == -1)
	                index = this.length - 1;
	            var /** @type {?} */ view = this._element.detachView(index);
	            view.destroy();
	            // view is intentionally not returned to the client.
	            wtfLeave(s);
	        };
	        /**
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.detach = function (index) {
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ s = this._detachScope();
	            if (index == -1)
	                index = this.length - 1;
	            var /** @type {?} */ view = this._element.detachView(index);
	            return wtfLeave(s, view.ref);
	        };
	        /**
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.clear = function () {
	            for (var /** @type {?} */ i = this.length - 1; i >= 0; i--) {
	                this.remove(i);
	            }
	        };
	        return ViewContainerRef_;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     * @abstract
	     */
	    var ViewRef = (function (_super) {
	        __extends$11(ViewRef, _super);
	        function ViewRef() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * Destroys the view and all of the data structures associated with it.
	         * @abstract
	         * @return {?}
	         */
	        ViewRef.prototype.destroy = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        ViewRef.prototype.destroyed = function () { };
	        /**
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        ViewRef.prototype.onDestroy = function (callback) { };
	        return ViewRef;
	    }(ChangeDetectorRef));
	    /**
	     * Represents an Angular View.
	     *
	     * <!-- TODO: move the next two paragraphs to the dev guide -->
	     * A View is a fundamental building block of the application UI. It is the smallest grouping of
	     * Elements which are created and destroyed together.
	     *
	     * Properties of elements in a View can change, but the structure (number and order) of elements in
	     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	     * removing nested Views via a {\@link ViewContainerRef}. Each View can contain many View Containers.
	     * <!-- /TODO -->
	     *
	     * ### Example
	     *
	     * Given this template...
	     *
	     * ```
	     * Count: {{items.length}}
	     * <ul>
	     *   <li *ngFor="let  item of items">{{item}}</li>
	     * </ul>
	     * ```
	     *
	     * We have two {\@link TemplateRef}s:
	     *
	     * Outer {\@link TemplateRef}:
	     * ```
	     * Count: {{items.length}}
	     * <ul>
	     *   <template ngFor let-item [ngForOf]="items"></template>
	     * </ul>
	     * ```
	     *
	     * Inner {\@link TemplateRef}:
	     * ```
	     *   <li>{{item}}</li>
	     * ```
	     *
	     * Notice that the original template is broken down into two separate {\@link TemplateRef}s.
	     *
	     * The outer/inner {\@link TemplateRef}s are then assembled into views like so:
	     *
	     * ```
	     * <!-- ViewRef: outer-0 -->
	     * Count: 2
	     * <ul>
	     *   <template view-container-ref></template>
	     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	     * </ul>
	     * <!-- /ViewRef: outer-0 -->
	     * ```
	     * \@experimental
	     * @abstract
	     */
	    var EmbeddedViewRef = (function (_super) {
	        __extends$11(EmbeddedViewRef, _super);
	        function EmbeddedViewRef() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        EmbeddedViewRef.prototype.context = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        EmbeddedViewRef.prototype.rootNodes = function () { };
	        return EmbeddedViewRef;
	    }(ViewRef));
	    var ViewRef_ = (function () {
	        /**
	         * @param {?} _view
	         * @param {?} animationQueue
	         */
	        function ViewRef_(_view, animationQueue) {
	            this._view = _view;
	            this.animationQueue = animationQueue;
	            this._view = _view;
	            this._originalMode = this._view.cdMode;
	        }
	        Object.defineProperty(ViewRef_.prototype, "internalView", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.flatRootNodes; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.detectChanges = function () {
	            this._view.detectChanges(false);
	            this.animationQueue.flush();
	        };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.reattach = function () {
	            this._view.cdMode = this._originalMode;
	            this.markForCheck();
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        ViewRef_.prototype.onDestroy = function (callback) {
	            if (!this._view.disposables) {
	                this._view.disposables = [];
	            }
	            this._view.disposables.push(callback);
	        };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.destroy = function () { this._view.detachAndDestroy(); };
	        return ViewRef_;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var EventListener = (function () {
	        /**
	         * @param {?} name
	         * @param {?} callback
	         */
	        function EventListener(name, callback) {
	            this.name = name;
	            this.callback = callback;
	        }
	        ;
	        return EventListener;
	    }());
	    /**
	     * \@experimental All debugging apis are currently experimental.
	     */
	    var DebugNode = (function () {
	        /**
	         * @param {?} nativeNode
	         * @param {?} parent
	         * @param {?} _debugInfo
	         */
	        function DebugNode(nativeNode, parent, _debugInfo) {
	            this._debugInfo = _debugInfo;
	            this.nativeNode = nativeNode;
	            if (parent && parent instanceof DebugElement) {
	                parent.addChild(this);
	            }
	            else {
	                this.parent = null;
	            }
	            this.listeners = [];
	        }
	        Object.defineProperty(DebugNode.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.injector : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "componentInstance", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.component : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.context : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "references", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._debugInfo ? this._debugInfo.references : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "providerTokens", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.providerTokens : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "source", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.source : null; },
	            enumerable: true,
	            configurable: true
	        });
	        return DebugNode;
	    }());
	    /**
	     * \@experimental All debugging apis are currently experimental.
	     */
	    var DebugElement = (function (_super) {
	        __extends$12(DebugElement, _super);
	        /**
	         * @param {?} nativeNode
	         * @param {?} parent
	         * @param {?} _debugInfo
	         */
	        function DebugElement(nativeNode, parent, _debugInfo) {
	            _super.call(this, nativeNode, parent, _debugInfo);
	            this.properties = {};
	            this.attributes = {};
	            this.classes = {};
	            this.styles = {};
	            this.childNodes = [];
	            this.nativeElement = nativeNode;
	        }
	        /**
	         * @param {?} child
	         * @return {?}
	         */
	        DebugElement.prototype.addChild = function (child) {
	            if (child) {
	                this.childNodes.push(child);
	                child.parent = this;
	            }
	        };
	        /**
	         * @param {?} child
	         * @return {?}
	         */
	        DebugElement.prototype.removeChild = function (child) {
	            var /** @type {?} */ childIndex = this.childNodes.indexOf(child);
	            if (childIndex !== -1) {
	                child.parent = null;
	                this.childNodes.splice(childIndex, 1);
	            }
	        };
	        /**
	         * @param {?} child
	         * @param {?} newChildren
	         * @return {?}
	         */
	        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	            var /** @type {?} */ siblingIndex = this.childNodes.indexOf(child);
	            if (siblingIndex !== -1) {
	                var /** @type {?} */ previousChildren = this.childNodes.slice(0, siblingIndex + 1);
	                var /** @type {?} */ nextChildren = this.childNodes.slice(siblingIndex + 1);
	                this.childNodes = previousChildren.concat(newChildren, nextChildren);
	                for (var /** @type {?} */ i = 0; i < newChildren.length; ++i) {
	                    var /** @type {?} */ newChild = newChildren[i];
	                    if (newChild.parent) {
	                        newChild.parent.removeChild(newChild);
	                    }
	                    newChild.parent = this;
	                }
	            }
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        DebugElement.prototype.query = function (predicate) {
	            var /** @type {?} */ results = this.queryAll(predicate);
	            return results[0] || null;
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        DebugElement.prototype.queryAll = function (predicate) {
	            var /** @type {?} */ matches = [];
	            _queryElementChildren(this, predicate, matches);
	            return matches;
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        DebugElement.prototype.queryAllNodes = function (predicate) {
	            var /** @type {?} */ matches = [];
	            _queryNodeChildren(this, predicate, matches);
	            return matches;
	        };
	        Object.defineProperty(DebugElement.prototype, "children", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (this.childNodes.filter(function (node) { return node instanceof DebugElement; }));
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} eventName
	         * @param {?} eventObj
	         * @return {?}
	         */
	        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	            this.listeners.forEach(function (listener) {
	                if (listener.name == eventName) {
	                    listener.callback(eventObj);
	                }
	            });
	        };
	        return DebugElement;
	    }(DebugNode));
	    /**
	     * \@experimental
	     * @param {?} debugEls
	     * @return {?}
	     */
	    function asNativeElements(debugEls) {
	        return debugEls.map(function (el) { return el.nativeElement; });
	    }
	    /**
	     * @param {?} element
	     * @param {?} predicate
	     * @param {?} matches
	     * @return {?}
	     */
	    function _queryElementChildren(element, predicate, matches) {
	        element.childNodes.forEach(function (node) {
	            if (node instanceof DebugElement) {
	                if (predicate(node)) {
	                    matches.push(node);
	                }
	                _queryElementChildren(node, predicate, matches);
	            }
	        });
	    }
	    /**
	     * @param {?} parentNode
	     * @param {?} predicate
	     * @param {?} matches
	     * @return {?}
	     */
	    function _queryNodeChildren(parentNode, predicate, matches) {
	        if (parentNode instanceof DebugElement) {
	            parentNode.childNodes.forEach(function (node) {
	                if (predicate(node)) {
	                    matches.push(node);
	                }
	                if (node instanceof DebugElement) {
	                    _queryNodeChildren(node, predicate, matches);
	                }
	            });
	        }
	    }
	    // Need to keep the nodes in a global Map so that multiple angular apps are supported.
	    var /** @type {?} */ _nativeNodeToDebugNode = new Map();
	    /**
	     * \@experimental
	     * @param {?} nativeNode
	     * @return {?}
	     */
	    function getDebugNode(nativeNode) {
	        return _nativeNodeToDebugNode.get(nativeNode);
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function indexDebugNode(node) {
	        _nativeNodeToDebugNode.set(node.nativeNode, node);
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function removeDebugNodeFromIndex(node) {
	        _nativeNodeToDebugNode.delete(node.nativeNode);
	    }

	    /**
	     * @return {?}
	     */
	    function _reflector() {
	        return reflector;
	    }
	    var /** @type {?} */ _CORE_PLATFORM_PROVIDERS = [
	        PlatformRef_,
	        { provide: PlatformRef, useExisting: PlatformRef_ },
	        { provide: Reflector, useFactory: _reflector, deps: [] },
	        { provide: ReflectorReader, useExisting: Reflector },
	        TestabilityRegistry,
	        Console,
	    ];
	    /**
	     * This platform has to be included in any other platform
	     *
	     * @experimental
	     */
	    var /** @type {?} */ platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

	    /**
	     * @experimental i18n support is experimental.
	     */
	    var /** @type {?} */ LOCALE_ID = new OpaqueToken('LocaleId');
	    /**
	     * @experimental i18n support is experimental.
	     */
	    var /** @type {?} */ TRANSLATIONS = new OpaqueToken('Translations');
	    /**
	     * @experimental i18n support is experimental.
	     */
	    var /** @type {?} */ TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');

	    /**
	     * @return {?}
	     */
	    function _iterableDiffersFactory() {
	        return defaultIterableDiffers;
	    }
	    /**
	     * @return {?}
	     */
	    function _keyValueDiffersFactory() {
	        return defaultKeyValueDiffers;
	    }
	    /**
	     * @param {?=} locale
	     * @return {?}
	     */
	    function _localeFactory(locale) {
	        return locale || 'en-US';
	    }
	    /**
	     * This module includes the providers of \@angular/core that are needed
	     * to bootstrap components via `ApplicationRef`.
	     *
	     * \@experimental
	     */
	    var ApplicationModule = (function () {
	        function ApplicationModule() {
	        }
	        ApplicationModule.decorators = [
	            { type: NgModule, args: [{
	                        providers: [
	                            ApplicationRef_,
	                            { provide: ApplicationRef, useExisting: ApplicationRef_ },
	                            ApplicationInitStatus,
	                            Compiler,
	                            APP_ID_RANDOM_PROVIDER,
	                            ViewUtils,
	                            AnimationQueue,
	                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
	                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
	                            {
	                                provide: LOCALE_ID,
	                                useFactory: _localeFactory,
	                                deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
	                            },
	                        ]
	                    },] },
	        ];
	        /** @nocollapse */
	        ApplicationModule.ctorParameters = function () { return []; };
	        return ApplicationModule;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
	    var /** @type {?} */ ANY_STATE = '*';
	    var /** @type {?} */ DEFAULT_STATE = '*';
	    var /** @type {?} */ EMPTY_STATE = 'void';

	    var AnimationGroupPlayer = (function () {
	        /**
	         * @param {?} _players
	         */
	        function AnimationGroupPlayer(_players) {
	            var _this = this;
	            this._players = _players;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._started = false;
	            this._destroyed = false;
	            this.parentPlayer = null;
	            var count = 0;
	            var total = this._players.length;
	            if (total == 0) {
	                scheduleMicroTask(function () { return _this._onFinish(); });
	            }
	            else {
	                this._players.forEach(function (player) {
	                    player.parentPlayer = _this;
	                    player.onDone(function () {
	                        if (++count >= total) {
	                            _this._onFinish();
	                        }
	                    });
	                });
	            }
	        }
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.play = function () {
	            if (!isPresent(this.parentPlayer)) {
	                this.init();
	            }
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._players.forEach(function (player) { return player.play(); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.finish = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.finish(); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.destroy = function () {
	            if (!this._destroyed) {
	                this._onFinish();
	                this._players.forEach(function (player) { return player.destroy(); });
	                this._destroyed = true;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.reset = function () {
	            this._players.forEach(function (player) { return player.reset(); });
	            this._destroyed = false;
	            this._finished = false;
	            this._started = false;
	        };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.setPosition = function (p) {
	            this._players.forEach(function (player) { player.setPosition(p); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.getPosition = function () {
	            var /** @type {?} */ min = 0;
	            this._players.forEach(function (player) {
	                var /** @type {?} */ p = player.getPosition();
	                min = Math.min(p, min);
	            });
	            return min;
	        };
	        Object.defineProperty(AnimationGroupPlayer.prototype, "players", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._players; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationGroupPlayer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * `AnimationKeyframe` consists of a series of styles (contained within {\@link AnimationStyles
	     * `AnimationStyles`})
	     * and an offset value indicating when those styles are applied within the `duration/delay/easing`
	     * timings.
	     * `AnimationKeyframe` is mostly an internal class which is designed to be used alongside {\@link
	     * Renderer#animate-anchor `Renderer.animate`}.
	     *
	     * \@experimental Animation support is experimental
	     */
	    var AnimationKeyframe = (function () {
	        /**
	         * @param {?} offset
	         * @param {?} styles
	         */
	        function AnimationKeyframe(offset, styles) {
	            this.offset = offset;
	            this.styles = styles;
	        }
	        return AnimationKeyframe;
	    }());

	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationPlayer = (function () {
	        function AnimationPlayer() {
	        }
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationPlayer.prototype.onDone = function (fn) { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationPlayer.prototype.onStart = function (fn) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.init = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.hasStarted = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.play = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.pause = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.restart = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.finish = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.destroy = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.reset = function () { };
	        /**
	         * @abstract
	         * @param {?} p
	         * @return {?}
	         */
	        AnimationPlayer.prototype.setPosition = function (p) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.getPosition = function () { };
	        Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            /**
	             * @param {?} player
	             * @return {?}
	             */
	            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationPlayer;
	    }());
	    var NoOpAnimationPlayer = (function () {
	        function NoOpAnimationPlayer() {
	            var _this = this;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._started = false;
	            this.parentPlayer = null;
	            scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype._onFinish = function () {
	            this._onDoneFns.forEach(function (fn) { return fn(); });
	            this._onDoneFns = [];
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.init = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.play = function () {
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	            }
	            this._started = true;
	        };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.pause = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.restart = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.destroy = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.reset = function () { };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.setPosition = function (p) { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
	        return NoOpAnimationPlayer;
	    }());

	    var AnimationSequencePlayer = (function () {
	        /**
	         * @param {?} _players
	         */
	        function AnimationSequencePlayer(_players) {
	            var _this = this;
	            this._players = _players;
	            this._currentIndex = 0;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._started = false;
	            this._destroyed = false;
	            this.parentPlayer = null;
	            this._players.forEach(function (player) { player.parentPlayer = _this; });
	            this._onNext(false);
	        }
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype._onNext = function (start) {
	            var _this = this;
	            if (this._finished)
	                return;
	            if (this._players.length == 0) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                scheduleMicroTask(function () { return _this._onFinish(); });
	            }
	            else if (this._currentIndex >= this._players.length) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                this._onFinish();
	            }
	            else {
	                var /** @type {?} */ player = this._players[this._currentIndex++];
	                player.onDone(function () { return _this._onNext(true); });
	                this._activePlayer = player;
	                if (start) {
	                    player.play();
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.play = function () {
	            if (!isPresent(this.parentPlayer)) {
	                this.init();
	            }
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._activePlayer.play();
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.restart = function () {
	            this.reset();
	            if (this._players.length > 0) {
	                this._players[0].restart();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.reset = function () {
	            this._players.forEach(function (player) { return player.reset(); });
	            this._destroyed = false;
	            this._finished = false;
	            this._started = false;
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.finish = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.finish(); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.destroy = function () {
	            if (!this._destroyed) {
	                this._onFinish();
	                this._players.forEach(function (player) { return player.destroy(); });
	                this._destroyed = true;
	                this._activePlayer = new NoOpAnimationPlayer();
	            }
	        };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.setPosition = function (p) { this._players[0].setPosition(p); };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
	        Object.defineProperty(AnimationSequencePlayer.prototype, "players", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._players; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationSequencePlayer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @experimental Animation support is experimental.
	     */
	    var /** @type {?} */ AUTO_STYLE = '*';
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link trigger trigger
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationEntryMetadata = (function () {
	        /**
	         * @param {?} name
	         * @param {?} definitions
	         */
	        function AnimationEntryMetadata(name, definitions) {
	            this.name = name;
	            this.definitions = definitions;
	        }
	        return AnimationEntryMetadata;
	    }());
	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationStateMetadata = (function () {
	        function AnimationStateMetadata() {
	        }
	        return AnimationStateMetadata;
	    }());
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link state state animation
	     * function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationStateDeclarationMetadata = (function (_super) {
	        __extends$13(AnimationStateDeclarationMetadata, _super);
	        /**
	         * @param {?} stateNameExpr
	         * @param {?} styles
	         */
	        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
	            _super.call(this);
	            this.stateNameExpr = stateNameExpr;
	            this.styles = styles;
	        }
	        return AnimationStateDeclarationMetadata;
	    }(AnimationStateMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the
	     * {\@link transition transition animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationStateTransitionMetadata = (function (_super) {
	        __extends$13(AnimationStateTransitionMetadata, _super);
	        /**
	         * @param {?} stateChangeExpr
	         * @param {?} steps
	         */
	        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
	            _super.call(this);
	            this.stateChangeExpr = stateChangeExpr;
	            this.steps = steps;
	        }
	        return AnimationStateTransitionMetadata;
	    }(AnimationStateMetadata));
	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationMetadata = (function () {
	        function AnimationMetadata() {
	        }
	        return AnimationMetadata;
	    }());
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link keyframes keyframes
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationKeyframesSequenceMetadata = (function (_super) {
	        __extends$13(AnimationKeyframesSequenceMetadata, _super);
	        /**
	         * @param {?} steps
	         */
	        function AnimationKeyframesSequenceMetadata(steps) {
	            _super.call(this);
	            this.steps = steps;
	        }
	        return AnimationKeyframesSequenceMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link style style animation
	     * function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationStyleMetadata = (function (_super) {
	        __extends$13(AnimationStyleMetadata, _super);
	        /**
	         * @param {?} styles
	         * @param {?=} offset
	         */
	        function AnimationStyleMetadata(styles, offset) {
	            if (offset === void 0) { offset = null; }
	            _super.call(this);
	            this.styles = styles;
	            this.offset = offset;
	        }
	        return AnimationStyleMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link animate animate
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationAnimateMetadata = (function (_super) {
	        __extends$13(AnimationAnimateMetadata, _super);
	        /**
	         * @param {?} timings
	         * @param {?} styles
	         */
	        function AnimationAnimateMetadata(timings, styles) {
	            _super.call(this);
	            this.timings = timings;
	            this.styles = styles;
	        }
	        return AnimationAnimateMetadata;
	    }(AnimationMetadata));
	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationWithStepsMetadata = (function (_super) {
	        __extends$13(AnimationWithStepsMetadata, _super);
	        function AnimationWithStepsMetadata() {
	            _super.call(this);
	        }
	        Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationWithStepsMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link sequence sequence
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationSequenceMetadata = (function (_super) {
	        __extends$13(AnimationSequenceMetadata, _super);
	        /**
	         * @param {?} _steps
	         */
	        function AnimationSequenceMetadata(_steps) {
	            _super.call(this);
	            this._steps = _steps;
	        }
	        Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._steps; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationSequenceMetadata;
	    }(AnimationWithStepsMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link group group animation
	     * function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationGroupMetadata = (function (_super) {
	        __extends$13(AnimationGroupMetadata, _super);
	        /**
	         * @param {?} _steps
	         */
	        function AnimationGroupMetadata(_steps) {
	            _super.call(this);
	            this._steps = _steps;
	        }
	        Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._steps; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationGroupMetadata;
	    }(AnimationWithStepsMetadata));
	    /**
	     * `animate` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `animate` specifies an animation step that will apply the provided `styles` data for a given
	     * amount of
	     * time based on the provided `timing` expression value. Calls to `animate` are expected to be
	     * used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link transition
	     * transition}.
	     *
	     * ### Usage
	     *
	     * The `animate` function accepts two input parameters: `timing` and `styles`:
	     *
	     * - `timing` is a string based value that can be a combination of a duration with optional
	     * delay and easing values. The format for the expression breaks down to `duration delay easing`
	     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	     * delay=100, easing=ease-out`.
	     * If a numeric value is provided then that will be used as the `duration` value in millisecond
	     * form.
	     * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
	     * keyframes keyframes}.
	     * If left empty then the styles from the destination state will be collected and used (this is
	     * useful when
	     * describing an animation step that will complete an animation by {\@link
	     * transition#the-final-animate-call animating to the final state}).
	     *
	     * ```typescript
	     * // various functions for specifying timing data
	     * animate(500, style(...))
	     * animate("1s", style(...))
	     * animate("100ms 0.5s", style(...))
	     * animate("5s ease", style(...))
	     * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	     *
	     * // either style() of keyframes() can be used
	     * animate(500, style({ background: "red" }))
	     * animate(500, keyframes([
	     *   style({ background: "blue" })),
	     *   style({ background: "red" }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} timing
	     * @param {?=} styles
	     * @return {?}
	     */
	    function animate(timing, styles) {
	        if (styles === void 0) { styles = null; }
	        var /** @type {?} */ stylesEntry = styles;
	        if (!isPresent(stylesEntry)) {
	            var /** @type {?} */ EMPTY_STYLE = {};
	            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
	        }
	        return new AnimationAnimateMetadata(timing, stylesEntry);
	    }
	    /**
	     * `group` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
	     * are useful when a series of styles must be animated/closed off
	     * at different statrting/ending times.
	     *
	     * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
	     * transition}
	     * and it will only continue to the next instruction once all of the inner animation steps
	     * have completed.
	     *
	     * ### Usage
	     *
	     * The `steps` data that is passed into the `group` animation function can either consist
	     * of {\@link style style} or {\@link animate animate} function calls. Each call to `style()` or
	     * `animate()`
	     * within a group will be executed instantly (use {\@link keyframes keyframes} or a
	     * {\@link animate#usage animate() with a delay value} to offset styles to be applied at a later
	     * time).
	     *
	     * ```typescript
	     * group([
	     *   animate("1s", { background: "black" }))
	     *   animate("2s", { color: "white" }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} steps
	     * @return {?}
	     */
	    function group(steps) {
	        return new AnimationGroupMetadata(steps);
	    }
	    /**
	     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
	     * by default when an array is passed as animation data into {\@link transition transition}.)
	     *
	     * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
	     * transition}
	     * and it will only continue to the next instruction once each of the inner animation steps
	     * have completed.
	     *
	     * To perform animation styling in parallel with other animation steps then
	     * have a look at the {\@link group group} animation function.
	     *
	     * ### Usage
	     *
	     * The `steps` data that is passed into the `sequence` animation function can either consist
	     * of {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply
	     * the
	     * provided styling data immediately while a call to `animate()` will apply its styling
	     * data over a given time depending on its timing data.
	     *
	     * ```typescript
	     * sequence([
	     *   style({ opacity: 0 })),
	     *   animate("1s", { opacity: 1 }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} steps
	     * @return {?}
	     */
	    function sequence(steps) {
	        return new AnimationSequenceMetadata(steps);
	    }
	    /**
	     * `style` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `style` declares a key/value object containing CSS properties/styles that can then
	     * be used for {\@link state animation states}, within an {\@link sequence animation sequence}, or as
	     * styling data for both {\@link animate animate} and {\@link keyframes keyframes}.
	     *
	     * ### Usage
	     *
	     * `style` takes in a key/value string map as data and expects one or more CSS property/value
	     * pairs to be defined.
	     *
	     * ```typescript
	     * // string values are used for css properties
	     * style({ background: "red", color: "blue" })
	     *
	     * // numerical (pixel) values are also supported
	     * style({ width: 100, height: 0 })
	     * ```
	     *
	     * #### Auto-styles (using `*`)
	     *
	     * When an asterix (`*`) character is used as a value then it will be detected from the element
	     * being animated
	     * and applied as animation data when the animation starts.
	     *
	     * This feature proves useful for a state depending on layout and/or environment factors; in such
	     * cases
	     * the styles are calculated just before the animation starts.
	     *
	     * ```typescript
	     * // the steps below will animate from 0 to the
	     * // actual height of the element
	     * style({ height: 0 }),
	     * animate("1s", style({ height: "*" }))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} tokens
	     * @return {?}
	     */
	    function style(tokens) {
	        var /** @type {?} */ input;
	        var /** @type {?} */ offset = null;
	        if (typeof tokens === 'string') {
	            input = [(tokens)];
	        }
	        else {
	            if (Array.isArray(tokens)) {
	                input = (tokens);
	            }
	            else {
	                input = [(tokens)];
	            }
	            input.forEach(function (entry) {
	                var /** @type {?} */ entryOffset = ((entry) /** TODO #9100 */)['offset'];
	                if (isPresent(entryOffset)) {
	                    offset = offset == null ? parseFloat(entryOffset) : offset;
	                }
	            });
	        }
	        return new AnimationStyleMetadata(input, offset);
	    }
	    /**
	     * `state` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `state` declares an animation state within the given trigger. When a state is
	     * active within a component then its associated styles will persist on
	     * the element that the trigger is attached to (even when the animation ends).
	     *
	     * To animate between states, have a look at the animation {\@link transition transition}
	     * DSL function. To register states to an animation trigger please have a look
	     * at the {\@link trigger trigger} function.
	     *
	     * #### The `void` state
	     *
	     * The `void` state value is a reserved word that angular uses to determine when the element is not
	     * apart
	     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	     * associated element
	     * is void).
	     *
	     * #### The `*` (default) state
	     *
	     * The `*` state (when styled) is a fallback state that will be used if
	     * the state that is being animated is not declared within the trigger.
	     *
	     * ### Usage
	     *
	     * `state` will declare an animation state with its associated styles
	     * within the given trigger.
	     *
	     * - `stateNameExpr` can be one or more state names separated by commas.
	     * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
	     * the state
	     * has been reached.
	     *
	     * ```typescript
	     * // "void" is a reserved name for a state and is used to represent
	     * // the state in which an element is detached from from the application.
	     * state("void", style({ height: 0 }))
	     *
	     * // user-defined states
	     * state("closed", style({ height: 0 }))
	     * state("open, visible", style({ height: "*" }))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} stateNameExpr
	     * @param {?} styles
	     * @return {?}
	     */
	    function state(stateNameExpr, styles) {
	        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
	    }
	    /**
	     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
	     * by an `offset` value.
	     *
	     * ### Usage
	     *
	     * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
	     * animation function. Instead of applying animations from where they are
	     * currently to their destination, keyframes can describe how each style entry is applied
	     * and at what point within the animation arc (much like CSS Keyframe Animations do).
	     *
	     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
	     * what percentage of the animate time the styles will be applied.
	     *
	     * ```typescript
	     * // the provided offset values describe when each backgroundColor value is applied.
	     * animate("5s", keyframes([
	     *   style({ backgroundColor: "red", offset: 0 }),
	     *   style({ backgroundColor: "blue", offset: 0.2 }),
	     *   style({ backgroundColor: "orange", offset: 0.3 }),
	     *   style({ backgroundColor: "black", offset: 1 })
	     * ]))
	     * ```
	     *
	     * Alternatively, if there are no `offset` values used within the style entries then the offsets
	     * will
	     * be calculated automatically.
	     *
	     * ```typescript
	     * animate("5s", keyframes([
	     *   style({ backgroundColor: "red" }) // offset = 0
	     *   style({ backgroundColor: "blue" }) // offset = 0.33
	     *   style({ backgroundColor: "orange" }) // offset = 0.66
	     *   style({ backgroundColor: "black" }) // offset = 1
	     * ]))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} steps
	     * @return {?}
	     */
	    function keyframes(steps) {
	        return new AnimationKeyframesSequenceMetadata(steps);
	    }
	    /**
	     * `transition` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
	     * provided
	     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
	     * which consists
	     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
	     *
	     * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
	     * to animate to
	     * a state value and persist its styles then one or more {\@link state animation states} is expected
	     * to be defined.
	     *
	     * ### Usage
	     *
	     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	     * what the
	     * previous state is and what the current state has become. In other words, if a transition is
	     * defined that
	     * matches the old/current state criteria then the associated animation will be triggered.
	     *
	     * ```typescript
	     * // all transition/state changes are defined within an animation trigger
	     * trigger("myAnimationTrigger", [
	     *   // if a state is defined then its styles will be persisted when the
	     *   // animation has fully completed itself
	     *   state("on", style({ background: "green" })),
	     *   state("off", style({ background: "grey" })),
	     *
	     *   // a transition animation that will be kicked off when the state value
	     *   // bound to "myAnimationTrigger" changes from "on" to "off"
	     *   transition("on => off", animate(500)),
	     *
	     *   // it is also possible to do run the same animation for both directions
	     *   transition("on <=> off", animate(500)),
	     *
	     *   // or to define multiple states pairs separated by commas
	     *   transition("on => off, off => void", animate(500)),
	     *
	     *   // this is a catch-all state change for when an element is inserted into
	     *   // the page and the destination state is unknown
	     *   transition("void => *", [
	     *     style({ opacity: 0 }),
	     *     animate(500)
	     *   ]),
	     *
	     *   // this will capture a state change between any states
	     *   transition("* => *", animate("1s 0s")),
	     * ])
	     * ```
	     *
	     * The template associated with this component will make use of the `myAnimationTrigger`
	     * animation trigger by binding to an element within its template code.
	     *
	     * ```html
	     * <!-- somewhere inside of my-component-tpl.html -->
	     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	     * ```
	     *
	     * #### The final `animate` call
	     *
	     * If the final step within the transition steps is a call to `animate()` that **only**
	     * uses a timing value with **no style data** then it will be automatically used as the final
	     * animation
	     * arc for the element to animate itself to the final state. This involves an automatic mix of
	     * adding/removing CSS styles so that the element will be in the exact state it should be for the
	     * applied state to be presented correctly.
	     *
	     * ```
	     * // start off by hiding the element, but make sure that it animates properly to whatever state
	     * // is currently active for "myAnimationTrigger"
	     * transition("void => *", [
	     *   style({ opacity: 0 }),
	     *   animate(500)
	     * ])
	     * ```
	     *
	     * ### Transition Aliases (`:enter` and `:leave`)
	     *
	     * Given that enter (insertion) and leave (removal) animations are so common,
	     * the `transition` function accepts both `:enter` and `:leave` values which
	     * are aliases for the `void => *` and `* => void` state changes.
	     *
	     * ```
	     * transition(":enter", [
	     *   style({ opacity: 0 }),
	     *   animate(500, style({ opacity: 1 }))
	     * ])
	     * transition(":leave", [
	     *   animate(500, style({ opacity: 0 }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} stateChangeExpr
	     * @param {?} steps
	     * @return {?}
	     */
	    function transition(stateChangeExpr, steps) {
	        var /** @type {?} */ animationData = Array.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;
	        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
	    }
	    /**
	     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `trigger` Creates an animation trigger which will a list of {\@link state state} and {\@link
	     * transition transition}
	     * entries that will be evaluated when the expression bound to the trigger changes.
	     *
	     * Triggers are registered within the component annotation data under the
	     * {\@link Component#animations-anchor animations section}. An animation trigger can
	     * be placed on an element within a template by referencing the name of the
	     * trigger followed by the expression value that the trigger is bound to
	     * (in the form of `[\@triggerName]="expression"`.
	     *
	     * ### Usage
	     *
	     * `trigger` will create an animation trigger reference based on the provided `name` value.
	     * The provided `animation` value is expected to be an array consisting of {\@link state state} and
	     * {\@link transition transition}
	     * declarations.
	     *
	     * ```typescript
	     * \@Component({
	     *   selector: 'my-component',
	     *   templateUrl: 'my-component-tpl.html',
	     *   animations: [
	     *     trigger("myAnimationTrigger", [
	     *       state(...),
	     *       state(...),
	     *       transition(...),
	     *       transition(...)
	     *     ])
	     *   ]
	     * })
	     * class MyComponent {
	     *   myStatusExp = "something";
	     * }
	     * ```
	     *
	     * The template associated with this component will make use of the `myAnimationTrigger`
	     * animation trigger by binding to an element within its template code.
	     *
	     * ```html
	     * <!-- somewhere inside of my-component-tpl.html -->
	     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} name
	     * @param {?} animation
	     * @return {?}
	     */
	    function trigger(name, animation) {
	        return new AnimationEntryMetadata(name, animation);
	    }

	    /**
	     * @param {?} previousStyles
	     * @param {?} newStyles
	     * @param {?=} nullValue
	     * @return {?}
	     */
	    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
	        if (nullValue === void 0) { nullValue = null; }
	        var /** @type {?} */ finalStyles = {};
	        Object.keys(newStyles).forEach(function (prop) {
	            var /** @type {?} */ value = newStyles[prop];
	            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
	        });
	        Object.keys(previousStyles).forEach(function (prop) {
	            if (!isPresent(finalStyles[prop])) {
	                finalStyles[prop] = nullValue;
	            }
	        });
	        return finalStyles;
	    }
	    /**
	     * @param {?} collectedStyles
	     * @param {?} finalStateStyles
	     * @param {?} keyframes
	     * @return {?}
	     */
	    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
	        var /** @type {?} */ limit = keyframes.length - 1;
	        var /** @type {?} */ firstKeyframe = keyframes[0];
	        // phase 1: copy all the styles from the first keyframe into the lookup map
	        var /** @type {?} */ flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
	        var /** @type {?} */ extraFirstKeyframeStyles = {};
	        var /** @type {?} */ hasExtraFirstStyles = false;
	        Object.keys(collectedStyles).forEach(function (prop) {
	            var /** @type {?} */ value = (collectedStyles[prop]);
	            // if the style is already defined in the first keyframe then
	            // we do not replace it.
	            if (!flatenedFirstKeyframeStyles[prop]) {
	                flatenedFirstKeyframeStyles[prop] = value;
	                extraFirstKeyframeStyles[prop] = value;
	                hasExtraFirstStyles = true;
	            }
	        });
	        var /** @type {?} */ keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
	        // phase 2: normalize the final keyframe
	        var /** @type {?} */ finalKeyframe = keyframes[limit];
	        finalKeyframe.styles.styles.unshift(finalStateStyles);
	        var /** @type {?} */ flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
	        var /** @type {?} */ extraFinalKeyframeStyles = {};
	        var /** @type {?} */ hasExtraFinalStyles = false;
	        Object.keys(keyframeCollectedStyles).forEach(function (prop) {
	            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
	                extraFinalKeyframeStyles[prop] = AUTO_STYLE;
	                hasExtraFinalStyles = true;
	            }
	        });
	        if (hasExtraFinalStyles) {
	            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
	        }
	        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {
	            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
	                extraFirstKeyframeStyles[prop] = AUTO_STYLE;
	                hasExtraFirstStyles = true;
	            }
	        });
	        if (hasExtraFirstStyles) {
	            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
	        }
	        collectAndResolveStyles(collectedStyles, [finalStateStyles]);
	        return keyframes;
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    function clearStyles(styles) {
	        var /** @type {?} */ finalStyles = {};
	        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });
	        return finalStyles;
	    }
	    /**
	     * @param {?} collection
	     * @param {?} styles
	     * @return {?}
	     */
	    function collectAndResolveStyles(collection, styles) {
	        return styles.map(function (entry) {
	            var /** @type {?} */ stylesObj = {};
	            Object.keys(entry).forEach(function (prop) {
	                var /** @type {?} */ value = entry[prop];
	                if (value == FILL_STYLE_FLAG) {
	                    value = collection[prop];
	                    if (!isPresent(value)) {
	                        value = AUTO_STYLE;
	                    }
	                }
	                collection[prop] = value;
	                stylesObj[prop] = value;
	            });
	            return stylesObj;
	        });
	    }
	    /**
	     * @param {?} element
	     * @param {?} renderer
	     * @param {?} styles
	     * @return {?}
	     */
	    function renderStyles(element, renderer, styles) {
	        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    function flattenStyles(styles) {
	        var /** @type {?} */ finalStyles = {};
	        styles.forEach(function (entry) {
	            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = (entry[prop]); });
	        });
	        return finalStyles;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * `AnimationStyles` consists of a collection of key/value maps containing CSS-based style data
	     * that can either be used as initial styling data or apart of a series of keyframes within an
	     * animation.
	     * This class is mostly internal, and it is designed to be used alongside
	     * {\@link AnimationKeyframe `AnimationKeyframe`} and {\@link Renderer#animate-anchor
	     * `Renderer.animate`}.
	     *
	     * \@experimental Animation support is experimental
	     */
	    var AnimationStyles = (function () {
	        /**
	         * @param {?} styles
	         */
	        function AnimationStyles(styles) {
	            this.styles = styles;
	        }
	        return AnimationStyles;
	    }());

	    /**
	     * An instance of this class is returned as an event parameter when an animation
	     * callback is captured for an animation either during the start or done phase.
	     *
	     * ```typescript
	     * \@Component({
	     *   host: {
	     *     '[\@myAnimationTrigger]': 'someExpression',
	     *     '(\@myAnimationTrigger.start)': 'captureStartEvent($event)',
	     *     '(\@myAnimationTrigger.done)': 'captureDoneEvent($event)',
	     *   },
	     *   animations: [
	     *     trigger("myAnimationTrigger", [
	     *        // ...
	     *     ])
	     *   ]
	     * })
	     * class MyComponent {
	     *   someExpression: any = false;
	     *   captureStartEvent(event: AnimationTransitionEvent) {
	     *     // the toState, fromState and totalTime data is accessible from the event variable
	     *   }
	     *
	     *   captureDoneEvent(event: AnimationTransitionEvent) {
	     *     // the toState, fromState and totalTime data is accessible from the event variable
	     *   }
	     * }
	     * ```
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationTransitionEvent = (function () {
	        /**
	         * @param {?} __0
	         */
	        function AnimationTransitionEvent(_a) {
	            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime, phaseName = _a.phaseName;
	            this.fromState = fromState;
	            this.toState = toState;
	            this.totalTime = totalTime;
	            this.phaseName = phaseName;
	        }
	        return AnimationTransitionEvent;
	    }());

	    var AnimationTransition = (function () {
	        /**
	         * @param {?} _player
	         * @param {?} _fromState
	         * @param {?} _toState
	         * @param {?} _totalTime
	         */
	        function AnimationTransition(_player, _fromState, _toState, _totalTime) {
	            this._player = _player;
	            this._fromState = _fromState;
	            this._toState = _toState;
	            this._totalTime = _totalTime;
	        }
	        /**
	         * @param {?} phaseName
	         * @return {?}
	         */
	        AnimationTransition.prototype._createEvent = function (phaseName) {
	            return new AnimationTransitionEvent({
	                fromState: this._fromState,
	                toState: this._toState,
	                totalTime: this._totalTime,
	                phaseName: phaseName
	            });
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        AnimationTransition.prototype.onStart = function (callback) {
	            var _this = this;
	            var /** @type {?} */ fn = (Zone.current.wrap(function () { return callback(_this._createEvent('start')); }, 'player.onStart'));
	            this._player.onStart(fn);
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        AnimationTransition.prototype.onDone = function (callback) {
	            var _this = this;
	            var /** @type {?} */ fn = (Zone.current.wrap(function () { return callback(_this._createEvent('done')); }, 'player.onDone'));
	            this._player.onDone(fn);
	        };
	        return AnimationTransition;
	    }());

	    var DebugDomRootRenderer = (function () {
	        /**
	         * @param {?} _delegate
	         */
	        function DebugDomRootRenderer(_delegate) {
	            this._delegate = _delegate;
	        }
	        /**
	         * @param {?} componentProto
	         * @return {?}
	         */
	        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
	            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
	        };
	        return DebugDomRootRenderer;
	    }());
	    var DebugDomRenderer = (function () {
	        /**
	         * @param {?} _delegate
	         */
	        function DebugDomRenderer(_delegate) {
	            this._delegate = _delegate;
	        }
	        /**
	         * @param {?} selectorOrNode
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	            var /** @type {?} */ nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
	            var /** @type {?} */ debugEl = new DebugElement(nativeEl, null, debugInfo);
	            indexDebugNode(debugEl);
	            return nativeEl;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} name
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
	            var /** @type {?} */ nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
	            var /** @type {?} */ debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
	            debugEl.name = name;
	            indexDebugNode(debugEl);
	            return nativeEl;
	        };
	        /**
	         * @param {?} hostElement
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
	        /**
	         * @param {?} parentElement
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	            var /** @type {?} */ comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
	            var /** @type {?} */ debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return comment;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} value
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	            var /** @type {?} */ text = this._delegate.createText(parentElement, value, debugInfo);
	            var /** @type {?} */ debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return text;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} nodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	            var /** @type {?} */ debugParent = getDebugNode(parentElement);
	            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
	                var /** @type {?} */ debugElement_1 = debugParent;
	                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });
	            }
	            this._delegate.projectNodes(parentElement, nodes);
	        };
	        /**
	         * @param {?} node
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
	            var /** @type {?} */ debugNode = getDebugNode(node);
	            if (isPresent(debugNode)) {
	                var /** @type {?} */ debugParent = debugNode.parent;
	                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
	                    var /** @type {?} */ debugViewRootNodes_1 = [];
	                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes_1.push(getDebugNode(rootNode)); });
	                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes_1);
	                }
	            }
	            this._delegate.attachViewAfter(node, viewRootNodes);
	        };
	        /**
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
	            viewRootNodes.forEach(function (node) {
	                var /** @type {?} */ debugNode = getDebugNode(node);
	                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
	                    debugNode.parent.removeChild(debugNode);
	                }
	            });
	            this._delegate.detachView(viewRootNodes);
	        };
	        /**
	         * @param {?} hostElement
	         * @param {?} viewAllNodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	            viewAllNodes = viewAllNodes || [];
	            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });
	            this._delegate.destroyView(hostElement, viewAllNodes);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl)) {
	                debugEl.listeners.push(new EventListener(name, callback));
	            }
	            return this._delegate.listen(renderElement, name, callback);
	        };
	        /**
	         * @param {?} target
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
	            return this._delegate.listenGlobal(target, name, callback);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.properties[propertyName] = propertyValue;
	            }
	            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} attributeName
	         * @param {?} attributeValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.attributes[attributeName] = attributeValue;
	            }
	            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} className
	         * @param {?} isAdd
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.classes[className] = isAdd;
	            }
	            this._delegate.setElementClass(renderElement, className, isAdd);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.styles[styleName] = styleValue;
	            }
	            this._delegate.setElementStyle(renderElement, styleName, styleValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} methodName
	         * @param {?=} args
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	            this._delegate.invokeElementMethod(renderElement, methodName, args);
	        };
	        /**
	         * @param {?} renderNode
	         * @param {?} text
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing, previousPlayers);
	        };
	        return DebugDomRenderer;
	    }());

	    var ViewType = {};
	    ViewType.HOST = 0;
	    ViewType.COMPONENT = 1;
	    ViewType.EMBEDDED = 2;
	    ViewType[ViewType.HOST] = "HOST";
	    ViewType[ViewType.COMPONENT] = "COMPONENT";
	    ViewType[ViewType.EMBEDDED] = "EMBEDDED";

	    var StaticNodeDebugInfo = (function () {
	        /**
	         * @param {?} providerTokens
	         * @param {?} componentToken
	         * @param {?} refTokens
	         */
	        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
	            this.providerTokens = providerTokens;
	            this.componentToken = componentToken;
	            this.refTokens = refTokens;
	        }
	        return StaticNodeDebugInfo;
	    }());
	    var DebugContext = (function () {
	        /**
	         * @param {?} _view
	         * @param {?} _nodeIndex
	         * @param {?} _tplRow
	         * @param {?} _tplCol
	         */
	        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
	            this._view = _view;
	            this._nodeIndex = _nodeIndex;
	            this._tplRow = _tplRow;
	            this._tplCol = _tplCol;
	        }
	        Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "component", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
	                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
	                    return this.injector.get(staticNodeInfo.componentToken);
	                }
	                return null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ componentView = this._view;
	                while (isPresent(componentView.parentView) && componentView.type !== ViewType.COMPONENT) {
	                    componentView = (componentView.parentView);
	                }
	                return componentView.parentElement;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.injector(this._nodeIndex); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "renderNode", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                if (isPresent(this._nodeIndex) && this._view.allNodes) {
	                    return this._view.allNodes[this._nodeIndex];
	                }
	                else {
	                    return null;
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "providerTokens", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
	                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "source", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "references", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var _this = this;
	                var /** @type {?} */ varValues = {};
	                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
	                if (isPresent(staticNodeInfo)) {
	                    var /** @type {?} */ refs_1 = staticNodeInfo.refTokens;
	                    Object.keys(refs_1).forEach(function (refName) {
	                        var /** @type {?} */ refToken = refs_1[refName];
	                        var /** @type {?} */ varValue;
	                        if (isBlank(refToken)) {
	                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
	                        }
	                        else {
	                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
	                        }
	                        varValues[refName] = varValue;
	                    });
	                }
	                return varValues;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return DebugContext;
	    }());

	    var ViewAnimationMap = (function () {
	        function ViewAnimationMap() {
	            this._map = new Map();
	            this._allPlayers = [];
	        }
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.find = function (element, animationName) {
	            var /** @type {?} */ playersByAnimation = this._map.get(element);
	            if (isPresent(playersByAnimation)) {
	                return playersByAnimation[animationName];
	            }
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
	            var /** @type {?} */ el = this._map.get(element);
	            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];
	        };
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @param {?} player
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.set = function (element, animationName, player) {
	            var /** @type {?} */ playersByAnimation = this._map.get(element);
	            if (!isPresent(playersByAnimation)) {
	                playersByAnimation = {};
	            }
	            var /** @type {?} */ existingEntry = playersByAnimation[animationName];
	            if (isPresent(existingEntry)) {
	                this.remove(element, animationName);
	            }
	            playersByAnimation[animationName] = player;
	            this._allPlayers.push(player);
	            this._map.set(element, playersByAnimation);
	        };
	        /**
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @param {?=} targetPlayer
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.remove = function (element, animationName, targetPlayer) {
	            if (targetPlayer === void 0) { targetPlayer = null; }
	            var /** @type {?} */ playersByAnimation = this._map.get(element);
	            if (playersByAnimation) {
	                var /** @type {?} */ player = playersByAnimation[animationName];
	                if (!targetPlayer || player === targetPlayer) {
	                    delete playersByAnimation[animationName];
	                    var /** @type {?} */ index = this._allPlayers.indexOf(player);
	                    this._allPlayers.splice(index, 1);
	                    if (Object.keys(playersByAnimation).length === 0) {
	                        this._map.delete(element);
	                    }
	                }
	            }
	        };
	        return ViewAnimationMap;
	    }());

	    var AnimationViewContext = (function () {
	        /**
	         * @param {?} _animationQueue
	         */
	        function AnimationViewContext(_animationQueue) {
	            this._animationQueue = _animationQueue;
	            this._players = new ViewAnimationMap();
	        }
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        AnimationViewContext.prototype.onAllActiveAnimationsDone = function (callback) {
	            var /** @type {?} */ activeAnimationPlayers = this._players.getAllPlayers();
	            // we check for the length to avoid having GroupAnimationPlayer
	            // issue an unnecessary microtask when zero players are passed in
	            if (activeAnimationPlayers.length) {
	                new AnimationGroupPlayer(activeAnimationPlayers).onDone(function () { return callback(); });
	            }
	            else {
	                callback();
	            }
	        };
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @param {?} player
	         * @return {?}
	         */
	        AnimationViewContext.prototype.queueAnimation = function (element, animationName, player) {
	            var _this = this;
	            this._animationQueue.enqueue(player);
	            this._players.set(element, animationName, player);
	            player.onDone(function () { return _this._players.remove(element, animationName, player); });
	        };
	        /**
	         * @param {?} element
	         * @param {?=} animationName
	         * @return {?}
	         */
	        AnimationViewContext.prototype.getAnimationPlayers = function (element, animationName) {
	            if (animationName === void 0) { animationName = null; }
	            var /** @type {?} */ players = [];
	            if (animationName) {
	                var /** @type {?} */ currentPlayer = this._players.find(element, animationName);
	                if (currentPlayer) {
	                    _recursePlayers(currentPlayer, players);
	                }
	            }
	            else {
	                this._players.findAllPlayersByElement(element).forEach(function (player) { return _recursePlayers(player, players); });
	            }
	            return players;
	        };
	        return AnimationViewContext;
	    }());
	    /**
	     * @param {?} player
	     * @param {?} collectedPlayers
	     * @return {?}
	     */
	    function _recursePlayers(player, collectedPlayers) {
	        if ((player instanceof AnimationGroupPlayer) || (player instanceof AnimationSequencePlayer)) {
	            player.players.forEach(function (player) { return _recursePlayers(player, collectedPlayers); });
	        }
	        else {
	            collectedPlayers.push(player);
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$15 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ElementInjector = (function (_super) {
	        __extends$15(ElementInjector, _super);
	        /**
	         * @param {?} _view
	         * @param {?} _nodeIndex
	         */
	        function ElementInjector(_view, _nodeIndex) {
	            _super.call(this);
	            this._view = _view;
	            this._nodeIndex = _nodeIndex;
	        }
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        ElementInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            return this._view.injectorGet(token, this._nodeIndex, notFoundValue);
	        };
	        return ElementInjector;
	    }(Injector));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$14 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _scope_check = wtfCreateScope("AppView#check(ascii id)");
	    /**
	     * @experimental
	     */
	    var /** @type {?} */ EMPTY_CONTEXT = new Object();
	    var /** @type {?} */ UNDEFINED$1 = new Object();
	    /**
	     * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	     *
	     * @abstract
	     */
	    var AppView = (function () {
	        /**
	         * @param {?} clazz
	         * @param {?} componentType
	         * @param {?} type
	         * @param {?} viewUtils
	         * @param {?} parentView
	         * @param {?} parentIndex
	         * @param {?} parentElement
	         * @param {?} cdMode
	         * @param {?=} declaredViewContainer
	         */
	        function AppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentElement, cdMode, declaredViewContainer) {
	            if (declaredViewContainer === void 0) { declaredViewContainer = null; }
	            this.clazz = clazz;
	            this.componentType = componentType;
	            this.type = type;
	            this.viewUtils = viewUtils;
	            this.parentView = parentView;
	            this.parentIndex = parentIndex;
	            this.parentElement = parentElement;
	            this.cdMode = cdMode;
	            this.declaredViewContainer = declaredViewContainer;
	            this.numberOfChecks = 0;
	            this.ref = new ViewRef_(this, viewUtils.animationQueue);
	            if (type === ViewType.COMPONENT || type === ViewType.HOST) {
	                this.renderer = viewUtils.renderComponent(componentType);
	            }
	            else {
	                this.renderer = parentView.renderer;
	            }
	            this._directRenderer = this.renderer.directRenderer;
	        }
	        Object.defineProperty(AppView.prototype, "animationContext", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                if (!this._animationContext) {
	                    this._animationContext = new AnimationViewContext(this.viewUtils.animationQueue);
	                }
	                return this._animationContext;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} context
	         * @return {?}
	         */
	        AppView.prototype.create = function (context) {
	            this.context = context;
	            return this.createInternal(null);
	        };
	        /**
	         * @param {?} rootSelectorOrNode
	         * @param {?} hostInjector
	         * @param {?} projectableNodes
	         * @return {?}
	         */
	        AppView.prototype.createHostView = function (rootSelectorOrNode, hostInjector, projectableNodes) {
	            this.context = (EMPTY_CONTEXT);
	            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
	            this._hostInjector = hostInjector;
	            this._hostProjectableNodes = projectableNodes;
	            return this.createInternal(rootSelectorOrNode);
	        };
	        /**
	         * Overwritten by implementations.
	         * Returns the ComponentRef for the host element for ViewType.HOST.
	         * @param {?} rootSelectorOrNode
	         * @return {?}
	         */
	        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
	        /**
	         * Overwritten by implementations.
	         * @param {?} templateNodeIndex
	         * @return {?}
	         */
	        AppView.prototype.createEmbeddedViewInternal = function (templateNodeIndex) { return null; };
	        /**
	         * @param {?} lastRootNode
	         * @param {?} allNodes
	         * @param {?} disposables
	         * @return {?}
	         */
	        AppView.prototype.init = function (lastRootNode, allNodes, disposables) {
	            this.lastRootNode = lastRootNode;
	            this.allNodes = allNodes;
	            this.disposables = disposables;
	            if (this.type === ViewType.COMPONENT) {
	                this.dirtyParentQueriesInternal();
	            }
	        };
	        /**
	         * @param {?} token
	         * @param {?} nodeIndex
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            var /** @type {?} */ result = UNDEFINED$1;
	            var /** @type {?} */ view = this;
	            while (result === UNDEFINED$1) {
	                if (isPresent(nodeIndex)) {
	                    result = view.injectorGetInternal(token, nodeIndex, UNDEFINED$1);
	                }
	                if (result === UNDEFINED$1 && view.type === ViewType.HOST) {
	                    result = view._hostInjector.get(token, notFoundValue);
	                }
	                nodeIndex = view.parentIndex;
	                view = view.parentView;
	            }
	            return result;
	        };
	        /**
	         * Overwritten by implementations
	         * @param {?} token
	         * @param {?} nodeIndex
	         * @param {?} notFoundResult
	         * @return {?}
	         */
	        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
	            return notFoundResult;
	        };
	        /**
	         * @param {?} nodeIndex
	         * @return {?}
	         */
	        AppView.prototype.injector = function (nodeIndex) { return new ElementInjector(this, nodeIndex); };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.detachAndDestroy = function () {
	            if (this.viewContainer) {
	                this.viewContainer.detachView(this.viewContainer.nestedViews.indexOf(this));
	            }
	            else if (this.appRef) {
	                this.appRef.detachView(this.ref);
	            }
	            else if (this._hasExternalHostElement) {
	                this.detach();
	            }
	            this.destroy();
	        };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.destroy = function () {
	            var _this = this;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                return;
	            }
	            var /** @type {?} */ hostElement = this.type === ViewType.COMPONENT ? this.parentElement : null;
	            if (this.disposables) {
	                for (var /** @type {?} */ i = 0; i < this.disposables.length; i++) {
	                    this.disposables[i]();
	                }
	            }
	            this.destroyInternal();
	            this.dirtyParentQueriesInternal();
	            if (this._animationContext) {
	                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.destroyView(hostElement, _this.allNodes); });
	            }
	            else {
	                this.renderer.destroyView(hostElement, this.allNodes);
	            }
	            this.cdMode = ChangeDetectorStatus.Destroyed;
	        };
	        /**
	         * Overwritten by implementations
	         * @return {?}
	         */
	        AppView.prototype.destroyInternal = function () { };
	        /**
	         * Overwritten by implementations
	         * @return {?}
	         */
	        AppView.prototype.detachInternal = function () { };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.detach = function () {
	            var _this = this;
	            this.detachInternal();
	            if (this._animationContext) {
	                this._animationContext.onAllActiveAnimationsDone(function () { return _this._renderDetach(); });
	            }
	            else {
	                this._renderDetach();
	            }
	            if (this.declaredViewContainer && this.declaredViewContainer !== this.viewContainer &&
	                this.declaredViewContainer.projectedViews) {
	                var /** @type {?} */ projectedViews = this.declaredViewContainer.projectedViews;
	                var /** @type {?} */ index = projectedViews.indexOf(this);
	                // perf: pop is faster than splice!
	                if (index >= projectedViews.length - 1) {
	                    projectedViews.pop();
	                }
	                else {
	                    projectedViews.splice(index, 1);
	                }
	            }
	            this.appRef = null;
	            this.viewContainer = null;
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @return {?}
	         */
	        AppView.prototype._renderDetach = function () {
	            if (this._directRenderer) {
	                this.visitRootNodesInternal(this._directRenderer.remove, null);
	            }
	            else {
	                this.renderer.detachView(this.flatRootNodes);
	            }
	        };
	        /**
	         * @param {?} appRef
	         * @return {?}
	         */
	        AppView.prototype.attachToAppRef = function (appRef) {
	            if (this.viewContainer) {
	                throw new Error('This view is already attached to a ViewContainer!');
	            }
	            this.appRef = appRef;
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @param {?} viewContainer
	         * @param {?} prevView
	         * @return {?}
	         */
	        AppView.prototype.attachAfter = function (viewContainer, prevView) {
	            if (this.appRef) {
	                throw new Error('This view is already attached directly to the ApplicationRef!');
	            }
	            this._renderAttach(viewContainer, prevView);
	            this.viewContainer = viewContainer;
	            if (this.declaredViewContainer && this.declaredViewContainer !== viewContainer) {
	                if (!this.declaredViewContainer.projectedViews) {
	                    this.declaredViewContainer.projectedViews = [];
	                }
	                this.declaredViewContainer.projectedViews.push(this);
	            }
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @param {?} viewContainer
	         * @param {?} prevView
	         * @return {?}
	         */
	        AppView.prototype.moveAfter = function (viewContainer, prevView) {
	            this._renderAttach(viewContainer, prevView);
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @param {?} viewContainer
	         * @param {?} prevView
	         * @return {?}
	         */
	        AppView.prototype._renderAttach = function (viewContainer, prevView) {
	            var /** @type {?} */ prevNode = prevView ? prevView.lastRootNode : viewContainer.nativeElement;
	            if (this._directRenderer) {
	                var /** @type {?} */ nextSibling = this._directRenderer.nextSibling(prevNode);
	                if (nextSibling) {
	                    this.visitRootNodesInternal(this._directRenderer.insertBefore, nextSibling);
	                }
	                else {
	                    var /** @type {?} */ parentElement = this._directRenderer.parentElement(prevNode);
	                    if (parentElement) {
	                        this.visitRootNodesInternal(this._directRenderer.appendChild, parentElement);
	                    }
	                }
	            }
	            else {
	                this.renderer.attachViewAfter(prevNode, this.flatRootNodes);
	            }
	        };
	        Object.defineProperty(AppView.prototype, "changeDetectorRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "flatRootNodes", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ nodes = [];
	                this.visitRootNodesInternal(addToArray, nodes);
	                return nodes;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} parentElement
	         * @param {?} ngContentIndex
	         * @return {?}
	         */
	        AppView.prototype.projectNodes = function (parentElement, ngContentIndex) {
	            if (this._directRenderer) {
	                this.visitProjectedNodes(ngContentIndex, this._directRenderer.appendChild, parentElement);
	            }
	            else {
	                var /** @type {?} */ nodes = [];
	                this.visitProjectedNodes(ngContentIndex, addToArray, nodes);
	                this.renderer.projectNodes(parentElement, nodes);
	            }
	        };
	        /**
	         * @param {?} ngContentIndex
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        AppView.prototype.visitProjectedNodes = function (ngContentIndex, cb, c) {
	            switch (this.type) {
	                case ViewType.EMBEDDED:
	                    this.parentView.visitProjectedNodes(ngContentIndex, cb, c);
	                    break;
	                case ViewType.COMPONENT:
	                    if (this.parentView.type === ViewType.HOST) {
	                        var /** @type {?} */ nodes = this.parentView._hostProjectableNodes[ngContentIndex] || [];
	                        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	                            cb(nodes[i], c);
	                        }
	                    }
	                    else {
	                        this.parentView.visitProjectableNodesInternal(this.parentIndex, ngContentIndex, cb, c);
	                    }
	                    break;
	            }
	        };
	        /**
	         * Overwritten by implementations
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        AppView.prototype.visitRootNodesInternal = function (cb, c) { };
	        /**
	         * Overwritten by implementations
	         * @param {?} nodeIndex
	         * @param {?} ngContentIndex
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        AppView.prototype.visitProjectableNodesInternal = function (nodeIndex, ngContentIndex, cb, c) { };
	        /**
	         * Overwritten by implementations
	         * @return {?}
	         */
	        AppView.prototype.dirtyParentQueriesInternal = function () { };
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        AppView.prototype.internalDetectChanges = function (throwOnChange) {
	            if (this.cdMode !== ChangeDetectorStatus.Detached) {
	                this.detectChanges(throwOnChange);
	            }
	        };
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        AppView.prototype.detectChanges = function (throwOnChange) {
	            var /** @type {?} */ s = _scope_check(this.clazz);
	            if (this.cdMode === ChangeDetectorStatus.Checked ||
	                this.cdMode === ChangeDetectorStatus.Errored)
	                return;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                this.throwDestroyedError('detectChanges');
	            }
	            this.detectChangesInternal(throwOnChange);
	            if (this.cdMode === ChangeDetectorStatus.CheckOnce)
	                this.cdMode = ChangeDetectorStatus.Checked;
	            this.numberOfChecks++;
	            wtfLeave(s);
	        };
	        /**
	         * Overwritten by implementations
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        AppView.prototype.detectChangesInternal = function (throwOnChange) { };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.markPathToRootAsCheckOnce = function () {
	            var /** @type {?} */ c = this;
	            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
	                if (c.cdMode === ChangeDetectorStatus.Checked) {
	                    c.cdMode = ChangeDetectorStatus.CheckOnce;
	                }
	                if (c.type === ViewType.COMPONENT) {
	                    c = c.parentView;
	                }
	                else {
	                    c = c.viewContainer ? c.viewContainer.parentView : null;
	                }
	            }
	        };
	        /**
	         * @param {?} cb
	         * @return {?}
	         */
	        AppView.prototype.eventHandler = function (cb) {
	            return cb;
	        };
	        /**
	         * @param {?} details
	         * @return {?}
	         */
	        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };
	        return AppView;
	    }());
	    var DebugAppView = (function (_super) {
	        __extends$14(DebugAppView, _super);
	        /**
	         * @param {?} clazz
	         * @param {?} componentType
	         * @param {?} type
	         * @param {?} viewUtils
	         * @param {?} parentView
	         * @param {?} parentIndex
	         * @param {?} parentNode
	         * @param {?} cdMode
	         * @param {?} staticNodeDebugInfos
	         * @param {?=} declaredViewContainer
	         */
	        function DebugAppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, staticNodeDebugInfos, declaredViewContainer) {
	            if (declaredViewContainer === void 0) { declaredViewContainer = null; }
	            _super.call(this, clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, declaredViewContainer);
	            this.staticNodeDebugInfos = staticNodeDebugInfos;
	            this._currentDebugContext = null;
	        }
	        /**
	         * @param {?} context
	         * @return {?}
	         */
	        DebugAppView.prototype.create = function (context) {
	            this._resetDebug();
	            try {
	                return _super.prototype.create.call(this, context);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} rootSelectorOrNode
	         * @param {?} injector
	         * @param {?=} projectableNodes
	         * @return {?}
	         */
	        DebugAppView.prototype.createHostView = function (rootSelectorOrNode, injector, projectableNodes) {
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            this._resetDebug();
	            try {
	                return _super.prototype.createHostView.call(this, rootSelectorOrNode, injector, projectableNodes);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} token
	         * @param {?} nodeIndex
	         * @param {?=} notFoundResult
	         * @return {?}
	         */
	        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	            this._resetDebug();
	            try {
	                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DebugAppView.prototype.detach = function () {
	            this._resetDebug();
	            try {
	                _super.prototype.detach.call(this);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DebugAppView.prototype.destroy = function () {
	            this._resetDebug();
	            try {
	                _super.prototype.destroy.call(this);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        DebugAppView.prototype.detectChanges = function (throwOnChange) {
	            this._resetDebug();
	            try {
	                _super.prototype.detectChanges.call(this, throwOnChange);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
	        /**
	         * @param {?} nodeIndex
	         * @param {?} rowNum
	         * @param {?} colNum
	         * @return {?}
	         */
	        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
	            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
	        };
	        /**
	         * @param {?} e
	         * @return {?}
	         */
	        DebugAppView.prototype._rethrowWithContext = function (e) {
	            if (!(e instanceof ViewWrappedError)) {
	                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {
	                    this.cdMode = ChangeDetectorStatus.Errored;
	                }
	                if (isPresent(this._currentDebugContext)) {
	                    throw new ViewWrappedError(e, this._currentDebugContext);
	                }
	            }
	        };
	        /**
	         * @param {?} cb
	         * @return {?}
	         */
	        DebugAppView.prototype.eventHandler = function (cb) {
	            var _this = this;
	            var /** @type {?} */ superHandler = _super.prototype.eventHandler.call(this, cb);
	            return function (eventName, event) {
	                _this._resetDebug();
	                try {
	                    return superHandler.call(_this, eventName, event);
	                }
	                catch (e) {
	                    _this._rethrowWithContext(e);
	                    throw e;
	                }
	            };
	        };
	        return DebugAppView;
	    }(AppView));

	    /**
	     * A ViewContainer is created for elements that have a ViewContainerRef
	     * to keep track of the nested views.
	     */
	    var ViewContainer = (function () {
	        /**
	         * @param {?} index
	         * @param {?} parentIndex
	         * @param {?} parentView
	         * @param {?} nativeElement
	         */
	        function ViewContainer(index, parentIndex, parentView, nativeElement) {
	            this.index = index;
	            this.parentIndex = parentIndex;
	            this.parentView = parentView;
	            this.nativeElement = nativeElement;
	        }
	        Object.defineProperty(ViewContainer.prototype, "elementRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ElementRef(this.nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainer.prototype, "vcRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ViewContainerRef_(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainer.prototype, "parentInjector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.parentView.injector(this.parentIndex); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainer.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.parentView.injector(this.index); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        ViewContainer.prototype.detectChangesInNestedViews = function (throwOnChange) {
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    this.nestedViews[i].detectChanges(throwOnChange);
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        ViewContainer.prototype.destroyNestedViews = function () {
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    this.nestedViews[i].destroy();
	                }
	            }
	        };
	        /**
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        ViewContainer.prototype.visitNestedViewRootNodes = function (cb, c) {
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    this.nestedViews[i].visitRootNodesInternal(cb, c);
	                }
	            }
	        };
	        /**
	         * @param {?} nestedViewClass
	         * @param {?} callback
	         * @return {?}
	         */
	        ViewContainer.prototype.mapNestedViews = function (nestedViewClass, callback) {
	            var /** @type {?} */ result = [];
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    var /** @type {?} */ nestedView = this.nestedViews[i];
	                    if (nestedView.clazz === nestedViewClass) {
	                        result.push(callback(nestedView));
	                    }
	                }
	            }
	            if (this.projectedViews) {
	                for (var /** @type {?} */ i = 0; i < this.projectedViews.length; i++) {
	                    var /** @type {?} */ projectedView = this.projectedViews[i];
	                    if (projectedView.clazz === nestedViewClass) {
	                        result.push(callback(projectedView));
	                    }
	                }
	            }
	            return result;
	        };
	        /**
	         * @param {?} view
	         * @param {?} currentIndex
	         * @return {?}
	         */
	        ViewContainer.prototype.moveView = function (view, currentIndex) {
	            var /** @type {?} */ previousIndex = this.nestedViews.indexOf(view);
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            var /** @type {?} */ nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            nestedViews.splice(previousIndex, 1);
	            nestedViews.splice(currentIndex, 0, view);
	            var /** @type {?} */ prevView = currentIndex > 0 ? nestedViews[currentIndex - 1] : null;
	            view.moveAfter(this, prevView);
	        };
	        /**
	         * @param {?} view
	         * @param {?} viewIndex
	         * @return {?}
	         */
	        ViewContainer.prototype.attachView = function (view, viewIndex) {
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            var /** @type {?} */ nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            // perf: array.push is faster than array.splice!
	            if (viewIndex >= nestedViews.length) {
	                nestedViews.push(view);
	            }
	            else {
	                nestedViews.splice(viewIndex, 0, view);
	            }
	            var /** @type {?} */ prevView = viewIndex > 0 ? nestedViews[viewIndex - 1] : null;
	            view.attachAfter(this, prevView);
	        };
	        /**
	         * @param {?} viewIndex
	         * @return {?}
	         */
	        ViewContainer.prototype.detachView = function (viewIndex) {
	            var /** @type {?} */ view = this.nestedViews[viewIndex];
	            // perf: array.pop is faster than array.splice!
	            if (viewIndex >= this.nestedViews.length - 1) {
	                this.nestedViews.pop();
	            }
	            else {
	                this.nestedViews.splice(viewIndex, 1);
	            }
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            view.detach();
	            return view;
	        };
	        return ViewContainer;
	    }());

	    var /** @type {?} */ __core_private__ = {
	        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
	        ChangeDetectorStatus: ChangeDetectorStatus,
	        constructDependencies: constructDependencies,
	        LifecycleHooks: LifecycleHooks,
	        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
	        ReflectorReader: ReflectorReader,
	        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
	        ComponentRef_: ComponentRef_,
	        ViewContainer: ViewContainer,
	        AppView: AppView,
	        DebugAppView: DebugAppView,
	        NgModuleInjector: NgModuleInjector,
	        registerModuleFactory: registerModuleFactory,
	        ViewType: ViewType,
	        view_utils: view_utils,
	        ViewMetadata: ViewMetadata,
	        DebugContext: DebugContext,
	        StaticNodeDebugInfo: StaticNodeDebugInfo,
	        devModeEqual: devModeEqual,
	        UNINITIALIZED: UNINITIALIZED,
	        ValueUnwrapper: ValueUnwrapper,
	        RenderDebugInfo: RenderDebugInfo,
	        TemplateRef_: TemplateRef_,
	        ReflectionCapabilities: ReflectionCapabilities,
	        makeDecorator: makeDecorator,
	        DebugDomRootRenderer: DebugDomRootRenderer,
	        Console: Console,
	        reflector: reflector,
	        Reflector: Reflector,
	        NoOpAnimationPlayer: NoOpAnimationPlayer,
	        AnimationPlayer: AnimationPlayer,
	        AnimationSequencePlayer: AnimationSequencePlayer,
	        AnimationGroupPlayer: AnimationGroupPlayer,
	        AnimationKeyframe: AnimationKeyframe,
	        prepareFinalAnimationStyles: prepareFinalAnimationStyles,
	        balanceAnimationKeyframes: balanceAnimationKeyframes,
	        flattenStyles: flattenStyles,
	        clearStyles: clearStyles,
	        renderStyles: renderStyles,
	        collectAndResolveStyles: collectAndResolveStyles,
	        APP_ID_RANDOM_PROVIDER: APP_ID_RANDOM_PROVIDER,
	        AnimationStyles: AnimationStyles,
	        ANY_STATE: ANY_STATE,
	        DEFAULT_STATE: DEFAULT_STATE,
	        EMPTY_STATE: EMPTY_STATE,
	        FILL_STYLE_FLAG: FILL_STYLE_FLAG,
	        ComponentStillLoadingError: ComponentStillLoadingError,
	        isPromise: isPromise,
	        isObservable: isObservable,
	        AnimationTransition: AnimationTransition
	    };

	    exports.createPlatform = createPlatform;
	    exports.assertPlatform = assertPlatform;
	    exports.destroyPlatform = destroyPlatform;
	    exports.getPlatform = getPlatform;
	    exports.PlatformRef = PlatformRef;
	    exports.ApplicationRef = ApplicationRef;
	    exports.enableProdMode = enableProdMode;
	    exports.isDevMode = isDevMode;
	    exports.createPlatformFactory = createPlatformFactory;
	    exports.NgProbeToken = NgProbeToken;
	    exports.APP_ID = APP_ID;
	    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
	    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
	    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
	    exports.APP_INITIALIZER = APP_INITIALIZER;
	    exports.ApplicationInitStatus = ApplicationInitStatus;
	    exports.DebugElement = DebugElement;
	    exports.DebugNode = DebugNode;
	    exports.asNativeElements = asNativeElements;
	    exports.getDebugNode = getDebugNode;
	    exports.Testability = Testability;
	    exports.TestabilityRegistry = TestabilityRegistry;
	    exports.setTestabilityGetter = setTestabilityGetter;
	    exports.TRANSLATIONS = TRANSLATIONS;
	    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
	    exports.LOCALE_ID = LOCALE_ID;
	    exports.ApplicationModule = ApplicationModule;
	    exports.wtfCreateScope = wtfCreateScope;
	    exports.wtfLeave = wtfLeave;
	    exports.wtfStartTimeRange = wtfStartTimeRange;
	    exports.wtfEndTimeRange = wtfEndTimeRange;
	    exports.Type = Type;
	    exports.EventEmitter = EventEmitter;
	    exports.ErrorHandler = ErrorHandler;
	    exports.AnimationTransitionEvent = AnimationTransitionEvent;
	    exports.AnimationPlayer = AnimationPlayer;
	    exports.AnimationStyles = AnimationStyles;
	    exports.AnimationKeyframe = AnimationKeyframe;
	    exports.Sanitizer = Sanitizer;
	    exports.SecurityContext = SecurityContext;
	    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
	    exports.Attribute = Attribute;
	    exports.ContentChild = ContentChild;
	    exports.ContentChildren = ContentChildren;
	    exports.Query = Query;
	    exports.ViewChild = ViewChild;
	    exports.ViewChildren = ViewChildren;
	    exports.Component = Component;
	    exports.Directive = Directive;
	    exports.HostBinding = HostBinding;
	    exports.HostListener = HostListener;
	    exports.Input = Input;
	    exports.Output = Output;
	    exports.Pipe = Pipe;
	    exports.AfterContentChecked = AfterContentChecked;
	    exports.AfterContentInit = AfterContentInit;
	    exports.AfterViewChecked = AfterViewChecked;
	    exports.AfterViewInit = AfterViewInit;
	    exports.DoCheck = DoCheck;
	    exports.OnChanges = OnChanges;
	    exports.OnDestroy = OnDestroy;
	    exports.OnInit = OnInit;
	    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
	    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
	    exports.NgModule = NgModule;
	    exports.ViewEncapsulation = ViewEncapsulation;
	    exports.Version = Version;
	    exports.VERSION = VERSION;
	    exports.Class = Class;
	    exports.forwardRef = forwardRef;
	    exports.resolveForwardRef = resolveForwardRef;
	    exports.Injector = Injector;
	    exports.ReflectiveInjector = ReflectiveInjector;
	    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	    exports.ReflectiveKey = ReflectiveKey;
	    exports.OpaqueToken = OpaqueToken;
	    exports.Inject = Inject;
	    exports.Optional = Optional;
	    exports.Injectable = Injectable;
	    exports.Self = Self;
	    exports.SkipSelf = SkipSelf;
	    exports.Host = Host;
	    exports.NgZone = NgZone;
	    exports.RenderComponentType = RenderComponentType;
	    exports.Renderer = Renderer;
	    exports.RootRenderer = RootRenderer;
	    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
	    exports.Compiler = Compiler;
	    exports.CompilerFactory = CompilerFactory;
	    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
	    exports.ComponentFactory = ComponentFactory;
	    exports.ComponentRef = ComponentRef;
	    exports.ComponentFactoryResolver = ComponentFactoryResolver;
	    exports.ElementRef = ElementRef;
	    exports.NgModuleFactory = NgModuleFactory;
	    exports.NgModuleRef = NgModuleRef;
	    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
	    exports.getModuleFactory = getModuleFactory;
	    exports.QueryList = QueryList;
	    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
	    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
	    exports.TemplateRef = TemplateRef;
	    exports.ViewContainerRef = ViewContainerRef;
	    exports.EmbeddedViewRef = EmbeddedViewRef;
	    exports.ViewRef = ViewRef;
	    exports.ChangeDetectionStrategy = ChangeDetectionStrategy;
	    exports.ChangeDetectorRef = ChangeDetectorRef;
	    exports.CollectionChangeRecord = CollectionChangeRecord;
	    exports.DefaultIterableDiffer = DefaultIterableDiffer;
	    exports.IterableDiffers = IterableDiffers;
	    exports.KeyValueChangeRecord = KeyValueChangeRecord;
	    exports.KeyValueDiffers = KeyValueDiffers;
	    exports.SimpleChange = SimpleChange;
	    exports.WrappedValue = WrappedValue;
	    exports.platformCore = platformCore;
	    exports.__core_private__ = __core_private__;
	    exports.AUTO_STYLE = AUTO_STYLE;
	    exports.AnimationEntryMetadata = AnimationEntryMetadata;
	    exports.AnimationStateMetadata = AnimationStateMetadata;
	    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
	    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
	    exports.AnimationMetadata = AnimationMetadata;
	    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
	    exports.AnimationStyleMetadata = AnimationStyleMetadata;
	    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
	    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
	    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
	    exports.AnimationGroupMetadata = AnimationGroupMetadata;
	    exports.animate = animate;
	    exports.group = group;
	    exports.sequence = sequence;
	    exports.style = style;
	    exports.state = state;
	    exports.keyframes = keyframes;
	    exports.transition = transition;
	    exports.trigger = trigger;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.$$observable = getSymbolObservable(root_1.root);
	//# sourceMappingURL=observable.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * window: browser in DOM main thread
	 * self: browser in WebWorker
	 * global: Node.js/other
	 */
	exports.root = (typeof window == 'object' && window.window === window && window
	    || typeof self == 'object' && self.self === self && self
	    || typeof global == 'object' && global.global === global && global);
	if (!exports.root) {
	    throw new Error('RxJS could not find any global context (window, self, global)');
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var Subscriber_1 = __webpack_require__(9);
	var Subscription_1 = __webpack_require__(11);
	var ObjectUnsubscribedError_1 = __webpack_require__(19);
	var SubjectSubscription_1 = __webpack_require__(20);
	var rxSubscriber_1 = __webpack_require__(18);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	var toSubscriber_1 = __webpack_require__(8);
	var observable_1 = __webpack_require__(4);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._subscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(9);
	var rxSubscriber_1 = __webpack_require__(18);
	var Observer_1 = __webpack_require__(17);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(10);
	var Subscription_1 = __webpack_require__(11);
	var Observer_1 = __webpack_require__(17);
	var rxSubscriber_1 = __webpack_require__(18);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(12);
	var isObject_1 = __webpack_require__(13);
	var isFunction_1 = __webpack_require__(10);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var UnsubscriptionError_1 = __webpack_require__(16);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.closed || typeof sub.unsubscribe !== 'function') {
	                    return sub;
	                }
	                else if (this.closed) {
	                    sub.unsubscribe();
	                    return sub;
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var childSub = new ChildSubscription(sub, this);
	        this._subscriptions = this._subscriptions || [];
	        this._subscriptions.push(childSub);
	        return childSub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	var ChildSubscription = (function (_super) {
	    __extends(ChildSubscription, _super);
	    function ChildSubscription(_innerSub, _parent) {
	        _super.call(this);
	        this._innerSub = _innerSub;
	        this._parent = _parent;
	    }
	    ChildSubscription.prototype._unsubscribe = function () {
	        var _a = this, _innerSub = _a._innerSub, _parent = _a._parent;
	        _parent.remove(this);
	        _innerSub.unsubscribe();
	    };
	    return ChildSubscription;
	}(Subscription));
	exports.ChildSubscription = ChildSubscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(15);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(11);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(22), __webpack_require__(3)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));
	}(this, function (exports,_angular_common,core) { 'use strict';

	    var /** @type {?} */ DebugDomRootRenderer = core.__core_private__.DebugDomRootRenderer;
	    var /** @type {?} */ NoOpAnimationPlayer = core.__core_private__.NoOpAnimationPlayer;

	    /**
	     * \@experimental
	     */
	    var NoOpAnimationDriver = (function () {
	        function NoOpAnimationDriver() {
	        }
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            return new NoOpAnimationPlayer();
	        };
	        return NoOpAnimationDriver;
	    }());
	    /**
	     * \@experimental
	     * @abstract
	     */
	    var AnimationDriver = (function () {
	        function AnimationDriver() {
	        }
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        AnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
	        AnimationDriver.NOOP = new NoOpAnimationDriver();
	        return AnimationDriver;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = (self);
	        }
	        else {
	            globalScope = (global);
	        }
	    }
	    else {
	        globalScope = (window);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var /** @type {?} */ global$1 = globalScope;
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    global$1.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    /**
	     * @param {?} global
	     * @param {?} path
	     * @param {?} value
	     * @return {?}
	     */
	    function setValueOnPath(global, path, value) {
	        var /** @type {?} */ parts = path.split('.');
	        var /** @type {?} */ obj = global;
	        while (parts.length > 1) {
	            var /** @type {?} */ name_1 = parts.shift();
	            if (obj.hasOwnProperty(name_1) && obj[name_1] != null) {
	                obj = obj[name_1];
	            }
	            else {
	                obj = obj[name_1] = {};
	            }
	        }
	        if (obj === undefined || obj === null) {
	            obj = {};
	        }
	        obj[parts.shift()] = value;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ _DOM = null;
	    /**
	     * @return {?}
	     */
	    function getDOM() {
	        return _DOM;
	    }
	    /**
	     * @param {?} adapter
	     * @return {?}
	     */
	    function setRootDomAdapter(adapter) {
	        if (!_DOM) {
	            _DOM = adapter;
	        }
	    }
	    /**
	     * Provides DOM operations in an environment-agnostic way.
	     *
	     * \@security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     * @abstract
	     */
	    var DomAdapter = (function () {
	        function DomAdapter() {
	            this.resourceLoaderType = null;
	        }
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.hasProperty = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setProperty = function (el, name, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getProperty = function (el, name) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} methodName
	         * @param {?} args
	         * @return {?}
	         */
	        DomAdapter.prototype.invoke = function (el, methodName, args) { };
	        /**
	         * @abstract
	         * @param {?} error
	         * @return {?}
	         */
	        DomAdapter.prototype.logError = function (error) { };
	        /**
	         * @abstract
	         * @param {?} error
	         * @return {?}
	         */
	        DomAdapter.prototype.log = function (error) { };
	        /**
	         * @abstract
	         * @param {?} error
	         * @return {?}
	         */
	        DomAdapter.prototype.logGroup = function (error) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.logGroupEnd = function () { };
	        Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
	            /**
	             * Maps attribute names to their corresponding property names for cases
	             * where attribute name doesn't match property name.
	             * @return {?}
	             */
	            get: function () { return this._attrToPropMap; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { this._attrToPropMap = value; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        ;
	        /**
	         * @abstract
	         * @param {?} templateHtml
	         * @return {?}
	         */
	        DomAdapter.prototype.parse = function (templateHtml) { };
	        /**
	         * @abstract
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.query = function (selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.querySelector = function (el /** TODO #9100 */, selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.querySelectorAll = function (el /** TODO #9100 */, selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        DomAdapter.prototype.on = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        DomAdapter.prototype.onAndCancel = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} evt
	         * @return {?}
	         */
	        DomAdapter.prototype.dispatchEvent = function (el /** TODO #9100 */, evt) { };
	        /**
	         * @abstract
	         * @param {?} eventType
	         * @return {?}
	         */
	        DomAdapter.prototype.createMouseEvent = function (eventType) { };
	        /**
	         * @abstract
	         * @param {?} eventType
	         * @return {?}
	         */
	        DomAdapter.prototype.createEvent = function (eventType) { };
	        /**
	         * @abstract
	         * @param {?} evt
	         * @return {?}
	         */
	        DomAdapter.prototype.preventDefault = function (evt) { };
	        /**
	         * @abstract
	         * @param {?} evt
	         * @return {?}
	         */
	        DomAdapter.prototype.isPrevented = function (evt) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getInnerHTML = function (el) { };
	        /**
	         * Returns content if el is a <template> element, null otherwise.
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getTemplateContent = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getOuterHTML = function (el) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.nodeName = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.nodeValue = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.type = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.content = function (node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.firstChild = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.nextSibling = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.parentElement = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.childNodes = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.childNodesAsList = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.clearNodes = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.appendChild = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.removeChild = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} newNode
	         * @param {?} oldNode
	         * @return {?}
	         */
	        DomAdapter.prototype.replaceChild = function (el /** TODO #9100 */, newNode /** TODO #9100 */, oldNode) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.remove = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.insertBefore = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} nodes
	         * @return {?}
	         */
	        DomAdapter.prototype.insertAllBefore = function (el /** TODO #9100 */, nodes) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.insertAfter = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setInnerHTML = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getText = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setText = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getValue = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setValue = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getChecked = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setChecked = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} text
	         * @return {?}
	         */
	        DomAdapter.prototype.createComment = function (text) { };
	        /**
	         * @abstract
	         * @param {?} html
	         * @return {?}
	         */
	        DomAdapter.prototype.createTemplate = function (html) { };
	        /**
	         * @abstract
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createElement = function (tagName /** TODO #9100 */, doc) { };
	        /**
	         * @abstract
	         * @param {?} ns
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createElementNS = function (ns, tagName, doc) { };
	        /**
	         * @abstract
	         * @param {?} text
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createTextNode = function (text, doc) { };
	        /**
	         * @abstract
	         * @param {?} attrName
	         * @param {?} attrValue
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) { };
	        /**
	         * @abstract
	         * @param {?} css
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createStyleElement = function (css, doc) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.createShadowRoot = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getShadowRoot = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getHost = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getDistributedNodes = function (el) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.clone /*<T extends Node>*/ = function (node) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getElementsByClassName = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getElementsByTagName = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.classList = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        DomAdapter.prototype.addClass = function (element /** TODO #9100 */, className) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        DomAdapter.prototype.removeClass = function (element /** TODO #9100 */, className) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        DomAdapter.prototype.hasClass = function (element /** TODO #9100 */, className) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        DomAdapter.prototype.setStyle = function (element /** TODO #9100 */, styleName, styleValue) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @return {?}
	         */
	        DomAdapter.prototype.removeStyle = function (element /** TODO #9100 */, styleName) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @return {?}
	         */
	        DomAdapter.prototype.getStyle = function (element /** TODO #9100 */, styleName) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?=} styleValue
	         * @return {?}
	         */
	        DomAdapter.prototype.hasStyle = function (element /** TODO #9100 */, styleName, styleValue) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.tagName = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.attributeMap = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.hasAttribute = function (element /** TODO #9100 */, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.hasAttributeNS = function (element /** TODO #9100 */, ns, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.getAttribute = function (element /** TODO #9100 */, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.getAttributeNS = function (element /** TODO #9100 */, ns, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setAttribute = function (element /** TODO #9100 */, name, value) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setAttributeNS = function (element /** TODO #9100 */, ns, name, value) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.removeAttribute = function (element /** TODO #9100 */, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.removeAttributeNS = function (element /** TODO #9100 */, ns, attribute) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.templateAwareRoot = function (el) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.createHtmlDocument = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.defaultDoc = function () { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getBoundingClientRect = function (el) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getTitle = function () { };
	        /**
	         * @abstract
	         * @param {?} newTitle
	         * @return {?}
	         */
	        DomAdapter.prototype.setTitle = function (newTitle) { };
	        /**
	         * @abstract
	         * @param {?} n
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.elementMatches = function (n /** TODO #9100 */, selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.isTemplateElement = function (el) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isTextNode = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isCommentNode = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isElementNode = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.hasShadowRoot = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isShadowRoot = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (node) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.getHref = function (element) { };
	        /**
	         * @abstract
	         * @param {?} event
	         * @return {?}
	         */
	        DomAdapter.prototype.getEventKey = function (event) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} baseUrl
	         * @param {?} href
	         * @return {?}
	         */
	        DomAdapter.prototype.resolveAndSetHref = function (element /** TODO #9100 */, baseUrl, href) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsDOMEvents = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsNativeShadowDOM = function () { };
	        /**
	         * @abstract
	         * @param {?} target
	         * @return {?}
	         */
	        DomAdapter.prototype.getGlobalEventTarget = function (target) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getHistory = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getLocation = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getBaseHref = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.resetBaseElement = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getUserAgent = function () { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setData = function (element /** TODO #9100 */, name, value) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.getComputedStyle = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getData = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setGlobalVar = function (name, value) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsWebAnimation = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.performanceNow = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getAnimationPrefix = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getTransitionEnd = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsAnimation = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsCookies = function () { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getCookie = function (name) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setCookie = function (name, value) { };
	        return DomAdapter;
	    }());

	    var WebAnimationsPlayer = (function () {
	        /**
	         * @param {?} element
	         * @param {?} keyframes
	         * @param {?} options
	         * @param {?=} previousPlayers
	         */
	        function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
	            var _this = this;
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            this.element = element;
	            this.keyframes = keyframes;
	            this.options = options;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._initialized = false;
	            this._finished = false;
	            this._started = false;
	            this._destroyed = false;
	            this.parentPlayer = null;
	            this._duration = options['duration'];
	            this.previousStyles = {};
	            previousPlayers.forEach(function (player) {
	                var styles = player._captureStyles();
	                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
	            });
	        }
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.init = function () {
	            var _this = this;
	            if (this._initialized)
	                return;
	            this._initialized = true;
	            var /** @type {?} */ keyframes = this.keyframes.map(function (styles) {
	                var /** @type {?} */ formattedKeyframe = {};
	                Object.keys(styles).forEach(function (prop, index) {
	                    var /** @type {?} */ value = styles[prop];
	                    if (value == core.AUTO_STYLE) {
	                        value = _computeStyle(_this.element, prop);
	                    }
	                    if (value != undefined) {
	                        formattedKeyframe[prop] = value;
	                    }
	                });
	                return formattedKeyframe;
	            });
	            var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
	            if (previousStyleProps.length) {
	                var /** @type {?} */ startingKeyframe_1 = keyframes[0];
	                var /** @type {?} */ missingStyleProps_1 = [];
	                previousStyleProps.forEach(function (prop) {
	                    if (!isPresent(startingKeyframe_1[prop])) {
	                        missingStyleProps_1.push(prop);
	                    }
	                    startingKeyframe_1[prop] = _this.previousStyles[prop];
	                });
	                if (missingStyleProps_1.length) {
	                    var _loop_1 = function(i) {
	                        var /** @type {?} */ kf = keyframes[i];
	                        missingStyleProps_1.forEach(function (prop) { kf[prop] = _computeStyle(_this.element, prop); });
	                    };
	                    for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
	                        _loop_1(i);
	                    }
	                }
	            }
	            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
	            this._finalKeyframe = _copyKeyframeStyles(keyframes[keyframes.length - 1]);
	            // this is required so that the player doesn't start to animate right away
	            this._resetDomPlayerState();
	            this._player.addEventListener('finish', function () { return _this._onFinish(); });
	        };
	        /**
	         * \@internal
	         * @param {?} element
	         * @param {?} keyframes
	         * @param {?} options
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
	            // jscompiler doesn't seem to know animate is a native property because it's not fully
	            // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
	            return (element['animate'](keyframes, options));
	        };
	        Object.defineProperty(WebAnimationsPlayer.prototype, "domPlayer", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._player; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.play = function () {
	            this.init();
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._player.play();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.pause = function () {
	            this.init();
	            this._player.pause();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.finish = function () {
	            this.init();
	            this._onFinish();
	            this._player.finish();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.reset = function () {
	            this._resetDomPlayerState();
	            this._destroyed = false;
	            this._finished = false;
	            this._started = false;
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._resetDomPlayerState = function () {
	            if (this._player) {
	                this._player.cancel();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.restart = function () {
	            this.reset();
	            this.play();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.destroy = function () {
	            if (!this._destroyed) {
	                this._resetDomPlayerState();
	                this._onFinish();
	                this._destroyed = true;
	            }
	        };
	        Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._duration; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._captureStyles = function () {
	            var _this = this;
	            var /** @type {?} */ styles = {};
	            if (this.hasStarted()) {
	                Object.keys(this._finalKeyframe).forEach(function (prop) {
	                    if (prop != 'offset') {
	                        styles[prop] =
	                            _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
	                    }
	                });
	            }
	            return styles;
	        };
	        return WebAnimationsPlayer;
	    }());
	    /**
	     * @param {?} element
	     * @param {?} prop
	     * @return {?}
	     */
	    function _computeStyle(element, prop) {
	        return getDOM().getComputedStyle(element)[prop];
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    function _copyKeyframeStyles(styles) {
	        var /** @type {?} */ newStyles = {};
	        Object.keys(styles).forEach(function (prop) {
	            if (prop != 'offset') {
	                newStyles[prop] = styles[prop];
	            }
	        });
	        return newStyles;
	    }

	    var WebAnimationsDriver = (function () {
	        function WebAnimationsDriver() {
	        }
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            var /** @type {?} */ formattedSteps = [];
	            var /** @type {?} */ startingStyleLookup = {};
	            if (isPresent(startingStyles)) {
	                startingStyleLookup = _populateStyles(startingStyles, {});
	            }
	            keyframes.forEach(function (keyframe) {
	                var /** @type {?} */ data = _populateStyles(keyframe.styles, startingStyleLookup);
	                data['offset'] = Math.max(0, Math.min(1, keyframe.offset));
	                formattedSteps.push(data);
	            });
	            // Styling passed into element.animate() must always be balanced.
	            // The special cases below can occur if only style() calls exist
	            // within an animation or when a style() calls are used prior
	            // to a group() animation being issued or if the renderer is
	            // invoked by the user directly.
	            if (formattedSteps.length == 0) {
	                formattedSteps = [startingStyleLookup, startingStyleLookup];
	            }
	            else if (formattedSteps.length == 1) {
	                var /** @type {?} */ start = startingStyleLookup;
	                var /** @type {?} */ end = formattedSteps[0];
	                end['offset'] = null;
	                formattedSteps = [start, end];
	            }
	            var /** @type {?} */ playerOptions = {
	                'duration': duration,
	                'delay': delay,
	                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
	            };
	            // we check for this to avoid having a null|undefined value be present
	            // for the easing (which results in an error for certain browsers #9752)
	            if (easing) {
	                playerOptions['easing'] = easing;
	            }
	            // there may be a chance a NoOp player is returned depending
	            // on when the previous animation was cancelled
	            previousPlayers = previousPlayers.filter(filterWebAnimationPlayerFn);
	            return new WebAnimationsPlayer(element, formattedSteps, playerOptions, /** @type {?} */ (previousPlayers));
	        };
	        return WebAnimationsDriver;
	    }());
	    /**
	     * @param {?} styles
	     * @param {?} defaultStyles
	     * @return {?}
	     */
	    function _populateStyles(styles, defaultStyles) {
	        var /** @type {?} */ data = {};
	        styles.styles.forEach(function (entry) { Object.keys(entry).forEach(function (prop) { data[prop] = entry[prop]; }); });
	        Object.keys(defaultStyles).forEach(function (prop) {
	            if (!isPresent(data[prop])) {
	                data[prop] = defaultStyles[prop];
	            }
	        });
	        return data;
	    }
	    /**
	     * @param {?} player
	     * @return {?}
	     */
	    function filterWebAnimationPlayerFn(player) {
	        return player instanceof WebAnimationsPlayer;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Provides DOM operations in any browser environment.
	     *
	     * \@security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     * @abstract
	     */
	    var GenericBrowserDomAdapter = (function (_super) {
	        __extends$1(GenericBrowserDomAdapter, _super);
	        function GenericBrowserDomAdapter() {
	            var _this = this;
	            _super.call(this);
	            this._animationPrefix = null;
	            this._transitionEnd = null;
	            try {
	                var element_1 = this.createElement('div', this.defaultDoc());
	                if (isPresent(this.getStyle(element_1, 'animationName'))) {
	                    this._animationPrefix = '';
	                }
	                else {
	                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
	                    for (var i = 0; i < domPrefixes.length; i++) {
	                        if (isPresent(this.getStyle(element_1, domPrefixes[i] + 'AnimationName'))) {
	                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
	                            break;
	                        }
	                    }
	                }
	                var transEndEventNames_1 = {
	                    WebkitTransition: 'webkitTransitionEnd',
	                    MozTransition: 'transitionend',
	                    OTransition: 'oTransitionEnd otransitionend',
	                    transition: 'transitionend'
	                };
	                Object.keys(transEndEventNames_1).forEach(function (key) {
	                    if (isPresent(_this.getStyle(element_1, key))) {
	                        _this._transitionEnd = transEndEventNames_1[key];
	                    }
	                });
	            }
	            catch (e) {
	                this._animationPrefix = null;
	                this._transitionEnd = null;
	            }
	        }
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return ((el)).getDistributedNodes(); };
	        /**
	         * @param {?} el
	         * @param {?} baseUrl
	         * @param {?} href
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
	            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	        };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
	            return typeof ((this.defaultDoc().body)).createShadowRoot === 'function';
	        };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
	            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);
	        };
	        return GenericBrowserDomAdapter;
	    }(DomAdapter));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _attrToPropMap = {
	        'class': 'className',
	        'innerHtml': 'innerHTML',
	        'readonly': 'readOnly',
	        'tabindex': 'tabIndex',
	    };
	    var /** @type {?} */ DOM_KEY_LOCATION_NUMPAD = 3;
	    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	    var /** @type {?} */ _keyMap = {
	        // The following values are here for cross-browser compatibility and to match the W3C standard
	        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	        '\b': 'Backspace',
	        '\t': 'Tab',
	        '\x7F': 'Delete',
	        '\x1B': 'Escape',
	        'Del': 'Delete',
	        'Esc': 'Escape',
	        'Left': 'ArrowLeft',
	        'Right': 'ArrowRight',
	        'Up': 'ArrowUp',
	        'Down': 'ArrowDown',
	        'Menu': 'ContextMenu',
	        'Scroll': 'ScrollLock',
	        'Win': 'OS'
	    };
	    // There is a bug in Chrome for numeric keypad keys:
	    // https://code.google.com/p/chromium/issues/detail?id=155654
	    // 1, 2, 3 ... are reported as A, B, C ...
	    var /** @type {?} */ _chromeNumKeyPadMap = {
	        'A': '1',
	        'B': '2',
	        'C': '3',
	        'D': '4',
	        'E': '5',
	        'F': '6',
	        'G': '7',
	        'H': '8',
	        'I': '9',
	        'J': '*',
	        'K': '+',
	        'M': '-',
	        'N': '.',
	        'O': '/',
	        '\x60': '0',
	        '\x90': 'NumLock'
	    };
	    var BrowserDomAdapter = (function (_super) {
	        __extends(BrowserDomAdapter, _super);
	        function BrowserDomAdapter() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} templateHtml
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
	        /**
	         * @param {?} el
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { ((el))[name] = value; };
	        /**
	         * @param {?} el
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getProperty = function (el, name) { return ((el))[name]; };
	        /**
	         * @param {?} el
	         * @param {?} methodName
	         * @param {?} args
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { (_a = ((el)))[methodName].apply(_a, args); var _a; };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.logError = function (error) {
	            if (window.console) {
	                if (console.error) {
	                    console.error(error);
	                }
	                else {
	                    console.log(error);
	                }
	            }
	        };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.log = function (error) {
	            if (window.console) {
	                window.console.log && window.console.log(error);
	            }
	        };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.logGroup = function (error) {
	            if (window.console) {
	                window.console.group && window.console.group(error);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.logGroupEnd = function () {
	            if (window.console) {
	                window.console.groupEnd && window.console.groupEnd();
	            }
	        };
	        Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
	            /**
	             * @return {?}
	             */
	            get: function () { return _attrToPropMap; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
	        /**
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.querySelector = function (el, selector) {
	            return (el.querySelector(selector));
	        };
	        /**
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
	        /**
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
	        /**
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
	            el.addEventListener(evt, listener, false);
	            // Needed to follow Dart's subscription semantic, until fix of
	            // https://code.google.com/p/dart/issues/detail?id=17406
	            return function () { el.removeEventListener(evt, listener, false); };
	        };
	        /**
	         * @param {?} el
	         * @param {?} evt
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
	        /**
	         * @param {?} eventType
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
	            var /** @type {?} */ evt = document.createEvent('MouseEvent');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        };
	        /**
	         * @param {?} eventType
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createEvent = function (eventType) {
	            var /** @type {?} */ evt = document.createEvent('Event');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        };
	        /**
	         * @param {?} evt
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.preventDefault = function (evt) {
	            evt.preventDefault();
	            evt.returnValue = false;
	        };
	        /**
	         * @param {?} evt
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isPrevented = function (evt) {
	            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getTemplateContent = function (el) {
	            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.type = function (node) { return node.type; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.content = function (node) {
	            if (this.hasProperty(node, 'content')) {
	                return ((node)).content;
	            }
	            else {
	                return node;
	            }
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.childNodesAsList = function (el) {
	            var /** @type {?} */ childNodes = el.childNodes;
	            var /** @type {?} */ res = new Array(childNodes.length);
	            for (var /** @type {?} */ i = 0; i < childNodes.length; i++) {
	                res[i] = childNodes[i];
	            }
	            return res;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.clearNodes = function (el) {
	            while (el.firstChild) {
	                el.removeChild(el.firstChild);
	            }
	        };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
	        /**
	         * @param {?} el
	         * @param {?} newChild
	         * @param {?} oldChild
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.remove = function (node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	            return node;
	        };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
	        /**
	         * @param {?} el
	         * @param {?} nodes
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {
	            nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); });
	        };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
	        /**
	         * @param {?} html
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createTemplate = function (html) {
	            var /** @type {?} */ t = document.createElement('template');
	            t.innerHTML = html;
	            return t;
	        };
	        /**
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createElement(tagName);
	        };
	        /**
	         * @param {?} ns
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createElementNS(ns, tagName);
	        };
	        /**
	         * @param {?} text
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createTextNode(text);
	        };
	        /**
	         * @param {?} attrName
	         * @param {?} attrValue
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	            if (doc === void 0) { doc = document; }
	            var /** @type {?} */ el = (doc.createElement('SCRIPT'));
	            el.setAttribute(attrName, attrValue);
	            return el;
	        };
	        /**
	         * @param {?} css
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
	            if (doc === void 0) { doc = document; }
	            var /** @type {?} */ style = (doc.createElement('style'));
	            this.appendChild(style, this.createTextNode(css));
	            return style;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return ((el)).createShadowRoot(); };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return ((el)).shadowRoot; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getHost = function (el) { return ((el)).host; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
	            return element.getElementsByClassName(name);
	        };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
	            return element.getElementsByTagName(name);
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
	        /**
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
	        /**
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
	        /**
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasClass = function (element, className) {
	            return element.classList.contains(className);
	        };
	        /**
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
	            element.style[styleName] = styleValue;
	        };
	        /**
	         * @param {?} element
	         * @param {?} stylename
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
	            // IE requires '' instead of null
	            // see https://github.com/angular/angular/issues/7916
	            element.style[stylename] = '';
	        };
	        /**
	         * @param {?} element
	         * @param {?} stylename
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
	        /**
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?=} styleValue
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
	            if (styleValue === void 0) { styleValue = null; }
	            var /** @type {?} */ value = this.getStyle(element, styleName) || '';
	            return styleValue ? value == styleValue : value.length > 0;
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.attributeMap = function (element) {
	            var /** @type {?} */ res = new Map();
	            var /** @type {?} */ elAttrs = element.attributes;
	            for (var /** @type {?} */ i = 0; i < elAttrs.length; i++) {
	                var /** @type {?} */ attrib = elAttrs[i];
	                res.set(attrib.name, attrib.value);
	            }
	            return res;
	        };
	        /**
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
	            return element.hasAttribute(attribute);
	        };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
	            return element.hasAttributeNS(ns, attribute);
	        };
	        /**
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
	            return element.getAttribute(attribute);
	        };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
	            return element.getAttributeNS(ns, name);
	        };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
	            element.setAttributeNS(ns, name, value);
	        };
	        /**
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
	            element.removeAttributeNS(ns, name);
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createHtmlDocument = function () {
	            return document.implementation.createHTMLDocument('fakeTitle');
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
	            try {
	                return el.getBoundingClientRect();
	            }
	            catch (e) {
	                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
	        /**
	         * @param {?} newTitle
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
	        /**
	         * @param {?} n
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
	            if (n instanceof HTMLElement) {
	                return n.matches && n.matches(selector) ||
	                    n.msMatchesSelector && n.msMatchesSelector(selector) ||
	                    n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
	            }
	            return false;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isTemplateElement = function (el) {
	            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
	        };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
	            return isPresent(node.shadowRoot) && node instanceof HTMLElement;
	        };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getHref = function (el) { return ((el)).href; };
	        /**
	         * @param {?} event
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getEventKey = function (event) {
	            var /** @type {?} */ key = event.key;
	            if (isBlank(key)) {
	                key = event.keyIdentifier;
	                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	                // Safari cf
	                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	                if (isBlank(key)) {
	                    return 'Unidentified';
	                }
	                if (key.startsWith('U+')) {
	                    key = String.fromCharCode(parseInt(key.substring(2), 16));
	                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                        // There is a bug in Chrome for numeric keypad keys:
	                        // https://code.google.com/p/chromium/issues/detail?id=155654
	                        // 1, 2, 3 ... are reported as A, B, C ...
	                        key = ((_chromeNumKeyPadMap))[key];
	                    }
	                }
	            }
	            return _keyMap[key] || key;
	        };
	        /**
	         * @param {?} target
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
	            if (target === 'window') {
	                return window;
	            }
	            if (target === 'document') {
	                return document;
	            }
	            if (target === 'body') {
	                return document.body;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getBaseHref = function () {
	            var /** @type {?} */ href = getBaseElementHref();
	            return isBlank(href) ? null : relativePath(href);
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setData = function (element, name, value) {
	            this.setAttribute(element, 'data-' + name, value);
	        };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getData = function (element, name) {
	            return this.getAttribute(element, 'data-' + name);
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
	        /**
	         * @param {?} path
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.supportsWebAnimation = function () {
	            return typeof ((Element)).prototype['animate'] === 'function';
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.performanceNow = function () {
	            // performance.now() is not available in all browsers, see
	            // http://caniuse.com/#search=performance.now
	            return window.performance && window.performance.now ? window.performance.now() :
	                new Date().getTime();
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setCookie = function (name, value) {
	            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
	            // not clear other cookies.
	            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	        };
	        return BrowserDomAdapter;
	    }(GenericBrowserDomAdapter));
	    var /** @type {?} */ baseElement = null;
	    /**
	     * @return {?}
	     */
	    function getBaseElementHref() {
	        if (!baseElement) {
	            baseElement = document.querySelector('base');
	            if (!baseElement) {
	                return null;
	            }
	        }
	        return baseElement.getAttribute('href');
	    }
	    // based on urlUtils.js in AngularJS 1
	    var /** @type {?} */ urlParsingNode;
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function relativePath(url) {
	        if (!urlParsingNode) {
	            urlParsingNode = document.createElement('a');
	        }
	        urlParsingNode.setAttribute('href', url);
	        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname;
	    }
	    /**
	     * @param {?} cookieStr
	     * @param {?} name
	     * @return {?}
	     */
	    function parseCookieValue(cookieStr, name) {
	        name = encodeURIComponent(name);
	        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
	            var cookie = _a[_i];
	            var /** @type {?} */ eqIndex = cookie.indexOf('=');
	            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
	            if (cookieName.trim() === name) {
	                return decodeURIComponent(cookieValue);
	            }
	        }
	        return null;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     * @return {?}
	     */
	    function supportsState() {
	        return !!window.history.pushState;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
	     * This class should not be used directly by an application developer. Instead, use
	     * {\@link Location}.
	     */
	    var BrowserPlatformLocation = (function (_super) {
	        __extends$2(BrowserPlatformLocation, _super);
	        function BrowserPlatformLocation() {
	            _super.call(this);
	            this._init();
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype._init = function () {
	            this._location = getDOM().getLocation();
	            this._history = getDOM().getHistory();
	        };
	        Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.onPopState = function (fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.onHashChange = function (fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
	        };
	        Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location.pathname; },
	            /**
	             * @param {?} newPath
	             * @return {?}
	             */
	            set: function (newPath) { this._location.pathname = newPath; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location.search; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location.hash; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
	            if (supportsState()) {
	                this._history.pushState(state, title, url);
	            }
	            else {
	                this._location.hash = url;
	            }
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
	            if (supportsState()) {
	                this._history.replaceState(state, title, url);
	            }
	            else {
	                this._location.hash = url;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
	        /**
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
	        BrowserPlatformLocation.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        BrowserPlatformLocation.ctorParameters = function () { return []; };
	        return BrowserPlatformLocation;
	    }(_angular_common.PlatformLocation));

	    var BrowserGetTestability = (function () {
	        function BrowserGetTestability() {
	        }
	        /**
	         * @return {?}
	         */
	        BrowserGetTestability.init = function () { core.setTestabilityGetter(new BrowserGetTestability()); };
	        /**
	         * @param {?} registry
	         * @return {?}
	         */
	        BrowserGetTestability.prototype.addToWindow = function (registry) {
	            global$1.getAngularTestability = function (elem, findInAncestors) {
	                if (findInAncestors === void 0) { findInAncestors = true; }
	                var /** @type {?} */ testability = registry.findTestabilityInTree(elem, findInAncestors);
	                if (testability == null) {
	                    throw new Error('Could not find testability for element.');
	                }
	                return testability;
	            };
	            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };
	            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
	            var /** @type {?} */ whenAllStable = function (callback /** TODO #9100 */) {
	                var /** @type {?} */ testabilities = global$1.getAllAngularTestabilities();
	                var /** @type {?} */ count = testabilities.length;
	                var /** @type {?} */ didWork = false;
	                var /** @type {?} */ decrement = function (didWork_ /** TODO #9100 */) {
	                    didWork = didWork || didWork_;
	                    count--;
	                    if (count == 0) {
	                        callback(didWork);
	                    }
	                };
	                testabilities.forEach(function (testability /** TODO #9100 */) {
	                    testability.whenStable(decrement);
	                });
	            };
	            if (!global$1['frameworkStabilizers']) {
	                global$1['frameworkStabilizers'] = [];
	            }
	            global$1['frameworkStabilizers'].push(whenAllStable);
	        };
	        /**
	         * @param {?} registry
	         * @param {?} elem
	         * @param {?} findInAncestors
	         * @return {?}
	         */
	        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	            if (elem == null) {
	                return null;
	            }
	            var /** @type {?} */ t = registry.getTestability(elem);
	            if (isPresent(t)) {
	                return t;
	            }
	            else if (!findInAncestors) {
	                return null;
	            }
	            if (getDOM().isShadowRoot(elem)) {
	                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
	            }
	            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
	        };
	        return BrowserGetTestability;
	    }());

	    /**
	     * A service that can be used to get and set the title of a current HTML document.
	     *
	     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
	     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
	     * (representing the `<title>` tag). Instead, this service can be used to set and get the current
	     * title value.
	     *
	     * \@experimental
	     */
	    var Title = (function () {
	        function Title() {
	        }
	        /**
	         * Get the title of the current HTML document.
	         * @return {?}
	         */
	        Title.prototype.getTitle = function () { return getDOM().getTitle(); };
	        /**
	         * Set the title of the current HTML document.
	         * @param {?} newTitle
	         * @return {?}
	         */
	        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };
	        return Title;
	    }());

	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());

	    /**
	     * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	     *
	     * Note: Document might not be available in the Application Context when Application and Rendering
	     * Contexts are not the same (e.g. when running the application into a Web Worker).
	     *
	     * @stable
	     */
	    var /** @type {?} */ DOCUMENT = new core.OpaqueToken('DocumentToken');

	    /**
	     * @stable
	     */
	    var /** @type {?} */ EVENT_MANAGER_PLUGINS = new core.OpaqueToken('EventManagerPlugins');
	    /**
	     * \@stable
	     */
	    var EventManager = (function () {
	        /**
	         * @param {?} plugins
	         * @param {?} _zone
	         */
	        function EventManager(plugins, _zone) {
	            var _this = this;
	            this._zone = _zone;
	            this._eventNameToPlugin = new Map();
	            plugins.forEach(function (p) { return p.manager = _this; });
	            this._plugins = plugins.slice().reverse();
	        }
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManager.prototype.addEventListener = function (element, eventName, handler) {
	            var /** @type {?} */ plugin = this._findPluginFor(eventName);
	            return plugin.addEventListener(element, eventName, handler);
	        };
	        /**
	         * @param {?} target
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
	            var /** @type {?} */ plugin = this._findPluginFor(eventName);
	            return plugin.addGlobalEventListener(target, eventName, handler);
	        };
	        /**
	         * @return {?}
	         */
	        EventManager.prototype.getZone = function () { return this._zone; };
	        /**
	         * \@internal
	         * @param {?} eventName
	         * @return {?}
	         */
	        EventManager.prototype._findPluginFor = function (eventName) {
	            var /** @type {?} */ plugin = this._eventNameToPlugin.get(eventName);
	            if (plugin) {
	                return plugin;
	            }
	            var /** @type {?} */ plugins = this._plugins;
	            for (var /** @type {?} */ i = 0; i < plugins.length; i++) {
	                var /** @type {?} */ plugin_1 = plugins[i];
	                if (plugin_1.supports(eventName)) {
	                    this._eventNameToPlugin.set(eventName, plugin_1);
	                    return plugin_1;
	                }
	            }
	            throw new Error("No event manager plugin found for event " + eventName);
	        };
	        EventManager.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        EventManager.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },
	            { type: core.NgZone, },
	        ]; };
	        return EventManager;
	    }());
	    /**
	     * @abstract
	     */
	    var EventManagerPlugin = (function () {
	        function EventManagerPlugin() {
	        }
	        /**
	         * @abstract
	         * @param {?} eventName
	         * @return {?}
	         */
	        EventManagerPlugin.prototype.supports = function (eventName) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) { };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
	            var /** @type {?} */ target = getDOM().getGlobalEventTarget(element);
	            if (!target) {
	                throw new Error("Unsupported event target " + target + " for event " + eventName);
	            }
	            return this.addEventListener(target, eventName, handler);
	        };
	        ;
	        return EventManagerPlugin;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var SharedStylesHost = (function () {
	        function SharedStylesHost() {
	            /** @internal */
	            this._stylesSet = new Set();
	        }
	        /**
	         * @param {?} styles
	         * @return {?}
	         */
	        SharedStylesHost.prototype.addStyles = function (styles) {
	            var _this = this;
	            var /** @type {?} */ additions = new Set();
	            styles.forEach(function (style) {
	                if (!_this._stylesSet.has(style)) {
	                    _this._stylesSet.add(style);
	                    additions.add(style);
	                }
	            });
	            this.onStylesAdded(additions);
	        };
	        /**
	         * @param {?} additions
	         * @return {?}
	         */
	        SharedStylesHost.prototype.onStylesAdded = function (additions) { };
	        /**
	         * @return {?}
	         */
	        SharedStylesHost.prototype.getAllStyles = function () { return Array.from(this._stylesSet); };
	        SharedStylesHost.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        SharedStylesHost.ctorParameters = function () { return []; };
	        return SharedStylesHost;
	    }());
	    var DomSharedStylesHost = (function (_super) {
	        __extends$4(DomSharedStylesHost, _super);
	        /**
	         * @param {?} _doc
	         */
	        function DomSharedStylesHost(_doc) {
	            _super.call(this);
	            this._doc = _doc;
	            this._hostNodes = new Set();
	            this._styleNodes = new Set();
	            this._hostNodes.add(_doc.head);
	        }
	        /**
	         * @param {?} styles
	         * @param {?} host
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
	            var _this = this;
	            styles.forEach(function (style) {
	                var /** @type {?} */ styleEl = _this._doc.createElement('style');
	                styleEl.textContent = style;
	                _this._styleNodes.add(host.appendChild(styleEl));
	            });
	        };
	        /**
	         * @param {?} hostNode
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.addHost = function (hostNode) {
	            this._addStylesToHost(this._stylesSet, hostNode);
	            this._hostNodes.add(hostNode);
	        };
	        /**
	         * @param {?} hostNode
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
	        /**
	         * @param {?} additions
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
	            var _this = this;
	            this._hostNodes.forEach(function (hostNode) { return _this._addStylesToHost(additions, hostNode); });
	        };
	        /**
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.ngOnDestroy = function () { this._styleNodes.forEach(function (styleNode) { return getDOM().remove(styleNode); }); };
	        DomSharedStylesHost.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomSharedStylesHost.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: core.Inject, args: [DOCUMENT,] },] },
	        ]; };
	        return DomSharedStylesHost;
	    }(SharedStylesHost));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ NAMESPACE_URIS = {
	        'xlink': 'http://www.w3.org/1999/xlink',
	        'svg': 'http://www.w3.org/2000/svg',
	        'xhtml': 'http://www.w3.org/1999/xhtml'
	    };
	    var /** @type {?} */ TEMPLATE_COMMENT_TEXT = 'template bindings={}';
	    var /** @type {?} */ TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
	    /**
	     * @abstract
	     */
	    var DomRootRenderer = (function () {
	        /**
	         * @param {?} document
	         * @param {?} eventManager
	         * @param {?} sharedStylesHost
	         * @param {?} animationDriver
	         * @param {?} appId
	         */
	        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver, appId) {
	            this.document = document;
	            this.eventManager = eventManager;
	            this.sharedStylesHost = sharedStylesHost;
	            this.animationDriver = animationDriver;
	            this.appId = appId;
	            this.registeredComponents = new Map();
	        }
	        /**
	         * @param {?} componentProto
	         * @return {?}
	         */
	        DomRootRenderer.prototype.renderComponent = function (componentProto) {
	            var /** @type {?} */ renderer = this.registeredComponents.get(componentProto.id);
	            if (!renderer) {
	                renderer = new DomRenderer(this, componentProto, this.animationDriver, this.appId + "-" + componentProto.id);
	                this.registeredComponents.set(componentProto.id, renderer);
	            }
	            return renderer;
	        };
	        return DomRootRenderer;
	    }());
	    var DomRootRenderer_ = (function (_super) {
	        __extends$3(DomRootRenderer_, _super);
	        /**
	         * @param {?} _document
	         * @param {?} _eventManager
	         * @param {?} sharedStylesHost
	         * @param {?} animationDriver
	         * @param {?} appId
	         */
	        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver, appId) {
	            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver, appId);
	        }
	        DomRootRenderer_.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomRootRenderer_.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: core.Inject, args: [DOCUMENT,] },] },
	            { type: EventManager, },
	            { type: DomSharedStylesHost, },
	            { type: AnimationDriver, },
	            { type: undefined, decorators: [{ type: core.Inject, args: [core.APP_ID,] },] },
	        ]; };
	        return DomRootRenderer_;
	    }(DomRootRenderer));
	    var /** @type {?} */ DIRECT_DOM_RENDERER = {
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        remove: function (node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	        },
	        /**
	         * @param {?} node
	         * @param {?} parent
	         * @return {?}
	         */
	        appendChild: function (node, parent) { parent.appendChild(node); },
	        /**
	         * @param {?} node
	         * @param {?} refNode
	         * @return {?}
	         */
	        insertBefore: function (node, refNode) { refNode.parentNode.insertBefore(node, refNode); },
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        nextSibling: function (node) { return node.nextSibling; },
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        parentElement: function (node) { return (node.parentNode); }
	    };
	    var DomRenderer = (function () {
	        /**
	         * @param {?} _rootRenderer
	         * @param {?} componentProto
	         * @param {?} _animationDriver
	         * @param {?} styleShimId
	         */
	        function DomRenderer(_rootRenderer, componentProto, _animationDriver, styleShimId) {
	            this._rootRenderer = _rootRenderer;
	            this.componentProto = componentProto;
	            this._animationDriver = _animationDriver;
	            this.directRenderer = DIRECT_DOM_RENDERER;
	            this._styles = flattenStyles(styleShimId, componentProto.styles, []);
	            if (componentProto.encapsulation !== core.ViewEncapsulation.Native) {
	                this._rootRenderer.sharedStylesHost.addStyles(this._styles);
	            }
	            if (this.componentProto.encapsulation === core.ViewEncapsulation.Emulated) {
	                this._contentAttr = shimContentAttribute(styleShimId);
	                this._hostAttr = shimHostAttribute(styleShimId);
	            }
	            else {
	                this._contentAttr = null;
	                this._hostAttr = null;
	            }
	        }
	        /**
	         * @param {?} selectorOrNode
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	            var /** @type {?} */ el;
	            if (typeof selectorOrNode === 'string') {
	                el = this._rootRenderer.document.querySelector(selectorOrNode);
	                if (!el) {
	                    throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
	                }
	            }
	            else {
	                el = selectorOrNode;
	            }
	            while (el.firstChild) {
	                el.removeChild(el.firstChild);
	            }
	            return el;
	        };
	        /**
	         * @param {?} parent
	         * @param {?} name
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
	            var /** @type {?} */ el;
	            if (isNamespaced(name)) {
	                var /** @type {?} */ nsAndName = splitNamespace(name);
	                el = document.createElementNS((NAMESPACE_URIS)[nsAndName[0]], nsAndName[1]);
	            }
	            else {
	                el = document.createElement(name);
	            }
	            if (this._contentAttr) {
	                el.setAttribute(this._contentAttr, '');
	            }
	            if (parent) {
	                parent.appendChild(el);
	            }
	            return el;
	        };
	        /**
	         * @param {?} hostElement
	         * @return {?}
	         */
	        DomRenderer.prototype.createViewRoot = function (hostElement) {
	            var /** @type {?} */ nodesParent;
	            if (this.componentProto.encapsulation === core.ViewEncapsulation.Native) {
	                nodesParent = ((hostElement)).createShadowRoot();
	                for (var /** @type {?} */ i = 0; i < this._styles.length; i++) {
	                    var /** @type {?} */ styleEl = document.createElement('style');
	                    styleEl.textContent = this._styles[i];
	                    nodesParent.appendChild(styleEl);
	                }
	            }
	            else {
	                if (this._hostAttr) {
	                    hostElement.setAttribute(this._hostAttr, '');
	                }
	                nodesParent = hostElement;
	            }
	            return nodesParent;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	            var /** @type {?} */ comment = document.createComment(TEMPLATE_COMMENT_TEXT);
	            if (parentElement) {
	                parentElement.appendChild(comment);
	            }
	            return comment;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} value
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	            var /** @type {?} */ node = document.createTextNode(value);
	            if (parentElement) {
	                parentElement.appendChild(node);
	            }
	            return node;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} nodes
	         * @return {?}
	         */
	        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	            if (!parentElement)
	                return;
	            appendNodes(parentElement, nodes);
	        };
	        /**
	         * @param {?} node
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };
	        /**
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DomRenderer.prototype.detachView = function (viewRootNodes) {
	            for (var /** @type {?} */ i = 0; i < viewRootNodes.length; i++) {
	                var /** @type {?} */ node = viewRootNodes[i];
	                if (node.parentNode) {
	                    node.parentNode.removeChild(node);
	                }
	            }
	        };
	        /**
	         * @param {?} hostElement
	         * @param {?} viewAllNodes
	         * @return {?}
	         */
	        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	            if (this.componentProto.encapsulation === core.ViewEncapsulation.Native && hostElement) {
	                this._rootRenderer.sharedStylesHost.removeHost(((hostElement)).shadowRoot);
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DomRenderer.prototype.listen = function (renderElement, name, callback) {
	            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
	        };
	        /**
	         * @param {?} target
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DomRenderer.prototype.listenGlobal = function (target, name, callback) {
	            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	            ((renderElement))[propertyName] = propertyValue;
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} attributeName
	         * @param {?} attributeValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	            var /** @type {?} */ attrNs;
	            var /** @type {?} */ attrNameWithoutNs = attributeName;
	            if (isNamespaced(attributeName)) {
	                var /** @type {?} */ nsAndName = splitNamespace(attributeName);
	                attrNameWithoutNs = nsAndName[1];
	                attributeName = nsAndName[0] + ':' + nsAndName[1];
	                attrNs = NAMESPACE_URIS[nsAndName[0]];
	            }
	            if (isPresent(attributeValue)) {
	                if (attrNs) {
	                    renderElement.setAttributeNS(attrNs, attributeName, attributeValue);
	                }
	                else {
	                    renderElement.setAttribute(attributeName, attributeValue);
	                }
	            }
	            else {
	                if (isPresent(attrNs)) {
	                    renderElement.removeAttributeNS(attrNs, attrNameWithoutNs);
	                }
	                else {
	                    renderElement.removeAttribute(attributeName);
	                }
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	            if (renderElement.nodeType === Node.COMMENT_NODE) {
	                var /** @type {?} */ existingBindings = renderElement.nodeValue.replace(/\n/g, '').match(TEMPLATE_BINDINGS_EXP);
	                var /** @type {?} */ parsedBindings = JSON.parse(existingBindings[1]);
	                parsedBindings[propertyName] = propertyValue;
	                renderElement.nodeValue =
	                    TEMPLATE_COMMENT_TEXT.replace('{}', JSON.stringify(parsedBindings, null, 2));
	            }
	            else {
	                this.setElementAttribute(renderElement, propertyName, propertyValue);
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} className
	         * @param {?} isAdd
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	            if (isAdd) {
	                renderElement.classList.add(className);
	            }
	            else {
	                renderElement.classList.remove(className);
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	            if (isPresent(styleValue)) {
	                ((renderElement.style))[styleName] = stringify(styleValue);
	            }
	            else {
	                // IE requires '' instead of null
	                // see https://github.com/angular/angular/issues/7916
	                ((renderElement.style))[styleName] = '';
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} methodName
	         * @param {?} args
	         * @return {?}
	         */
	        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	            ((renderElement))[methodName].apply(renderElement, args);
	        };
	        /**
	         * @param {?} renderNode
	         * @param {?} text
	         * @return {?}
	         */
	        DomRenderer.prototype.setText = function (renderNode, text) { renderNode.nodeValue = text; };
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            if (this._rootRenderer.document.body.contains(element)) {
	                return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing, previousPlayers);
	            }
	            return new NoOpAnimationPlayer();
	        };
	        return DomRenderer;
	    }());
	    /**
	     * @param {?} sibling
	     * @param {?} nodes
	     * @return {?}
	     */
	    function moveNodesAfterSibling(sibling, nodes) {
	        var /** @type {?} */ parent = sibling.parentNode;
	        if (nodes.length > 0 && parent) {
	            var /** @type {?} */ nextSibling = sibling.nextSibling;
	            if (nextSibling) {
	                for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	                    parent.insertBefore(nodes[i], nextSibling);
	                }
	            }
	            else {
	                for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	                    parent.appendChild(nodes[i]);
	                }
	            }
	        }
	    }
	    /**
	     * @param {?} parent
	     * @param {?} nodes
	     * @return {?}
	     */
	    function appendNodes(parent, nodes) {
	        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	            parent.appendChild(nodes[i]);
	        }
	    }
	    /**
	     * @param {?} eventHandler
	     * @return {?}
	     */
	    function decoratePreventDefault(eventHandler) {
	        return function (event) {
	            var /** @type {?} */ allowDefaultBehavior = eventHandler(event);
	            if (allowDefaultBehavior === false) {
	                // TODO(tbosch): move preventDefault into event plugins...
	                event.preventDefault();
	                event.returnValue = false;
	            }
	        };
	    }
	    var /** @type {?} */ COMPONENT_REGEX = /%COMP%/g;
	    var /** @type {?} */ COMPONENT_VARIABLE = '%COMP%';
	    var /** @type {?} */ HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
	    var /** @type {?} */ CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
	    /**
	     * @param {?} componentShortId
	     * @return {?}
	     */
	    function shimContentAttribute(componentShortId) {
	        return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
	    }
	    /**
	     * @param {?} componentShortId
	     * @return {?}
	     */
	    function shimHostAttribute(componentShortId) {
	        return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
	    }
	    /**
	     * @param {?} compId
	     * @param {?} styles
	     * @param {?} target
	     * @return {?}
	     */
	    function flattenStyles(compId, styles, target) {
	        for (var /** @type {?} */ i = 0; i < styles.length; i++) {
	            var /** @type {?} */ style = styles[i];
	            if (Array.isArray(style)) {
	                flattenStyles(compId, style, target);
	            }
	            else {
	                style = style.replace(COMPONENT_REGEX, compId);
	                target.push(style);
	            }
	        }
	        return target;
	    }
	    var /** @type {?} */ NS_PREFIX_RE = /^:([^:]+):(.+)$/;
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function isNamespaced(name) {
	        return name[0] === ':';
	    }
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function splitNamespace(name) {
	        var /** @type {?} */ match = name.match(NS_PREFIX_RE);
	        return [match[1], match[2]];
	    }

	    var /** @type {?} */ CORE_TOKENS = {
	        'ApplicationRef': core.ApplicationRef,
	        'NgZone': core.NgZone,
	    };
	    var /** @type {?} */ INSPECT_GLOBAL_NAME = 'ng.probe';
	    var /** @type {?} */ CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
	    /**
	     * Returns a {\@link DebugElement} for the given native DOM element, or
	     * null if the given native element does not have an Angular view associated
	     * with it.
	     * @param {?} element
	     * @return {?}
	     */
	    function inspectNativeElement(element) {
	        return core.getDebugNode(element);
	    }
	    /**
	     * Deprecated. Use the one from '\@angular/core'.
	     * @deprecated
	     */
	    var NgProbeToken = (function () {
	        /**
	         * @param {?} name
	         * @param {?} token
	         */
	        function NgProbeToken(name, token) {
	            this.name = name;
	            this.token = token;
	        }
	        return NgProbeToken;
	    }());
	    /**
	     * @param {?} rootRenderer
	     * @param {?} extraTokens
	     * @param {?} coreTokens
	     * @return {?}
	     */
	    function _createConditionalRootRenderer(rootRenderer, extraTokens, coreTokens) {
	        return core.isDevMode() ?
	            _createRootRenderer(rootRenderer, (extraTokens || []).concat(coreTokens || [])) :
	            rootRenderer;
	    }
	    /**
	     * @param {?} rootRenderer
	     * @param {?} extraTokens
	     * @return {?}
	     */
	    function _createRootRenderer(rootRenderer, extraTokens) {
	        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));
	        return new DebugDomRootRenderer(rootRenderer);
	    }
	    /**
	     * @param {?} tokens
	     * @return {?}
	     */
	    function _ngProbeTokensToMap(tokens) {
	        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
	    }
	    /**
	     * Providers which support debugging Angular applications (e.g. via `ng.probe`).
	     */
	    var /** @type {?} */ ELEMENT_PROBE_PROVIDERS = [{
	            provide: core.RootRenderer,
	            useFactory: _createConditionalRootRenderer,
	            deps: [
	                DomRootRenderer, [NgProbeToken, new core.Optional()],
	                [core.NgProbeToken, new core.Optional()]
	            ]
	        }];

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var DomEventsPlugin = (function (_super) {
	        __extends$5(DomEventsPlugin, _super);
	        function DomEventsPlugin() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        DomEventsPlugin.prototype.supports = function (eventName) { return true; };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            element.addEventListener(eventName, /** @type {?} */ (handler), false);
	            return function () { return element.removeEventListener(eventName, /** @type {?} */ (handler), false); };
	        };
	        DomEventsPlugin.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomEventsPlugin.ctorParameters = function () { return []; };
	        return DomEventsPlugin;
	    }(EventManagerPlugin));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ EVENT_NAMES = {
	        // pan
	        'pan': true,
	        'panstart': true,
	        'panmove': true,
	        'panend': true,
	        'pancancel': true,
	        'panleft': true,
	        'panright': true,
	        'panup': true,
	        'pandown': true,
	        // pinch
	        'pinch': true,
	        'pinchstart': true,
	        'pinchmove': true,
	        'pinchend': true,
	        'pinchcancel': true,
	        'pinchin': true,
	        'pinchout': true,
	        // press
	        'press': true,
	        'pressup': true,
	        // rotate
	        'rotate': true,
	        'rotatestart': true,
	        'rotatemove': true,
	        'rotateend': true,
	        'rotatecancel': true,
	        // swipe
	        'swipe': true,
	        'swipeleft': true,
	        'swiperight': true,
	        'swipeup': true,
	        'swipedown': true,
	        // tap
	        'tap': true,
	    };
	    /**
	     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
	     * Hammer gestures.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ HAMMER_GESTURE_CONFIG = new core.OpaqueToken('HammerGestureConfig');
	    /**
	     * \@experimental
	     */
	    var HammerGestureConfig = (function () {
	        function HammerGestureConfig() {
	            this.events = [];
	            this.overrides = {};
	        }
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        HammerGestureConfig.prototype.buildHammer = function (element) {
	            var /** @type {?} */ mc = new Hammer(element);
	            mc.get('pinch').set({ enable: true });
	            mc.get('rotate').set({ enable: true });
	            for (var eventName in this.overrides) {
	                mc.get(eventName).set(this.overrides[eventName]);
	            }
	            return mc;
	        };
	        HammerGestureConfig.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        HammerGestureConfig.ctorParameters = function () { return []; };
	        return HammerGestureConfig;
	    }());
	    var HammerGesturesPlugin = (function (_super) {
	        __extends$6(HammerGesturesPlugin, _super);
	        /**
	         * @param {?} _config
	         */
	        function HammerGesturesPlugin(_config) {
	            _super.call(this);
	            this._config = _config;
	        }
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        HammerGesturesPlugin.prototype.supports = function (eventName) {
	            if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
	                return false;
	            }
	            if (!((window)).Hammer) {
	                throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
	            }
	            return true;
	        };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var _this = this;
	            var /** @type {?} */ zone = this.manager.getZone();
	            eventName = eventName.toLowerCase();
	            return zone.runOutsideAngular(function () {
	                // Creating the manager bind events, must be done outside of angular
	                var /** @type {?} */ mc = _this._config.buildHammer(element);
	                var /** @type {?} */ callback = function (eventObj) {
	                    zone.runGuarded(function () { handler(eventObj); });
	                };
	                mc.on(eventName, callback);
	                return function () { return mc.off(eventName, callback); };
	            });
	        };
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
	        HammerGesturesPlugin.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        HammerGesturesPlugin.ctorParameters = function () { return [
	            { type: HammerGestureConfig, decorators: [{ type: core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },
	        ]; };
	        return HammerGesturesPlugin;
	    }(EventManagerPlugin));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
	    var /** @type {?} */ MODIFIER_KEY_GETTERS = {
	        'alt': function (event) { return event.altKey; },
	        'control': function (event) { return event.ctrlKey; },
	        'meta': function (event) { return event.metaKey; },
	        'shift': function (event) { return event.shiftKey; }
	    };
	    /**
	     * \@experimental
	     */
	    var KeyEventsPlugin = (function (_super) {
	        __extends$7(KeyEventsPlugin, _super);
	        function KeyEventsPlugin() {
	            _super.call(this);
	        }
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        KeyEventsPlugin.prototype.supports = function (eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var /** @type {?} */ parsedEvent = KeyEventsPlugin.parseEventName(eventName);
	            var /** @type {?} */ outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
	            return this.manager.getZone().runOutsideAngular(function () {
	                return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
	            });
	        };
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        KeyEventsPlugin.parseEventName = function (eventName) {
	            var /** @type {?} */ parts = eventName.toLowerCase().split('.');
	            var /** @type {?} */ domEventName = parts.shift();
	            if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
	                return null;
	            }
	            var /** @type {?} */ key = KeyEventsPlugin._normalizeKey(parts.pop());
	            var /** @type {?} */ fullKey = '';
	            MODIFIER_KEYS.forEach(function (modifierName) {
	                var /** @type {?} */ index = parts.indexOf(modifierName);
	                if (index > -1) {
	                    parts.splice(index, 1);
	                    fullKey += modifierName + '.';
	                }
	            });
	            fullKey += key;
	            if (parts.length != 0 || key.length === 0) {
	                // returning null instead of throwing to let another plugin process the event
	                return null;
	            }
	            var /** @type {?} */ result = {};
	            result['domEventName'] = domEventName;
	            result['fullKey'] = fullKey;
	            return result;
	        };
	        /**
	         * @param {?} event
	         * @return {?}
	         */
	        KeyEventsPlugin.getEventFullKey = function (event) {
	            var /** @type {?} */ fullKey = '';
	            var /** @type {?} */ key = getDOM().getEventKey(event);
	            key = key.toLowerCase();
	            if (key === ' ') {
	                key = 'space'; // for readability
	            }
	            else if (key === '.') {
	                key = 'dot'; // because '.' is used as a separator in event names
	            }
	            MODIFIER_KEYS.forEach(function (modifierName) {
	                if (modifierName != key) {
	                    var /** @type {?} */ modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
	                    if (modifierGetter(event)) {
	                        fullKey += modifierName + '.';
	                    }
	                }
	            });
	            fullKey += key;
	            return fullKey;
	        };
	        /**
	         * @param {?} fullKey
	         * @param {?} handler
	         * @param {?} zone
	         * @return {?}
	         */
	        KeyEventsPlugin.eventCallback = function (fullKey, handler, zone) {
	            return function (event /** TODO #9100 */) {
	                if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
	                    zone.runGuarded(function () { return handler(event); });
	                }
	            };
	        };
	        /**
	         * \@internal
	         * @param {?} keyName
	         * @return {?}
	         */
	        KeyEventsPlugin._normalizeKey = function (keyName) {
	            // TODO: switch to a Map if the mapping grows too much
	            switch (keyName) {
	                case 'esc':
	                    return 'escape';
	                default:
	                    return keyName;
	            }
	        };
	        KeyEventsPlugin.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        KeyEventsPlugin.ctorParameters = function () { return []; };
	        return KeyEventsPlugin;
	    }(EventManagerPlugin));

	    /**
	     * A pattern that recognizes a commonly useful subset of URLs that are safe.
	     *
	     * This regular expression matches a subset of URLs that will not cause script
	     * execution if used in URL context within a HTML document. Specifically, this
	     * regular expression matches if (comment from here on and regex copied from
	     * Soy's EscapingConventions):
	     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
	     * (2) or no protocol.  A protocol must be followed by a colon. The below
	     *     allows that by allowing colons only after one of the characters [/?#].
	     *     A colon after a hash (#) must be in the fragment.
	     *     Otherwise, a colon after a (?) must be in a query.
	     *     Otherwise, a colon after a single solidus (/) must be in a path.
	     *     Otherwise, a colon after a double solidus (//) must be in the authority
	     *     (before port).
	     *
	     * The pattern disallows &, used in HTML entity declarations before
	     * one of the characters in [/?#]. This disallows HTML entities used in the
	     * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
	     * It also disallows HTML entities in the first path part of a relative path,
	     * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
	     * that. More importantly, it disallows masking of a colon,
	     * e.g. "javascript&#58;...".
	     *
	     * This regular expression was taken from the Closure sanitization library.
	     */
	    var /** @type {?} */ SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */
	    var /** @type {?} */ DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function sanitizeUrl(url) {
	        url = String(url);
	        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
	            return url;
	        if (core.isDevMode()) {
	            getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
	        }
	        return 'unsafe:' + url;
	    }
	    /**
	     * @param {?} srcset
	     * @return {?}
	     */
	    function sanitizeSrcset(srcset) {
	        srcset = String(srcset);
	        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
	    }

	    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
	    var /** @type {?} */ inertElement = null;
	    /** Lazily initialized to make sure the DOM adapter gets set before use. */
	    var /** @type {?} */ DOM = null;
	    /**
	     * Returns an HTML element that is guaranteed to not execute code when creating elements in it.
	     * @return {?}
	     */
	    function getInertElement() {
	        if (inertElement)
	            return inertElement;
	        DOM = getDOM();
	        // Prefer using <template> element if supported.
	        var /** @type {?} */ templateEl = DOM.createElement('template');
	        if ('content' in templateEl)
	            return templateEl;
	        var /** @type {?} */ doc = DOM.createHtmlDocument();
	        inertElement = DOM.querySelector(doc, 'body');
	        if (inertElement == null) {
	            // usually there should be only one body element in the document, but IE doesn't have any, so we
	            // need to create one.
	            var /** @type {?} */ html = DOM.createElement('html', doc);
	            inertElement = DOM.createElement('body', doc);
	            DOM.appendChild(html, inertElement);
	            DOM.appendChild(doc, html);
	        }
	        return inertElement;
	    }
	    /**
	     * @param {?} tags
	     * @return {?}
	     */
	    function tagSet(tags) {
	        var /** @type {?} */ res = {};
	        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
	            var t = _a[_i];
	            res[t] = true;
	        }
	        return res;
	    }
	    /**
	     * @param {...?} sets
	     * @return {?}
	     */
	    function merge() {
	        var sets = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            sets[_i - 0] = arguments[_i];
	        }
	        var /** @type {?} */ res = {};
	        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
	            var s = sets_1[_a];
	            for (var v in s) {
	                if (s.hasOwnProperty(v))
	                    res[v] = true;
	            }
	        }
	        return res;
	    }
	    // Good source of info about elements and attributes
	    // http://dev.w3.org/html5/spec/Overview.html#semantics
	    // http://simon.html5.org/html-elements
	    // Safe Void Elements - HTML5
	    // http://dev.w3.org/html5/spec/Overview.html#void-elements
	    var /** @type {?} */ VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
	    // Elements that you can, intentionally, leave open (and which close themselves)
	    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
	    var /** @type {?} */ OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
	    var /** @type {?} */ OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
	    var /** @type {?} */ OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
	    // Safe Block Elements - HTML5
	    var /** @type {?} */ BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
	        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
	        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
	    // Inline Elements - HTML5
	    var /** @type {?} */ INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
	        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
	        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
	    var /** @type {?} */ VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
	    // Attributes that have href and hence need to be sanitized
	    var /** @type {?} */ URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
	    // Attributes that have special href set hence need to be sanitized
	    var /** @type {?} */ SRCSET_ATTRS = tagSet('srcset');
	    var /** @type {?} */ HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
	        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
	        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
	        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
	        'valign,value,vspace,width');
	    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
	    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	    // innerHTML is required, SVG attributes should be added here.
	    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	    // can be sanitized, but they increase security surface area without a legitimate use case, so they
	    // are left out here.
	    var /** @type {?} */ VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
	    /**
	     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
	     * attributes.
	     */
	    var SanitizingHtmlSerializer = (function () {
	        function SanitizingHtmlSerializer() {
	            this.sanitizedSomething = false;
	            this.buf = [];
	        }
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
	            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
	            // However this code never accesses properties off of `document` before deleting its contents
	            // again, so it shouldn't be vulnerable to DOM clobbering.
	            var /** @type {?} */ current = el.firstChild;
	            while (current) {
	                if (DOM.isElementNode(current)) {
	                    this.startElement(/** @type {?} */ (current));
	                }
	                else if (DOM.isTextNode(current)) {
	                    this.chars(DOM.nodeValue(current));
	                }
	                else {
	                    // Strip non-element, non-text nodes.
	                    this.sanitizedSomething = true;
	                }
	                if (DOM.firstChild(current)) {
	                    current = DOM.firstChild(current);
	                    continue;
	                }
	                while (current) {
	                    // Leaving the element. Walk up and to the right, closing tags as we go.
	                    if (DOM.isElementNode(current)) {
	                        this.endElement(/** @type {?} */ (current));
	                    }
	                    if (DOM.nextSibling(current)) {
	                        current = DOM.nextSibling(current);
	                        break;
	                    }
	                    current = DOM.parentElement(current);
	                }
	            }
	            return this.buf.join('');
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.startElement = function (element) {
	            var _this = this;
	            var /** @type {?} */ tagName = DOM.nodeName(element).toLowerCase();
	            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.sanitizedSomething = true;
	                return;
	            }
	            this.buf.push('<');
	            this.buf.push(tagName);
	            DOM.attributeMap(element).forEach(function (value, attrName) {
	                var /** @type {?} */ lower = attrName.toLowerCase();
	                if (!VALID_ATTRS.hasOwnProperty(lower)) {
	                    _this.sanitizedSomething = true;
	                    return;
	                }
	                // TODO(martinprobst): Special case image URIs for data:image/...
	                if (URI_ATTRS[lower])
	                    value = sanitizeUrl(value);
	                if (SRCSET_ATTRS[lower])
	                    value = sanitizeSrcset(value);
	                _this.buf.push(' ');
	                _this.buf.push(attrName);
	                _this.buf.push('="');
	                _this.buf.push(encodeEntities(value));
	                _this.buf.push('"');
	            });
	            this.buf.push('>');
	        };
	        /**
	         * @param {?} current
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.endElement = function (current) {
	            var /** @type {?} */ tagName = DOM.nodeName(current).toLowerCase();
	            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.buf.push('</');
	                this.buf.push(tagName);
	                this.buf.push('>');
	            }
	        };
	        /**
	         * @param {?} chars
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };
	        return SanitizingHtmlSerializer;
	    }());
	    // Regular Expressions for parsing tags and attributes
	    var /** @type {?} */ SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	    // ! to ~ is the ASCII range.
	    var /** @type {?} */ NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	    /**
	     * Escapes all potentially dangerous characters, so that the
	     * resulting string can be safely inserted into attribute or
	     * element text.
	     * @param {?} value
	     * @return {?}
	     */
	    function encodeEntities(value) {
	        return value.replace(/&/g, '&amp;')
	            .replace(SURROGATE_PAIR_REGEXP, function (match) {
	            var /** @type {?} */ hi = match.charCodeAt(0);
	            var /** @type {?} */ low = match.charCodeAt(1);
	            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	        })
	            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;');
	    }
	    /**
	     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
	     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
	     *
	     * This is undesirable since we don't want to allow any of these custom attributes. This method
	     * strips them all.
	     * @param {?} el
	     * @return {?}
	     */
	    function stripCustomNsAttrs(el) {
	        DOM.attributeMap(el).forEach(function (_, attrName) {
	            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	                DOM.removeAttribute(el, attrName);
	            }
	        });
	        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
	            var n = _a[_i];
	            if (DOM.isElementNode(n))
	                stripCustomNsAttrs(/** @type {?} */ (n));
	        }
	    }
	    /**
	     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
	     * the DOM in a browser environment.
	     * @param {?} unsafeHtmlInput
	     * @return {?}
	     */
	    function sanitizeHtml(unsafeHtmlInput) {
	        try {
	            var /** @type {?} */ containerEl = getInertElement();
	            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
	            var /** @type {?} */ unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
	            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
	            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
	            var /** @type {?} */ mXSSAttempts = 5;
	            var /** @type {?} */ parsedHtml = unsafeHtml;
	            do {
	                if (mXSSAttempts === 0) {
	                    throw new Error('Failed to sanitize html because the input is unstable');
	                }
	                mXSSAttempts--;
	                unsafeHtml = parsedHtml;
	                DOM.setInnerHTML(containerEl, unsafeHtml);
	                if (((DOM.defaultDoc())).documentMode) {
	                    // strip custom-namespaced attributes on IE<=11
	                    stripCustomNsAttrs(containerEl);
	                }
	                parsedHtml = DOM.getInnerHTML(containerEl);
	            } while (unsafeHtml !== parsedHtml);
	            var /** @type {?} */ sanitizer = new SanitizingHtmlSerializer();
	            var /** @type {?} */ safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
	            // Clear out the body element.
	            var /** @type {?} */ parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
	            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
	                var child = _a[_i];
	                DOM.removeChild(parent_1, child);
	            }
	            if (core.isDevMode() && sanitizer.sanitizedSomething) {
	                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
	            }
	            return safeHtml;
	        }
	        catch (e) {
	            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
	            inertElement = null;
	            throw e;
	        }
	    }

	    /**
	     * Regular expression for safe style values.
	     *
	     * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
	     *
	     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
	     * font-family) and hence could allow multiple values to get injected, but that should pose no risk
	     * of XSS.
	     *
	     * The function expression checks only for XSS safety, not for CSS validity.
	     *
	     * This regular expression was taken from the Closure sanitization library, and augmented for
	     * transformation values.
	     */
	    var /** @type {?} */ VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
	    var /** @type {?} */ TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
	    var /** @type {?} */ COLOR_FNS = '(?:rgb|hsl)a?';
	    var /** @type {?} */ GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
	    var /** @type {?} */ CSS3_FNS = '(?:calc|attr)';
	    var /** @type {?} */ FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
	    var /** @type {?} */ SAFE_STYLE_VALUE = new RegExp(("^(" + VALUES + "|") +
	        ("(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + "|" + GRADIENTS + "|" + CSS3_FNS + ")") +
	        (FN_ARGS + ")$"), 'g');
	    /**
	     * Matches a `url(...)` value with an arbitrary argument as long as it does
	     * not contain parentheses.
	     *
	     * The URL value still needs to be sanitized separately.
	     *
	     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
	     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
	     * by observing whether scroll bars are displayed, or character ranges used by a font face
	     * definition.
	     *
	     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
	     * binding a URL value without further cooperation from the page will cause an information leak, and
	     * if so, it is just a leak, not a full blown XSS vulnerability.
	     *
	     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
	     * code is permissive and allows URLs that sanitize otherwise.
	     */
	    var /** @type {?} */ URL_RE = /^url\(([^)]+)\)$/;
	    /**
	     * Checks that quotes (" and ') are properly balanced inside a string. Assumes
	     * that neither escape (\) nor any other character that could result in
	     * breaking out of a string parsing context are allowed;
	     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
	     *
	     * This code was taken from the Closure sanitization library.
	     * @param {?} value
	     * @return {?}
	     */
	    function hasBalancedQuotes(value) {
	        var /** @type {?} */ outsideSingle = true;
	        var /** @type {?} */ outsideDouble = true;
	        for (var /** @type {?} */ i = 0; i < value.length; i++) {
	            var /** @type {?} */ c = value.charAt(i);
	            if (c === '\'' && outsideDouble) {
	                outsideSingle = !outsideSingle;
	            }
	            else if (c === '"' && outsideSingle) {
	                outsideDouble = !outsideDouble;
	            }
	        }
	        return outsideSingle && outsideDouble;
	    }
	    /**
	     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
	     * value) and returns a value that is safe to use in a browser environment.
	     * @param {?} value
	     * @return {?}
	     */
	    function sanitizeStyle(value) {
	        value = String(value).trim(); // Make sure it's actually a string.
	        if (!value)
	            return '';
	        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
	        // reasoning behind this.
	        var /** @type {?} */ urlMatch = value.match(URL_RE);
	        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
	            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
	            return value; // Safe style values.
	        }
	        if (core.isDevMode()) {
	            getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
	        }
	        return 'unsafe';
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
	     * values to be safe to use in the different DOM contexts.
	     *
	     * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
	     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
	     * the website.
	     *
	     * In specific situations, it might be necessary to disable sanitization, for example if the
	     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
	     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
	     * methods, and then binding to that value from the template.
	     *
	     * These situations should be very rare, and extraordinary care must be taken to avoid creating a
	     * Cross Site Scripting (XSS) security bug!
	     *
	     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
	     * close as possible to the source of the value, to make it easy to verify no security bug is
	     * created by its use.
	     *
	     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
	     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
	     * code. The sanitizer leaves safe values intact.
	     *
	     * \@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
	     * sanitization for the value passed in. Carefully check and audit all values and code paths going
	     * into this call. Make sure any user data is appropriately escaped for this security context.
	     * For more detail, see the [Security Guide](http://g.co/ng/security).
	     *
	     * \@stable
	     * @abstract
	     */
	    var DomSanitizer = (function () {
	        function DomSanitizer() {
	        }
	        /**
	         * Sanitizes a value for use in the given SecurityContext.
	         *
	         * If value is trusted for the context, this method will unwrap the contained safe value and use
	         * it directly. Otherwise, value will be sanitized to be safe in the given context, for example
	         * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation
	         * is responsible to make sure that the value can definitely be safely used in the given context.
	         * @abstract
	         * @param {?} context
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.sanitize = function (context, value) { };
	        /**
	         * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML
	         * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will
	         * leave safe HTML intact, so in most situations this method should not be used.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustHtml = function (value) { };
	        /**
	         * Bypass security and trust the given value to be safe style value (CSS).
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustStyle = function (value) { };
	        /**
	         * Bypass security and trust the given value to be safe JavaScript.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustScript = function (value) { };
	        /**
	         * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used
	         * in hyperlinks or `<img src>`.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustUrl = function (value) { };
	        /**
	         * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may
	         * be used to load executable code from, like `<script src>`, or `<iframe src>`.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function (value) { };
	        return DomSanitizer;
	    }());
	    var DomSanitizerImpl = (function (_super) {
	        __extends$8(DomSanitizerImpl, _super);
	        function DomSanitizerImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} ctx
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
	            if (value == null)
	                return null;
	            switch (ctx) {
	                case core.SecurityContext.NONE:
	                    return value;
	                case core.SecurityContext.HTML:
	                    if (value instanceof SafeHtmlImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'HTML');
	                    return sanitizeHtml(String(value));
	                case core.SecurityContext.STYLE:
	                    if (value instanceof SafeStyleImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Style');
	                    return sanitizeStyle(value);
	                case core.SecurityContext.SCRIPT:
	                    if (value instanceof SafeScriptImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Script');
	                    throw new Error('unsafe value used in a script context');
	                case core.SecurityContext.URL:
	                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
	                        // Allow resource URLs in URL contexts, they are strictly more trusted.
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'URL');
	                    return sanitizeUrl(String(value));
	                case core.SecurityContext.RESOURCE_URL:
	                    if (value instanceof SafeResourceUrlImpl) {
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'ResourceURL');
	                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
	                default:
	                    throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
	            }
	        };
	        /**
	         * @param {?} value
	         * @param {?} expectedType
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
	            if (value instanceof SafeValueImpl) {
	                throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") +
	                    "(see http://g.co/ng/security#xss)");
	            }
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
	            return new SafeResourceUrlImpl(value);
	        };
	        DomSanitizerImpl.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomSanitizerImpl.ctorParameters = function () { return []; };
	        return DomSanitizerImpl;
	    }(DomSanitizer));
	    /**
	     * @abstract
	     */
	    var SafeValueImpl = (function () {
	        /**
	         * @param {?} changingThisBreaksApplicationSecurity
	         */
	        function SafeValueImpl(changingThisBreaksApplicationSecurity) {
	            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
	            // empty
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        SafeValueImpl.prototype.getTypeName = function () { };
	        /**
	         * @return {?}
	         */
	        SafeValueImpl.prototype.toString = function () {
	            return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) +
	                " (see http://g.co/ng/security#xss)";
	        };
	        return SafeValueImpl;
	    }());
	    var SafeHtmlImpl = (function (_super) {
	        __extends$8(SafeHtmlImpl, _super);
	        function SafeHtmlImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
	        return SafeHtmlImpl;
	    }(SafeValueImpl));
	    var SafeStyleImpl = (function (_super) {
	        __extends$8(SafeStyleImpl, _super);
	        function SafeStyleImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
	        return SafeStyleImpl;
	    }(SafeValueImpl));
	    var SafeScriptImpl = (function (_super) {
	        __extends$8(SafeScriptImpl, _super);
	        function SafeScriptImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
	        return SafeScriptImpl;
	    }(SafeValueImpl));
	    var SafeUrlImpl = (function (_super) {
	        __extends$8(SafeUrlImpl, _super);
	        function SafeUrlImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
	        return SafeUrlImpl;
	    }(SafeValueImpl));
	    var SafeResourceUrlImpl = (function (_super) {
	        __extends$8(SafeResourceUrlImpl, _super);
	        function SafeResourceUrlImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
	        return SafeResourceUrlImpl;
	    }(SafeValueImpl));

	    var /** @type {?} */ INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
	        { provide: core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
	        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }
	    ];
	    /**
	     * @security Replacing built-in sanitization providers exposes the application to XSS risks.
	     * Attacker-controlled data introduced by an unsanitized provider could expose your
	     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	     * @experimental
	     */
	    var /** @type {?} */ BROWSER_SANITIZATION_PROVIDERS = [
	        { provide: core.Sanitizer, useExisting: DomSanitizer },
	        { provide: DomSanitizer, useClass: DomSanitizerImpl },
	    ];
	    /**
	     * @stable
	     */
	    var /** @type {?} */ platformBrowser = core.createPlatformFactory(core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
	    /**
	     * @return {?}
	     */
	    function initDomAdapter() {
	        BrowserDomAdapter.makeCurrent();
	        BrowserGetTestability.init();
	    }
	    /**
	     * @return {?}
	     */
	    function errorHandler() {
	        return new core.ErrorHandler();
	    }
	    /**
	     * @return {?}
	     */
	    function _document() {
	        return getDOM().defaultDoc();
	    }
	    /**
	     * @return {?}
	     */
	    function _resolveDefaultAnimationDriver() {
	        if (getDOM().supportsWebAnimation()) {
	            return new WebAnimationsDriver();
	        }
	        return AnimationDriver.NOOP;
	    }
	    /**
	     * The ng module for the browser.
	     *
	     * \@stable
	     */
	    var BrowserModule = (function () {
	        /**
	         * @param {?} parentModule
	         */
	        function BrowserModule(parentModule) {
	            if (parentModule) {
	                throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
	            }
	        }
	        BrowserModule.decorators = [
	            { type: core.NgModule, args: [{
	                        providers: [
	                            BROWSER_SANITIZATION_PROVIDERS, { provide: core.ErrorHandler, useFactory: errorHandler, deps: [] },
	                            { provide: DOCUMENT, useFactory: _document, deps: [] },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
	                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
	                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },
	                            { provide: core.RootRenderer, useExisting: DomRootRenderer },
	                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
	                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,
	                            core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title
	                        ],
	                        exports: [_angular_common.CommonModule, core.ApplicationModule]
	                    },] },
	        ];
	        /** @nocollapse */
	        BrowserModule.ctorParameters = function () { return [
	            { type: BrowserModule, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
	        ]; };
	        return BrowserModule;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * JS version of browser APIs. This library can only run in the browser.
	     */
	    var /** @type {?} */ win = typeof window !== 'undefined' && window || ({});

	    var ChangeDetectionPerfRecord = (function () {
	        /**
	         * @param {?} msPerTick
	         * @param {?} numTicks
	         */
	        function ChangeDetectionPerfRecord(msPerTick, numTicks) {
	            this.msPerTick = msPerTick;
	            this.numTicks = numTicks;
	        }
	        return ChangeDetectionPerfRecord;
	    }());
	    /**
	     * Entry point for all Angular debug tools. This object corresponds to the `ng`
	     * global variable accessible in the dev console.
	     */
	    var AngularTools = (function () {
	        /**
	         * @param {?} ref
	         */
	        function AngularTools(ref) {
	            this.profiler = new AngularProfiler(ref);
	        }
	        return AngularTools;
	    }());
	    /**
	     * Entry point for all Angular profiling-related debug tools. This object
	     * corresponds to the `ng.profiler` in the dev console.
	     */
	    var AngularProfiler = (function () {
	        /**
	         * @param {?} ref
	         */
	        function AngularProfiler(ref) {
	            this.appRef = ref.injector.get(core.ApplicationRef);
	        }
	        /**
	         * Exercises change detection in a loop and then prints the average amount of
	         * time in milliseconds how long a single round of change detection takes for
	         * the current state of the UI. It runs a minimum of 5 rounds for a minimum
	         * of 500 milliseconds.
	         *
	         * Optionally, a user may pass a `config` parameter containing a map of
	         * options. Supported options are:
	         *
	         * `record` (boolean) - causes the profiler to record a CPU profile while
	         * it exercises the change detector. Example:
	         *
	         * ```
	         * ng.profiler.timeChangeDetection({record: true})
	         * ```
	         * @param {?} config
	         * @return {?}
	         */
	        AngularProfiler.prototype.timeChangeDetection = function (config) {
	            var /** @type {?} */ record = config && config['record'];
	            var /** @type {?} */ profileName = 'Change Detection';
	            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
	            var /** @type {?} */ isProfilerAvailable = isPresent(win.console.profile);
	            if (record && isProfilerAvailable) {
	                win.console.profile(profileName);
	            }
	            var /** @type {?} */ start = getDOM().performanceNow();
	            var /** @type {?} */ numTicks = 0;
	            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
	                this.appRef.tick();
	                numTicks++;
	            }
	            var /** @type {?} */ end = getDOM().performanceNow();
	            if (record && isProfilerAvailable) {
	                // need to cast to <any> because type checker thinks there's no argument
	                // while in fact there is:
	                //
	                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
	                ((win.console.profileEnd))(profileName);
	            }
	            var /** @type {?} */ msPerTick = (end - start) / numTicks;
	            win.console.log("ran " + numTicks + " change detection cycles");
	            win.console.log(msPerTick.toFixed(2) + " ms per check");
	            return new ChangeDetectionPerfRecord(msPerTick, numTicks);
	        };
	        return AngularProfiler;
	    }());

	    var /** @type {?} */ context = (global$1);
	    /**
	     * Enabled Angular 2 debug tools that are accessible via your browser's
	     * developer console.
	     *
	     * Usage:
	     *
	     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
	     * 1. Type `ng.` (usually the console will show auto-complete suggestion)
	     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
	     *    then hit Enter.
	     *
	     * \@experimental All debugging apis are currently experimental.
	     * @param {?} ref
	     * @return {?}
	     */
	    function enableDebugTools(ref) {
	        ((Object)).assign(context.ng, new AngularTools(ref));
	        return ref;
	    }
	    /**
	     * Disables Angular 2 tools.
	     *
	     * \@experimental All debugging apis are currently experimental.
	     * @return {?}
	     */
	    function disableDebugTools() {
	        if (context.ng) {
	            delete context.ng.profiler;
	        }
	    }

	    /**
	     * Predicates for use with {\@link DebugElement}'s query functions.
	     *
	     * \@experimental All debugging apis are currently experimental.
	     */
	    var By = (function () {
	        function By() {
	        }
	        /**
	         * Match all elements.
	         *
	         * ## Example
	         *
	         * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
	         * @return {?}
	         */
	        By.all = function () { return function (debugElement) { return true; }; };
	        /**
	         * Match elements by the given CSS selector.
	         *
	         * ## Example
	         *
	         * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
	         * @param {?} selector
	         * @return {?}
	         */
	        By.css = function (selector) {
	            return function (debugElement) {
	                return isPresent(debugElement.nativeElement) ?
	                    getDOM().elementMatches(debugElement.nativeElement, selector) :
	                    false;
	            };
	        };
	        /**
	         * Match elements that have the given directive present.
	         *
	         * ## Example
	         *
	         * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
	         * @param {?} type
	         * @return {?}
	         */
	        By.directive = function (type) {
	            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
	        };
	        return By;
	    }());

	    var /** @type {?} */ __platform_browser_private__ = {
	        BrowserPlatformLocation: BrowserPlatformLocation,
	        DomAdapter: DomAdapter,
	        BrowserDomAdapter: BrowserDomAdapter,
	        BrowserGetTestability: BrowserGetTestability,
	        getDOM: getDOM,
	        setRootDomAdapter: setRootDomAdapter,
	        DomRootRenderer_: DomRootRenderer_,
	        DomRootRenderer: DomRootRenderer,
	        NAMESPACE_URIS: NAMESPACE_URIS,
	        shimContentAttribute: shimContentAttribute,
	        shimHostAttribute: shimHostAttribute,
	        flattenStyles: flattenStyles,
	        splitNamespace: splitNamespace,
	        isNamespaced: isNamespaced,
	        DomSharedStylesHost: DomSharedStylesHost,
	        SharedStylesHost: SharedStylesHost,
	        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,
	        DomEventsPlugin: DomEventsPlugin,
	        KeyEventsPlugin: KeyEventsPlugin,
	        HammerGesturesPlugin: HammerGesturesPlugin,
	        initDomAdapter: initDomAdapter,
	        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,
	        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS,
	        WebAnimationsDriver: WebAnimationsDriver
	    };

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new core.Version('2.4.10');

	    exports.BrowserModule = BrowserModule;
	    exports.platformBrowser = platformBrowser;
	    exports.Title = Title;
	    exports.disableDebugTools = disableDebugTools;
	    exports.enableDebugTools = enableDebugTools;
	    exports.AnimationDriver = AnimationDriver;
	    exports.By = By;
	    exports.NgProbeToken = NgProbeToken;
	    exports.DOCUMENT = DOCUMENT;
	    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
	    exports.EventManager = EventManager;
	    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
	    exports.HammerGestureConfig = HammerGestureConfig;
	    exports.DomSanitizer = DomSanitizer;
	    exports.VERSION = VERSION;
	    exports.__platform_browser_private__ = __platform_browser_private__;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));
	}(this, function (exports,_angular_core) { 'use strict';

	    /**
	     * This class should not be used directly by an application developer. Instead, use
	     * {\@link Location}.
	     *
	     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
	     * agnostic.
	     * This means that we can have different implementation of `PlatformLocation` for the different
	     * platforms
	     * that angular supports. For example, the default `PlatformLocation` is {\@link
	     * BrowserPlatformLocation},
	     * however when you run your app in a WebWorker you use {\@link WebWorkerPlatformLocation}.
	     *
	     * The `PlatformLocation` class is used directly by all implementations of {\@link LocationStrategy}
	     * when
	     * they need to interact with the DOM apis like pushState, popState, etc...
	     *
	     * {\@link LocationStrategy} in turn is used by the {\@link Location} service which is used directly
	     * by
	     * the {\@link Router} in order to navigate between routes. Since all interactions between {\@link
	     * Router} /
	     * {\@link Location} / {\@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
	     * class
	     * they are all platform independent.
	     *
	     * \@stable
	     * @abstract
	     */
	    var PlatformLocation = (function () {
	        function PlatformLocation() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformLocation.prototype.getBaseHrefFromDOM = function () { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        PlatformLocation.prototype.onPopState = function (fn) { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        PlatformLocation.prototype.onHashChange = function (fn) { };
	        Object.defineProperty(PlatformLocation.prototype, "pathname", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformLocation.prototype, "search", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformLocation.prototype, "hash", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        PlatformLocation.prototype.replaceState = function (state, title, url) { };
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        PlatformLocation.prototype.pushState = function (state, title, url) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformLocation.prototype.forward = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformLocation.prototype.back = function () { };
	        return PlatformLocation;
	    }());
	    /**
	     * @whatItDoes indicates when a location is initialized
	     * @experimental
	     */
	    var /** @type {?} */ LOCATION_INITIALIZED = new _angular_core.OpaqueToken('Location Initialized');

	    /**
	     * `LocationStrategy` is responsible for representing and reading route state
	     * from the browser's URL. Angular provides two strategies:
	     * {\@link HashLocationStrategy} and {\@link PathLocationStrategy}.
	     *
	     * This is used under the hood of the {\@link Location} service.
	     *
	     * Applications should use the {\@link Router} or {\@link Location} services to
	     * interact with application route state.
	     *
	     * For instance, {\@link HashLocationStrategy} produces URLs like
	     * `http://example.com#/foo`, and {\@link PathLocationStrategy} produces
	     * `http://example.com/foo` as an equivalent URL.
	     *
	     * See these two classes for more.
	     *
	     * \@stable
	     * @abstract
	     */
	    var LocationStrategy = (function () {
	        function LocationStrategy() {
	        }
	        /**
	         * @abstract
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        LocationStrategy.prototype.path = function (includeHash) { };
	        /**
	         * @abstract
	         * @param {?} internal
	         * @return {?}
	         */
	        LocationStrategy.prototype.prepareExternalUrl = function (internal) { };
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        LocationStrategy.prototype.pushState = function (state, title, url, queryParams) { };
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        LocationStrategy.prototype.replaceState = function (state, title, url, queryParams) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        LocationStrategy.prototype.forward = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        LocationStrategy.prototype.back = function () { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        LocationStrategy.prototype.onPopState = function (fn) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        LocationStrategy.prototype.getBaseHref = function () { };
	        return LocationStrategy;
	    }());
	    /**
	     * The `APP_BASE_HREF` token represents the base href to be used with the
	     * {@link PathLocationStrategy}.
	     *
	     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
	     * representing the URL prefix that should be preserved when generating and recognizing
	     * URLs.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * import {Component, NgModule} from '@angular/core';
	     * import {APP_BASE_HREF} from '@angular/common';
	     *
	     * @NgModule({
	     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
	     * })
	     * class AppModule {}
	     * ```
	     *
	     * @stable
	     */
	    var /** @type {?} */ APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = (self);
	        }
	        else {
	            globalScope = (global);
	        }
	    }
	    else {
	        globalScope = (window);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var /** @type {?} */ _global = globalScope;
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function getTypeNameForDebugging(type) {
	        return type['name'] || typeof type;
	    }
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    _global.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    var NumberWrapper = (function () {
	        function NumberWrapper() {
	        }
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        NumberWrapper.parseIntAutoRadix = function (text) {
	            var /** @type {?} */ result = parseInt(text);
	            if (isNaN(result)) {
	                throw new Error('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	        return NumberWrapper;
	    }());
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    var /** @type {?} */ _symbolIterator = null;
	    /**
	     * @return {?}
	     */
	    function getSymbolIterator() {
	        if (!_symbolIterator) {
	            if (((globalScope)).Symbol && Symbol.iterator) {
	                _symbolIterator = Symbol.iterator;
	            }
	            else {
	                // es6-shim specific logic
	                var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
	                for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	                    var /** @type {?} */ key = keys[i];
	                    if (key !== 'entries' && key !== 'size' &&
	                        ((Map)).prototype[key] === Map.prototype['entries']) {
	                        _symbolIterator = key;
	                    }
	                }
	            }
	        }
	        return _symbolIterator;
	    }

	    /**
	     * \@whatItDoes `Location` is a service that applications can use to interact with a browser's URL.
	     * \@description
	     * Depending on which {\@link LocationStrategy} is used, `Location` will either persist
	     * to the URL's path or the URL's hash segment.
	     *
	     * Note: it's better to use {\@link Router#navigate} service to trigger route changes. Use
	     * `Location` only if you need to interact with or create normalized URLs outside of
	     * routing.
	     *
	     * `Location` is responsible for normalizing the URL against the application's base href.
	     * A normalized URL is absolute from the URL host, includes the application's base href, and has no
	     * trailing slash:
	     * - `/my/app/user/123` is normalized
	     * - `my/app/user/123` **is not** normalized
	     * - `/my/app/user/123/` **is not** normalized
	     *
	     * ### Example
	     * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
	     * \@stable
	     */
	    var Location = (function () {
	        /**
	         * @param {?} platformStrategy
	         */
	        function Location(platformStrategy) {
	            var _this = this;
	            /** @internal */
	            this._subject = new _angular_core.EventEmitter();
	            this._platformStrategy = platformStrategy;
	            var browserBaseHref = this._platformStrategy.getBaseHref();
	            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
	            this._platformStrategy.onPopState(function (ev) {
	                _this._subject.emit({
	                    'url': _this.path(true),
	                    'pop': true,
	                    'type': ev.type,
	                });
	            });
	        }
	        /**
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        Location.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            return this.normalize(this._platformStrategy.path(includeHash));
	        };
	        /**
	         * Normalizes the given path and compares to the current normalized path.
	         * @param {?} path
	         * @param {?=} query
	         * @return {?}
	         */
	        Location.prototype.isCurrentPathEqualTo = function (path, query) {
	            if (query === void 0) { query = ''; }
	            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
	        };
	        /**
	         * Given a string representing a URL, returns the normalized URL path without leading or
	         * trailing slashes.
	         * @param {?} url
	         * @return {?}
	         */
	        Location.prototype.normalize = function (url) {
	            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
	        };
	        /**
	         * Given a string representing a URL, returns the platform-specific external URL path.
	         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
	         * before normalizing. This method will also add a hash if `HashLocationStrategy` is
	         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
	         * @param {?} url
	         * @return {?}
	         */
	        Location.prototype.prepareExternalUrl = function (url) {
	            if (url && url[0] !== '/') {
	                url = '/' + url;
	            }
	            return this._platformStrategy.prepareExternalUrl(url);
	        };
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and pushes a
	         * new item onto the platform's history.
	         * @param {?} path
	         * @param {?=} query
	         * @return {?}
	         */
	        Location.prototype.go = function (path, query) {
	            if (query === void 0) { query = ''; }
	            this._platformStrategy.pushState(null, '', path, query);
	        };
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and replaces
	         * the top item on the platform's history stack.
	         * @param {?} path
	         * @param {?=} query
	         * @return {?}
	         */
	        Location.prototype.replaceState = function (path, query) {
	            if (query === void 0) { query = ''; }
	            this._platformStrategy.replaceState(null, '', path, query);
	        };
	        /**
	         * Navigates forward in the platform's history.
	         * @return {?}
	         */
	        Location.prototype.forward = function () { this._platformStrategy.forward(); };
	        /**
	         * Navigates back in the platform's history.
	         * @return {?}
	         */
	        Location.prototype.back = function () { this._platformStrategy.back(); };
	        /**
	         * Subscribe to the platform's `popState` events.
	         * @param {?} onNext
	         * @param {?=} onThrow
	         * @param {?=} onReturn
	         * @return {?}
	         */
	        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
	            if (onThrow === void 0) { onThrow = null; }
	            if (onReturn === void 0) { onReturn = null; }
	            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
	        };
	        /**
	         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
	         * is.
	         * @param {?} params
	         * @return {?}
	         */
	        Location.normalizeQueryParams = function (params) {
	            return params && params[0] !== '?' ? '?' + params : params;
	        };
	        /**
	         * Given 2 parts of a url, join them with a slash if needed.
	         * @param {?} start
	         * @param {?} end
	         * @return {?}
	         */
	        Location.joinWithSlash = function (start, end) {
	            if (start.length == 0) {
	                return end;
	            }
	            if (end.length == 0) {
	                return start;
	            }
	            var /** @type {?} */ slashes = 0;
	            if (start.endsWith('/')) {
	                slashes++;
	            }
	            if (end.startsWith('/')) {
	                slashes++;
	            }
	            if (slashes == 2) {
	                return start + end.substring(1);
	            }
	            if (slashes == 1) {
	                return start + end;
	            }
	            return start + '/' + end;
	        };
	        /**
	         * If url has a trailing slash, remove it, otherwise return url as is.
	         * @param {?} url
	         * @return {?}
	         */
	        Location.stripTrailingSlash = function (url) { return url.replace(/\/$/, ''); };
	        Location.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        Location.ctorParameters = function () { return [
	            { type: LocationStrategy, },
	        ]; };
	        return Location;
	    }());
	    /**
	     * @param {?} baseHref
	     * @param {?} url
	     * @return {?}
	     */
	    function _stripBaseHref(baseHref, url) {
	        return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
	    }
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function _stripIndexHtml(url) {
	        return url.replace(/\/index.html$/, '');
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@whatItDoes Use URL hash for storing application location data.
	     * \@description
	     * `HashLocationStrategy` is a {\@link LocationStrategy} used to configure the
	     * {\@link Location} service to represent its state in the
	     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
	     * of the browser's URL.
	     *
	     * For instance, if you call `location.go('/foo')`, the browser's URL will become
	     * `example.com#/foo`.
	     *
	     * ### Example
	     *
	     * {\@example common/location/ts/hash_location_component.ts region='LocationComponent'}
	     *
	     * \@stable
	     */
	    var HashLocationStrategy = (function (_super) {
	        __extends(HashLocationStrategy, _super);
	        /**
	         * @param {?} _platformLocation
	         * @param {?=} _baseHref
	         */
	        function HashLocationStrategy(_platformLocation, _baseHref) {
	            _super.call(this);
	            this._platformLocation = _platformLocation;
	            this._baseHref = '';
	            if (isPresent(_baseHref)) {
	                this._baseHref = _baseHref;
	            }
	        }
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.onPopState = function (fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        };
	        /**
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	        /**
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            // the hash value is always prefixed with a `#`
	            // and if it is empty then it will stay empty
	            var /** @type {?} */ path = this._platformLocation.hash;
	            if (!isPresent(path))
	                path = '#';
	            return path.length > 0 ? path.substring(1) : path;
	        };
	        /**
	         * @param {?} internal
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	            var /** @type {?} */ url = Location.joinWithSlash(this._baseHref, internal);
	            return url.length > 0 ? ('#' + url) : url;
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} path
	         * @param {?} queryParams
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
	            var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.pushState(state, title, url);
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} path
	         * @param {?} queryParams
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
	            var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.replaceState(state, title, url);
	        };
	        /**
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	        /**
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	        HashLocationStrategy.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        HashLocationStrategy.ctorParameters = function () { return [
	            { type: PlatformLocation, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	        ]; };
	        return HashLocationStrategy;
	    }(LocationStrategy));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@whatItDoes Use URL for storing application location data.
	     * \@description
	     * `PathLocationStrategy` is a {\@link LocationStrategy} used to configure the
	     * {\@link Location} service to represent its state in the
	     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
	     * browser's URL.
	     *
	     * If you're using `PathLocationStrategy`, you must provide a {\@link APP_BASE_HREF}
	     * or add a base element to the document. This URL prefix that will be preserved
	     * when generating and recognizing URLs.
	     *
	     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
	     * `location.go('/foo')`, the browser's URL will become
	     * `example.com/my/app/foo`.
	     *
	     * Similarly, if you add `<base href='/my/app'/>` to the document and call
	     * `location.go('/foo')`, the browser's URL will become
	     * `example.com/my/app/foo`.
	     *
	     * ### Example
	     *
	     * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
	     *
	     * \@stable
	     */
	    var PathLocationStrategy = (function (_super) {
	        __extends$1(PathLocationStrategy, _super);
	        /**
	         * @param {?} _platformLocation
	         * @param {?=} href
	         */
	        function PathLocationStrategy(_platformLocation, href) {
	            _super.call(this);
	            this._platformLocation = _platformLocation;
	            if (isBlank(href)) {
	                href = this._platformLocation.getBaseHrefFromDOM();
	            }
	            if (isBlank(href)) {
	                throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
	            }
	            this._baseHref = href;
	        }
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.onPopState = function (fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        };
	        /**
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	        /**
	         * @param {?} internal
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	            return Location.joinWithSlash(this._baseHref, internal);
	        };
	        /**
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            var /** @type {?} */ pathname = this._platformLocation.pathname +
	                Location.normalizeQueryParams(this._platformLocation.search);
	            var /** @type {?} */ hash = this._platformLocation.hash;
	            return hash && includeHash ? "" + pathname + hash : pathname;
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
	            var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.pushState(state, title, externalUrl);
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
	            var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.replaceState(state, title, externalUrl);
	        };
	        /**
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	        /**
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	        PathLocationStrategy.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        PathLocationStrategy.ctorParameters = function () { return [
	            { type: PlatformLocation, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	        ]; };
	        return PathLocationStrategy;
	    }(LocationStrategy));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@experimental
	     * @abstract
	     */
	    var NgLocalization = (function () {
	        function NgLocalization() {
	        }
	        /**
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        NgLocalization.prototype.getPluralCategory = function (value) { };
	        return NgLocalization;
	    }());
	    /**
	     * Returns the plural category for a given value.
	     * - "=value" when the case exists,
	     * - the plural category otherwise
	     *
	     * \@internal
	     * @param {?} value
	     * @param {?} cases
	     * @param {?} ngLocalization
	     * @return {?}
	     */
	    function getPluralCategory(value, cases, ngLocalization) {
	        var /** @type {?} */ key = "=" + value;
	        if (cases.indexOf(key) > -1) {
	            return key;
	        }
	        key = ngLocalization.getPluralCategory(value);
	        if (cases.indexOf(key) > -1) {
	            return key;
	        }
	        if (cases.indexOf('other') > -1) {
	            return 'other';
	        }
	        throw new Error("No plural message found for value \"" + value + "\"");
	    }
	    /**
	     * Returns the plural case based on the locale
	     *
	     * \@experimental
	     */
	    var NgLocaleLocalization = (function (_super) {
	        __extends$2(NgLocaleLocalization, _super);
	        /**
	         * @param {?} _locale
	         */
	        function NgLocaleLocalization(_locale) {
	            _super.call(this);
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgLocaleLocalization.prototype.getPluralCategory = function (value) {
	            var /** @type {?} */ plural = getPluralCase(this._locale, value);
	            switch (plural) {
	                case Plural.Zero:
	                    return 'zero';
	                case Plural.One:
	                    return 'one';
	                case Plural.Two:
	                    return 'two';
	                case Plural.Few:
	                    return 'few';
	                case Plural.Many:
	                    return 'many';
	                default:
	                    return 'other';
	            }
	        };
	        NgLocaleLocalization.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        NgLocaleLocalization.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return NgLocaleLocalization;
	    }(NgLocalization));
	    var Plural = {};
	    Plural.Zero = 0;
	    Plural.One = 1;
	    Plural.Two = 2;
	    Plural.Few = 3;
	    Plural.Many = 4;
	    Plural.Other = 5;
	    Plural[Plural.Zero] = "Zero";
	    Plural[Plural.One] = "One";
	    Plural[Plural.Two] = "Two";
	    Plural[Plural.Few] = "Few";
	    Plural[Plural.Many] = "Many";
	    Plural[Plural.Other] = "Other";
	    /**
	     * Returns the plural case based on the locale
	     *
	     * \@experimental
	     * @param {?} locale
	     * @param {?} nLike
	     * @return {?}
	     */
	    function getPluralCase(locale, nLike) {
	        // TODO(vicb): lazy compute
	        if (typeof nLike === 'string') {
	            nLike = parseInt(/** @type {?} */ (nLike), 10);
	        }
	        var /** @type {?} */ n = (nLike);
	        var /** @type {?} */ nDecimal = n.toString().replace(/^[^.]*\.?/, '');
	        var /** @type {?} */ i = Math.floor(Math.abs(n));
	        var /** @type {?} */ v = nDecimal.length;
	        var /** @type {?} */ f = parseInt(nDecimal, 10);
	        var /** @type {?} */ t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
	        var /** @type {?} */ lang = locale.split('-')[0].toLowerCase();
	        switch (lang) {
	            case 'af':
	            case 'asa':
	            case 'az':
	            case 'bem':
	            case 'bez':
	            case 'bg':
	            case 'brx':
	            case 'ce':
	            case 'cgg':
	            case 'chr':
	            case 'ckb':
	            case 'ee':
	            case 'el':
	            case 'eo':
	            case 'es':
	            case 'eu':
	            case 'fo':
	            case 'fur':
	            case 'gsw':
	            case 'ha':
	            case 'haw':
	            case 'hu':
	            case 'jgo':
	            case 'jmc':
	            case 'ka':
	            case 'kk':
	            case 'kkj':
	            case 'kl':
	            case 'ks':
	            case 'ksb':
	            case 'ky':
	            case 'lb':
	            case 'lg':
	            case 'mas':
	            case 'mgo':
	            case 'ml':
	            case 'mn':
	            case 'nb':
	            case 'nd':
	            case 'ne':
	            case 'nn':
	            case 'nnh':
	            case 'nyn':
	            case 'om':
	            case 'or':
	            case 'os':
	            case 'ps':
	            case 'rm':
	            case 'rof':
	            case 'rwk':
	            case 'saq':
	            case 'seh':
	            case 'sn':
	            case 'so':
	            case 'sq':
	            case 'ta':
	            case 'te':
	            case 'teo':
	            case 'tk':
	            case 'tr':
	            case 'ug':
	            case 'uz':
	            case 'vo':
	            case 'vun':
	            case 'wae':
	            case 'xog':
	                if (n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'agq':
	            case 'bas':
	            case 'cu':
	            case 'dav':
	            case 'dje':
	            case 'dua':
	            case 'dyo':
	            case 'ebu':
	            case 'ewo':
	            case 'guz':
	            case 'kam':
	            case 'khq':
	            case 'ki':
	            case 'kln':
	            case 'kok':
	            case 'ksf':
	            case 'lrc':
	            case 'lu':
	            case 'luo':
	            case 'luy':
	            case 'mer':
	            case 'mfe':
	            case 'mgh':
	            case 'mua':
	            case 'mzn':
	            case 'nmg':
	            case 'nus':
	            case 'qu':
	            case 'rn':
	            case 'rw':
	            case 'sbp':
	            case 'twq':
	            case 'vai':
	            case 'yav':
	            case 'yue':
	            case 'zgh':
	            case 'ak':
	            case 'ln':
	            case 'mg':
	            case 'pa':
	            case 'ti':
	                if (n === Math.floor(n) && n >= 0 && n <= 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'am':
	            case 'as':
	            case 'bn':
	            case 'fa':
	            case 'gu':
	            case 'hi':
	            case 'kn':
	            case 'mr':
	            case 'zu':
	                if (i === 0 || n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'ar':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
	                    return Plural.Few;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'ast':
	            case 'ca':
	            case 'de':
	            case 'en':
	            case 'et':
	            case 'fi':
	            case 'fy':
	            case 'gl':
	            case 'it':
	            case 'nl':
	            case 'sv':
	            case 'sw':
	            case 'ur':
	            case 'yi':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                return Plural.Other;
	            case 'be':
	                if (n % 10 === 1 && !(n % 100 === 11))
	                    return Plural.One;
	                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
	                    !(n % 100 >= 12 && n % 100 <= 14))
	                    return Plural.Few;
	                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
	                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'br':
	                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
	                    return Plural.One;
	                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
	                    return Plural.Two;
	                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
	                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
	                        n % 100 >= 90 && n % 100 <= 99))
	                    return Plural.Few;
	                if (!(n === 0) && n % 1e6 === 0)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'bs':
	            case 'hr':
	            case 'sr':
	                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14) ||
	                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
	                        !(f % 100 >= 12 && f % 100 <= 14))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'cs':
	            case 'sk':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
	                    return Plural.Few;
	                if (!(v === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'cy':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n === 3)
	                    return Plural.Few;
	                if (n === 6)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'da':
	                if (n === 1 || !(t === 0) && (i === 0 || i === 1))
	                    return Plural.One;
	                return Plural.Other;
	            case 'dsb':
	            case 'hsb':
	                if (v === 0 && i % 100 === 1 || f % 100 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 100 === 2 || f % 100 === 2)
	                    return Plural.Two;
	                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
	                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'ff':
	            case 'fr':
	            case 'hy':
	            case 'kab':
	                if (i === 0 || i === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'fil':
	                if (v === 0 && (i === 1 || i === 2 || i === 3) ||
	                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
	                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ga':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n === Math.floor(n) && n >= 3 && n <= 6)
	                    return Plural.Few;
	                if (n === Math.floor(n) && n >= 7 && n <= 10)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'gd':
	                if (n === 1 || n === 11)
	                    return Plural.One;
	                if (n === 2 || n === 12)
	                    return Plural.Two;
	                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'gv':
	                if (v === 0 && i % 10 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 10 === 2)
	                    return Plural.Two;
	                if (v === 0 &&
	                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
	                    return Plural.Few;
	                if (!(v === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'he':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (i === 2 && v === 0)
	                    return Plural.Two;
	                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'is':
	                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ksh':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'kw':
	            case 'naq':
	            case 'se':
	            case 'smn':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                return Plural.Other;
	            case 'lag':
	                if (n === 0)
	                    return Plural.Zero;
	                if ((i === 0 || i === 1) && !(n === 0))
	                    return Plural.One;
	                return Plural.Other;
	            case 'lt':
	                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
	                    return Plural.One;
	                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
	                    !(n % 100 >= 11 && n % 100 <= 19))
	                    return Plural.Few;
	                if (!(f === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'lv':
	            case 'prg':
	                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
	                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
	                    return Plural.Zero;
	                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
	                    !(v === 2) && f % 10 === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'mk':
	                if (v === 0 && i % 10 === 1 || f % 10 === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'mt':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
	                    return Plural.Few;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'pl':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14))
	                    return Plural.Few;
	                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
	                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'pt':
	                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ro':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (!(v === 0) || n === 0 ||
	                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'ru':
	            case 'uk':
	                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14))
	                    return Plural.Few;
	                if (v === 0 && i % 10 === 0 ||
	                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'shi':
	                if (i === 0 || n === 1)
	                    return Plural.One;
	                if (n === Math.floor(n) && n >= 2 && n <= 10)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'si':
	                if (n === 0 || n === 1 || i === 0 && f === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'sl':
	                if (v === 0 && i % 100 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 100 === 2)
	                    return Plural.Two;
	                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'tzm':
	                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
	                    return Plural.One;
	                return Plural.Other;
	            default:
	                return Plural.Other;
	        }
	    }

	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isListLikeIterable(obj) {
	        if (!isJsObject(obj))
	            return false;
	        return Array.isArray(obj) ||
	            (!(obj instanceof Map) &&
	                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	    }

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Adds and removes CSS classes on an HTML element.
	     *
	     * \@howToUse
	     * ```
	     *     <some-element [ngClass]="'first second'">...</some-element>
	     *
	     *     <some-element [ngClass]="['first', 'second']">...</some-element>
	     *
	     *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
	     *
	     *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
	     *
	     *     <some-element [ngClass]="{'class1 class2 class3' : true}">...</some-element>
	     * ```
	     *
	     * \@description
	     *
	     * The CSS classes are updated as follows, depending on the type of the expression evaluation:
	     * - `string` - the CSS classes listed in the string (space delimited) are added,
	     * - `Array` - the CSS classes declared as Array elements are added,
	     * - `Object` - keys are CSS classes that get added when the expression given in the value
	     *              evaluates to a truthy value, otherwise they are removed.
	     *
	     * \@stable
	     */
	    var NgClass = (function () {
	        /**
	         * @param {?} _iterableDiffers
	         * @param {?} _keyValueDiffers
	         * @param {?} _ngEl
	         * @param {?} _renderer
	         */
	        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	            this._iterableDiffers = _iterableDiffers;
	            this._keyValueDiffers = _keyValueDiffers;
	            this._ngEl = _ngEl;
	            this._renderer = _renderer;
	            this._initialClasses = [];
	        }
	        Object.defineProperty(NgClass.prototype, "klass", {
	            /**
	             * @param {?} v
	             * @return {?}
	             */
	            set: function (v) {
	                this._applyInitialClasses(true);
	                this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
	                this._applyInitialClasses(false);
	                this._applyClasses(this._rawClass, false);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgClass.prototype, "ngClass", {
	            /**
	             * @param {?} v
	             * @return {?}
	             */
	            set: function (v) {
	                this._cleanupClasses(this._rawClass);
	                this._iterableDiffer = null;
	                this._keyValueDiffer = null;
	                this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
	                if (this._rawClass) {
	                    if (isListLikeIterable(this._rawClass)) {
	                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);
	                    }
	                    else {
	                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);
	                    }
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgClass.prototype.ngDoCheck = function () {
	            if (this._iterableDiffer) {
	                var /** @type {?} */ changes = this._iterableDiffer.diff(this._rawClass);
	                if (changes) {
	                    this._applyIterableChanges(changes);
	                }
	            }
	            else if (this._keyValueDiffer) {
	                var /** @type {?} */ changes = this._keyValueDiffer.diff(this._rawClass);
	                if (changes) {
	                    this._applyKeyValueChanges(changes);
	                }
	            }
	        };
	        /**
	         * @param {?} rawClassVal
	         * @return {?}
	         */
	        NgClass.prototype._cleanupClasses = function (rawClassVal) {
	            this._applyClasses(rawClassVal, true);
	            this._applyInitialClasses(false);
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgClass.prototype._applyKeyValueChanges = function (changes) {
	            var _this = this;
	            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	            changes.forEachRemovedItem(function (record) {
	                if (record.previousValue) {
	                    _this._toggleClass(record.key, false);
	                }
	            });
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgClass.prototype._applyIterableChanges = function (changes) {
	            var _this = this;
	            changes.forEachAddedItem(function (record) {
	                if (typeof record.item === 'string') {
	                    _this._toggleClass(record.item, true);
	                }
	                else {
	                    throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + stringify(record.item));
	                }
	            });
	            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
	        };
	        /**
	         * @param {?} isCleanup
	         * @return {?}
	         */
	        NgClass.prototype._applyInitialClasses = function (isCleanup) {
	            var _this = this;
	            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	        };
	        /**
	         * @param {?} rawClassVal
	         * @param {?} isCleanup
	         * @return {?}
	         */
	        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
	            var _this = this;
	            if (rawClassVal) {
	                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
	                    ((rawClassVal)).forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	                }
	                else {
	                    Object.keys(rawClassVal).forEach(function (klass) {
	                        if (rawClassVal[klass] != null)
	                            _this._toggleClass(klass, !isCleanup);
	                    });
	                }
	            }
	        };
	        /**
	         * @param {?} klass
	         * @param {?} enabled
	         * @return {?}
	         */
	        NgClass.prototype._toggleClass = function (klass, enabled) {
	            var _this = this;
	            klass = klass.trim();
	            if (klass) {
	                klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });
	            }
	        };
	        NgClass.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },
	        ];
	        /** @nocollapse */
	        NgClass.ctorParameters = function () { return [
	            { type: _angular_core.IterableDiffers, },
	            { type: _angular_core.KeyValueDiffers, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	        ]; };
	        NgClass.propDecorators = {
	            'klass': [{ type: _angular_core.Input, args: ['class',] },],
	            'ngClass': [{ type: _angular_core.Input },],
	        };
	        return NgClass;
	    }());

	    var NgForRow = (function () {
	        /**
	         * @param {?} $implicit
	         * @param {?} index
	         * @param {?} count
	         */
	        function NgForRow($implicit, index, count) {
	            this.$implicit = $implicit;
	            this.index = index;
	            this.count = count;
	        }
	        Object.defineProperty(NgForRow.prototype, "first", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.index === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "last", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.index === this.count - 1; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "even", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.index % 2 === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "odd", {
	            /**
	             * @return {?}
	             */
	            get: function () { return !this.even; },
	            enumerable: true,
	            configurable: true
	        });
	        return NgForRow;
	    }());
	    /**
	     * The `NgFor` directive instantiates a template once per item from an iterable. The context for
	     * each instantiated template inherits from the outer context with the given loop variable set
	     * to the current item from the iterable.
	     *
	     * ### Local Variables
	     *
	     * `NgFor` provides several exported values that can be aliased to local variables:
	     *
	     * * `index` will be set to the current loop iteration for each template context.
	     * * `first` will be set to a boolean value indicating whether the item is the first one in the
	     *   iteration.
	     * * `last` will be set to a boolean value indicating whether the item is the last one in the
	     *   iteration.
	     * * `even` will be set to a boolean value indicating whether this item has an even index.
	     * * `odd` will be set to a boolean value indicating whether this item has an odd index.
	     *
	     * ### Change Propagation
	     *
	     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
	     *
	     * * When an item is added, a new instance of the template is added to the DOM.
	     * * When an item is removed, its template instance is removed from the DOM.
	     * * When items are reordered, their respective templates are reordered in the DOM.
	     * * Otherwise, the DOM element for that item will remain the same.
	     *
	     * Angular uses object identity to track insertions and deletions within the iterator and reproduce
	     * those changes in the DOM. This has important implications for animations and any stateful
	     * controls
	     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be
	     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such
	     * as user input.
	     *
	     * It is possible for the identities of elements in the iterator to change while the data does not.
	     * This can happen, for example, if the iterator produced from an RPC to the server, and that
	     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
	     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
	     * elements were deleted and all new elements inserted). This is an expensive operation and should
	     * be avoided if possible.
	     *
	     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.
	     * `trackBy` takes a function which has two arguments: `index` and `item`.
	     * If `trackBy` is given, Angular tracks changes by the return value of the function.
	     *
	     * ### Syntax
	     *
	     * - `<li *ngFor="let item of items; let i = index; trackBy: trackByFn">...</li>`
	     * - `<li template="ngFor let item of items; let i = index; trackBy: trackByFn">...</li>`
	     *
	     * With `<template>` element:
	     *
	     * ```
	     * <template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
	     *   <li>...</li>
	     * </template>
	     * ```
	     *
	     * ### Example
	     *
	     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
	     * example.
	     *
	     * \@stable
	     */
	    var NgFor = (function () {
	        /**
	         * @param {?} _viewContainer
	         * @param {?} _template
	         * @param {?} _differs
	         * @param {?} _cdr
	         */
	        function NgFor(_viewContainer, _template, _differs, _cdr) {
	            this._viewContainer = _viewContainer;
	            this._template = _template;
	            this._differs = _differs;
	            this._cdr = _cdr;
	            this._differ = null;
	        }
	        Object.defineProperty(NgFor.prototype, "ngForTrackBy", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._trackByFn; },
	            /**
	             * @param {?} fn
	             * @return {?}
	             */
	            set: function (fn) {
	                if (_angular_core.isDevMode() && fn != null && typeof fn !== 'function') {
	                    // TODO(vicb): use a log service once there is a public one available
	                    if ((console) && (console.warn)) {
	                        console.warn(("trackBy must be a function, but received " + JSON.stringify(fn) + ". ") +
	                            "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.");
	                    }
	                }
	                this._trackByFn = fn;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgFor.prototype, "ngForTemplate", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (value) {
	                    this._template = value;
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgFor.prototype.ngOnChanges = function (changes) {
	            if ('ngForOf' in changes) {
	                // React on ngForOf changes only once all inputs have been initialized
	                var /** @type {?} */ value = changes['ngForOf'].currentValue;
	                if (!this._differ && value) {
	                    try {
	                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);
	                    }
	                    catch (e) {
	                        throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
	                    }
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgFor.prototype.ngDoCheck = function () {
	            if (this._differ) {
	                var /** @type {?} */ changes = this._differ.diff(this.ngForOf);
	                if (changes)
	                    this._applyChanges(changes);
	            }
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgFor.prototype._applyChanges = function (changes) {
	            var _this = this;
	            var /** @type {?} */ insertTuples = [];
	            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
	                if (item.previousIndex == null) {
	                    var /** @type {?} */ view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);
	                    var /** @type {?} */ tuple = new RecordViewTuple(item, view);
	                    insertTuples.push(tuple);
	                }
	                else if (currentIndex == null) {
	                    _this._viewContainer.remove(adjustedPreviousIndex);
	                }
	                else {
	                    var /** @type {?} */ view = _this._viewContainer.get(adjustedPreviousIndex);
	                    _this._viewContainer.move(view, currentIndex);
	                    var /** @type {?} */ tuple = new RecordViewTuple(item, /** @type {?} */ (view));
	                    insertTuples.push(tuple);
	                }
	            });
	            for (var /** @type {?} */ i = 0; i < insertTuples.length; i++) {
	                this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	            }
	            for (var /** @type {?} */ i = 0, /** @type {?} */ ilen = this._viewContainer.length; i < ilen; i++) {
	                var /** @type {?} */ viewRef = (this._viewContainer.get(i));
	                viewRef.context.index = i;
	                viewRef.context.count = ilen;
	            }
	            changes.forEachIdentityChange(function (record) {
	                var /** @type {?} */ viewRef = (_this._viewContainer.get(record.currentIndex));
	                viewRef.context.$implicit = record.item;
	            });
	        };
	        /**
	         * @param {?} view
	         * @param {?} record
	         * @return {?}
	         */
	        NgFor.prototype._perViewChange = function (view, record) {
	            view.context.$implicit = record.item;
	        };
	        NgFor.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
	        ];
	        /** @nocollapse */
	        NgFor.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: _angular_core.IterableDiffers, },
	            { type: _angular_core.ChangeDetectorRef, },
	        ]; };
	        NgFor.propDecorators = {
	            'ngForOf': [{ type: _angular_core.Input },],
	            'ngForTrackBy': [{ type: _angular_core.Input },],
	            'ngForTemplate': [{ type: _angular_core.Input },],
	        };
	        return NgFor;
	    }());
	    var RecordViewTuple = (function () {
	        /**
	         * @param {?} record
	         * @param {?} view
	         */
	        function RecordViewTuple(record, view) {
	            this.record = record;
	            this.view = view;
	        }
	        return RecordViewTuple;
	    }());

	    /**
	     * Removes or recreates a portion of the DOM tree based on an {expression}.
	     *
	     * If the expression assigned to `ngIf` evaluates to a falsy value then the element
	     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
	     *
	     * ```
	     * <div *ngIf="errorCount > 0" class="error">
	     *   <!-- Error message displayed when the errorCount property in the current context is greater
	     * than 0. -->
	     *   {{errorCount}} errors detected
	     * </div>
	     * ```
	     *
	     * ### Syntax
	     *
	     * - `<div *ngIf="condition">...</div>`
	     * - `<div template="ngIf condition">...</div>`
	     * - `<template [ngIf]="condition"><div>...</div></template>`
	     *
	     * \@stable
	     */
	    var NgIf = (function () {
	        /**
	         * @param {?} _viewContainer
	         * @param {?} _template
	         */
	        function NgIf(_viewContainer, _template) {
	            this._viewContainer = _viewContainer;
	            this._template = _template;
	            this._hasView = false;
	        }
	        Object.defineProperty(NgIf.prototype, "ngIf", {
	            /**
	             * @param {?} condition
	             * @return {?}
	             */
	            set: function (condition) {
	                if (condition && !this._hasView) {
	                    this._hasView = true;
	                    this._viewContainer.createEmbeddedView(this._template);
	                }
	                else if (!condition && this._hasView) {
	                    this._hasView = false;
	                    this._viewContainer.clear();
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgIf.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },
	        ];
	        /** @nocollapse */
	        NgIf.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	        ]; };
	        NgIf.propDecorators = {
	            'ngIf': [{ type: _angular_core.Input },],
	        };
	        return NgIf;
	    }());

	    var SwitchView = (function () {
	        /**
	         * @param {?} _viewContainerRef
	         * @param {?} _templateRef
	         */
	        function SwitchView(_viewContainerRef, _templateRef) {
	            this._viewContainerRef = _viewContainerRef;
	            this._templateRef = _templateRef;
	            this._created = false;
	        }
	        /**
	         * @return {?}
	         */
	        SwitchView.prototype.create = function () {
	            this._created = true;
	            this._viewContainerRef.createEmbeddedView(this._templateRef);
	        };
	        /**
	         * @return {?}
	         */
	        SwitchView.prototype.destroy = function () {
	            this._created = false;
	            this._viewContainerRef.clear();
	        };
	        /**
	         * @param {?} created
	         * @return {?}
	         */
	        SwitchView.prototype.enforceState = function (created) {
	            if (created && !this._created) {
	                this.create();
	            }
	            else if (!created && this._created) {
	                this.destroy();
	            }
	        };
	        return SwitchView;
	    }());
	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
	     *             expression.
	     *
	     * \@howToUse
	     * ```
	     *     <container-element [ngSwitch]="switch_expression">
	     *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
	     *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
	     *       <ng-container *ngSwitchCase="match_expression_3">
	     *         <!-- use a ng-container to group multiple root nodes -->
	     *         <inner-element></inner-element>
	     *         <inner-other-element></inner-other-element>
	     *       </ng-container>
	     *       <some-element *ngSwitchDefault>...</some-element>
	     *     </container-element>
	     * ```
	     * \@description
	     *
	     * `NgSwitch` stamps out nested views when their match expression value matches the value of the
	     * switch expression.
	     *
	     * In other words:
	     * - you define a container element (where you place the directive with a switch expression on the
	     * `[ngSwitch]="..."` attribute)
	     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
	     * root elements.
	     *
	     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
	     * be preserved at the location.
	     *
	     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
	     * expression is evaluated.
	     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
	     * stamped out.
	     *
	     * \@stable
	     */
	    var NgSwitch = (function () {
	        function NgSwitch() {
	            this._defaultUsed = false;
	            this._caseCount = 0;
	            this._lastCaseCheckIndex = 0;
	            this._lastCasesMatched = false;
	        }
	        Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
	            /**
	             * @param {?} newValue
	             * @return {?}
	             */
	            set: function (newValue) {
	                this._ngSwitch = newValue;
	                if (this._caseCount === 0) {
	                    this._updateDefaultCases(true);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NgSwitch.prototype._addCase = function () { return this._caseCount++; };
	        /**
	         * \@internal
	         * @param {?} view
	         * @return {?}
	         */
	        NgSwitch.prototype._addDefault = function (view) {
	            if (!this._defaultViews) {
	                this._defaultViews = [];
	            }
	            this._defaultViews.push(view);
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSwitch.prototype._matchCase = function (value) {
	            var /** @type {?} */ matched = value == this._ngSwitch;
	            this._lastCasesMatched = this._lastCasesMatched || matched;
	            this._lastCaseCheckIndex++;
	            if (this._lastCaseCheckIndex === this._caseCount) {
	                this._updateDefaultCases(!this._lastCasesMatched);
	                this._lastCaseCheckIndex = 0;
	                this._lastCasesMatched = false;
	            }
	            return matched;
	        };
	        /**
	         * @param {?} useDefault
	         * @return {?}
	         */
	        NgSwitch.prototype._updateDefaultCases = function (useDefault) {
	            if (this._defaultViews && useDefault !== this._defaultUsed) {
	                this._defaultUsed = useDefault;
	                for (var /** @type {?} */ i = 0; i < this._defaultViews.length; i++) {
	                    var /** @type {?} */ defaultView = this._defaultViews[i];
	                    defaultView.enforceState(useDefault);
	                }
	            }
	        };
	        NgSwitch.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitch.ctorParameters = function () { return []; };
	        NgSwitch.propDecorators = {
	            'ngSwitch': [{ type: _angular_core.Input },],
	        };
	        return NgSwitch;
	    }());
	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgSwitch} when the
	     *             given expression evaluate to respectively the same/different value as the switch
	     *             expression.
	     *
	     * \@howToUse
	     * ```
	     * <container-element [ngSwitch]="switch_expression">
	     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     * </container-element>
	     * ```
	     * \@description
	     *
	     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
	     * expression.
	     *
	     * If multiple match expressions match the switch expression value, all of them are displayed.
	     *
	     * See {\@link NgSwitch} for more details and example.
	     *
	     * \@stable
	     */
	    var NgSwitchCase = (function () {
	        /**
	         * @param {?} viewContainer
	         * @param {?} templateRef
	         * @param {?} ngSwitch
	         */
	        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
	            this.ngSwitch = ngSwitch;
	            ngSwitch._addCase();
	            this._view = new SwitchView(viewContainer, templateRef);
	        }
	        /**
	         * @return {?}
	         */
	        NgSwitchCase.prototype.ngDoCheck = function () { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)); };
	        NgSwitchCase.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitchCase.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	        ]; };
	        NgSwitchCase.propDecorators = {
	            'ngSwitchCase': [{ type: _angular_core.Input },],
	        };
	        return NgSwitchCase;
	    }());
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Creates a view that is added to the parent {\@link NgSwitch} when no case expressions
	     * match the
	     *             switch expression.
	     *
	     * \@howToUse
	     * ```
	     * <container-element [ngSwitch]="switch_expression">
	     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     *   <some-other-element *ngSwitchDefault>...</some-other-element>
	     * </container-element>
	     * ```
	     *
	     * \@description
	     *
	     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
	     * expression.
	     *
	     * See {\@link NgSwitch} for more details and example.
	     *
	     * \@stable
	     */
	    var NgSwitchDefault = (function () {
	        /**
	         * @param {?} viewContainer
	         * @param {?} templateRef
	         * @param {?} ngSwitch
	         */
	        function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {
	            ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
	        }
	        NgSwitchDefault.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitchDefault.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	        ]; };
	        return NgSwitchDefault;
	    }());

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
	     *
	     * \@howToUse
	     * ```
	     * <some-element [ngPlural]="value">
	     *   <template ngPluralCase="=0">there is nothing</template>
	     *   <template ngPluralCase="=1">there is one</template>
	     *   <template ngPluralCase="few">there are a few</template>
	     * </some-element>
	     * ```
	     *
	     * \@description
	     *
	     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
	     * that match the switch expression's pluralization category.
	     *
	     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
	     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
	     * expression:
	     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
	     *   matches the switch expression exactly,
	     * - otherwise, the view will be treated as a "category match", and will only display if exact
	     *   value matches aren't found and the value maps to its category for the defined locale.
	     *
	     * See http://cldr.unicode.org/index/cldr-spec/plural-rules
	     *
	     * \@experimental
	     */
	    var NgPlural = (function () {
	        /**
	         * @param {?} _localization
	         */
	        function NgPlural(_localization) {
	            this._localization = _localization;
	            this._caseViews = {};
	        }
	        Object.defineProperty(NgPlural.prototype, "ngPlural", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._switchValue = value;
	                this._updateView();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} value
	         * @param {?} switchView
	         * @return {?}
	         */
	        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
	        /**
	         * @return {?}
	         */
	        NgPlural.prototype._updateView = function () {
	            this._clearViews();
	            var /** @type {?} */ cases = Object.keys(this._caseViews);
	            var /** @type {?} */ key = getPluralCategory(this._switchValue, cases, this._localization);
	            this._activateView(this._caseViews[key]);
	        };
	        /**
	         * @return {?}
	         */
	        NgPlural.prototype._clearViews = function () {
	            if (this._activeView)
	                this._activeView.destroy();
	        };
	        /**
	         * @param {?} view
	         * @return {?}
	         */
	        NgPlural.prototype._activateView = function (view) {
	            if (view) {
	                this._activeView = view;
	                this._activeView.create();
	            }
	        };
	        NgPlural.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },
	        ];
	        /** @nocollapse */
	        NgPlural.ctorParameters = function () { return [
	            { type: NgLocalization, },
	        ]; };
	        NgPlural.propDecorators = {
	            'ngPlural': [{ type: _angular_core.Input },],
	        };
	        return NgPlural;
	    }());
	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgPlural} when the
	     *             given expression matches the plural expression according to CLDR rules.
	     *
	     * \@howToUse
	     * ```
	     * <some-element [ngPlural]="value">
	     *   <template ngPluralCase="=0">...</template>
	     *   <template ngPluralCase="other">...</template>
	     * </some-element>
	     * ```
	     *
	     * See {\@link NgPlural} for more details and example.
	     *
	     * \@experimental
	     */
	    var NgPluralCase = (function () {
	        /**
	         * @param {?} value
	         * @param {?} template
	         * @param {?} viewContainer
	         * @param {?} ngPlural
	         */
	        function NgPluralCase(value, template, viewContainer, ngPlural) {
	            this.value = value;
	            var isANumber = !isNaN(Number(value));
	            ngPlural.addCase(isANumber ? "=" + value : value, new SwitchView(viewContainer, template));
	        }
	        NgPluralCase.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },
	        ];
	        /** @nocollapse */
	        NgPluralCase.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
	            { type: _angular_core.TemplateRef, },
	            { type: _angular_core.ViewContainerRef, },
	            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
	        ]; };
	        return NgPluralCase;
	    }());

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Update an HTML element styles.
	     *
	     * \@howToUse
	     * ```
	     * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
	     *
	     * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
	     *
	     * <some-element [ngStyle]="objExp">...</some-element>
	     * ```
	     *
	     * \@description
	     *
	     * The styles are updated according to the value of the expression evaluation:
	     * - keys are style names with an optional `.<unit>` suffix (ie 'top.px', 'font-style.em'),
	     * - values are the values assigned to those properties (expressed in the given unit).
	     *
	     * \@stable
	     */
	    var NgStyle = (function () {
	        /**
	         * @param {?} _differs
	         * @param {?} _ngEl
	         * @param {?} _renderer
	         */
	        function NgStyle(_differs, _ngEl, _renderer) {
	            this._differs = _differs;
	            this._ngEl = _ngEl;
	            this._renderer = _renderer;
	        }
	        Object.defineProperty(NgStyle.prototype, "ngStyle", {
	            /**
	             * @param {?} v
	             * @return {?}
	             */
	            set: function (v) {
	                this._ngStyle = v;
	                if (!this._differ && v) {
	                    this._differ = this._differs.find(v).create(null);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgStyle.prototype.ngDoCheck = function () {
	            if (this._differ) {
	                var /** @type {?} */ changes = this._differ.diff(this._ngStyle);
	                if (changes) {
	                    this._applyChanges(changes);
	                }
	            }
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgStyle.prototype._applyChanges = function (changes) {
	            var _this = this;
	            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
	            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	        };
	        /**
	         * @param {?} nameAndUnit
	         * @param {?} value
	         * @return {?}
	         */
	        NgStyle.prototype._setStyle = function (nameAndUnit, value) {
	            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
	            value = value && unit ? "" + value + unit : value;
	            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);
	        };
	        NgStyle.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },
	        ];
	        /** @nocollapse */
	        NgStyle.ctorParameters = function () { return [
	            { type: _angular_core.KeyValueDiffers, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	        ]; };
	        NgStyle.propDecorators = {
	            'ngStyle': [{ type: _angular_core.Input },],
	        };
	        return NgStyle;
	    }());

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Inserts an embedded view from a prepared `TemplateRef`
	     *
	     * \@howToUse
	     * ```
	     * <template [ngTemplateOutlet]="templateRefExpression"
	     *           [ngOutletContext]="objectExpression">
	     * </template>
	     * ```
	     *
	     * \@description
	     *
	     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.
	     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables
	     * available within the `TemplateRef`.
	     *
	     * Note: using the key `$implicit` in the context object will set it's value as default.
	     *
	     * \@experimental
	     */
	    var NgTemplateOutlet = (function () {
	        /**
	         * @param {?} _viewContainerRef
	         */
	        function NgTemplateOutlet(_viewContainerRef) {
	            this._viewContainerRef = _viewContainerRef;
	        }
	        Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
	            /**
	             * @param {?} context
	             * @return {?}
	             */
	            set: function (context) { this._context = context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
	            /**
	             * @param {?} templateRef
	             * @return {?}
	             */
	            set: function (templateRef) { this._templateRef = templateRef; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
	            if (this._viewRef) {
	                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
	            }
	            if (this._templateRef) {
	                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
	            }
	        };
	        NgTemplateOutlet.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
	        ];
	        /** @nocollapse */
	        NgTemplateOutlet.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	        ]; };
	        NgTemplateOutlet.propDecorators = {
	            'ngOutletContext': [{ type: _angular_core.Input },],
	            'ngTemplateOutlet': [{ type: _angular_core.Input },],
	        };
	        return NgTemplateOutlet;
	    }());

	    /**
	     * A collection of Angular directives that are likely to be used in each and every Angular
	     * application.
	     */
	    var /** @type {?} */ COMMON_DIRECTIVES = [
	        NgClass,
	        NgFor,
	        NgIf,
	        NgTemplateOutlet,
	        NgStyle,
	        NgSwitch,
	        NgSwitchCase,
	        NgSwitchDefault,
	        NgPlural,
	        NgPluralCase,
	    ];

	    var /** @type {?} */ isPromise = _angular_core.__core_private__.isPromise;
	    var /** @type {?} */ isObservable = _angular_core.__core_private__.isObservable;

	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     */
	    var BaseError = (function (_super) {
	        __extends$4(BaseError, _super);
	        /**
	         * @param {?} message
	         */
	        function BaseError(message) {
	            _super.call(this, message);
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            // TODO(bradfordcsmith): Remove this hack when
	            //     google/closure-compiler/issues/2102 is fixed.
	            var nativeError = new Error(message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.message; },
	            /**
	             * @param {?} message
	             * @return {?}
	             */
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () { return ((this._nativeError)).stack; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { ((this._nativeError)).stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * \@stable
	     */
	    var WrappedError = (function (_super) {
	        __extends$4(WrappedError, _super);
	        /**
	         * @param {?} message
	         * @param {?} error
	         */
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (((this.originalError instanceof Error ? this.originalError : this._nativeError)))
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var InvalidPipeArgumentError = (function (_super) {
	        __extends$3(InvalidPipeArgumentError, _super);
	        /**
	         * @param {?} type
	         * @param {?} value
	         */
	        function InvalidPipeArgumentError(type, value) {
	            _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify(type) + "'");
	        }
	        return InvalidPipeArgumentError;
	    }(BaseError));

	    var ObservableStrategy = (function () {
	        function ObservableStrategy() {
	        }
	        /**
	         * @param {?} async
	         * @param {?} updateLatestValue
	         * @return {?}
	         */
	        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
	        };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
	        return ObservableStrategy;
	    }());
	    var PromiseStrategy = (function () {
	        function PromiseStrategy() {
	        }
	        /**
	         * @param {?} async
	         * @param {?} updateLatestValue
	         * @return {?}
	         */
	        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	            return async.then(updateLatestValue, function (e) { throw e; });
	        };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        PromiseStrategy.prototype.dispose = function (subscription) { };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        PromiseStrategy.prototype.onDestroy = function (subscription) { };
	        return PromiseStrategy;
	    }());
	    var /** @type {?} */ _promiseStrategy = new PromiseStrategy();
	    var /** @type {?} */ _observableStrategy = new ObservableStrategy();
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Unwraps a value from an asynchronous primitive.
	     * \@howToUse `observable_or_promise_expression | async`
	     * \@description
	     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
	     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
	     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
	     * potential memory leaks.
	     *
	     *
	     * ## Examples
	     *
	     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
	     * promise.
	     *
	     * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
	     *
	     * It's also possible to use `async` with Observables. The example below binds the `time` Observable
	     * to the view. The Observable continuously updates the view with the current time.
	     *
	     * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
	     *
	     * \@stable
	     */
	    var AsyncPipe = (function () {
	        /**
	         * @param {?} _ref
	         */
	        function AsyncPipe(_ref) {
	            this._ref = _ref;
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	            this._strategy = null;
	        }
	        /**
	         * @return {?}
	         */
	        AsyncPipe.prototype.ngOnDestroy = function () {
	            if (this._subscription) {
	                this._dispose();
	            }
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        AsyncPipe.prototype.transform = function (obj) {
	            if (!this._obj) {
	                if (obj) {
	                    this._subscribe(obj);
	                }
	                this._latestReturnedValue = this._latestValue;
	                return this._latestValue;
	            }
	            if (obj !== this._obj) {
	                this._dispose();
	                return this.transform(obj);
	            }
	            if (this._latestValue === this._latestReturnedValue) {
	                return this._latestReturnedValue;
	            }
	            this._latestReturnedValue = this._latestValue;
	            return _angular_core.WrappedValue.wrap(this._latestValue);
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        AsyncPipe.prototype._subscribe = function (obj) {
	            var _this = this;
	            this._obj = obj;
	            this._strategy = this._selectStrategy(obj);
	            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        AsyncPipe.prototype._selectStrategy = function (obj) {
	            if (isPromise(obj)) {
	                return _promiseStrategy;
	            }
	            if (isObservable(obj)) {
	                return _observableStrategy;
	            }
	            throw new InvalidPipeArgumentError(AsyncPipe, obj);
	        };
	        /**
	         * @return {?}
	         */
	        AsyncPipe.prototype._dispose = function () {
	            this._strategy.dispose(this._subscription);
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	        };
	        /**
	         * @param {?} async
	         * @param {?} value
	         * @return {?}
	         */
	        AsyncPipe.prototype._updateLatestValue = function (async, value) {
	            if (async === this._obj) {
	                this._latestValue = value;
	                this._ref.markForCheck();
	            }
	        };
	        AsyncPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },
	        ];
	        /** @nocollapse */
	        AsyncPipe.ctorParameters = function () { return [
	            { type: _angular_core.ChangeDetectorRef, },
	        ]; };
	        return AsyncPipe;
	    }());

	    var NumberFormatStyle = {};
	    NumberFormatStyle.Decimal = 0;
	    NumberFormatStyle.Percent = 1;
	    NumberFormatStyle.Currency = 2;
	    NumberFormatStyle[NumberFormatStyle.Decimal] = "Decimal";
	    NumberFormatStyle[NumberFormatStyle.Percent] = "Percent";
	    NumberFormatStyle[NumberFormatStyle.Currency] = "Currency";
	    var NumberFormatter = (function () {
	        function NumberFormatter() {
	        }
	        /**
	         * @param {?} num
	         * @param {?} locale
	         * @param {?} style
	         * @param {?=} __3
	         * @return {?}
	         */
	        NumberFormatter.format = function (num, locale, style, _a) {
	            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
	            var /** @type {?} */ options = {
	                minimumIntegerDigits: minimumIntegerDigits,
	                minimumFractionDigits: minimumFractionDigits,
	                maximumFractionDigits: maximumFractionDigits,
	                style: NumberFormatStyle[style].toLowerCase()
	            };
	            if (style == NumberFormatStyle.Currency) {
	                options.currency = currency;
	                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	            }
	            return new Intl.NumberFormat(locale, options).format(num);
	        };
	        return NumberFormatter;
	    }());
	    var /** @type {?} */ DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
	    var /** @type {?} */ PATTERN_ALIASES = {
	        // Keys are quoted so they do not get renamed during closure compilation.
	        'yMMMdjms': datePartGetterFactory(combine([
	            digitCondition('year', 1),
	            nameCondition('month', 3),
	            digitCondition('day', 1),
	            digitCondition('hour', 1),
	            digitCondition('minute', 1),
	            digitCondition('second', 1),
	        ])),
	        'yMdjm': datePartGetterFactory(combine([
	            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
	            digitCondition('hour', 1), digitCondition('minute', 1)
	        ])),
	        'yMMMMEEEEd': datePartGetterFactory(combine([
	            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
	            digitCondition('day', 1)
	        ])),
	        'yMMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
	        'yMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
	        'yMd': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
	        'jms': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
	        'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
	    };
	    var /** @type {?} */ DATE_FORMATS = {
	        // Keys are quoted so they do not get renamed.
	        'yyyy': datePartGetterFactory(digitCondition('year', 4)),
	        'yy': datePartGetterFactory(digitCondition('year', 2)),
	        'y': datePartGetterFactory(digitCondition('year', 1)),
	        'MMMM': datePartGetterFactory(nameCondition('month', 4)),
	        'MMM': datePartGetterFactory(nameCondition('month', 3)),
	        'MM': datePartGetterFactory(digitCondition('month', 2)),
	        'M': datePartGetterFactory(digitCondition('month', 1)),
	        'LLLL': datePartGetterFactory(nameCondition('month', 4)),
	        'L': datePartGetterFactory(nameCondition('month', 1)),
	        'dd': datePartGetterFactory(digitCondition('day', 2)),
	        'd': datePartGetterFactory(digitCondition('day', 1)),
	        'HH': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
	        'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
	        'hh': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
	        'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	        'jj': datePartGetterFactory(digitCondition('hour', 2)),
	        'j': datePartGetterFactory(digitCondition('hour', 1)),
	        'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
	        'm': datePartGetterFactory(digitCondition('minute', 1)),
	        'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),
	        's': datePartGetterFactory(digitCondition('second', 1)),
	        // while ISO 8601 requires fractions to be prefixed with `.` or `,`
	        // we can be just safely rely on using `sss` since we currently don't support single or two digit
	        // fractions
	        'sss': datePartGetterFactory(digitCondition('second', 3)),
	        'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),
	        'EEE': datePartGetterFactory(nameCondition('weekday', 3)),
	        'EE': datePartGetterFactory(nameCondition('weekday', 2)),
	        'E': datePartGetterFactory(nameCondition('weekday', 1)),
	        'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	        'Z': timeZoneGetter('short'),
	        'z': timeZoneGetter('long'),
	        'ww': datePartGetterFactory({}),
	        // first Thursday of the year. not support ?
	        'w': datePartGetterFactory({}),
	        // of the year not support ?
	        'G': datePartGetterFactory(nameCondition('era', 1)),
	        'GG': datePartGetterFactory(nameCondition('era', 2)),
	        'GGG': datePartGetterFactory(nameCondition('era', 3)),
	        'GGGG': datePartGetterFactory(nameCondition('era', 4))
	    };
	    /**
	     * @param {?} inner
	     * @return {?}
	     */
	    function digitModifier(inner) {
	        return function (date, locale) {
	            var /** @type {?} */ result = inner(date, locale);
	            return result.length == 1 ? '0' + result : result;
	        };
	    }
	    /**
	     * @param {?} inner
	     * @return {?}
	     */
	    function hourClockExtractor(inner) {
	        return function (date, locale) { return inner(date, locale).split(' ')[1]; };
	    }
	    /**
	     * @param {?} inner
	     * @return {?}
	     */
	    function hourExtractor(inner) {
	        return function (date, locale) { return inner(date, locale).split(' ')[0]; };
	    }
	    /**
	     * @param {?} date
	     * @param {?} locale
	     * @param {?} options
	     * @return {?}
	     */
	    function intlDateFormat(date, locale, options) {
	        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
	    }
	    /**
	     * @param {?} timezone
	     * @return {?}
	     */
	    function timeZoneGetter(timezone) {
	        // To workaround `Intl` API restriction for single timezone let format with 24 hours
	        var /** @type {?} */ options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
	        return function (date, locale) {
	            var /** @type {?} */ result = intlDateFormat(date, locale, options);
	            // Then extract first 3 letters that related to hours
	            return result ? result.substring(3) : '';
	        };
	    }
	    /**
	     * @param {?} options
	     * @param {?} value
	     * @return {?}
	     */
	    function hour12Modify(options, value) {
	        options.hour12 = value;
	        return options;
	    }
	    /**
	     * @param {?} prop
	     * @param {?} len
	     * @return {?}
	     */
	    function digitCondition(prop, len) {
	        var /** @type {?} */ result = {};
	        result[prop] = len === 2 ? '2-digit' : 'numeric';
	        return result;
	    }
	    /**
	     * @param {?} prop
	     * @param {?} len
	     * @return {?}
	     */
	    function nameCondition(prop, len) {
	        var /** @type {?} */ result = {};
	        if (len < 4) {
	            result[prop] = len > 1 ? 'short' : 'narrow';
	        }
	        else {
	            result[prop] = 'long';
	        }
	        return result;
	    }
	    /**
	     * @param {?} options
	     * @return {?}
	     */
	    function combine(options) {
	        return (_a = ((Object))).assign.apply(_a, [{}].concat(options));
	        var _a;
	    }
	    /**
	     * @param {?} ret
	     * @return {?}
	     */
	    function datePartGetterFactory(ret) {
	        return function (date, locale) { return intlDateFormat(date, locale, ret); };
	    }
	    var /** @type {?} */ DATE_FORMATTER_CACHE = new Map();
	    /**
	     * @param {?} format
	     * @param {?} date
	     * @param {?} locale
	     * @return {?}
	     */
	    function dateFormatter(format, date, locale) {
	        var /** @type {?} */ fn = PATTERN_ALIASES[format];
	        if (fn)
	            return fn(date, locale);
	        var /** @type {?} */ cacheKey = format;
	        var /** @type {?} */ parts = DATE_FORMATTER_CACHE.get(cacheKey);
	        if (!parts) {
	            parts = [];
	            var /** @type {?} */ match = void 0;
	            DATE_FORMATS_SPLIT.exec(format);
	            while (format) {
	                match = DATE_FORMATS_SPLIT.exec(format);
	                if (match) {
	                    parts = parts.concat(match.slice(1));
	                    format = parts.pop();
	                }
	                else {
	                    parts.push(format);
	                    format = null;
	                }
	            }
	            DATE_FORMATTER_CACHE.set(cacheKey, parts);
	        }
	        return parts.reduce(function (text, part) {
	            var /** @type {?} */ fn = DATE_FORMATS[part];
	            return text + (fn ? fn(date, locale) : partToTime(part));
	        }, '');
	    }
	    /**
	     * @param {?} part
	     * @return {?}
	     */
	    function partToTime(part) {
	        return part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
	    }
	    var DateFormatter = (function () {
	        function DateFormatter() {
	        }
	        /**
	         * @param {?} date
	         * @param {?} locale
	         * @param {?} pattern
	         * @return {?}
	         */
	        DateFormatter.format = function (date, locale, pattern) {
	            return dateFormatter(pattern, date, locale);
	        };
	        return DateFormatter;
	    }());

	    var /** @type {?} */ ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a date according to locale rules.
	     * \@howToUse `date_expression | date[:format]`
	     * \@description
	     *
	     * Where:
	     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
	     * (https://www.w3.org/TR/NOTE-datetime).
	     * - `format` indicates which date/time components to include. The format can be predefined as
	     *   shown below or custom as shown in the table.
	     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
	     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
	     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
	     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
	     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
	     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
	     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
	     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
	     *
	     *
	     *  | Component | Symbol | Narrow | Short Form   | Long Form         | Numeric   | 2-digit   |
	     *  |-----------|:------:|--------|--------------|-------------------|-----------|-----------|
	     *  | era       |   G    | G (A)  | GGG (AD)     | GGGG (Anno Domini)| -         | -         |
	     *  | year      |   y    | -      | -            | -                 | y (2015)  | yy (15)   |
	     *  | month     |   M    | L (S)  | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
	     *  | day       |   d    | -      | -            | -                 | d (3)     | dd (03)   |
	     *  | weekday   |   E    | E (S)  | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
	     *  | hour      |   j    | -      | -            | -                 | j (13)    | jj (13)   |
	     *  | hour12    |   h    | -      | -            | -                 | h (1 PM)  | hh (01 PM)|
	     *  | hour24    |   H    | -      | -            | -                 | H (13)    | HH (13)   |
	     *  | minute    |   m    | -      | -            | -                 | m (5)     | mm (05)   |
	     *  | second    |   s    | -      | -            | -                 | s (9)     | ss (09)   |
	     *  | timezone  |   z    | -      | -            | z (Pacific Standard Time)| -  | -         |
	     *  | timezone  |   Z    | -      | Z (GMT-8:00) | -                 | -         | -         |
	     *  | timezone  |   a    | -      | a (PM)       | -                 | -         | -         |
	     *
	     * In javascript, only the components specified will be respected (not the ordering,
	     * punctuations, ...) and details of the formatting will be dependent on the locale.
	     *
	     * Timezone of the formatted text will be the local system timezone of the end-user's machine.
	     *
	     * When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not
	     * applied and the formatted text will have the same day, month and year of the expression.
	     *
	     * WARNINGS:
	     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
	     *   Instead users should treat the date as an immutable object and change the reference when the
	     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
	     *   which would be an expensive operation).
	     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
	     *   browsers.
	     *
	     * ### Examples
	     *
	     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
	     * in the _local_ time and locale is 'en-US':
	     *
	     * ```
	     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
	     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
	     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
	     *     {{ dateObj | date:'mmss' }}        // output is '43:11'
	     * ```
	     *
	     * {\@example common/pipes/ts/date_pipe.ts region='DatePipe'}
	     *
	     * \@stable
	     */
	    var DatePipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function DatePipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} pattern
	         * @return {?}
	         */
	        DatePipe.prototype.transform = function (value, pattern) {
	            if (pattern === void 0) { pattern = 'mediumDate'; }
	            var /** @type {?} */ date;
	            if (isBlank$1(value) || value !== value)
	                return null;
	            if (typeof value === 'string') {
	                value = value.trim();
	            }
	            if (isDate(value)) {
	                date = value;
	            }
	            else if (NumberWrapper.isNumeric(value)) {
	                date = new Date(parseFloat(value));
	            }
	            else if (typeof value === 'string' && /^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
	                /**
	                * For ISO Strings without time the day, month and year must be extracted from the ISO String
	                * before Date creation to avoid time offset and errors in the new Date.
	                * If we only replace '-' with ',' in the ISO String ("2015,01,01"), and try to create a new
	                * date, some browsers (e.g. IE 9) will throw an invalid Date error
	                * If we leave the '-' ("2015-01-01") and try to create a new Date("2015-01-01") the timeoffset
	                * is applied
	                * Note: ISO months are 0 for January, 1 for February, ...
	                */
	                var _a = value.split('-').map(function (val) { return parseInt(val, 10); }), y = _a[0], m = _a[1], d = _a[2];
	                date = new Date(y, m - 1, d);
	            }
	            else {
	                date = new Date(value);
	            }
	            if (!isDate(date)) {
	                var /** @type {?} */ match = void 0;
	                if ((typeof value === 'string') && (match = value.match(ISO8601_DATE_REGEX))) {
	                    date = isoStringToDate(match);
	                }
	                else {
	                    throw new InvalidPipeArgumentError(DatePipe, value);
	                }
	            }
	            return DateFormatter.format(date, this._locale, DatePipe._ALIASES[pattern] || pattern);
	        };
	        /** @internal */
	        DatePipe._ALIASES = {
	            'medium': 'yMMMdjms',
	            'short': 'yMdjm',
	            'fullDate': 'yMMMMEEEEd',
	            'longDate': 'yMMMMd',
	            'mediumDate': 'yMMMd',
	            'shortDate': 'yMd',
	            'mediumTime': 'jms',
	            'shortTime': 'jm'
	        };
	        DatePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },
	        ];
	        /** @nocollapse */
	        DatePipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return DatePipe;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank$1(obj) {
	        return obj == null || obj === '';
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isDate(obj) {
	        return obj instanceof Date && !isNaN(obj.valueOf());
	    }
	    /**
	     * @param {?} match
	     * @return {?}
	     */
	    function isoStringToDate(match) {
	        var /** @type {?} */ date = new Date(0);
	        var /** @type {?} */ tzHour = 0;
	        var /** @type {?} */ tzMin = 0;
	        var /** @type {?} */ dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
	        var /** @type {?} */ timeSetter = match[8] ? date.setUTCHours : date.setHours;
	        if (match[9]) {
	            tzHour = toInt(match[9] + match[10]);
	            tzMin = toInt(match[9] + match[11]);
	        }
	        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
	        var /** @type {?} */ h = toInt(match[4] || '0') - tzHour;
	        var /** @type {?} */ m = toInt(match[5] || '0') - tzMin;
	        var /** @type {?} */ s = toInt(match[6] || '0');
	        var /** @type {?} */ ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
	        timeSetter.call(date, h, m, s, ms);
	        return date;
	    }
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function toInt(str) {
	        return parseInt(str, 10);
	    }

	    var /** @type {?} */ _INTERPOLATION_REGEXP = /#/g;
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
	     * \@howToUse `expression | i18nPlural:mapping`
	     * \@description
	     *
	     *  Where:
	     *  - `expression` is a number.
	     *  - `mapping` is an object that mimics the ICU format, see
	     *    http://userguide.icu-project.org/formatparse/messages
	     *
	     *  ## Example
	     *
	     * {\@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
	     *
	     * \@experimental
	     */
	    var I18nPluralPipe = (function () {
	        /**
	         * @param {?} _localization
	         */
	        function I18nPluralPipe(_localization) {
	            this._localization = _localization;
	        }
	        /**
	         * @param {?} value
	         * @param {?} pluralMap
	         * @return {?}
	         */
	        I18nPluralPipe.prototype.transform = function (value, pluralMap) {
	            if (value == null)
	                return '';
	            if (typeof pluralMap !== 'object' || pluralMap === null) {
	                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);
	            }
	            var /** @type {?} */ key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
	            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
	        };
	        I18nPluralPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
	        ];
	        /** @nocollapse */
	        I18nPluralPipe.ctorParameters = function () { return [
	            { type: NgLocalization, },
	        ]; };
	        return I18nPluralPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Generic selector that displays the string that matches the current value.
	     * \@howToUse `expression | i18nSelect:mapping`
	     * \@description
	     *
	     *  Where `mapping` is an object that indicates the text that should be displayed
	     *  for different values of the provided `expression`.
	     *  If none of the keys of the mapping match the value of the `expression`, then the content
	     *  of the `other` key is returned when present, otherwise an empty string is returned.
	     *
	     *  ## Example
	     *
	     * {\@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
	     *
	     *  \@experimental
	     */
	    var I18nSelectPipe = (function () {
	        function I18nSelectPipe() {
	        }
	        /**
	         * @param {?} value
	         * @param {?} mapping
	         * @return {?}
	         */
	        I18nSelectPipe.prototype.transform = function (value, mapping) {
	            if (value == null)
	                return '';
	            if (typeof mapping !== 'object' || typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);
	            }
	            if (mapping.hasOwnProperty(value)) {
	                return mapping[value];
	            }
	            if (mapping.hasOwnProperty('other')) {
	                return mapping['other'];
	            }
	            return '';
	        };
	        I18nSelectPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
	        ];
	        /** @nocollapse */
	        I18nSelectPipe.ctorParameters = function () { return []; };
	        return I18nSelectPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Converts value into JSON string.
	     * \@howToUse `expression | json`
	     * \@description
	     *
	     * Converts value into string using `JSON.stringify`. Useful for debugging.
	     *
	     * ### Example
	     * {\@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
	     *
	     * \@stable
	     */
	    var JsonPipe = (function () {
	        function JsonPipe() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };
	        JsonPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },
	        ];
	        /** @nocollapse */
	        JsonPipe.ctorParameters = function () { return []; };
	        return JsonPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Transforms string to lowercase.
	     * \@howToUse `expression | lowercase`
	     * \@description
	     *
	     * Converts value into a lowercase string using `String.prototype.toLowerCase()`.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
	     *
	     * \@stable
	     */
	    var LowerCasePipe = (function () {
	        function LowerCasePipe() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        LowerCasePipe.prototype.transform = function (value) {
	            if (isBlank(value))
	                return value;
	            if (typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(LowerCasePipe, value);
	            }
	            return value.toLowerCase();
	        };
	        LowerCasePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },
	        ];
	        /** @nocollapse */
	        LowerCasePipe.ctorParameters = function () { return []; };
	        return LowerCasePipe;
	    }());

	    var /** @type {?} */ _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
	    /**
	     * @param {?} pipe
	     * @param {?} locale
	     * @param {?} value
	     * @param {?} style
	     * @param {?} digits
	     * @param {?=} currency
	     * @param {?=} currencyAsSymbol
	     * @return {?}
	     */
	    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
	        if (currency === void 0) { currency = null; }
	        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
	        if (value == null)
	            return null;
	        // Convert strings to numbers
	        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;
	        if (typeof value !== 'number') {
	            throw new InvalidPipeArgumentError(pipe, value);
	        }
	        var /** @type {?} */ minInt;
	        var /** @type {?} */ minFraction;
	        var /** @type {?} */ maxFraction;
	        if (style !== NumberFormatStyle.Currency) {
	            // rely on Intl default for currency
	            minInt = 1;
	            minFraction = 0;
	            maxFraction = 3;
	        }
	        if (digits) {
	            var /** @type {?} */ parts = digits.match(_NUMBER_FORMAT_REGEXP);
	            if (parts === null) {
	                throw new Error(digits + " is not a valid digit info for number pipes");
	            }
	            if (parts[1] != null) {
	                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
	            }
	            if (parts[3] != null) {
	                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
	            }
	            if (parts[5] != null) {
	                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
	            }
	        }
	        return NumberFormatter.format(/** @type {?} */ (value), locale, style, {
	            minimumIntegerDigits: minInt,
	            minimumFractionDigits: minFraction,
	            maximumFractionDigits: maxFraction,
	            currency: currency,
	            currencyAsSymbol: currencyAsSymbol,
	        });
	    }
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a number according to locale rules.
	     * \@howToUse `number_expression | number[:digitInfo]`
	     *
	     * Formats a number as text. Group sizing and separator and other locale-specific
	     * configurations are based on the active locale.
	     *
	     * where `expression` is a number:
	     *  - `digitInfo` is a `string` which has a following format: <br>
	     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
	     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
	     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
	     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
	     *
	     * For more information on the acceptable range for each of these numbers and other
	     * details see your native internationalization library.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
	     *
	     * \@stable
	     */
	    var DecimalPipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function DecimalPipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} digits
	         * @return {?}
	         */
	        DecimalPipe.prototype.transform = function (value, digits) {
	            if (digits === void 0) { digits = null; }
	            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
	        };
	        DecimalPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'number' },] },
	        ];
	        /** @nocollapse */
	        DecimalPipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return DecimalPipe;
	    }());
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a number as a percentage according to locale rules.
	     * \@howToUse `number_expression | percent[:digitInfo]`
	     *
	     * \@description
	     *
	     * Formats a number as percentage.
	     *
	     * - `digitInfo` See {\@link DecimalPipe} for detailed description.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
	     *
	     * \@stable
	     */
	    var PercentPipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function PercentPipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} digits
	         * @return {?}
	         */
	        PercentPipe.prototype.transform = function (value, digits) {
	            if (digits === void 0) { digits = null; }
	            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
	        };
	        PercentPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },
	        ];
	        /** @nocollapse */
	        PercentPipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return PercentPipe;
	    }());
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a number as currency using locale rules.
	     * \@howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
	     * \@description
	     *
	     * Use `currency` to format a number as currency.
	     *
	     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
	     *    as `USD` for the US dollar and `EUR` for the euro.
	     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
	     *   - `true`: use symbol (e.g. `$`).
	     *   - `false`(default): use code (e.g. `USD`).
	     * - `digitInfo` See {\@link DecimalPipe} for detailed description.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
	     *
	     * \@stable
	     */
	    var CurrencyPipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function CurrencyPipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} currencyCode
	         * @param {?=} symbolDisplay
	         * @param {?=} digits
	         * @return {?}
	         */
	        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
	            if (currencyCode === void 0) { currencyCode = 'USD'; }
	            if (symbolDisplay === void 0) { symbolDisplay = false; }
	            if (digits === void 0) { digits = null; }
	            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	        };
	        CurrencyPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },
	        ];
	        /** @nocollapse */
	        CurrencyPipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return CurrencyPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Creates a new List or String containing a subset (slice) of the elements.
	     * \@howToUse `array_or_string_expression | slice:start[:end]`
	     * \@description
	     *
	     * Where the input expression is a `List` or `String`, and:
	     * - `start`: The starting index of the subset to return.
	     *   - **a positive integer**: return the item at `start` index and all items after
	     *     in the list or string expression.
	     *   - **a negative integer**: return the item at `start` index from the end and all items after
	     *     in the list or string expression.
	     *   - **if positive and greater than the size of the expression**: return an empty list or string.
	     *   - **if negative and greater than the size of the expression**: return entire list or string.
	     * - `end`: The ending index of the subset to return.
	     *   - **omitted**: return all items until the end.
	     *   - **if positive**: return all items before `end` index of the list or string.
	     *   - **if negative**: return all items before `end` index from the end of the list or string.
	     *
	     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
	     * and `String.prototype.slice()`.
	     *
	     * When operating on a [List], the returned list is always a copy even when all
	     * the elements are being returned.
	     *
	     * When operating on a blank value, the pipe returns the blank value.
	     *
	     * ## List Example
	     *
	     * This `ngFor` example:
	     *
	     * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
	     *
	     * produces the following:
	     *
	     *     <li>b</li>
	     *     <li>c</li>
	     *
	     * ## String Examples
	     *
	     * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
	     *
	     * \@stable
	     */
	    var SlicePipe = (function () {
	        function SlicePipe() {
	        }
	        /**
	         * @param {?} value
	         * @param {?} start
	         * @param {?=} end
	         * @return {?}
	         */
	        SlicePipe.prototype.transform = function (value, start, end) {
	            if (value == null)
	                return value;
	            if (!this.supports(value)) {
	                throw new InvalidPipeArgumentError(SlicePipe, value);
	            }
	            return value.slice(start, end);
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
	        SlicePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },
	        ];
	        /** @nocollapse */
	        SlicePipe.ctorParameters = function () { return []; };
	        return SlicePipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Transforms string to uppercase.
	     * \@howToUse `expression | uppercase`
	     * \@description
	     *
	     * Converts value into an uppercase string using `String.prototype.toUpperCase()`.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
	     *
	     * \@stable
	     */
	    var UpperCasePipe = (function () {
	        function UpperCasePipe() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        UpperCasePipe.prototype.transform = function (value) {
	            if (isBlank(value))
	                return value;
	            if (typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(UpperCasePipe, value);
	            }
	            return value.toUpperCase();
	        };
	        UpperCasePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },
	        ];
	        /** @nocollapse */
	        UpperCasePipe.ctorParameters = function () { return []; };
	        return UpperCasePipe;
	    }());

	    /**
	     * A collection of Angular pipes that are likely to be used in each and every application.
	     */
	    var /** @type {?} */ COMMON_PIPES = [
	        AsyncPipe,
	        UpperCasePipe,
	        LowerCasePipe,
	        JsonPipe,
	        SlicePipe,
	        DecimalPipe,
	        PercentPipe,
	        CurrencyPipe,
	        DatePipe,
	        I18nPluralPipe,
	        I18nSelectPipe,
	    ];

	    /**
	     * The module that includes all the basic Angular directives like {\@link NgIf}, {\@link NgFor}, ...
	     *
	     * \@stable
	     */
	    var CommonModule = (function () {
	        function CommonModule() {
	        }
	        CommonModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
	                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],
	                        providers: [
	                            { provide: NgLocalization, useClass: NgLocaleLocalization },
	                        ],
	                    },] },
	        ];
	        /** @nocollapse */
	        CommonModule.ctorParameters = function () { return []; };
	        return CommonModule;
	    }());

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.10');

	    exports.NgLocalization = NgLocalization;
	    exports.CommonModule = CommonModule;
	    exports.NgClass = NgClass;
	    exports.NgFor = NgFor;
	    exports.NgIf = NgIf;
	    exports.NgPlural = NgPlural;
	    exports.NgPluralCase = NgPluralCase;
	    exports.NgStyle = NgStyle;
	    exports.NgSwitch = NgSwitch;
	    exports.NgSwitchCase = NgSwitchCase;
	    exports.NgSwitchDefault = NgSwitchDefault;
	    exports.NgTemplateOutlet = NgTemplateOutlet;
	    exports.AsyncPipe = AsyncPipe;
	    exports.DatePipe = DatePipe;
	    exports.I18nPluralPipe = I18nPluralPipe;
	    exports.I18nSelectPipe = I18nSelectPipe;
	    exports.JsonPipe = JsonPipe;
	    exports.LowerCasePipe = LowerCasePipe;
	    exports.CurrencyPipe = CurrencyPipe;
	    exports.DecimalPipe = DecimalPipe;
	    exports.PercentPipe = PercentPipe;
	    exports.SlicePipe = SlicePipe;
	    exports.UpperCasePipe = UpperCasePipe;
	    exports.VERSION = VERSION;
	    exports.Version = _angular_core.Version;
	    exports.PlatformLocation = PlatformLocation;
	    exports.LOCATION_INITIALIZED = LOCATION_INITIALIZED;
	    exports.LocationStrategy = LocationStrategy;
	    exports.APP_BASE_HREF = APP_BASE_HREF;
	    exports.HashLocationStrategy = HashLocationStrategy;
	    exports.PathLocationStrategy = PathLocationStrategy;
	    exports.Location = Location;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var of_1 = __webpack_require__(28);
	Observable_1.Observable.of = of_1.of;
	//# sourceMappingURL=of.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(29);
	exports.of = ArrayObservable_1.ArrayObservable.of;
	//# sourceMappingURL=of.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var ScalarObservable_1 = __webpack_require__(30);
	var EmptyObservable_1 = __webpack_require__(31);
	var isScheduler_1 = __webpack_require__(32);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` IScheduler, which means the `next`
	     * notifications are sent synchronously, although with a different IScheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.closed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1.Observable));
	exports.ArrayObservable = ArrayObservable;
	//# sourceMappingURL=ArrayObservable.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	        if (scheduler) {
	            this._isScalar = false;
	        }
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.closed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1.Observable));
	exports.ScalarObservable = ScalarObservable;
	//# sourceMappingURL=ScalarObservable.js.map

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following to the console:
	     * // x is equal to the count on the interval eg(0,1,2,3,...)
	     * // x will occur every 1000ms
	     * // if x % 2 is equal to 1 print abc
	     * // if x % 2 is not equal to 1 nothing will be output
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1.Observable));
	exports.EmptyObservable = EmptyObservable;
	//# sourceMappingURL=EmptyObservable.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	"use strict";
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	exports.isScheduler = isScheduler;
	//# sourceMappingURL=isScheduler.js.map

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var throw_1 = __webpack_require__(34);
	Observable_1.Observable.throw = throw_1._throw;
	//# sourceMappingURL=throw.js.map

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ErrorObservable_1 = __webpack_require__(35);
	exports._throw = ErrorObservable_1.ErrorObservable.create;
	//# sourceMappingURL=throw.js.map

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ErrorObservable = (function (_super) {
	    __extends(ErrorObservable, _super);
	    function ErrorObservable(error, scheduler) {
	        _super.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits an error notification.
	     *
	     * <span class="informal">Just emits 'error', and nothing else.
	     * </span>
	     *
	     * <img src="./img/throw.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the error notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then emit an error.</caption>
	     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x === 13 ?
	     *     Rx.Observable.throw('Thirteens are bad') :
	     *     Rx.Observable.of('a', 'b', 'c')
	     * );
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link of}
	     *
	     * @param {any} error The particular Error to pass to the error notification.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the error notification.
	     * @return {Observable} An error Observable: emits only the error notification
	     * using the given error argument.
	     * @static true
	     * @name throw
	     * @owner Observable
	     */
	    ErrorObservable.create = function (error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };
	    ErrorObservable.dispatch = function (arg) {
	        var error = arg.error, subscriber = arg.subscriber;
	        subscriber.error(error);
	    };
	    ErrorObservable.prototype._subscribe = function (subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.error(error);
	        }
	    };
	    return ErrorObservable;
	}(Observable_1.Observable));
	exports.ErrorObservable = ErrorObservable;
	//# sourceMappingURL=ErrorObservable.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var catch_1 = __webpack_require__(37);
	Observable_1.Observable.prototype.catch = catch_1._catch;
	Observable_1.Observable.prototype._catch = catch_1._catch;
	//# sourceMappingURL=catch.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} an observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @method catch
	 * @name catch
	 * @owner Observable
	 */
	function _catch(selector) {
	    var operator = new CatchOperator(selector);
	    var caught = this.lift(operator);
	    return (operator.caught = caught);
	}
	exports._catch = _catch;
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CatchSubscriber = (function (_super) {
	    __extends(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        _super.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	    // NOTE: overriding `error` instead of `_error` because we don't want
	    // to have this flag this subscriber as `isStopped`.
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err) {
	                this.destination.error(err);
	                return;
	            }
	            this.unsubscribe();
	            this.destination.remove(this);
	            subscribeToResult_1.subscribeToResult(this, result);
	        }
	    };
	    return CatchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=catch.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;
	//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	var isArray_1 = __webpack_require__(12);
	var isPromise_1 = __webpack_require__(40);
	var isObject_1 = __webpack_require__(13);
	var Observable_1 = __webpack_require__(7);
	var iterator_1 = __webpack_require__(41);
	var InnerSubscriber_1 = __webpack_require__(42);
	var observable_1 = __webpack_require__(4);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.closed) {
	        return null;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return null;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    else if (isArray_1.isArray(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.closed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.closed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (result && typeof result[iterator_1.$$iterator] === 'function') {
	        var iterator = result[iterator_1.$$iterator]();
	        do {
	            var item = iterator.next();
	            if (item.done) {
	                destination.complete();
	                break;
	            }
	            destination.next(item.value);
	            if (destination.closed) {
	                break;
	            }
	        } while (true);
	    }
	    else if (result && typeof result[observable_1.$$observable] === 'function') {
	        var obs = result[observable_1.$$observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = ("You provided " + value + " where a stream was expected.")
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        destination.error(new TypeError(msg));
	    }
	    return null;
	}
	exports.subscribeToResult = subscribeToResult;
	//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;
	//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	function symbolIteratorPonyfill(root) {
	    var Symbol = root.Symbol;
	    if (typeof Symbol === 'function') {
	        if (!Symbol.iterator) {
	            Symbol.iterator = Symbol('iterator polyfill');
	        }
	        return Symbol.iterator;
	    }
	    else {
	        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
	        var Set_1 = root.Set;
	        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
	            return '@@iterator';
	        }
	        var Map_1 = root.Map;
	        // required for compatability with es6-shim
	        if (Map_1) {
	            var keys = Object.getOwnPropertyNames(Map_1.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
	                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
	                    return key;
	                }
	            }
	        }
	        return '@@iterator';
	    }
	}
	exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
	exports.$$iterator = symbolIteratorPonyfill(root_1.root);
	//# sourceMappingURL=iterator.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;
	//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var debounceTime_1 = __webpack_require__(44);
	Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
	//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var async_1 = __webpack_require__(45);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link delay}, but passes only the most
	 * recent value from each burst of emissions.</span>
	 *
	 * <img src="./img/debounceTime.png" width="100%">
	 *
	 * `debounceTime` delays values emitted by the source Observable, but drops
	 * previous pending delayed emissions if a new value arrives on the source
	 * Observable. This operator keeps track of the most recent value from the
	 * source Observable, and emits that only when `dueTime` enough time has passed
	 * without any other value appearing on the source Observable. If a new value
	 * appears before `dueTime` silence occurs, the previous value will be dropped
	 * and will not be emitted on the output Observable.
	 *
	 * This is a rate-limiting operator, because it is impossible for more than one
	 * value to be emitted in any time window of duration `dueTime`, but it is also
	 * a delay-like operator since output emissions do not occur at the same time as
	 * they did on the source Observable. Optionally takes a {@link IScheduler} for
	 * managing timers.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounceTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} dueTime The timeout duration in milliseconds (or the time
	 * unit determined internally by the optional `scheduler`) for the window of
	 * time required to wait for emission silence before emitting the most recent
	 * source value.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the timeout for each value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified `dueTime`, and may drop some values if they occur
	 * too frequently.
	 * @method debounceTime
	 * @owner Observable
	 */
	function debounceTime(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	exports.debounceTime = debounceTime;
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceTimeSubscriber = (function (_super) {
	    __extends(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _super.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this.hasValue = false;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	            this.hasValue = false;
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.debouncedNext();
	}
	//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncAction_1 = __webpack_require__(46);
	var AsyncScheduler_1 = __webpack_require__(48);
	exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
	//# sourceMappingURL=async.js.map

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(5);
	var Action_1 = __webpack_require__(47);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsyncAction = (function (_super) {
	    __extends(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.pending = false;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        // Always replace the current state with the new state.
	        this.state = state;
	        // Set the pending flag indicating that this action has been scheduled, or
	        // has recursively rescheduled itself.
	        this.pending = true;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        //
	        // Important implementation note:
	        //
	        // Actions only execute once by default, unless rescheduled from within the
	        // scheduled callback. This allows us to implement single and repeat
	        // actions via the same code path, without adding API surface area, as well
	        // as mimic traditional recursion but across asynchronous boundaries.
	        //
	        // However, JS runtimes and timers distinguish between intervals achieved by
	        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
	        // serial `setTimeout` calls can be individually delayed, which delays
	        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
	        // guarantee the interval callback will be invoked more precisely to the
	        // interval period, regardless of load.
	        //
	        // Therefore, we use `setInterval` to schedule single and repeat actions.
	        // If the action reschedules itself with the same delay, the interval is not
	        // canceled. If the action doesn't reschedule, or reschedules with a
	        // different delay, the interval will be canceled after scheduled callback
	        // execution.
	        //
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.delay = delay;
	        // If this action has already an async Id, don't request a new one.
	        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If this action is rescheduled with the same delay time, don't clear the interval id.
	        if (delay !== null && this.delay === delay) {
	            return id;
	        }
	        // Otherwise, if the action's delay time is different from the current delay,
	        // clear the interval id
	        return root_1.root.clearInterval(id) && undefined || undefined;
	    };
	    /**
	     * Immediately executes this action and the `work` it contains.
	     * @return {any}
	     */
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            // Dequeue if the action didn't reschedule itself. Don't call
	            // unsubscribe(), because the action could reschedule later.
	            // For example:
	            // ```
	            // scheduler.schedule(function doWork(counter) {
	            //   /* ... I'm a busy worker bee ... */
	            //   var originalAction = this;
	            //   /* wait 100ms before rescheduling the action */
	            //   setTimeout(function () {
	            //     originalAction.schedule(counter + 1);
	            //   }, 100);
	            // }, 1000);
	            // ```
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, delay) {
	        var errored = false;
	        var errorValue = undefined;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = !!e && e || new Error(e);
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype._unsubscribe = function () {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = null;
	        this.delay = null;
	        this.state = null;
	        this.pending = false;
	        this.scheduler = null;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, null);
	        }
	    };
	    return AsyncAction;
	}(Action_1.Action));
	exports.AsyncAction = AsyncAction;
	//# sourceMappingURL=AsyncAction.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(11);
	/**
	 * A unit of work to be executed in a {@link Scheduler}. An action is typically
	 * created from within a Scheduler and an RxJS user does not need to concern
	 * themselves about creating and manipulating an Action.
	 *
	 * ```ts
	 * class Action<T> extends Subscription {
	 *   new (scheduler: Scheduler, work: (state?: T) => void);
	 *   schedule(state?: T, delay: number = 0): Subscription;
	 * }
	 * ```
	 *
	 * @class Action<T>
	 */
	var Action = (function (_super) {
	    __extends(Action, _super);
	    function Action(scheduler, work) {
	        _super.call(this);
	    }
	    /**
	     * Schedules this action on its parent Scheduler for execution. May be passed
	     * some context object, `state`. May happen at some point in the future,
	     * according to the `delay` parameter, if specified.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler.
	     * @return {void}
	     */
	    Action.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        return this;
	    };
	    return Action;
	}(Subscription_1.Subscription));
	exports.Action = Action;
	//# sourceMappingURL=Action.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Scheduler_1 = __webpack_require__(49);
	var AsyncScheduler = (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler() {
	        _super.apply(this, arguments);
	        this.actions = [];
	        /**
	         * A flag to indicate whether the Scheduler is currently executing a batch of
	         * queued actions.
	         * @type {boolean}
	         */
	        this.active = false;
	        /**
	         * An internal ID used to track the latest asynchronous task such as those
	         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
	         * others.
	         * @type {any}
	         */
	        this.scheduled = undefined;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this.active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this.active = true;
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (action = actions.shift()); // exhaust the scheduler queue
	        this.active = false;
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler_1.Scheduler));
	exports.AsyncScheduler = AsyncScheduler;
	//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	"use strict";
	/**
	 * An execution context and a data structure to order tasks and schedule their
	 * execution. Provides a notion of (potentially virtual) time, through the
	 * `now()` getter method.
	 *
	 * Each unit of work in a Scheduler is called an {@link Action}.
	 *
	 * ```ts
	 * class Scheduler {
	 *   now(): number;
	 *   schedule(work, delay?, state?): Subscription;
	 * }
	 * ```
	 *
	 * @class Scheduler
	 */
	var Scheduler = (function () {
	    function Scheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.SchedulerAction = SchedulerAction;
	        this.now = now;
	    }
	    /**
	     * Schedules a function, `work`, for execution. May happen at some point in
	     * the future, according to the `delay` parameter, if specified. May be passed
	     * some context object, `state`, which will be passed to the `work` function.
	     *
	     * The given arguments will be processed an stored as an Action object in a
	     * queue of actions.
	     *
	     * @param {function(state: ?T): ?Subscription} work A function representing a
	     * task, or some unit of work to be executed by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler itself.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @return {Subscription} A subscription in order to be able to unsubscribe
	     * the scheduled work.
	     */
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.SchedulerAction(this, work).schedule(state, delay);
	    };
	    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
	    return Scheduler;
	}());
	exports.Scheduler = Scheduler;
	//# sourceMappingURL=Scheduler.js.map

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var distinctUntilChanged_1 = __webpack_require__(51);
	Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
	//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	/* tslint:disable:max-line-length */
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
	 *
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 *
	 * If a comparator function is not provided, an equality check is used by default.
	 *
	 * @example <caption>A simple example with numbers</caption>
	 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
	 *   .distinctUntilChanged()
	 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
	 *
	 * @example <caption>An example using a compare function</caption>
	 * interface Person {
	 *    age: number,
	 *    name: string
	 * }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'})
	 *     { age: 6, name: 'Foo'})
	 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo' }
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilKeyChanged}
	 *
	 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
	 * @method distinctUntilChanged
	 * @owner Observable
	 */
	function distinctUntilChanged(compare, keySelector) {
	    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
	}
	exports.distinctUntilChanged = distinctUntilChanged;
	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare, keySelector) {
	        this.compare = compare;
	        this.keySelector = keySelector;
	    }
	    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	    };
	    return DistinctUntilChangedOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctUntilChangedSubscriber = (function (_super) {
	    __extends(DistinctUntilChangedSubscriber, _super);
	    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.hasKey = false;
	        if (typeof compare === 'function') {
	            this.compare = compare;
	        }
	    }
	    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	        return x === y;
	    };
	    DistinctUntilChangedSubscriber.prototype._next = function (value) {
	        var keySelector = this.keySelector;
	        var key = value;
	        if (keySelector) {
	            key = tryCatch_1.tryCatch(this.keySelector)(value);
	            if (key === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        var result = false;
	        if (this.hasKey) {
	            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
	            if (result === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        else {
	            this.hasKey = true;
	        }
	        if (Boolean(result) === false) {
	            this.key = key;
	            this.destination.next(value);
	        }
	    };
	    return DistinctUntilChangedSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var do_1 = __webpack_require__(53);
	Observable_1.Observable.prototype.do = do_1._do;
	Observable_1.Observable.prototype._do = do_1._do;
	//# sourceMappingURL=do.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/* tslint:disable:max-line-length */
	/**
	 * Perform a side effect for every emission on the source Observable, but return
	 * an Observable that is identical to the source.
	 *
	 * <span class="informal">Intercepts each emission on the source and runs a
	 * function, but returns an output which is identical to the source.</span>
	 *
	 * <img src="./img/do.png" width="100%">
	 *
	 * Returns a mirrored Observable of the source Observable, but modified so that
	 * the provided Observer is called to perform a side effect for every value,
	 * error, and completion emitted by the source. Any errors that are thrown in
	 * the aforementioned Observer or handlers are safely sent down the error path
	 * of the output Observable.
	 *
	 * This operator is useful for debugging your Observables for the correct values
	 * or performing other side effects.
	 *
	 * Note: this is different to a `subscribe` on the Observable. If the Observable
	 * returned by `do` is not subscribed, the side effects specified by the
	 * Observer will never happen. `do` therefore simply spies on existing
	 * execution, it does not trigger an execution to happen like `subscribe` does.
	 *
	 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks
	 *   .do(ev => console.log(ev))
	 *   .map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 * @see {@link subscribe}
	 *
	 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
	 * callback for `next`.
	 * @param {function} [error] Callback for errors in the source.
	 * @param {function} [complete] Callback for the completion of the source.
	 * @return {Observable} An Observable identical to the source, but runs the
	 * specified Observer or callback(s) for each item.
	 * @method do
	 * @name do
	 * @owner Observable
	 */
	function _do(nextOrObserver, error, complete) {
	    return this.lift(new DoOperator(nextOrObserver, error, complete));
	}
	exports._do = _do;
	var DoOperator = (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DoSubscriber = (function (_super) {
	    __extends(DoSubscriber, _super);
	    function DoSubscriber(destination, nextOrObserver, error, complete) {
	        _super.call(this, destination);
	        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	        safeSubscriber.syncErrorThrowable = true;
	        this.add(safeSubscriber);
	        this.safeSubscriber = safeSubscriber;
	    }
	    DoSubscriber.prototype._next = function (value) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.next(value);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.next(value);
	        }
	    };
	    DoSubscriber.prototype._error = function (err) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.error(err);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.error(err);
	        }
	    };
	    DoSubscriber.prototype._complete = function () {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.complete();
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return DoSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=do.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var filter_1 = __webpack_require__(55);
	Observable_1.Observable.prototype.filter = filter_1.filter;
	//# sourceMappingURL=filter.js.map

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/* tslint:disable:max-line-length */
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	exports.filter = filter;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=filter.js.map

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var map_1 = __webpack_require__(57);
	Observable_1.Observable.prototype.map = map_1.map;
	//# sourceMappingURL=map.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	exports.map = map;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	exports.MapOperator = MapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=map.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var switchMap_1 = __webpack_require__(59);
	Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
	//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	exports.switchMap = switchMap;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var toPromise_1 = __webpack_require__(61);
	Observable_1.Observable.prototype.toPromise = toPromise_1.toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	/* tslint:disable:max-line-length */
	/**
	 * @param PromiseCtor
	 * @return {Promise<T>}
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	            PromiseCtor = root_1.root.Rx.config.Promise;
	        }
	        else if (root_1.root.Promise) {
	            PromiseCtor = root_1.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	exports.toPromise = toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 62 */,
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var PromiseObservable_1 = __webpack_require__(64);
	exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
	//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(5);
	var Observable_1 = __webpack_require__(7);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Converts a Promise to an Observable.
	     *
	     * <span class="informal">Returns an Observable that just emits the Promise's
	     * resolved value, then completes.</span>
	     *
	     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
	     * Observable. If the Promise resolves with a value, the output Observable
	     * emits that resolved value as a `next`, and then completes. If the Promise
	     * is rejected, then the output Observable emits the corresponding Error.
	     *
	     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
	     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     *
	     * @param {Promise<T>} promise The promise to be converted.
	     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
	     * the delivery of the resolved value (or the rejection).
	     * @return {Observable<T>} An Observable which wraps the Promise.
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1.Observable));
	exports.PromiseObservable = PromiseObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.error(err);
	    }
	}
	//# sourceMappingURL=PromiseObservable.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3), __webpack_require__(7), __webpack_require__(21)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Observable', '@angular/platform-browser'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.http = global.ng.http || {}),global.ng.core,global.Rx,global.ng.platformBrowser));
	}(this, function (exports,_angular_core,rxjs_Observable,_angular_platformBrowser) { 'use strict';

	    /**
	     * A backend for http that uses the `XMLHttpRequest` browser API.
	     *
	     * Take care not to evaluate this in non-browser contexts.
	     *
	     * \@experimental
	     */
	    var BrowserXhr = (function () {
	        function BrowserXhr() {
	        }
	        /**
	         * @return {?}
	         */
	        BrowserXhr.prototype.build = function () { return ((new XMLHttpRequest())); };
	        BrowserXhr.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        BrowserXhr.ctorParameters = function () { return []; };
	        return BrowserXhr;
	    }());

	    var RequestMethod = {};
	    RequestMethod.Get = 0;
	    RequestMethod.Post = 1;
	    RequestMethod.Put = 2;
	    RequestMethod.Delete = 3;
	    RequestMethod.Options = 4;
	    RequestMethod.Head = 5;
	    RequestMethod.Patch = 6;
	    RequestMethod[RequestMethod.Get] = "Get";
	    RequestMethod[RequestMethod.Post] = "Post";
	    RequestMethod[RequestMethod.Put] = "Put";
	    RequestMethod[RequestMethod.Delete] = "Delete";
	    RequestMethod[RequestMethod.Options] = "Options";
	    RequestMethod[RequestMethod.Head] = "Head";
	    RequestMethod[RequestMethod.Patch] = "Patch";
	    var ReadyState = {};
	    ReadyState.Unsent = 0;
	    ReadyState.Open = 1;
	    ReadyState.HeadersReceived = 2;
	    ReadyState.Loading = 3;
	    ReadyState.Done = 4;
	    ReadyState.Cancelled = 5;
	    ReadyState[ReadyState.Unsent] = "Unsent";
	    ReadyState[ReadyState.Open] = "Open";
	    ReadyState[ReadyState.HeadersReceived] = "HeadersReceived";
	    ReadyState[ReadyState.Loading] = "Loading";
	    ReadyState[ReadyState.Done] = "Done";
	    ReadyState[ReadyState.Cancelled] = "Cancelled";
	    var ResponseType = {};
	    ResponseType.Basic = 0;
	    ResponseType.Cors = 1;
	    ResponseType.Default = 2;
	    ResponseType.Error = 3;
	    ResponseType.Opaque = 4;
	    ResponseType[ResponseType.Basic] = "Basic";
	    ResponseType[ResponseType.Cors] = "Cors";
	    ResponseType[ResponseType.Default] = "Default";
	    ResponseType[ResponseType.Error] = "Error";
	    ResponseType[ResponseType.Opaque] = "Opaque";
	    var ContentType = {};
	    ContentType.NONE = 0;
	    ContentType.JSON = 1;
	    ContentType.FORM = 2;
	    ContentType.FORM_DATA = 3;
	    ContentType.TEXT = 4;
	    ContentType.BLOB = 5;
	    ContentType.ARRAY_BUFFER = 6;
	    ContentType[ContentType.NONE] = "NONE";
	    ContentType[ContentType.JSON] = "JSON";
	    ContentType[ContentType.FORM] = "FORM";
	    ContentType[ContentType.FORM_DATA] = "FORM_DATA";
	    ContentType[ContentType.TEXT] = "TEXT";
	    ContentType[ContentType.BLOB] = "BLOB";
	    ContentType[ContentType.ARRAY_BUFFER] = "ARRAY_BUFFER";
	    var ResponseContentType = {};
	    ResponseContentType.Text = 0;
	    ResponseContentType.Json = 1;
	    ResponseContentType.ArrayBuffer = 2;
	    ResponseContentType.Blob = 3;
	    ResponseContentType[ResponseContentType.Text] = "Text";
	    ResponseContentType[ResponseContentType.Json] = "Json";
	    ResponseContentType[ResponseContentType.ArrayBuffer] = "ArrayBuffer";
	    ResponseContentType[ResponseContentType.Blob] = "Blob";

	    /**
	     * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
	     * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
	     *
	     * The only known difference between this `Headers` implementation and the spec is the
	     * lack of an `entries` method.
	     *
	     * ### Example
	     *
	     * ```
	     * import {Headers} from '\@angular/http';
	     *
	     * var firstHeaders = new Headers();
	     * firstHeaders.append('Content-Type', 'image/jpeg');
	     * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
	     *
	     * // Create headers from Plain Old JavaScript Object
	     * var secondHeaders = new Headers({
	     *   'X-My-Custom-Header': 'Angular'
	     * });
	     * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
	     *
	     * var thirdHeaders = new Headers(secondHeaders);
	     * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
	     * ```
	     *
	     * \@experimental
	     */
	    var Headers = (function () {
	        /**
	         * @param {?=} headers
	         */
	        function Headers(headers) {
	            var _this = this;
	            /** @internal header names are lower case */
	            this._headers = new Map();
	            /** @internal map lower case names to actual names */
	            this._normalizedNames = new Map();
	            if (!headers) {
	                return;
	            }
	            if (headers instanceof Headers) {
	                headers.forEach(function (values, name) {
	                    values.forEach(function (value) { return _this.append(name, value); });
	                });
	                return;
	            }
	            Object.keys(headers).forEach(function (name) {
	                var values = Array.isArray(headers[name]) ? headers[name] : [headers[name]];
	                _this.delete(name);
	                values.forEach(function (value) { return _this.append(name, value); });
	            });
	        }
	        /**
	         * Returns a new Headers instance from the given DOMString of Response Headers
	         * @param {?} headersString
	         * @return {?}
	         */
	        Headers.fromResponseHeaderString = function (headersString) {
	            var /** @type {?} */ headers = new Headers();
	            headersString.split('\n').forEach(function (line) {
	                var /** @type {?} */ index = line.indexOf(':');
	                if (index > 0) {
	                    var /** @type {?} */ name_1 = line.slice(0, index);
	                    var /** @type {?} */ value = line.slice(index + 1).trim();
	                    headers.set(name_1, value);
	                }
	            });
	            return headers;
	        };
	        /**
	         * Appends a header to existing list of header values for a given header name.
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        Headers.prototype.append = function (name, value) {
	            var /** @type {?} */ values = this.getAll(name);
	            if (values === null) {
	                this.set(name, value);
	            }
	            else {
	                values.push(value);
	            }
	        };
	        /**
	         * Deletes all header values for the given name.
	         * @param {?} name
	         * @return {?}
	         */
	        Headers.prototype.delete = function (name) {
	            var /** @type {?} */ lcName = name.toLowerCase();
	            this._normalizedNames.delete(lcName);
	            this._headers.delete(lcName);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        Headers.prototype.forEach = function (fn) {
	            var _this = this;
	            this._headers.forEach(function (values, lcName) { return fn(values, _this._normalizedNames.get(lcName), _this._headers); });
	        };
	        /**
	         * Returns first header that matches given name.
	         * @param {?} name
	         * @return {?}
	         */
	        Headers.prototype.get = function (name) {
	            var /** @type {?} */ values = this.getAll(name);
	            if (values === null) {
	                return null;
	            }
	            return values.length > 0 ? values[0] : null;
	        };
	        /**
	         * Checks for existence of header by given name.
	         * @param {?} name
	         * @return {?}
	         */
	        Headers.prototype.has = function (name) { return this._headers.has(name.toLowerCase()); };
	        /**
	         * Returns the names of the headers
	         * @return {?}
	         */
	        Headers.prototype.keys = function () { return Array.from(this._normalizedNames.values()); };
	        /**
	         * Sets or overrides header value for given name.
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        Headers.prototype.set = function (name, value) {
	            if (Array.isArray(value)) {
	                if (value.length) {
	                    this._headers.set(name.toLowerCase(), [value.join(',')]);
	                }
	            }
	            else {
	                this._headers.set(name.toLowerCase(), [value]);
	            }
	            this.mayBeSetNormalizedName(name);
	        };
	        /**
	         * Returns values of all headers.
	         * @return {?}
	         */
	        Headers.prototype.values = function () { return Array.from(this._headers.values()); };
	        /**
	         * @return {?}
	         */
	        Headers.prototype.toJSON = function () {
	            var _this = this;
	            var /** @type {?} */ serialized = {};
	            this._headers.forEach(function (values, name) {
	                var /** @type {?} */ split = [];
	                values.forEach(function (v) { return split.push.apply(split, v.split(',')); });
	                serialized[_this._normalizedNames.get(name)] = split;
	            });
	            return serialized;
	        };
	        /**
	         * Returns list of header values for a given name.
	         * @param {?} name
	         * @return {?}
	         */
	        Headers.prototype.getAll = function (name) {
	            return this.has(name) ? this._headers.get(name.toLowerCase()) : null;
	        };
	        /**
	         * This method is not implemented.
	         * @return {?}
	         */
	        Headers.prototype.entries = function () { throw new Error('"entries" method is not implemented on Headers class'); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Headers.prototype.mayBeSetNormalizedName = function (name) {
	            var /** @type {?} */ lcName = name.toLowerCase();
	            if (!this._normalizedNames.has(lcName)) {
	                this._normalizedNames.set(lcName, name);
	            }
	        };
	        return Headers;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Creates a response options object to be optionally provided when instantiating a
	     * {\@link Response}.
	     *
	     * This class is based on the `ResponseInit` description in the [Fetch
	     * Spec](https://fetch.spec.whatwg.org/#responseinit).
	     *
	     * All values are null by default. Typical defaults can be found in the
	     * {\@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
	     *
	     * This class may be used in tests to build {\@link Response Responses} for
	     * mock responses (see {\@link MockBackend}).
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
	     *
	     * ```typescript
	     * import {ResponseOptions, Response} from '\@angular/http';
	     *
	     * var options = new ResponseOptions({
	     *   body: '{"name":"Jeff"}'
	     * });
	     * var res = new Response(options);
	     *
	     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	     * ```
	     *
	     * \@experimental
	     */
	    var ResponseOptions = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function ResponseOptions(_a) {
	            var _b = _a === void 0 ? {} : _a, body = _b.body, status = _b.status, headers = _b.headers, statusText = _b.statusText, type = _b.type, url = _b.url;
	            this.body = body != null ? body : null;
	            this.status = status != null ? status : null;
	            this.headers = headers != null ? headers : null;
	            this.statusText = statusText != null ? statusText : null;
	            this.type = type != null ? type : null;
	            this.url = url != null ? url : null;
	        }
	        /**
	         * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
	         * override
	         * existing values. This method will not change the values of the instance on which it is being
	         * called.
	         *
	         * This may be useful when sharing a base `ResponseOptions` object inside tests,
	         * where certain properties may change from test to test.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
	         *
	         * ```typescript
	         * import {ResponseOptions, Response} from '\@angular/http';
	         *
	         * var options = new ResponseOptions({
	         *   body: {name: 'Jeff'}
	         * });
	         * var res = new Response(options.merge({
	         *   url: 'https://google.com'
	         * }));
	         * console.log('options.url:', options.url); // null
	         * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	         * console.log('res.url:', res.url); // https://google.com
	         * ```
	         * @param {?=} options
	         * @return {?}
	         */
	        ResponseOptions.prototype.merge = function (options) {
	            return new ResponseOptions({
	                body: options && options.body != null ? options.body : this.body,
	                status: options && options.status != null ? options.status : this.status,
	                headers: options && options.headers != null ? options.headers : this.headers,
	                statusText: options && options.statusText != null ? options.statusText : this.statusText,
	                type: options && options.type != null ? options.type : this.type,
	                url: options && options.url != null ? options.url : this.url,
	            });
	        };
	        return ResponseOptions;
	    }());
	    /**
	     * Subclass of {\@link ResponseOptions}, with default values.
	     *
	     * Default values:
	     *  * status: 200
	     *  * headers: empty {\@link Headers} object
	     *
	     * This class could be extended and bound to the {\@link ResponseOptions} class
	     * when configuring an {\@link Injector}, in order to override the default options
	     * used by {\@link Http} to create {\@link Response Responses}.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/qv8DLT?p=preview))
	     *
	     * ```typescript
	     * import {provide} from '\@angular/core';
	     * import {bootstrap} from '\@angular/platform-browser/browser';
	     * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from
	     * '\@angular/http';
	     * import {App} from './myapp';
	     *
	     * class MyOptions extends BaseResponseOptions {
	     *   headers:Headers = new Headers({network: 'github'});
	     * }
	     *
	     * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);
	     * ```
	     *
	     * The options could also be extended when manually creating a {\@link Response}
	     * object.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/VngosOWiaExEtbstDoix?p=preview))
	     *
	     * ```
	     * import {BaseResponseOptions, Response} from '\@angular/http';
	     *
	     * var options = new BaseResponseOptions();
	     * var res = new Response(options.merge({
	     *   body: 'Angular',
	     *   headers: new Headers({framework: 'angular'})
	     * }));
	     * console.log('res.headers.get("framework"):', res.headers.get('framework')); // angular
	     * console.log('res.text():', res.text()); // Angular;
	     * ```
	     *
	     * \@experimental
	     */
	    var BaseResponseOptions = (function (_super) {
	        __extends$1(BaseResponseOptions, _super);
	        function BaseResponseOptions() {
	            _super.call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() });
	        }
	        BaseResponseOptions.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        BaseResponseOptions.ctorParameters = function () { return []; };
	        return BaseResponseOptions;
	    }(ResponseOptions));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Abstract class from which real backends are derived.
	     *
	     * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
	     * {\@link Request}.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var ConnectionBackend = (function () {
	        function ConnectionBackend() {
	        }
	        /**
	         * @abstract
	         * @param {?} request
	         * @return {?}
	         */
	        ConnectionBackend.prototype.createConnection = function (request) { };
	        return ConnectionBackend;
	    }());
	    /**
	     * Abstract class from which real connections are derived.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var Connection = (function () {
	        function Connection() {
	        }
	        return Connection;
	    }());
	    /**
	     * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var XSRFStrategy = (function () {
	        function XSRFStrategy() {
	        }
	        /**
	         * @abstract
	         * @param {?} req
	         * @return {?}
	         */
	        XSRFStrategy.prototype.configureRequest = function (req) { };
	        return XSRFStrategy;
	    }());

	    /**
	     * @param {?} method
	     * @return {?}
	     */
	    function normalizeMethodName(method) {
	        if (typeof method !== 'string')
	            return method;
	        switch (method.toUpperCase()) {
	            case 'GET':
	                return RequestMethod.Get;
	            case 'POST':
	                return RequestMethod.Post;
	            case 'PUT':
	                return RequestMethod.Put;
	            case 'DELETE':
	                return RequestMethod.Delete;
	            case 'OPTIONS':
	                return RequestMethod.Options;
	            case 'HEAD':
	                return RequestMethod.Head;
	            case 'PATCH':
	                return RequestMethod.Patch;
	        }
	        throw new Error("Invalid request method. The method \"" + method + "\" is not supported.");
	    }
	    var /** @type {?} */ isSuccess = function (status) { return (status >= 200 && status < 300); };
	    /**
	     * @param {?} xhr
	     * @return {?}
	     */
	    function getResponseURL(xhr) {
	        if ('responseURL' in xhr) {
	            return xhr.responseURL;
	        }
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	            return xhr.getResponseHeader('X-Request-URL');
	        }
	        return;
	    }
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function stringToArrayBuffer(input) {
	        var /** @type {?} */ view = new Uint16Array(input.length);
	        for (var /** @type {?} */ i = 0, /** @type {?} */ strLen = input.length; i < strLen; i++) {
	            view[i] = input.charCodeAt(i);
	        }
	        return view.buffer;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     * @param {?=} rawParams
	     * @return {?}
	     */
	    function paramParser(rawParams) {
	        if (rawParams === void 0) { rawParams = ''; }
	        var /** @type {?} */ map = new Map();
	        if (rawParams.length > 0) {
	            var /** @type {?} */ params = rawParams.split('&');
	            params.forEach(function (param) {
	                var /** @type {?} */ eqIdx = param.indexOf('=');
	                var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];
	                var /** @type {?} */ list = map.get(key) || [];
	                list.push(val);
	                map.set(key, list);
	            });
	        }
	        return map;
	    }
	    /**
	     * \@experimental
	     *
	     */
	    var QueryEncoder = (function () {
	        function QueryEncoder() {
	        }
	        /**
	         * @param {?} k
	         * @return {?}
	         */
	        QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };
	        /**
	         * @param {?} v
	         * @return {?}
	         */
	        QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };
	        return QueryEncoder;
	    }());
	    /**
	     * @param {?} v
	     * @return {?}
	     */
	    function standardEncoding(v) {
	        return encodeURIComponent(v)
	            .replace(/%40/gi, '@')
	            .replace(/%3A/gi, ':')
	            .replace(/%24/gi, '$')
	            .replace(/%2C/gi, ',')
	            .replace(/%3B/gi, ';')
	            .replace(/%2B/gi, '+')
	            .replace(/%3D/gi, '=')
	            .replace(/%3F/gi, '?')
	            .replace(/%2F/gi, '/');
	    }
	    /**
	     * Map-like representation of url search parameters, based on
	     * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
	     * with several extensions for merging URLSearchParams objects:
	     *   - setAll()
	     *   - appendAll()
	     *   - replaceAll()
	     *
	     * This class accepts an optional second parameter of ${\@link QueryEncoder},
	     * which is used to serialize parameters before making a request. By default,
	     * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,
	     * and then un-encodes certain characters that are allowed to be part of the query
	     * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.
	     *
	     * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`
	     *
	     * If the set of allowed query characters is not acceptable for a particular backend,
	     * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.
	     *
	     * ```
	     * import {URLSearchParams, QueryEncoder} from '\@angular/http';
	     * class MyQueryEncoder extends QueryEncoder {
	     *   encodeKey(k: string): string {
	     *     return myEncodingFunction(k);
	     *   }
	     *
	     *   encodeValue(v: string): string {
	     *     return myEncodingFunction(v);
	     *   }
	     * }
	     *
	     * let params = new URLSearchParams('', new MyQueryEncoder());
	     * ```
	     * \@experimental
	     */
	    var URLSearchParams = (function () {
	        /**
	         * @param {?=} rawParams
	         * @param {?=} queryEncoder
	         */
	        function URLSearchParams(rawParams, queryEncoder) {
	            if (rawParams === void 0) { rawParams = ''; }
	            if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }
	            this.rawParams = rawParams;
	            this.queryEncoder = queryEncoder;
	            this.paramsMap = paramParser(rawParams);
	        }
	        /**
	         * @return {?}
	         */
	        URLSearchParams.prototype.clone = function () {
	            var /** @type {?} */ clone = new URLSearchParams('', this.queryEncoder);
	            clone.appendAll(this);
	            return clone;
	        };
	        /**
	         * @param {?} param
	         * @return {?}
	         */
	        URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };
	        /**
	         * @param {?} param
	         * @return {?}
	         */
	        URLSearchParams.prototype.get = function (param) {
	            var /** @type {?} */ storedParam = this.paramsMap.get(param);
	            return Array.isArray(storedParam) ? storedParam[0] : null;
	        };
	        /**
	         * @param {?} param
	         * @return {?}
	         */
	        URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };
	        /**
	         * @param {?} param
	         * @param {?} val
	         * @return {?}
	         */
	        URLSearchParams.prototype.set = function (param, val) {
	            if (val === void 0 || val === null) {
	                this.delete(param);
	                return;
	            }
	            var /** @type {?} */ list = this.paramsMap.get(param) || [];
	            list.length = 0;
	            list.push(val);
	            this.paramsMap.set(param, list);
	        };
	        /**
	         * @param {?} searchParams
	         * @return {?}
	         */
	        URLSearchParams.prototype.setAll = function (searchParams) {
	            var _this = this;
	            searchParams.paramsMap.forEach(function (value, param) {
	                var /** @type {?} */ list = _this.paramsMap.get(param) || [];
	                list.length = 0;
	                list.push(value[0]);
	                _this.paramsMap.set(param, list);
	            });
	        };
	        /**
	         * @param {?} param
	         * @param {?} val
	         * @return {?}
	         */
	        URLSearchParams.prototype.append = function (param, val) {
	            if (val === void 0 || val === null)
	                return;
	            var /** @type {?} */ list = this.paramsMap.get(param) || [];
	            list.push(val);
	            this.paramsMap.set(param, list);
	        };
	        /**
	         * @param {?} searchParams
	         * @return {?}
	         */
	        URLSearchParams.prototype.appendAll = function (searchParams) {
	            var _this = this;
	            searchParams.paramsMap.forEach(function (value, param) {
	                var /** @type {?} */ list = _this.paramsMap.get(param) || [];
	                for (var /** @type {?} */ i = 0; i < value.length; ++i) {
	                    list.push(value[i]);
	                }
	                _this.paramsMap.set(param, list);
	            });
	        };
	        /**
	         * @param {?} searchParams
	         * @return {?}
	         */
	        URLSearchParams.prototype.replaceAll = function (searchParams) {
	            var _this = this;
	            searchParams.paramsMap.forEach(function (value, param) {
	                var /** @type {?} */ list = _this.paramsMap.get(param) || [];
	                list.length = 0;
	                for (var /** @type {?} */ i = 0; i < value.length; ++i) {
	                    list.push(value[i]);
	                }
	                _this.paramsMap.set(param, list);
	            });
	        };
	        /**
	         * @return {?}
	         */
	        URLSearchParams.prototype.toString = function () {
	            var _this = this;
	            var /** @type {?} */ paramsList = [];
	            this.paramsMap.forEach(function (values, k) {
	                values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });
	            });
	            return paramsList.join('&');
	        };
	        /**
	         * @param {?} param
	         * @return {?}
	         */
	        URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };
	        return URLSearchParams;
	    }());

	    /**
	     * HTTP request body used by both {\@link Request} and {\@link Response}
	     * https://fetch.spec.whatwg.org/#body
	     * @abstract
	     */
	    var Body = (function () {
	        function Body() {
	        }
	        /**
	         * Attempts to return body as parsed `JSON` object, or raises an exception.
	         * @return {?}
	         */
	        Body.prototype.json = function () {
	            if (typeof this._body === 'string') {
	                return JSON.parse(/** @type {?} */ (this._body));
	            }
	            if (this._body instanceof ArrayBuffer) {
	                return JSON.parse(this.text());
	            }
	            return this._body;
	        };
	        /**
	         * Returns the body as a string, presuming `toString()` can be called on the response body.
	         * @return {?}
	         */
	        Body.prototype.text = function () {
	            if (this._body instanceof URLSearchParams) {
	                return this._body.toString();
	            }
	            if (this._body instanceof ArrayBuffer) {
	                return String.fromCharCode.apply(null, new Uint16Array(/** @type {?} */ (this._body)));
	            }
	            if (this._body == null) {
	                return '';
	            }
	            if (typeof this._body === 'object') {
	                return JSON.stringify(this._body, null, 2);
	            }
	            return this._body.toString();
	        };
	        /**
	         * Return the body as an ArrayBuffer
	         * @return {?}
	         */
	        Body.prototype.arrayBuffer = function () {
	            if (this._body instanceof ArrayBuffer) {
	                return (this._body);
	            }
	            return stringToArrayBuffer(this.text());
	        };
	        /**
	         * Returns the request's body as a Blob, assuming that body exists.
	         * @return {?}
	         */
	        Body.prototype.blob = function () {
	            if (this._body instanceof Blob) {
	                return (this._body);
	            }
	            if (this._body instanceof ArrayBuffer) {
	                return new Blob([this._body]);
	            }
	            throw new Error('The request body isn\'t either a blob or an array buffer');
	        };
	        return Body;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Creates `Response` instances from provided values.
	     *
	     * Though this object isn't
	     * usually instantiated by end-users, it is the primary object interacted with when it comes time to
	     * add data to a view.
	     *
	     * ### Example
	     *
	     * ```
	     * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
	     * ```
	     *
	     * The Response's interface is inspired by the Response constructor defined in the [Fetch
	     * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
	     * can be accessed many times. There are other differences in the implementation, but this is the
	     * most significant.
	     *
	     * \@experimental
	     */
	    var Response = (function (_super) {
	        __extends$2(Response, _super);
	        /**
	         * @param {?} responseOptions
	         */
	        function Response(responseOptions) {
	            _super.call(this);
	            this._body = responseOptions.body;
	            this.status = responseOptions.status;
	            this.ok = (this.status >= 200 && this.status <= 299);
	            this.statusText = responseOptions.statusText;
	            this.headers = responseOptions.headers;
	            this.type = responseOptions.type;
	            this.url = responseOptions.url;
	        }
	        /**
	         * @return {?}
	         */
	        Response.prototype.toString = function () {
	            return "Response with status: " + this.status + " " + this.statusText + " for URL: " + this.url;
	        };
	        return Response;
	    }(Body));

	    var /** @type {?} */ _nextRequestId = 0;
	    var /** @type {?} */ JSONP_HOME = '__ng_jsonp__';
	    var /** @type {?} */ _jsonpConnections = null;
	    /**
	     * @return {?}
	     */
	    function _getJsonpConnections() {
	        var /** @type {?} */ w = typeof window == 'object' ? window : {};
	        if (_jsonpConnections === null) {
	            _jsonpConnections = w[JSONP_HOME] = {};
	        }
	        return _jsonpConnections;
	    }
	    var BrowserJsonp = (function () {
	        function BrowserJsonp() {
	        }
	        /**
	         * @param {?} url
	         * @return {?}
	         */
	        BrowserJsonp.prototype.build = function (url) {
	            var /** @type {?} */ node = document.createElement('script');
	            node.src = url;
	            return node;
	        };
	        /**
	         * @return {?}
	         */
	        BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + "." + id + ".finished"; };
	        /**
	         * @param {?} id
	         * @param {?} connection
	         * @return {?}
	         */
	        BrowserJsonp.prototype.exposeConnection = function (id, connection) {
	            var /** @type {?} */ connections = _getJsonpConnections();
	            connections[id] = connection;
	        };
	        /**
	         * @param {?} id
	         * @return {?}
	         */
	        BrowserJsonp.prototype.removeConnection = function (id) {
	            var /** @type {?} */ connections = _getJsonpConnections();
	            connections[id] = null;
	        };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserJsonp.prototype.send = function (node) { document.body.appendChild(/** @type {?} */ ((node))); };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserJsonp.prototype.cleanup = function (node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(/** @type {?} */ ((node)));
	            }
	        };
	        BrowserJsonp.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        BrowserJsonp.ctorParameters = function () { return []; };
	        return BrowserJsonp;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
	    var /** @type {?} */ JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
	    /**
	     * Abstract base class for an in-flight JSONP request.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var JSONPConnection = (function () {
	        function JSONPConnection() {
	        }
	        /**
	         * Callback called when the JSONP request completes, to notify the application
	         * of the new data.
	         * @abstract
	         * @param {?=} data
	         * @return {?}
	         */
	        JSONPConnection.prototype.finished = function (data) { };
	        return JSONPConnection;
	    }());
	    var JSONPConnection_ = (function (_super) {
	        __extends(JSONPConnection_, _super);
	        /**
	         * @param {?} req
	         * @param {?} _dom
	         * @param {?=} baseResponseOptions
	         */
	        function JSONPConnection_(req, _dom, baseResponseOptions) {
	            var _this = this;
	            _super.call(this);
	            this._dom = _dom;
	            this.baseResponseOptions = baseResponseOptions;
	            this._finished = false;
	            if (req.method !== RequestMethod.Get) {
	                throw new TypeError(JSONP_ERR_WRONG_METHOD);
	            }
	            this.request = req;
	            this.response = new rxjs_Observable.Observable(function (responseObserver) {
	                _this.readyState = ReadyState.Loading;
	                var id = _this._id = _dom.nextRequestID();
	                _dom.exposeConnection(id, _this);
	                // Workaround Dart
	                // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
	                var callback = _dom.requestCallback(_this._id);
	                var url = req.url;
	                if (url.indexOf('=JSONP_CALLBACK&') > -1) {
	                    url = url.replace('=JSONP_CALLBACK&', "=" + callback + "&");
	                }
	                else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
	                    url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
	                }
	                var script = _this._script = _dom.build(url);
	                var onLoad = function (event) {
	                    if (_this.readyState === ReadyState.Cancelled)
	                        return;
	                    _this.readyState = ReadyState.Done;
	                    _dom.cleanup(script);
	                    if (!_this._finished) {
	                        var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });
	                        if (baseResponseOptions) {
	                            responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
	                        }
	                        responseObserver.error(new Response(responseOptions_1));
	                        return;
	                    }
	                    var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });
	                    if (_this.baseResponseOptions) {
	                        responseOptions = _this.baseResponseOptions.merge(responseOptions);
	                    }
	                    responseObserver.next(new Response(responseOptions));
	                    responseObserver.complete();
	                };
	                var onError = function (error) {
	                    if (_this.readyState === ReadyState.Cancelled)
	                        return;
	                    _this.readyState = ReadyState.Done;
	                    _dom.cleanup(script);
	                    var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });
	                    if (baseResponseOptions) {
	                        responseOptions = baseResponseOptions.merge(responseOptions);
	                    }
	                    responseObserver.error(new Response(responseOptions));
	                };
	                script.addEventListener('load', onLoad);
	                script.addEventListener('error', onError);
	                _dom.send(script);
	                return function () {
	                    _this.readyState = ReadyState.Cancelled;
	                    script.removeEventListener('load', onLoad);
	                    script.removeEventListener('error', onError);
	                    _this._dom.cleanup(script);
	                };
	            });
	        }
	        /**
	         * @param {?=} data
	         * @return {?}
	         */
	        JSONPConnection_.prototype.finished = function (data) {
	            // Don't leak connections
	            this._finished = true;
	            this._dom.removeConnection(this._id);
	            if (this.readyState === ReadyState.Cancelled)
	                return;
	            this._responseData = data;
	        };
	        return JSONPConnection_;
	    }(JSONPConnection));
	    /**
	     * A {\@link ConnectionBackend} that uses the JSONP strategy of making requests.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var JSONPBackend = (function (_super) {
	        __extends(JSONPBackend, _super);
	        function JSONPBackend() {
	            _super.apply(this, arguments);
	        }
	        return JSONPBackend;
	    }(ConnectionBackend));
	    var JSONPBackend_ = (function (_super) {
	        __extends(JSONPBackend_, _super);
	        /**
	         * @param {?} _browserJSONP
	         * @param {?} _baseResponseOptions
	         */
	        function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
	            _super.call(this);
	            this._browserJSONP = _browserJSONP;
	            this._baseResponseOptions = _baseResponseOptions;
	        }
	        /**
	         * @param {?} request
	         * @return {?}
	         */
	        JSONPBackend_.prototype.createConnection = function (request) {
	            return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
	        };
	        JSONPBackend_.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        JSONPBackend_.ctorParameters = function () { return [
	            { type: BrowserJsonp, },
	            { type: ResponseOptions, },
	        ]; };
	        return JSONPBackend_;
	    }(JSONPBackend));

	    var /** @type {?} */ XSSI_PREFIX = /^\)\]\}',?\n/;
	    /**
	     * Creates connections using `XMLHttpRequest`. Given a fully-qualified
	     * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
	     * request.
	     *
	     * This class would typically not be created or interacted with directly inside applications, though
	     * the {\@link MockConnection} may be interacted with in tests.
	     *
	     * \@experimental
	     */
	    var XHRConnection = (function () {
	        /**
	         * @param {?} req
	         * @param {?} browserXHR
	         * @param {?=} baseResponseOptions
	         */
	        function XHRConnection(req, browserXHR, baseResponseOptions) {
	            var _this = this;
	            this.request = req;
	            this.response = new rxjs_Observable.Observable(function (responseObserver) {
	                var _xhr = browserXHR.build();
	                _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);
	                if (req.withCredentials != null) {
	                    _xhr.withCredentials = req.withCredentials;
	                }
	                // load event handler
	                var onLoad = function () {
	                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                    var status = _xhr.status === 1223 ? 204 : _xhr.status;
	                    var body = null;
	                    // HTTP 204 means no content
	                    if (status !== 204) {
	                        // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                        // response/responseType properties were introduced in ResourceLoader Level2 spec
	                        // (supported by IE10)
	                        body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;
	                        // Implicitly strip a potential XSSI prefix.
	                        if (typeof body === 'string') {
	                            body = body.replace(XSSI_PREFIX, '');
	                        }
	                    }
	                    // fix status code when it is 0 (0 status is undocumented).
	                    // Occurs when accessing file resources or on Android 4.1 stock browser
	                    // while retrieving files from application cache.
	                    if (status === 0) {
	                        status = body ? 200 : 0;
	                    }
	                    var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
	                    // IE 9 does not provide the way to get URL of response
	                    var url = getResponseURL(_xhr) || req.url;
	                    var statusText = _xhr.statusText || 'OK';
	                    var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
	                    if (baseResponseOptions != null) {
	                        responseOptions = baseResponseOptions.merge(responseOptions);
	                    }
	                    var response = new Response(responseOptions);
	                    response.ok = isSuccess(status);
	                    if (response.ok) {
	                        responseObserver.next(response);
	                        // TODO(gdi2290): defer complete if array buffer until done
	                        responseObserver.complete();
	                        return;
	                    }
	                    responseObserver.error(response);
	                };
	                // error event handler
	                var onError = function (err) {
	                    var responseOptions = new ResponseOptions({
	                        body: err,
	                        type: ResponseType.Error,
	                        status: _xhr.status,
	                        statusText: _xhr.statusText,
	                    });
	                    if (baseResponseOptions != null) {
	                        responseOptions = baseResponseOptions.merge(responseOptions);
	                    }
	                    responseObserver.error(new Response(responseOptions));
	                };
	                _this.setDetectedContentType(req, _xhr);
	                if (req.headers == null) {
	                    req.headers = new Headers();
	                }
	                if (!req.headers.has('Accept')) {
	                    req.headers.append('Accept', 'application/json, text/plain, */*');
	                }
	                req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
	                // Select the correct buffer type to store the response
	                if (req.responseType != null && _xhr.responseType != null) {
	                    switch (req.responseType) {
	                        case ResponseContentType.ArrayBuffer:
	                            _xhr.responseType = 'arraybuffer';
	                            break;
	                        case ResponseContentType.Json:
	                            _xhr.responseType = 'json';
	                            break;
	                        case ResponseContentType.Text:
	                            _xhr.responseType = 'text';
	                            break;
	                        case ResponseContentType.Blob:
	                            _xhr.responseType = 'blob';
	                            break;
	                        default:
	                            throw new Error('The selected responseType is not supported');
	                    }
	                }
	                _xhr.addEventListener('load', onLoad);
	                _xhr.addEventListener('error', onError);
	                _xhr.send(_this.request.getBody());
	                return function () {
	                    _xhr.removeEventListener('load', onLoad);
	                    _xhr.removeEventListener('error', onError);
	                    _xhr.abort();
	                };
	            });
	        }
	        /**
	         * @param {?} req
	         * @param {?} _xhr
	         * @return {?}
	         */
	        XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {
	            // Skip if a custom Content-Type header is provided
	            if (req.headers != null && req.headers.get('Content-Type') != null) {
	                return;
	            }
	            // Set the detected content type
	            switch (req.contentType) {
	                case ContentType.NONE:
	                    break;
	                case ContentType.JSON:
	                    _xhr.setRequestHeader('content-type', 'application/json');
	                    break;
	                case ContentType.FORM:
	                    _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	                    break;
	                case ContentType.TEXT:
	                    _xhr.setRequestHeader('content-type', 'text/plain');
	                    break;
	                case ContentType.BLOB:
	                    var /** @type {?} */ blob = req.blob();
	                    if (blob.type) {
	                        _xhr.setRequestHeader('content-type', blob.type);
	                    }
	                    break;
	            }
	        };
	        return XHRConnection;
	    }());
	    /**
	     * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
	     * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
	     * for more information on XSRF.
	     *
	     * Applications can configure custom cookie and header names by binding an instance of this class
	     * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
	     * details.
	     *
	     * \@experimental
	     */
	    var CookieXSRFStrategy = (function () {
	        /**
	         * @param {?=} _cookieName
	         * @param {?=} _headerName
	         */
	        function CookieXSRFStrategy(_cookieName, _headerName) {
	            if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }
	            if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }
	            this._cookieName = _cookieName;
	            this._headerName = _headerName;
	        }
	        /**
	         * @param {?} req
	         * @return {?}
	         */
	        CookieXSRFStrategy.prototype.configureRequest = function (req) {
	            var /** @type {?} */ xsrfToken = _angular_platformBrowser.__platform_browser_private__.getDOM().getCookie(this._cookieName);
	            if (xsrfToken) {
	                req.headers.set(this._headerName, xsrfToken);
	            }
	        };
	        return CookieXSRFStrategy;
	    }());
	    /**
	     * Creates {\@link XHRConnection} instances.
	     *
	     * This class would typically not be used by end users, but could be
	     * overridden if a different backend implementation should be used,
	     * such as in a node backend.
	     *
	     * ### Example
	     *
	     * ```
	     * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '\@angular/http';
	     * \@Component({
	     *   viewProviders: [
	     *     HTTP_PROVIDERS,
	     *     {provide: Http, useFactory: (backend, options) => {
	     *       return new Http(backend, options);
	     *     }, deps: [MyNodeBackend, BaseRequestOptions]}]
	     * })
	     * class MyComponent {
	     *   constructor(http:Http) {
	     *     http.request('people.json').subscribe(res => this.people = res.json());
	     *   }
	     * }
	     * ```
	     * \@experimental
	     */
	    var XHRBackend = (function () {
	        /**
	         * @param {?} _browserXHR
	         * @param {?} _baseResponseOptions
	         * @param {?} _xsrfStrategy
	         */
	        function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
	            this._browserXHR = _browserXHR;
	            this._baseResponseOptions = _baseResponseOptions;
	            this._xsrfStrategy = _xsrfStrategy;
	        }
	        /**
	         * @param {?} request
	         * @return {?}
	         */
	        XHRBackend.prototype.createConnection = function (request) {
	            this._xsrfStrategy.configureRequest(request);
	            return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
	        };
	        XHRBackend.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        XHRBackend.ctorParameters = function () { return [
	            { type: BrowserXhr, },
	            { type: ResponseOptions, },
	            { type: XSRFStrategy, },
	        ]; };
	        return XHRBackend;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Creates a request options object to be optionally provided when instantiating a
	     * {\@link Request}.
	     *
	     * This class is based on the `RequestInit` description in the [Fetch
	     * Spec](https://fetch.spec.whatwg.org/#requestinit).
	     *
	     * All values are null by default. Typical defaults can be found in the {\@link BaseRequestOptions}
	     * class, which sub-classes `RequestOptions`.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/7Wvi3lfLq41aQPKlxB4O?p=preview))
	     *
	     * ```typescript
	     * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
	     *
	     * var options = new RequestOptions({
	     *   method: RequestMethod.Post,
	     *   url: 'https://google.com'
	     * });
	     * var req = new Request(options);
	     * console.log('req.method:', RequestMethod[req.method]); // Post
	     * console.log('options.url:', options.url); // https://google.com
	     * ```
	     *
	     * \@experimental
	     */
	    var RequestOptions = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function RequestOptions(_a) {
	            var _b = _a === void 0 ? {} : _a, method = _b.method, headers = _b.headers, body = _b.body, url = _b.url, search = _b.search, withCredentials = _b.withCredentials, responseType = _b.responseType;
	            this.method = method != null ? normalizeMethodName(method) : null;
	            this.headers = headers != null ? headers : null;
	            this.body = body != null ? body : null;
	            this.url = url != null ? url : null;
	            this.search =
	                search != null ? (typeof search === 'string' ? new URLSearchParams(search) : search) : null;
	            this.withCredentials = withCredentials != null ? withCredentials : null;
	            this.responseType = responseType != null ? responseType : null;
	        }
	        /**
	         * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
	         * existing values. This method will not change the values of the instance on which it is being
	         * called.
	         *
	         * Note that `headers` and `search` will override existing values completely if present in
	         * the `options` object. If these values should be merged, it should be done prior to calling
	         * `merge` on the `RequestOptions` instance.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/6w8XA8YTkDRcPYpdB9dk?p=preview))
	         *
	         * ```typescript
	         * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
	         *
	         * var options = new RequestOptions({
	         *   method: RequestMethod.Post
	         * });
	         * var req = new Request(options.merge({
	         *   url: 'https://google.com'
	         * }));
	         * console.log('req.method:', RequestMethod[req.method]); // Post
	         * console.log('options.url:', options.url); // null
	         * console.log('req.url:', req.url); // https://google.com
	         * ```
	         * @param {?=} options
	         * @return {?}
	         */
	        RequestOptions.prototype.merge = function (options) {
	            return new RequestOptions({
	                method: options && options.method != null ? options.method : this.method,
	                headers: options && options.headers != null ? options.headers : new Headers(this.headers),
	                body: options && options.body != null ? options.body : this.body,
	                url: options && options.url != null ? options.url : this.url,
	                search: options && options.search != null ?
	                    (typeof options.search === 'string' ? new URLSearchParams(options.search) :
	                        options.search.clone()) :
	                    this.search,
	                withCredentials: options && options.withCredentials != null ? options.withCredentials :
	                    this.withCredentials,
	                responseType: options && options.responseType != null ? options.responseType :
	                    this.responseType
	            });
	        };
	        return RequestOptions;
	    }());
	    /**
	     * Subclass of {\@link RequestOptions}, with default values.
	     *
	     * Default values:
	     *  * method: {\@link RequestMethod RequestMethod.Get}
	     *  * headers: empty {\@link Headers} object
	     *
	     * This class could be extended and bound to the {\@link RequestOptions} class
	     * when configuring an {\@link Injector}, in order to override the default options
	     * used by {\@link Http} to create and send {\@link Request Requests}.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/LEKVSx?p=preview))
	     *
	     * ```typescript
	     * import {provide} from '\@angular/core';
	     * import {bootstrap} from '\@angular/platform-browser/browser';
	     * import {HTTP_PROVIDERS, Http, BaseRequestOptions, RequestOptions} from '\@angular/http';
	     * import {App} from './myapp';
	     *
	     * class MyOptions extends BaseRequestOptions {
	     *   search: string = 'coreTeam=true';
	     * }
	     *
	     * bootstrap(App, [HTTP_PROVIDERS, {provide: RequestOptions, useClass: MyOptions}]);
	     * ```
	     *
	     * The options could also be extended when manually creating a {\@link Request}
	     * object.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/oyBoEvNtDhOSfi9YxaVb?p=preview))
	     *
	     * ```
	     * import {BaseRequestOptions, Request, RequestMethod} from '\@angular/http';
	     *
	     * var options = new BaseRequestOptions();
	     * var req = new Request(options.merge({
	     *   method: RequestMethod.Post,
	     *   url: 'https://google.com'
	     * }));
	     * console.log('req.method:', RequestMethod[req.method]); // Post
	     * console.log('options.url:', options.url); // null
	     * console.log('req.url:', req.url); // https://google.com
	     * ```
	     *
	     * \@experimental
	     */
	    var BaseRequestOptions = (function (_super) {
	        __extends$3(BaseRequestOptions, _super);
	        function BaseRequestOptions() {
	            _super.call(this, { method: RequestMethod.Get, headers: new Headers() });
	        }
	        BaseRequestOptions.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        BaseRequestOptions.ctorParameters = function () { return []; };
	        return BaseRequestOptions;
	    }(RequestOptions));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Creates `Request` instances from provided values.
	     *
	     * The Request's interface is inspired by the Request constructor defined in the [Fetch
	     * Spec](https://fetch.spec.whatwg.org/#request-class),
	     * but is considered a static value whose body can be accessed many times. There are other
	     * differences in the implementation, but this is the most significant.
	     *
	     * `Request` instances are typically created by higher-level classes, like {\@link Http} and
	     * {\@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
	     * One such example is when creating services that wrap higher-level services, like {\@link Http},
	     * where it may be useful to generate a `Request` with arbitrary headers and search params.
	     *
	     * ```typescript
	     * import {Injectable, Injector} from '\@angular/core';
	     * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '\@angular/http';
	     *
	     * \@Injectable()
	     * class AutoAuthenticator {
	     *   constructor(public http:Http) {}
	     *   request(url:string) {
	     *     return this.http.request(new Request({
	     *       method: RequestMethod.Get,
	     *       url: url,
	     *       search: 'password=123'
	     *     }));
	     *   }
	     * }
	     *
	     * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
	     * var authenticator = injector.get(AutoAuthenticator);
	     * authenticator.request('people.json').subscribe(res => {
	     *   //URL should have included '?password=123'
	     *   console.log('people', res.json());
	     * });
	     * ```
	     *
	     * \@experimental
	     */
	    var Request = (function (_super) {
	        __extends$5(Request, _super);
	        /**
	         * @param {?} requestOptions
	         */
	        function Request(requestOptions) {
	            _super.call(this);
	            // TODO: assert that url is present
	            var url = requestOptions.url;
	            this.url = requestOptions.url;
	            if (requestOptions.search) {
	                var search = requestOptions.search.toString();
	                if (search.length > 0) {
	                    var prefix = '?';
	                    if (this.url.indexOf('?') != -1) {
	                        prefix = (this.url[this.url.length - 1] == '&') ? '' : '&';
	                    }
	                    // TODO: just delete search-query-looking string in url?
	                    this.url = url + prefix + search;
	                }
	            }
	            this._body = requestOptions.body;
	            this.method = normalizeMethodName(requestOptions.method);
	            // TODO(jeffbcross): implement behavior
	            // Defaults to 'omit', consistent with browser
	            this.headers = new Headers(requestOptions.headers);
	            this.contentType = this.detectContentType();
	            this.withCredentials = requestOptions.withCredentials;
	            this.responseType = requestOptions.responseType;
	        }
	        /**
	         * Returns the content type enum based on header options.
	         * @return {?}
	         */
	        Request.prototype.detectContentType = function () {
	            switch (this.headers.get('content-type')) {
	                case 'application/json':
	                    return ContentType.JSON;
	                case 'application/x-www-form-urlencoded':
	                    return ContentType.FORM;
	                case 'multipart/form-data':
	                    return ContentType.FORM_DATA;
	                case 'text/plain':
	                case 'text/html':
	                    return ContentType.TEXT;
	                case 'application/octet-stream':
	                    return this._body instanceof ArrayBuffer$1 ? ContentType.ARRAY_BUFFER : ContentType.BLOB;
	                default:
	                    return this.detectContentTypeFromBody();
	            }
	        };
	        /**
	         * Returns the content type of request's body based on its type.
	         * @return {?}
	         */
	        Request.prototype.detectContentTypeFromBody = function () {
	            if (this._body == null) {
	                return ContentType.NONE;
	            }
	            else if (this._body instanceof URLSearchParams) {
	                return ContentType.FORM;
	            }
	            else if (this._body instanceof FormData) {
	                return ContentType.FORM_DATA;
	            }
	            else if (this._body instanceof Blob$1) {
	                return ContentType.BLOB;
	            }
	            else if (this._body instanceof ArrayBuffer$1) {
	                return ContentType.ARRAY_BUFFER;
	            }
	            else if (this._body && typeof this._body === 'object') {
	                return ContentType.JSON;
	            }
	            else {
	                return ContentType.TEXT;
	            }
	        };
	        /**
	         * Returns the request's body according to its type. If body is undefined, return
	         * null.
	         * @return {?}
	         */
	        Request.prototype.getBody = function () {
	            switch (this.contentType) {
	                case ContentType.JSON:
	                    return this.text();
	                case ContentType.FORM:
	                    return this.text();
	                case ContentType.FORM_DATA:
	                    return this._body;
	                case ContentType.TEXT:
	                    return this.text();
	                case ContentType.BLOB:
	                    return this.blob();
	                case ContentType.ARRAY_BUFFER:
	                    return this.arrayBuffer();
	                default:
	                    return null;
	            }
	        };
	        return Request;
	    }(Body));
	    var /** @type {?} */ noop = function () { };
	    var /** @type {?} */ w = typeof window == 'object' ? window : noop;
	    var /** @type {?} */ FormData = ((w) /** TODO #9100 */)['FormData'] || noop;
	    var /** @type {?} */ Blob$1 = ((w) /** TODO #9100 */)['Blob'] || noop;
	    var /** @type {?} */ ArrayBuffer$1 = ((w) /** TODO #9100 */)['ArrayBuffer'] || noop;

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @param {?} backend
	     * @param {?} request
	     * @return {?}
	     */
	    function httpRequest(backend, request) {
	        return backend.createConnection(request).response;
	    }
	    /**
	     * @param {?} defaultOpts
	     * @param {?} providedOpts
	     * @param {?} method
	     * @param {?} url
	     * @return {?}
	     */
	    function mergeOptions(defaultOpts, providedOpts, method, url) {
	        var /** @type {?} */ newOptions = defaultOpts;
	        if (providedOpts) {
	            // Hack so Dart can used named parameters
	            return newOptions.merge(new RequestOptions({
	                method: providedOpts.method || method,
	                url: providedOpts.url || url,
	                search: providedOpts.search,
	                headers: providedOpts.headers,
	                body: providedOpts.body,
	                withCredentials: providedOpts.withCredentials,
	                responseType: providedOpts.responseType
	            }));
	        }
	        return newOptions.merge(new RequestOptions({ method: method, url: url }));
	    }
	    /**
	     * Performs http requests using `XMLHttpRequest` as the default backend.
	     *
	     * `Http` is available as an injectable class, with methods to perform http requests. Calling
	     * `request` returns an `Observable` which will emit a single {\@link Response} when a
	     * response is received.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * import {Http, HTTP_PROVIDERS} from '\@angular/http';
	     * import 'rxjs/add/operator/map'
	     * \@Component({
	     *   selector: 'http-app',
	     *   viewProviders: [HTTP_PROVIDERS],
	     *   templateUrl: 'people.html'
	     * })
	     * class PeopleComponent {
	     *   constructor(http: Http) {
	     *     http.get('people.json')
	     *       // Call map on the response observable to get the parsed people object
	     *       .map(res => res.json())
	     *       // Subscribe to the observable to get the parsed people object and attach it to the
	     *       // component
	     *       .subscribe(people => this.people = people);
	     *   }
	     * }
	     * ```
	     *
	     *
	     * ### Example
	     *
	     * ```
	     * http.get('people.json').subscribe((res:Response) => this.people = res.json());
	     * ```
	     *
	     * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a "Backend" (
	     * {\@link XHRBackend} in this case), which could be mocked with dependency injection by replacing
	     * the {\@link XHRBackend} provider, as in the following example:
	     *
	     * ### Example
	     *
	     * ```typescript
	     * import {BaseRequestOptions, Http} from '\@angular/http';
	     * import {MockBackend} from '\@angular/http/testing';
	     * var injector = Injector.resolveAndCreate([
	     *   BaseRequestOptions,
	     *   MockBackend,
	     *   {provide: Http, useFactory:
	     *       function(backend, defaultOptions) {
	     *         return new Http(backend, defaultOptions);
	     *       },
	     *       deps: [MockBackend, BaseRequestOptions]}
	     * ]);
	     * var http = injector.get(Http);
	     * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));
	     * ```
	     *
	     * \@experimental
	     */
	    var Http = (function () {
	        /**
	         * @param {?} _backend
	         * @param {?} _defaultOptions
	         */
	        function Http(_backend, _defaultOptions) {
	            this._backend = _backend;
	            this._defaultOptions = _defaultOptions;
	        }
	        /**
	         * Performs any type of http request. First argument is required, and can either be a url or
	         * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
	         * object can be provided as the 2nd argument. The options object will be merged with the values
	         * of {\@link BaseRequestOptions} before performing the request.
	         * @param {?} url
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.request = function (url, options) {
	            var /** @type {?} */ responseObservable;
	            if (typeof url === 'string') {
	                responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url))));
	            }
	            else if (url instanceof Request) {
	                responseObservable = httpRequest(this._backend, url);
	            }
	            else {
	                throw new Error('First argument must be a url string or Request instance.');
	            }
	            return responseObservable;
	        };
	        /**
	         * Performs a request with `get` http method.
	         * @param {?} url
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.get = function (url, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));
	        };
	        /**
	         * Performs a request with `post` http method.
	         * @param {?} url
	         * @param {?} body
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.post = function (url, body, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));
	        };
	        /**
	         * Performs a request with `put` http method.
	         * @param {?} url
	         * @param {?} body
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.put = function (url, body, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));
	        };
	        /**
	         * Performs a request with `delete` http method.
	         * @param {?} url
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.delete = function (url, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));
	        };
	        /**
	         * Performs a request with `patch` http method.
	         * @param {?} url
	         * @param {?} body
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.patch = function (url, body, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));
	        };
	        /**
	         * Performs a request with `head` http method.
	         * @param {?} url
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.head = function (url, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));
	        };
	        /**
	         * Performs a request with `options` http method.
	         * @param {?} url
	         * @param {?=} options
	         * @return {?}
	         */
	        Http.prototype.options = function (url, options) {
	            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));
	        };
	        Http.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        Http.ctorParameters = function () { return [
	            { type: ConnectionBackend, },
	            { type: RequestOptions, },
	        ]; };
	        return Http;
	    }());
	    /**
	     * \@experimental
	     */
	    var Jsonp = (function (_super) {
	        __extends$4(Jsonp, _super);
	        /**
	         * @param {?} backend
	         * @param {?} defaultOptions
	         */
	        function Jsonp(backend, defaultOptions) {
	            _super.call(this, backend, defaultOptions);
	        }
	        /**
	         * Performs any type of http request. First argument is required, and can either be a url or
	         * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
	         * object can be provided as the 2nd argument. The options object will be merged with the values
	         * of {\@link BaseRequestOptions} before performing the request.
	         *
	         * \@security Regular XHR is the safest alternative to JSONP for most applications, and is
	         * supported by all current browsers. Because JSONP creates a `<script>` element with
	         * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted
	         * source could expose your application to XSS risks. Data exposed by JSONP may also be
	         * readable by malicious third-party websites. In addition, JSONP introduces potential risk for
	         * future security issues (e.g. content sniffing).  For more detail, see the
	         * [Security Guide](http://g.co/ng/security).
	         * @param {?} url
	         * @param {?=} options
	         * @return {?}
	         */
	        Jsonp.prototype.request = function (url, options) {
	            var /** @type {?} */ responseObservable;
	            if (typeof url === 'string') {
	                url =
	                    new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url)));
	            }
	            if (url instanceof Request) {
	                if (url.method !== RequestMethod.Get) {
	                    throw new Error('JSONP requests must use GET request method.');
	                }
	                responseObservable = httpRequest(this._backend, url);
	            }
	            else {
	                throw new Error('First argument must be a url string or Request instance.');
	            }
	            return responseObservable;
	        };
	        Jsonp.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        Jsonp.ctorParameters = function () { return [
	            { type: ConnectionBackend, },
	            { type: RequestOptions, },
	        ]; };
	        return Jsonp;
	    }(Http));

	    /**
	     * @return {?}
	     */
	    function _createDefaultCookieXSRFStrategy() {
	        return new CookieXSRFStrategy();
	    }
	    /**
	     * @param {?} xhrBackend
	     * @param {?} requestOptions
	     * @return {?}
	     */
	    function httpFactory(xhrBackend, requestOptions) {
	        return new Http(xhrBackend, requestOptions);
	    }
	    /**
	     * @param {?} jsonpBackend
	     * @param {?} requestOptions
	     * @return {?}
	     */
	    function jsonpFactory(jsonpBackend, requestOptions) {
	        return new Jsonp(jsonpBackend, requestOptions);
	    }
	    /**
	     * The module that includes http's providers
	     *
	     * \@experimental
	     */
	    var HttpModule = (function () {
	        function HttpModule() {
	        }
	        HttpModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        providers: [
	                            // TODO(pascal): use factory type annotations once supported in DI
	                            // issue: https://github.com/angular/angular/issues/3183
	                            { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },
	                            BrowserXhr,
	                            { provide: RequestOptions, useClass: BaseRequestOptions },
	                            { provide: ResponseOptions, useClass: BaseResponseOptions },
	                            XHRBackend,
	                            { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },
	                        ],
	                    },] },
	        ];
	        /** @nocollapse */
	        HttpModule.ctorParameters = function () { return []; };
	        return HttpModule;
	    }());
	    /**
	     * The module that includes jsonp's providers
	     *
	     * \@experimental
	     */
	    var JsonpModule = (function () {
	        function JsonpModule() {
	        }
	        JsonpModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        providers: [
	                            // TODO(pascal): use factory type annotations once supported in DI
	                            // issue: https://github.com/angular/angular/issues/3183
	                            { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },
	                            BrowserJsonp,
	                            { provide: RequestOptions, useClass: BaseRequestOptions },
	                            { provide: ResponseOptions, useClass: BaseResponseOptions },
	                            { provide: JSONPBackend, useClass: JSONPBackend_ },
	                        ],
	                    },] },
	        ];
	        /** @nocollapse */
	        JsonpModule.ctorParameters = function () { return []; };
	        return JsonpModule;
	    }());

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.10');

	    exports.BrowserXhr = BrowserXhr;
	    exports.JSONPBackend = JSONPBackend;
	    exports.JSONPConnection = JSONPConnection;
	    exports.CookieXSRFStrategy = CookieXSRFStrategy;
	    exports.XHRBackend = XHRBackend;
	    exports.XHRConnection = XHRConnection;
	    exports.BaseRequestOptions = BaseRequestOptions;
	    exports.RequestOptions = RequestOptions;
	    exports.BaseResponseOptions = BaseResponseOptions;
	    exports.ResponseOptions = ResponseOptions;
	    exports.ReadyState = ReadyState;
	    exports.RequestMethod = RequestMethod;
	    exports.ResponseContentType = ResponseContentType;
	    exports.ResponseType = ResponseType;
	    exports.Headers = Headers;
	    exports.Http = Http;
	    exports.Jsonp = Jsonp;
	    exports.HttpModule = HttpModule;
	    exports.JsonpModule = JsonpModule;
	    exports.Connection = Connection;
	    exports.ConnectionBackend = ConnectionBackend;
	    exports.XSRFStrategy = XSRFStrategy;
	    exports.Request = Request;
	    exports.Response = Response;
	    exports.QueryEncoder = QueryEncoder;
	    exports.URLSearchParams = URLSearchParams;
	    exports.VERSION = VERSION;

	}));

/***/ }),
/* 66 */,
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {//     Backbone.js 1.3.3

	//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Backbone may be freely distributed under the MIT license.
	//     For all details and documentation:
	//     http://backbonejs.org

	(function(factory) {

	  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
	  // We use `self` instead of `window` for `WebWorker` support.
	  var root = (typeof self == 'object' && self.self === self && self) ||
	            (typeof global == 'object' && global.global === global && global);

	  // Set up Backbone appropriately for the environment. Start with AMD.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(67), __webpack_require__(69), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {
	      // Export global even in AMD case in case this script is loaded with
	      // others that may still expect a global Backbone.
	      root.Backbone = factory(root, exports, _, $);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
	  } else if (typeof exports !== 'undefined') {
	    var _ = require('underscore'), $;
	    try { $ = require('jquery'); } catch (e) {}
	    factory(root, exports, _, $);

	  // Finally, as a browser global.
	  } else {
	    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
	  }

	})(function(root, Backbone, _, $) {

	  // Initial Setup
	  // -------------

	  // Save the previous value of the `Backbone` variable, so that it can be
	  // restored later on, if `noConflict` is used.
	  var previousBackbone = root.Backbone;

	  // Create a local reference to a common array method we'll want to use later.
	  var slice = Array.prototype.slice;

	  // Current version of the library. Keep in sync with `package.json`.
	  Backbone.VERSION = '1.3.3';

	  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	  // the `$` variable.
	  Backbone.$ = $;

	  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	  // to its previous owner. Returns a reference to this Backbone object.
	  Backbone.noConflict = function() {
	    root.Backbone = previousBackbone;
	    return this;
	  };

	  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	  // set a `X-Http-Method-Override` header.
	  Backbone.emulateHTTP = false;

	  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
	  // `application/json` requests ... this will encode the body as
	  // `application/x-www-form-urlencoded` instead and will send the model in a
	  // form param named `model`.
	  Backbone.emulateJSON = false;

	  // Proxy Backbone class methods to Underscore functions, wrapping the model's
	  // `attributes` object or collection's `models` array behind the scenes.
	  //
	  // collection.filter(function(model) { return model.get('age') > 10 });
	  // collection.each(this.addView);
	  //
	  // `Function#apply` can be slow so we use the method's arg count, if we know it.
	  var addMethod = function(length, method, attribute) {
	    switch (length) {
	      case 1: return function() {
	        return _[method](this[attribute]);
	      };
	      case 2: return function(value) {
	        return _[method](this[attribute], value);
	      };
	      case 3: return function(iteratee, context) {
	        return _[method](this[attribute], cb(iteratee, this), context);
	      };
	      case 4: return function(iteratee, defaultVal, context) {
	        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
	      };
	      default: return function() {
	        var args = slice.call(arguments);
	        args.unshift(this[attribute]);
	        return _[method].apply(_, args);
	      };
	    }
	  };
	  var addUnderscoreMethods = function(Class, methods, attribute) {
	    _.each(methods, function(length, method) {
	      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
	    });
	  };

	  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
	  var cb = function(iteratee, instance) {
	    if (_.isFunction(iteratee)) return iteratee;
	    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
	    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
	    return iteratee;
	  };
	  var modelMatcher = function(attrs) {
	    var matcher = _.matches(attrs);
	    return function(model) {
	      return matcher(model.attributes);
	    };
	  };

	  // Backbone.Events
	  // ---------------

	  // A module that can be mixed in to *any object* in order to provide it with
	  // a custom event channel. You may bind a callback to an event with `on` or
	  // remove with `off`; `trigger`-ing an event fires all callbacks in
	  // succession.
	  //
	  //     var object = {};
	  //     _.extend(object, Backbone.Events);
	  //     object.on('expand', function(){ alert('expanded'); });
	  //     object.trigger('expand');
	  //
	  var Events = Backbone.Events = {};

	  // Regular expression used to split event strings.
	  var eventSplitter = /\s+/;

	  // Iterates over the standard `event, callback` (as well as the fancy multiple
	  // space-separated events `"change blur", callback` and jQuery-style event
	  // maps `{event: callback}`).
	  var eventsApi = function(iteratee, events, name, callback, opts) {
	    var i = 0, names;
	    if (name && typeof name === 'object') {
	      // Handle event maps.
	      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
	      for (names = _.keys(name); i < names.length ; i++) {
	        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
	      }
	    } else if (name && eventSplitter.test(name)) {
	      // Handle space-separated event names by delegating them individually.
	      for (names = name.split(eventSplitter); i < names.length; i++) {
	        events = iteratee(events, names[i], callback, opts);
	      }
	    } else {
	      // Finally, standard events.
	      events = iteratee(events, name, callback, opts);
	    }
	    return events;
	  };

	  // Bind an event to a `callback` function. Passing `"all"` will bind
	  // the callback to all events fired.
	  Events.on = function(name, callback, context) {
	    return internalOn(this, name, callback, context);
	  };

	  // Guard the `listening` argument from the public API.
	  var internalOn = function(obj, name, callback, context, listening) {
	    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
	      context: context,
	      ctx: obj,
	      listening: listening
	    });

	    if (listening) {
	      var listeners = obj._listeners || (obj._listeners = {});
	      listeners[listening.id] = listening;
	    }

	    return obj;
	  };

	  // Inversion-of-control versions of `on`. Tell *this* object to listen to
	  // an event in another object... keeping track of what it's listening to
	  // for easier unbinding later.
	  Events.listenTo = function(obj, name, callback) {
	    if (!obj) return this;
	    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
	    var listeningTo = this._listeningTo || (this._listeningTo = {});
	    var listening = listeningTo[id];

	    // This object is not listening to any other events on `obj` yet.
	    // Setup the necessary references to track the listening callbacks.
	    if (!listening) {
	      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
	      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
	    }

	    // Bind callbacks on obj, and keep track of them on listening.
	    internalOn(obj, name, callback, this, listening);
	    return this;
	  };

	  // The reducing API that adds a callback to the `events` object.
	  var onApi = function(events, name, callback, options) {
	    if (callback) {
	      var handlers = events[name] || (events[name] = []);
	      var context = options.context, ctx = options.ctx, listening = options.listening;
	      if (listening) listening.count++;

	      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});
	    }
	    return events;
	  };

	  // Remove one or many callbacks. If `context` is null, removes all
	  // callbacks with that function. If `callback` is null, removes all
	  // callbacks for the event. If `name` is null, removes all bound
	  // callbacks for all events.
	  Events.off = function(name, callback, context) {
	    if (!this._events) return this;
	    this._events = eventsApi(offApi, this._events, name, callback, {
	      context: context,
	      listeners: this._listeners
	    });
	    return this;
	  };

	  // Tell this object to stop listening to either specific events ... or
	  // to every object it's currently listening to.
	  Events.stopListening = function(obj, name, callback) {
	    var listeningTo = this._listeningTo;
	    if (!listeningTo) return this;

	    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

	    for (var i = 0; i < ids.length; i++) {
	      var listening = listeningTo[ids[i]];

	      // If listening doesn't exist, this object is not currently
	      // listening to obj. Break out early.
	      if (!listening) break;

	      listening.obj.off(name, callback, this);
	    }

	    return this;
	  };

	  // The reducing API that removes a callback from the `events` object.
	  var offApi = function(events, name, callback, options) {
	    if (!events) return;

	    var i = 0, listening;
	    var context = options.context, listeners = options.listeners;

	    // Delete all events listeners and "drop" events.
	    if (!name && !callback && !context) {
	      var ids = _.keys(listeners);
	      for (; i < ids.length; i++) {
	        listening = listeners[ids[i]];
	        delete listeners[listening.id];
	        delete listening.listeningTo[listening.objId];
	      }
	      return;
	    }

	    var names = name ? [name] : _.keys(events);
	    for (; i < names.length; i++) {
	      name = names[i];
	      var handlers = events[name];

	      // Bail out if there are no events stored.
	      if (!handlers) break;

	      // Replace events if there are any remaining.  Otherwise, clean up.
	      var remaining = [];
	      for (var j = 0; j < handlers.length; j++) {
	        var handler = handlers[j];
	        if (
	          callback && callback !== handler.callback &&
	            callback !== handler.callback._callback ||
	              context && context !== handler.context
	        ) {
	          remaining.push(handler);
	        } else {
	          listening = handler.listening;
	          if (listening && --listening.count === 0) {
	            delete listeners[listening.id];
	            delete listening.listeningTo[listening.objId];
	          }
	        }
	      }

	      // Update tail event if the list has any events.  Otherwise, clean up.
	      if (remaining.length) {
	        events[name] = remaining;
	      } else {
	        delete events[name];
	      }
	    }
	    return events;
	  };

	  // Bind an event to only be triggered a single time. After the first time
	  // the callback is invoked, its listener will be removed. If multiple events
	  // are passed in using the space-separated syntax, the handler will fire
	  // once for each event, not once for a combination of all events.
	  Events.once = function(name, callback, context) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
	    if (typeof name === 'string' && context == null) callback = void 0;
	    return this.on(events, callback, context);
	  };

	  // Inversion-of-control versions of `once`.
	  Events.listenToOnce = function(obj, name, callback) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
	    return this.listenTo(obj, events);
	  };

	  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
	  // `offer` unbinds the `onceWrapper` after it has been called.
	  var onceMap = function(map, name, callback, offer) {
	    if (callback) {
	      var once = map[name] = _.once(function() {
	        offer(name, once);
	        callback.apply(this, arguments);
	      });
	      once._callback = callback;
	    }
	    return map;
	  };

	  // Trigger one or many events, firing all bound callbacks. Callbacks are
	  // passed the same arguments as `trigger` is, apart from the event name
	  // (unless you're listening on `"all"`, which will cause your callback to
	  // receive the true name of the event as the first argument).
	  Events.trigger = function(name) {
	    if (!this._events) return this;

	    var length = Math.max(0, arguments.length - 1);
	    var args = Array(length);
	    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

	    eventsApi(triggerApi, this._events, name, void 0, args);
	    return this;
	  };

	  // Handles triggering the appropriate event callbacks.
	  var triggerApi = function(objEvents, name, callback, args) {
	    if (objEvents) {
	      var events = objEvents[name];
	      var allEvents = objEvents.all;
	      if (events && allEvents) allEvents = allEvents.slice();
	      if (events) triggerEvents(events, args);
	      if (allEvents) triggerEvents(allEvents, [name].concat(args));
	    }
	    return objEvents;
	  };

	  // A difficult-to-believe, but optimized internal dispatch function for
	  // triggering events. Tries to keep the usual cases speedy (most internal
	  // Backbone events have 3 arguments).
	  var triggerEvents = function(events, args) {
	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
	    switch (args.length) {
	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
	    }
	  };

	  // Aliases for backwards compatibility.
	  Events.bind   = Events.on;
	  Events.unbind = Events.off;

	  // Allow the `Backbone` object to serve as a global event bus, for folks who
	  // want global "pubsub" in a convenient place.
	  _.extend(Backbone, Events);

	  // Backbone.Model
	  // --------------

	  // Backbone **Models** are the basic data object in the framework --
	  // frequently representing a row in a table in a database on your server.
	  // A discrete chunk of data and a bunch of useful, related methods for
	  // performing computations and transformations on that data.

	  // Create a new model with the specified attributes. A client id (`cid`)
	  // is automatically generated and assigned for you.
	  var Model = Backbone.Model = function(attributes, options) {
	    var attrs = attributes || {};
	    options || (options = {});
	    this.cid = _.uniqueId(this.cidPrefix);
	    this.attributes = {};
	    if (options.collection) this.collection = options.collection;
	    if (options.parse) attrs = this.parse(attrs, options) || {};
	    var defaults = _.result(this, 'defaults');
	    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
	    this.set(attrs, options);
	    this.changed = {};
	    this.initialize.apply(this, arguments);
	  };

	  // Attach all inheritable methods to the Model prototype.
	  _.extend(Model.prototype, Events, {

	    // A hash of attributes whose current and previous value differ.
	    changed: null,

	    // The value returned during the last failed validation.
	    validationError: null,

	    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	    // CouchDB users may want to set this to `"_id"`.
	    idAttribute: 'id',

	    // The prefix is used to create the client id which is used to identify models locally.
	    // You may want to override this if you're experiencing name clashes with model ids.
	    cidPrefix: 'c',

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Return a copy of the model's `attributes` object.
	    toJSON: function(options) {
	      return _.clone(this.attributes);
	    },

	    // Proxy `Backbone.sync` by default -- but override this if you need
	    // custom syncing semantics for *this* particular model.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Get the value of an attribute.
	    get: function(attr) {
	      return this.attributes[attr];
	    },

	    // Get the HTML-escaped value of an attribute.
	    escape: function(attr) {
	      return _.escape(this.get(attr));
	    },

	    // Returns `true` if the attribute contains a value that is not null
	    // or undefined.
	    has: function(attr) {
	      return this.get(attr) != null;
	    },

	    // Special-cased proxy to underscore's `_.matches` method.
	    matches: function(attrs) {
	      return !!_.iteratee(attrs, this)(this.attributes);
	    },

	    // Set a hash of model attributes on the object, firing `"change"`. This is
	    // the core primitive operation of a model, updating the data and notifying
	    // anyone who needs to know about the change in state. The heart of the beast.
	    set: function(key, val, options) {
	      if (key == null) return this;

	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options || (options = {});

	      // Run validation.
	      if (!this._validate(attrs, options)) return false;

	      // Extract attributes and options.
	      var unset      = options.unset;
	      var silent     = options.silent;
	      var changes    = [];
	      var changing   = this._changing;
	      this._changing = true;

	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }

	      var current = this.attributes;
	      var changed = this.changed;
	      var prev    = this._previousAttributes;

	      // For each `set` attribute, update or delete the current value.
	      for (var attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) changes.push(attr);
	        if (!_.isEqual(prev[attr], val)) {
	          changed[attr] = val;
	        } else {
	          delete changed[attr];
	        }
	        unset ? delete current[attr] : current[attr] = val;
	      }

	      // Update the `id`.
	      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) this._pending = options;
	        for (var i = 0; i < changes.length; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }

	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) return this;
	      if (!silent) {
	        while (this._pending) {
	          options = this._pending;
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },

	    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	    // if the attribute doesn't exist.
	    unset: function(attr, options) {
	      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
	    },

	    // Clear all attributes on the model, firing `"change"`.
	    clear: function(options) {
	      var attrs = {};
	      for (var key in this.attributes) attrs[key] = void 0;
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },

	    // Determine if the model has changed since the last `"change"` event.
	    // If you specify an attribute name, determine if that attribute has changed.
	    hasChanged: function(attr) {
	      if (attr == null) return !_.isEmpty(this.changed);
	      return _.has(this.changed, attr);
	    },

	    // Return an object containing all the attributes that have changed, or
	    // false if there are no changed attributes. Useful for determining what
	    // parts of a view need to be updated and/or what attributes need to be
	    // persisted to the server. Unset attributes will be set to undefined.
	    // You can also pass an attributes object to diff against the model,
	    // determining if there *would be* a change.
	    changedAttributes: function(diff) {
	      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
	      var old = this._changing ? this._previousAttributes : this.attributes;
	      var changed = {};
	      for (var attr in diff) {
	        var val = diff[attr];
	        if (_.isEqual(old[attr], val)) continue;
	        changed[attr] = val;
	      }
	      return _.size(changed) ? changed : false;
	    },

	    // Get the previous value of an attribute, recorded at the time the last
	    // `"change"` event was fired.
	    previous: function(attr) {
	      if (attr == null || !this._previousAttributes) return null;
	      return this._previousAttributes[attr];
	    },

	    // Get all of the attributes of the model at the time of the previous
	    // `"change"` event.
	    previousAttributes: function() {
	      return _.clone(this._previousAttributes);
	    },

	    // Fetch the model from the server, merging the response with the model's
	    // local attributes. Any changed attributes will trigger a "change" event.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (!model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Set a hash of model attributes, and sync the model to the server.
	    // If the server returns an attributes hash that differs, the model's
	    // state will be `set` again.
	    save: function(key, val, options) {
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (key == null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options = _.extend({validate: true, parse: true}, options);
	      var wait = options.wait;

	      // If we're not waiting and attributes exist, save acts as
	      // `set(attr).save(null, opts)` with validation. Otherwise, check if
	      // the model will be valid when the attributes, if any, are set.
	      if (attrs && !wait) {
	        if (!this.set(attrs, options)) return false;
	      } else if (!this._validate(attrs, options)) {
	        return false;
	      }

	      // After a successful server-side save, the client is (optionally)
	      // updated with the server-side state.
	      var model = this;
	      var success = options.success;
	      var attributes = this.attributes;
	      options.success = function(resp) {
	        // Ensure attributes are restored during synchronous saves.
	        model.attributes = attributes;
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
	        if (serverAttrs && !model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);

	      // Set temporary attributes if `{wait: true}` to properly find new ids.
	      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

	      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	      if (method === 'patch' && !options.attrs) options.attrs = attrs;
	      var xhr = this.sync(method, this, options);

	      // Restore attributes.
	      this.attributes = attributes;

	      return xhr;
	    },

	    // Destroy this model on the server if it was already persisted.
	    // Optimistically removes the model from its collection, if it has one.
	    // If `wait: true` is passed, waits for the server to respond before removal.
	    destroy: function(options) {
	      options = options ? _.clone(options) : {};
	      var model = this;
	      var success = options.success;
	      var wait = options.wait;

	      var destroy = function() {
	        model.stopListening();
	        model.trigger('destroy', model, model.collection, options);
	      };

	      options.success = function(resp) {
	        if (wait) destroy();
	        if (success) success.call(options.context, model, resp, options);
	        if (!model.isNew()) model.trigger('sync', model, resp, options);
	      };

	      var xhr = false;
	      if (this.isNew()) {
	        _.defer(options.success);
	      } else {
	        wrapError(this, options);
	        xhr = this.sync('delete', this, options);
	      }
	      if (!wait) destroy();
	      return xhr;
	    },

	    // Default URL for the model's representation on the server -- if you're
	    // using Backbone's restful methods, override this to change the endpoint
	    // that will be called.
	    url: function() {
	      var base =
	        _.result(this, 'urlRoot') ||
	        _.result(this.collection, 'url') ||
	        urlError();
	      if (this.isNew()) return base;
	      var id = this.get(this.idAttribute);
	      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
	    },

	    // **parse** converts a response into the hash of attributes to be `set` on
	    // the model. The default implementation is just to pass the response along.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new model with identical attributes to this one.
	    clone: function() {
	      return new this.constructor(this.attributes);
	    },

	    // A model is new if it has never been saved to the server, and lacks an id.
	    isNew: function() {
	      return !this.has(this.idAttribute);
	    },

	    // Check if the model is currently in a valid state.
	    isValid: function(options) {
	      return this._validate({}, _.extend({}, options, {validate: true}));
	    },

	    // Run validation against the next complete set of model attributes,
	    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	    _validate: function(attrs, options) {
	      if (!options.validate || !this.validate) return true;
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validationError = this.validate(attrs, options) || null;
	      if (!error) return true;
	      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
	      return false;
	    }

	  });

	  // Underscore methods that we want to implement on the Model, mapped to the
	  // number of arguments they take.
	  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
	      omit: 0, chain: 1, isEmpty: 1};

	  // Mix in each Underscore method as a proxy to `Model#attributes`.
	  addUnderscoreMethods(Model, modelMethods, 'attributes');

	  // Backbone.Collection
	  // -------------------

	  // If models tend to represent a single row of data, a Backbone Collection is
	  // more analogous to a table full of data ... or a small slice or page of that
	  // table, or a collection of rows that belong together for a particular reason
	  // -- all of the messages in this particular folder, all of the documents
	  // belonging to this particular author, and so on. Collections maintain
	  // indexes of their models, both in order, and for lookup by `id`.

	  // Create a new **Collection**, perhaps to contain a specific type of `model`.
	  // If a `comparator` is specified, the Collection will maintain
	  // its models in sort order, as they're added and removed.
	  var Collection = Backbone.Collection = function(models, options) {
	    options || (options = {});
	    if (options.model) this.model = options.model;
	    if (options.comparator !== void 0) this.comparator = options.comparator;
	    this._reset();
	    this.initialize.apply(this, arguments);
	    if (models) this.reset(models, _.extend({silent: true}, options));
	  };

	  // Default options for `Collection#set`.
	  var setOptions = {add: true, remove: true, merge: true};
	  var addOptions = {add: true, remove: false};

	  // Splices `insert` into `array` at index `at`.
	  var splice = function(array, insert, at) {
	    at = Math.min(Math.max(at, 0), array.length);
	    var tail = Array(array.length - at);
	    var length = insert.length;
	    var i;
	    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
	    for (i = 0; i < length; i++) array[i + at] = insert[i];
	    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	  };

	  // Define the Collection's inheritable methods.
	  _.extend(Collection.prototype, Events, {

	    // The default model for a collection is just a **Backbone.Model**.
	    // This should be overridden in most cases.
	    model: Model,

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // The JSON representation of a Collection is an array of the
	    // models' attributes.
	    toJSON: function(options) {
	      return this.map(function(model) { return model.toJSON(options); });
	    },

	    // Proxy `Backbone.sync` by default.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Add a model, or list of models to the set. `models` may be Backbone
	    // Models or raw JavaScript objects to be converted to Models, or any
	    // combination of the two.
	    add: function(models, options) {
	      return this.set(models, _.extend({merge: false}, options, addOptions));
	    },

	    // Remove a model, or a list of models from the set.
	    remove: function(models, options) {
	      options = _.extend({}, options);
	      var singular = !_.isArray(models);
	      models = singular ? [models] : models.slice();
	      var removed = this._removeModels(models, options);
	      if (!options.silent && removed.length) {
	        options.changes = {added: [], merged: [], removed: removed};
	        this.trigger('update', this, options);
	      }
	      return singular ? removed[0] : removed;
	    },

	    // Update a collection by `set`-ing a new list of models, adding new ones,
	    // removing models that are no longer present, and merging models that
	    // already exist in the collection, as necessary. Similar to **Model#set**,
	    // the core operation for updating the data contained by the collection.
	    set: function(models, options) {
	      if (models == null) return;

	      options = _.extend({}, setOptions, options);
	      if (options.parse && !this._isModel(models)) {
	        models = this.parse(models, options) || [];
	      }

	      var singular = !_.isArray(models);
	      models = singular ? [models] : models.slice();

	      var at = options.at;
	      if (at != null) at = +at;
	      if (at > this.length) at = this.length;
	      if (at < 0) at += this.length + 1;

	      var set = [];
	      var toAdd = [];
	      var toMerge = [];
	      var toRemove = [];
	      var modelMap = {};

	      var add = options.add;
	      var merge = options.merge;
	      var remove = options.remove;

	      var sort = false;
	      var sortable = this.comparator && at == null && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      var model, i;
	      for (i = 0; i < models.length; i++) {
	        model = models[i];

	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        var existing = this.get(model);
	        if (existing) {
	          if (merge && model !== existing) {
	            var attrs = this._isModel(model) ? model.attributes : model;
	            if (options.parse) attrs = existing.parse(attrs, options);
	            existing.set(attrs, options);
	            toMerge.push(existing);
	            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
	          }
	          if (!modelMap[existing.cid]) {
	            modelMap[existing.cid] = true;
	            set.push(existing);
	          }
	          models[i] = existing;

	        // If this is a new, valid model, push it to the `toAdd` list.
	        } else if (add) {
	          model = models[i] = this._prepareModel(model, options);
	          if (model) {
	            toAdd.push(model);
	            this._addReference(model, options);
	            modelMap[model.cid] = true;
	            set.push(model);
	          }
	        }
	      }

	      // Remove stale models.
	      if (remove) {
	        for (i = 0; i < this.length; i++) {
	          model = this.models[i];
	          if (!modelMap[model.cid]) toRemove.push(model);
	        }
	        if (toRemove.length) this._removeModels(toRemove, options);
	      }

	      // See if sorting is needed, update `length` and splice in new models.
	      var orderChanged = false;
	      var replace = !sortable && add && remove;
	      if (set.length && replace) {
	        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
	          return m !== set[index];
	        });
	        this.models.length = 0;
	        splice(this.models, set, 0);
	        this.length = this.models.length;
	      } else if (toAdd.length) {
	        if (sortable) sort = true;
	        splice(this.models, toAdd, at == null ? this.length : at);
	        this.length = this.models.length;
	      }

	      // Silently sort the collection if appropriate.
	      if (sort) this.sort({silent: true});

	      // Unless silenced, it's time to fire all appropriate add/sort/update events.
	      if (!options.silent) {
	        for (i = 0; i < toAdd.length; i++) {
	          if (at != null) options.index = at + i;
	          model = toAdd[i];
	          model.trigger('add', model, this, options);
	        }
	        if (sort || orderChanged) this.trigger('sort', this, options);
	        if (toAdd.length || toRemove.length || toMerge.length) {
	          options.changes = {
	            added: toAdd,
	            removed: toRemove,
	            merged: toMerge
	          };
	          this.trigger('update', this, options);
	        }
	      }

	      // Return the added (or merged) model (or models).
	      return singular ? models[0] : models;
	    },

	    // When you have more items than you want to add or remove individually,
	    // you can reset the entire set with a new list of models, without firing
	    // any granular `add` or `remove` events. Fires `reset` when finished.
	    // Useful for bulk operations and optimizations.
	    reset: function(models, options) {
	      options = options ? _.clone(options) : {};
	      for (var i = 0; i < this.models.length; i++) {
	        this._removeReference(this.models[i], options);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      models = this.add(models, _.extend({silent: true}, options));
	      if (!options.silent) this.trigger('reset', this, options);
	      return models;
	    },

	    // Add a model to the end of the collection.
	    push: function(model, options) {
	      return this.add(model, _.extend({at: this.length}, options));
	    },

	    // Remove a model from the end of the collection.
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      return this.remove(model, options);
	    },

	    // Add a model to the beginning of the collection.
	    unshift: function(model, options) {
	      return this.add(model, _.extend({at: 0}, options));
	    },

	    // Remove a model from the beginning of the collection.
	    shift: function(options) {
	      var model = this.at(0);
	      return this.remove(model, options);
	    },

	    // Slice out a sub-array of models from the collection.
	    slice: function() {
	      return slice.apply(this.models, arguments);
	    },

	    // Get a model from the set by id, cid, model object with id or cid
	    // properties, or an attributes object that is transformed through modelId.
	    get: function(obj) {
	      if (obj == null) return void 0;
	      return this._byId[obj] ||
	        this._byId[this.modelId(obj.attributes || obj)] ||
	        obj.cid && this._byId[obj.cid];
	    },

	    // Returns `true` if the model is in the collection.
	    has: function(obj) {
	      return this.get(obj) != null;
	    },

	    // Get the model at the given index.
	    at: function(index) {
	      if (index < 0) index += this.length;
	      return this.models[index];
	    },

	    // Return models with matching attributes. Useful for simple cases of
	    // `filter`.
	    where: function(attrs, first) {
	      return this[first ? 'find' : 'filter'](attrs);
	    },

	    // Return the first model with matching attributes. Useful for simple cases
	    // of `find`.
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },

	    // Force the collection to re-sort itself. You don't need to call this under
	    // normal circumstances, as the set will maintain sort order as each item
	    // is added.
	    sort: function(options) {
	      var comparator = this.comparator;
	      if (!comparator) throw new Error('Cannot sort a set without a comparator');
	      options || (options = {});

	      var length = comparator.length;
	      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

	      // Run sort based on type of `comparator`.
	      if (length === 1 || _.isString(comparator)) {
	        this.models = this.sortBy(comparator);
	      } else {
	        this.models.sort(comparator);
	      }
	      if (!options.silent) this.trigger('sort', this, options);
	      return this;
	    },

	    // Pluck an attribute from each model in the collection.
	    pluck: function(attr) {
	      return this.map(attr + '');
	    },

	    // Fetch the default set of models for this collection, resetting the
	    // collection when they arrive. If `reset: true` is passed, the response
	    // data will be passed through the `reset` method instead of `set`.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	        var method = options.reset ? 'reset' : 'set';
	        collection[method](resp, options);
	        if (success) success.call(options.context, collection, resp, options);
	        collection.trigger('sync', collection, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Create a new instance of a model in this collection. Add the model to the
	    // collection immediately, unless `wait: true` is passed, in which case we
	    // wait for the server to agree.
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      var wait = options.wait;
	      model = this._prepareModel(model, options);
	      if (!model) return false;
	      if (!wait) this.add(model, options);
	      var collection = this;
	      var success = options.success;
	      options.success = function(m, resp, callbackOpts) {
	        if (wait) collection.add(m, callbackOpts);
	        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
	      };
	      model.save(null, options);
	      return model;
	    },

	    // **parse** converts a response into a list of models to be added to the
	    // collection. The default implementation is just to pass it through.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new collection with an identical list of models as this one.
	    clone: function() {
	      return new this.constructor(this.models, {
	        model: this.model,
	        comparator: this.comparator
	      });
	    },

	    // Define how to uniquely identify models in the collection.
	    modelId: function(attrs) {
	      return attrs[this.model.prototype.idAttribute || 'id'];
	    },

	    // Private method to reset all internal state. Called when the collection
	    // is first initialized or reset.
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },

	    // Prepare a hash of attributes (or other model) to be added to this
	    // collection.
	    _prepareModel: function(attrs, options) {
	      if (this._isModel(attrs)) {
	        if (!attrs.collection) attrs.collection = this;
	        return attrs;
	      }
	      options = options ? _.clone(options) : {};
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model.validationError) return model;
	      this.trigger('invalid', this, model.validationError, options);
	      return false;
	    },

	    // Internal method called by both remove and set.
	    _removeModels: function(models, options) {
	      var removed = [];
	      for (var i = 0; i < models.length; i++) {
	        var model = this.get(models[i]);
	        if (!model) continue;

	        var index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;

	        // Remove references before triggering 'remove' event to prevent an
	        // infinite loop. #3693
	        delete this._byId[model.cid];
	        var id = this.modelId(model.attributes);
	        if (id != null) delete this._byId[id];

	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }

	        removed.push(model);
	        this._removeReference(model, options);
	      }
	      return removed;
	    },

	    // Method for checking whether an object should be considered a model for
	    // the purposes of adding to the collection.
	    _isModel: function(model) {
	      return model instanceof Model;
	    },

	    // Internal method to create a model's ties to a collection.
	    _addReference: function(model, options) {
	      this._byId[model.cid] = model;
	      var id = this.modelId(model.attributes);
	      if (id != null) this._byId[id] = model;
	      model.on('all', this._onModelEvent, this);
	    },

	    // Internal method to sever a model's ties to a collection.
	    _removeReference: function(model, options) {
	      delete this._byId[model.cid];
	      var id = this.modelId(model.attributes);
	      if (id != null) delete this._byId[id];
	      if (this === model.collection) delete model.collection;
	      model.off('all', this._onModelEvent, this);
	    },

	    // Internal method called every time a model in the set fires an event.
	    // Sets need to update their indexes when models change ids. All other
	    // events simply proxy through. "add" and "remove" events that originate
	    // in other collections are ignored.
	    _onModelEvent: function(event, model, collection, options) {
	      if (model) {
	        if ((event === 'add' || event === 'remove') && collection !== this) return;
	        if (event === 'destroy') this.remove(model, options);
	        if (event === 'change') {
	          var prevId = this.modelId(model.previousAttributes());
	          var id = this.modelId(model.attributes);
	          if (prevId !== id) {
	            if (prevId != null) delete this._byId[prevId];
	            if (id != null) this._byId[id] = model;
	          }
	        }
	      }
	      this.trigger.apply(this, arguments);
	    }

	  });

	  // Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
	      foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
	      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
	      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
	      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
	      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
	      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
	      sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};

	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  addUnderscoreMethods(Collection, collectionMethods, 'models');

	  // Backbone.View
	  // -------------

	  // Backbone Views are almost more convention than they are actual code. A View
	  // is simply a JavaScript object that represents a logical chunk of UI in the
	  // DOM. This might be a single item, an entire list, a sidebar or panel, or
	  // even the surrounding frame which wraps your whole app. Defining a chunk of
	  // UI as a **View** allows you to define your DOM events declaratively, without
	  // having to worry about render order ... and makes it easy for the view to
	  // react to specific changes in the state of your models.

	  // Creating a Backbone.View creates its initial element outside of the DOM,
	  // if an existing element is not provided...
	  var View = Backbone.View = function(options) {
	    this.cid = _.uniqueId('view');
	    _.extend(this, _.pick(options, viewOptions));
	    this._ensureElement();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regex to split keys for `delegate`.
	  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	  // List of view options to be set as properties.
	  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

	  // Set up all inheritable **Backbone.View** properties and methods.
	  _.extend(View.prototype, Events, {

	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',

	    // jQuery delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be preferred to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },

	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this._removeElement();
	      this.stopListening();
	      return this;
	    },

	    // Remove this view's element from the document and all event listeners
	    // attached to it. Exposed for subclasses using an alternative DOM
	    // manipulation API.
	    _removeElement: function() {
	      this.$el.remove();
	    },

	    // Change the view's element (`this.el` property) and re-delegate the
	    // view's events on the new element.
	    setElement: function(element) {
	      this.undelegateEvents();
	      this._setElement(element);
	      this.delegateEvents();
	      return this;
	    },

	    // Creates the `this.el` and `this.$el` references for this view using the
	    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
	    // context or an element. Subclasses can override this to utilize an
	    // alternative DOM manipulation API and are only required to set the
	    // `this.el` property.
	    _setElement: function(el) {
	      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
	      this.el = this.$el[0];
	    },

	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save',
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    delegateEvents: function(events) {
	      events || (events = _.result(this, 'events'));
	      if (!events) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!_.isFunction(method)) method = this[method];
	        if (!method) continue;
	        var match = key.match(delegateEventSplitter);
	        this.delegate(match[1], match[2], _.bind(method, this));
	      }
	      return this;
	    },

	    // Add a single event listener to the view's element (or a child element
	    // using `selector`). This only works for delegate-able events: not `focus`,
	    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
	    delegate: function(eventName, selector, listener) {
	      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },

	    // Clears all callbacks previously bound to the view by `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
	      return this;
	    },

	    // A finer-grained `undelegateEvents` for removing a single delegated event.
	    // `selector` and `listener` are both optional.
	    undelegate: function(eventName, selector, listener) {
	      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },

	    // Produces a DOM element to be assigned to your view. Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _createElement: function(tagName) {
	      return document.createElement(tagName);
	    },

	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = _.extend({}, _.result(this, 'attributes'));
	        if (this.id) attrs.id = _.result(this, 'id');
	        if (this.className) attrs['class'] = _.result(this, 'className');
	        this.setElement(this._createElement(_.result(this, 'tagName')));
	        this._setAttributes(attrs);
	      } else {
	        this.setElement(_.result(this, 'el'));
	      }
	    },

	    // Set attributes from a hash on this view's element.  Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _setAttributes: function(attributes) {
	      this.$el.attr(attributes);
	    }

	  });

	  // Backbone.sync
	  // -------------

	  // Override this function to change the manner in which Backbone persists
	  // models to the server. You will be passed the type of request, and the
	  // model in question. By default, makes a RESTful Ajax request
	  // to the model's `url()`. Some possible customizations could be:
	  //
	  // * Use `setTimeout` to batch rapid-fire updates into a single request.
	  // * Send up the models as XML instead of JSON.
	  // * Persist models via WebSockets instead of Ajax.
	  //
	  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	  // as `POST`, with a `_method` parameter containing the true HTTP method,
	  // as well as all requests with the body as `application/x-www-form-urlencoded`
	  // instead of `application/json` with the model in a param named `model`.
	  // Useful when interfacing with server-side languages like **PHP** that make
	  // it difficult to read the body of `PUT` requests.
	  Backbone.sync = function(method, model, options) {
	    var type = methodMap[method];

	    // Default options, unless specified.
	    _.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });

	    // Default JSON-request options.
	    var params = {type: type, dataType: 'json'};

	    // Ensure that we have a URL.
	    if (!options.url) {
	      params.url = _.result(model, 'url') || urlError();
	    }

	    // Ensure that we have the appropriate request data.
	    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	    }

	    // For older servers, emulate JSON by encoding the request into an HTML-form.
	    if (options.emulateJSON) {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? {model: params.data} : {};
	    }

	    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	    // And an `X-HTTP-Method-Override` header.
	    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
	      params.type = 'POST';
	      if (options.emulateJSON) params.data._method = type;
	      var beforeSend = options.beforeSend;
	      options.beforeSend = function(xhr) {
	        xhr.setRequestHeader('X-HTTP-Method-Override', type);
	        if (beforeSend) return beforeSend.apply(this, arguments);
	      };
	    }

	    // Don't process data on a non-GET request.
	    if (params.type !== 'GET' && !options.emulateJSON) {
	      params.processData = false;
	    }

	    // Pass along `textStatus` and `errorThrown` from jQuery.
	    var error = options.error;
	    options.error = function(xhr, textStatus, errorThrown) {
	      options.textStatus = textStatus;
	      options.errorThrown = errorThrown;
	      if (error) error.call(options.context, xhr, textStatus, errorThrown);
	    };

	    // Make the request, allowing the user to override any Ajax options.
	    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
	    model.trigger('request', model, xhr, options);
	    return xhr;
	  };

	  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	  var methodMap = {
	    'create': 'POST',
	    'update': 'PUT',
	    'patch': 'PATCH',
	    'delete': 'DELETE',
	    'read': 'GET'
	  };

	  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	  // Override this if you'd like to use a different library.
	  Backbone.ajax = function() {
	    return Backbone.$.ajax.apply(Backbone.$, arguments);
	  };

	  // Backbone.Router
	  // ---------------

	  // Routers map faux-URLs to actions, and fire events when routes are
	  // matched. Creating a new one sets its `routes` hash, if not set statically.
	  var Router = Backbone.Router = function(options) {
	    options || (options = {});
	    if (options.routes) this.routes = options.routes;
	    this._bindRoutes();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regular expressions for matching named param parts and splatted
	  // parts of route strings.
	  var optionalParam = /\((.*?)\)/g;
	  var namedParam    = /(\(\?)?:\w+/g;
	  var splatParam    = /\*\w+/g;
	  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

	  // Set up all inheritable **Backbone.Router** properties and methods.
	  _.extend(Router.prototype, Events, {

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Manually bind a single named route to a callback. For example:
	    //
	    //     this.route('search/:query/p:num', 'search', function(query, num) {
	    //       ...
	    //     });
	    //
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) callback = this[name];
	      var router = this;
	      Backbone.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        if (router.execute(callback, args, name) !== false) {
	          router.trigger.apply(router, ['route:' + name].concat(args));
	          router.trigger('route', name, args);
	          Backbone.history.trigger('route', router, name, args);
	        }
	      });
	      return this;
	    },

	    // Execute a route handler with the provided parameters.  This is an
	    // excellent place to do pre-route setup or post-route cleanup.
	    execute: function(callback, args, name) {
	      if (callback) callback.apply(this, args);
	    },

	    // Simple proxy to `Backbone.history` to save a fragment into the history.
	    navigate: function(fragment, options) {
	      Backbone.history.navigate(fragment, options);
	      return this;
	    },

	    // Bind all defined routes to `Backbone.history`. We have to reverse the
	    // order of the routes here to support behavior where the most general
	    // routes can be defined at the bottom of the route map.
	    _bindRoutes: function() {
	      if (!this.routes) return;
	      this.routes = _.result(this, 'routes');
	      var route, routes = _.keys(this.routes);
	      while ((route = routes.pop()) != null) {
	        this.route(route, this.routes[route]);
	      }
	    },

	    // Convert a route string into a regular expression, suitable for matching
	    // against the current location hash.
	    _routeToRegExp: function(route) {
	      route = route.replace(escapeRegExp, '\\$&')
	                   .replace(optionalParam, '(?:$1)?')
	                   .replace(namedParam, function(match, optional) {
	                     return optional ? match : '([^/?]+)';
	                   })
	                   .replace(splatParam, '([^?]*?)');
	      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
	    },

	    // Given a route, and a URL fragment that it matches, return the array of
	    // extracted decoded parameters. Empty or unmatched parameters will be
	    // treated as `null` to normalize cross-browser behavior.
	    _extractParameters: function(route, fragment) {
	      var params = route.exec(fragment).slice(1);
	      return _.map(params, function(param, i) {
	        // Don't decode the search params.
	        if (i === params.length - 1) return param || null;
	        return param ? decodeURIComponent(param) : null;
	      });
	    }

	  });

	  // Backbone.History
	  // ----------------

	  // Handles cross-browser history management, based on either
	  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	  // and URL fragments. If the browser supports neither (old IE, natch),
	  // falls back to polling.
	  var History = Backbone.History = function() {
	    this.handlers = [];
	    this.checkUrl = _.bind(this.checkUrl, this);

	    // Ensure that `History` can be used outside of the browser.
	    if (typeof window !== 'undefined') {
	      this.location = window.location;
	      this.history = window.history;
	    }
	  };

	  // Cached regex for stripping a leading hash/slash and trailing space.
	  var routeStripper = /^[#\/]|\s+$/g;

	  // Cached regex for stripping leading and trailing slashes.
	  var rootStripper = /^\/+|\/+$/g;

	  // Cached regex for stripping urls of hash.
	  var pathStripper = /#.*$/;

	  // Has the history handling already been started?
	  History.started = false;

	  // Set up all inheritable **Backbone.History** properties and methods.
	  _.extend(History.prototype, Events, {

	    // The default interval to poll for hash changes, if necessary, is
	    // twenty times a second.
	    interval: 50,

	    // Are we at the app root?
	    atRoot: function() {
	      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
	      return path === this.root && !this.getSearch();
	    },

	    // Does the pathname match the root?
	    matchRoot: function() {
	      var path = this.decodeFragment(this.location.pathname);
	      var rootPath = path.slice(0, this.root.length - 1) + '/';
	      return rootPath === this.root;
	    },

	    // Unicode characters in `location.pathname` are percent encoded so they're
	    // decoded for comparison. `%25` should not be decoded since it may be part
	    // of an encoded parameter.
	    decodeFragment: function(fragment) {
	      return decodeURI(fragment.replace(/%25/g, '%2525'));
	    },

	    // In IE6, the hash fragment and search params are incorrect if the
	    // fragment contains `?`.
	    getSearch: function() {
	      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
	      return match ? match[0] : '';
	    },

	    // Gets the true hash value. Cannot use location.hash directly due to bug
	    // in Firefox where location.hash will always be decoded.
	    getHash: function(window) {
	      var match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	    },

	    // Get the pathname and search params, without the root.
	    getPath: function() {
	      var path = this.decodeFragment(
	        this.location.pathname + this.getSearch()
	      ).slice(this.root.length - 1);
	      return path.charAt(0) === '/' ? path.slice(1) : path;
	    },

	    // Get the cross-browser normalized URL fragment from the path or hash.
	    getFragment: function(fragment) {
	      if (fragment == null) {
	        if (this._usePushState || !this._wantsHashChange) {
	          fragment = this.getPath();
	        } else {
	          fragment = this.getHash();
	        }
	      }
	      return fragment.replace(routeStripper, '');
	    },

	    // Start the hash change handling, returning `true` if the current URL matches
	    // an existing route, and `false` otherwise.
	    start: function(options) {
	      if (History.started) throw new Error('Backbone.history has already been started');
	      History.started = true;

	      // Figure out the initial configuration. Do we need an iframe?
	      // Is pushState desired ... is it available?
	      this.options          = _.extend({root: '/'}, this.options, options);
	      this.root             = this.options.root;
	      this._wantsHashChange = this.options.hashChange !== false;
	      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
	      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
	      this._wantsPushState  = !!this.options.pushState;
	      this._hasPushState    = !!(this.history && this.history.pushState);
	      this._usePushState    = this._wantsPushState && this._hasPushState;
	      this.fragment         = this.getFragment();

	      // Normalize root to always include a leading and trailing slash.
	      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

	      // Transition from hashChange to pushState or vice versa if both are
	      // requested.
	      if (this._wantsHashChange && this._wantsPushState) {

	        // If we've started off with a route from a `pushState`-enabled
	        // browser, but we're currently in a browser that doesn't support it...
	        if (!this._hasPushState && !this.atRoot()) {
	          var rootPath = this.root.slice(0, -1) || '/';
	          this.location.replace(rootPath + '#' + this.getPath());
	          // Return immediately as browser will do redirect to new url
	          return true;

	        // Or if we've started out with a hash-based route, but we're currently
	        // in a browser where it could be `pushState`-based instead...
	        } else if (this._hasPushState && this.atRoot()) {
	          this.navigate(this.getHash(), {replace: true});
	        }

	      }

	      // Proxy an iframe to handle location events if the browser doesn't
	      // support the `hashchange` event, HTML5 history, or the user wants
	      // `hashChange` but not `pushState`.
	      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
	        this.iframe = document.createElement('iframe');
	        this.iframe.src = 'javascript:0';
	        this.iframe.style.display = 'none';
	        this.iframe.tabIndex = -1;
	        var body = document.body;
	        // Using `appendChild` will throw on IE < 9 if the document is not ready.
	        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
	        iWindow.document.open();
	        iWindow.document.close();
	        iWindow.location.hash = '#' + this.fragment;
	      }

	      // Add a cross-platform `addEventListener` shim for older browsers.
	      var addEventListener = window.addEventListener || function(eventName, listener) {
	        return attachEvent('on' + eventName, listener);
	      };

	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._usePushState) {
	        addEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        addEventListener('hashchange', this.checkUrl, false);
	      } else if (this._wantsHashChange) {
	        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }

	      if (!this.options.silent) return this.loadUrl();
	    },

	    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
	    // but possibly useful for unit testing Routers.
	    stop: function() {
	      // Add a cross-platform `removeEventListener` shim for older browsers.
	      var removeEventListener = window.removeEventListener || function(eventName, listener) {
	        return detachEvent('on' + eventName, listener);
	      };

	      // Remove window listeners.
	      if (this._usePushState) {
	        removeEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        removeEventListener('hashchange', this.checkUrl, false);
	      }

	      // Clean up the iframe if necessary.
	      if (this.iframe) {
	        document.body.removeChild(this.iframe);
	        this.iframe = null;
	      }

	      // Some environments will throw when clearing an undefined interval.
	      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
	      History.started = false;
	    },

	    // Add a route to be tested when the fragment changes. Routes added later
	    // may override previous routes.
	    route: function(route, callback) {
	      this.handlers.unshift({route: route, callback: callback});
	    },

	    // Checks the current URL to see if it has changed, and if it has,
	    // calls `loadUrl`, normalizing across the hidden iframe.
	    checkUrl: function(e) {
	      var current = this.getFragment();

	      // If the user pressed the back button, the iframe's hash will have
	      // changed and we should use that for comparison.
	      if (current === this.fragment && this.iframe) {
	        current = this.getHash(this.iframe.contentWindow);
	      }

	      if (current === this.fragment) return false;
	      if (this.iframe) this.navigate(current);
	      this.loadUrl();
	    },

	    // Attempt to load the current URL fragment. If a route succeeds with a
	    // match, returns `true`. If no defined routes matches the fragment,
	    // returns `false`.
	    loadUrl: function(fragment) {
	      // If the root doesn't match, no routes can match either.
	      if (!this.matchRoot()) return false;
	      fragment = this.fragment = this.getFragment(fragment);
	      return _.some(this.handlers, function(handler) {
	        if (handler.route.test(fragment)) {
	          handler.callback(fragment);
	          return true;
	        }
	      });
	    },

	    // Save a fragment into the hash history, or replace the URL state if the
	    // 'replace' option is passed. You are responsible for properly URL-encoding
	    // the fragment in advance.
	    //
	    // The options object can contain `trigger: true` if you wish to have the
	    // route callback be fired (not usually desirable), or `replace: true`, if
	    // you wish to modify the current URL without adding an entry to the history.
	    navigate: function(fragment, options) {
	      if (!History.started) return false;
	      if (!options || options === true) options = {trigger: !!options};

	      // Normalize the fragment.
	      fragment = this.getFragment(fragment || '');

	      // Don't include a trailing slash on the root.
	      var rootPath = this.root;
	      if (fragment === '' || fragment.charAt(0) === '?') {
	        rootPath = rootPath.slice(0, -1) || '/';
	      }
	      var url = rootPath + fragment;

	      // Strip the hash and decode for matching.
	      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

	      if (this.fragment === fragment) return;
	      this.fragment = fragment;

	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._usePushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

	      // If hash changes haven't been explicitly disabled, update the hash
	      // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
	          var iWindow = this.iframe.contentWindow;

	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if (!options.replace) {
	            iWindow.document.open();
	            iWindow.document.close();
	          }

	          this._updateHash(iWindow.location, fragment, options.replace);
	        }

	      // If you've told us that you explicitly don't want fallback hashchange-
	      // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) return this.loadUrl(fragment);
	    },

	    // Update the hash location, either replacing the current entry, or adding
	    // a new one to the browser history.
	    _updateHash: function(location, fragment, replace) {
	      if (replace) {
	        var href = location.href.replace(/(javascript:|#).*$/, '');
	        location.replace(href + '#' + fragment);
	      } else {
	        // Some browsers require that `hash` contains a leading #.
	        location.hash = '#' + fragment;
	      }
	    }

	  });

	  // Create the default Backbone.history.
	  Backbone.history = new History;

	  // Helpers
	  // -------

	  // Helper function to correctly set up the prototype chain for subclasses.
	  // Similar to `goog.inherits`, but uses a hash of prototype properties and
	  // class properties to be extended.
	  var extend = function(protoProps, staticProps) {
	    var parent = this;
	    var child;

	    // The constructor function for the new subclass is either defined by you
	    // (the "constructor" property in your `extend` definition), or defaulted
	    // by us to simply call the parent constructor.
	    if (protoProps && _.has(protoProps, 'constructor')) {
	      child = protoProps.constructor;
	    } else {
	      child = function(){ return parent.apply(this, arguments); };
	    }

	    // Add static properties to the constructor function, if supplied.
	    _.extend(child, parent, staticProps);

	    // Set the prototype chain to inherit from `parent`, without calling
	    // `parent`'s constructor function and add the prototype properties.
	    child.prototype = _.create(parent.prototype, protoProps);
	    child.prototype.constructor = child;

	    // Set a convenience property in case the parent's prototype is needed
	    // later.
	    child.__super__ = parent.prototype;

	    return child;
	  };

	  // Set up inheritance for the model, collection, router, view and history.
	  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function() {
	    throw new Error('A "url" property or function must be specified');
	  };

	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function(model, options) {
	    var error = options.error;
	    options.error = function(resp) {
	      if (error) error.call(options.context, model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };

	  return Backbone;
	});

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.2.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2017-03-20T18:59Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};



		function DOMEval( code, doc ) {
			doc = doc || document;

			var script = doc.createElement( "script" );

			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.2.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( ">tbody", elem )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;

		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;

		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with computed style
		var valueIsBorderBox,
			styles = getStyles( elem ),
			val = curCSS( elem, name, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Fall back to offsetWidth/Height when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		if ( val === "auto" ) {
			val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
		}

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var doc, docElem, rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			doc = elem.ownerDocument;
			docElem = doc.documentElement;
			win = doc.defaultView;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( jQuery.isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v3.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */(function (global, factory) {
	     true ? factory(exports, __webpack_require__(22), __webpack_require__(3), __webpack_require__(92), __webpack_require__(6), __webpack_require__(93), __webpack_require__(28), __webpack_require__(99), __webpack_require__(101), __webpack_require__(102), __webpack_require__(57), __webpack_require__(100), __webpack_require__(104), __webpack_require__(7), __webpack_require__(37), __webpack_require__(105), __webpack_require__(103), __webpack_require__(63), __webpack_require__(107), __webpack_require__(106), __webpack_require__(21), __webpack_require__(55)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/first', 'rxjs/operator/map', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/operator/mergeAll', '@angular/platform-browser', 'rxjs/operator/filter'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.platformBrowser,global.Rx.Observable.prototype));
	}(this, function (exports,_angular_common,_angular_core,rxjs_BehaviorSubject,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_first,rxjs_operator_map,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_operator_mergeAll,_angular_platformBrowser,rxjs_operator_filter) { 'use strict';

	    var /** @type {?} */ isPromise = _angular_core.__core_private__.isPromise;
	    var /** @type {?} */ isObservable = _angular_core.__core_private__.isObservable;

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @whatItDoes Name of the primary outlet.
	     *
	     * @stable
	     */
	    var /** @type {?} */ PRIMARY_OUTLET = 'primary';
	    var NavigationCancelingError = (function (_super) {
	        __extends(NavigationCancelingError, _super);
	        /**
	         * @param {?} message
	         */
	        function NavigationCancelingError(message) {
	            _super.call(this, message);
	            this.message = message;
	            this.stack = (new Error(message)).stack;
	        }
	        /**
	         * @return {?}
	         */
	        NavigationCancelingError.prototype.toString = function () { return this.message; };
	        return NavigationCancelingError;
	    }(Error));
	    /**
	     * @param {?} segments
	     * @param {?} segmentGroup
	     * @param {?} route
	     * @return {?}
	     */
	    function defaultUrlMatcher(segments, segmentGroup, route) {
	        var /** @type {?} */ path = route.path;
	        var /** @type {?} */ parts = path.split('/');
	        var /** @type {?} */ posParams = {};
	        var /** @type {?} */ consumed = [];
	        var /** @type {?} */ currentIndex = 0;
	        for (var /** @type {?} */ i = 0; i < parts.length; ++i) {
	            if (currentIndex >= segments.length)
	                return null;
	            var /** @type {?} */ current = segments[currentIndex];
	            var /** @type {?} */ p = parts[i];
	            var /** @type {?} */ isPosParam = p.startsWith(':');
	            if (!isPosParam && p !== current.path)
	                return null;
	            if (isPosParam) {
	                posParams[p.substring(1)] = current;
	            }
	            consumed.push(current);
	            currentIndex++;
	        }
	        if (route.pathMatch === 'full' &&
	            (segmentGroup.hasChildren() || currentIndex < segments.length)) {
	            return null;
	        }
	        else {
	            return { consumed: consumed, posParams: posParams };
	        }
	    }

	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function shallowEqualArrays(a, b) {
	        if (a.length !== b.length)
	            return false;
	        for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	            if (!shallowEqual(a[i], b[i]))
	                return false;
	        }
	        return true;
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function shallowEqual(a, b) {
	        var /** @type {?} */ k1 = Object.keys(a);
	        var /** @type {?} */ k2 = Object.keys(b);
	        if (k1.length != k2.length) {
	            return false;
	        }
	        var /** @type {?} */ key;
	        for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	            key = k1[i];
	            if (a[key] !== b[key]) {
	                return false;
	            }
	        }
	        return true;
	    }
	    /**
	     * @param {?} a
	     * @return {?}
	     */
	    function flatten(a) {
	        var /** @type {?} */ target = [];
	        for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	            for (var /** @type {?} */ j = 0; j < a[i].length; ++j) {
	                target.push(a[i][j]);
	            }
	        }
	        return target;
	    }
	    /**
	     * @param {?} a
	     * @return {?}
	     */
	    function last(a) {
	        return a.length > 0 ? a[a.length - 1] : null;
	    }
	    /**
	     * @param {?} m1
	     * @param {?} m2
	     * @return {?}
	     */
	    function merge(m1, m2) {
	        var /** @type {?} */ m = {};
	        for (var attr in m1) {
	            if (m1.hasOwnProperty(attr)) {
	                m[attr] = m1[attr];
	            }
	        }
	        for (var attr in m2) {
	            if (m2.hasOwnProperty(attr)) {
	                m[attr] = m2[attr];
	            }
	        }
	        return m;
	    }
	    /**
	     * @param {?} map
	     * @param {?} callback
	     * @return {?}
	     */
	    function forEach(map, callback) {
	        for (var prop in map) {
	            if (map.hasOwnProperty(prop)) {
	                callback(map[prop], prop);
	            }
	        }
	    }
	    /**
	     * @param {?} obj
	     * @param {?} fn
	     * @return {?}
	     */
	    function waitForMap(obj, fn) {
	        var /** @type {?} */ waitFor = [];
	        var /** @type {?} */ res = {};
	        forEach(obj, function (a, k) {
	            if (k === PRIMARY_OUTLET) {
	                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {
	                    res[k] = _;
	                    return _;
	                }));
	            }
	        });
	        forEach(obj, function (a, k) {
	            if (k !== PRIMARY_OUTLET) {
	                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {
	                    res[k] = _;
	                    return _;
	                }));
	            }
	        });
	        if (waitFor.length > 0) {
	            var /** @type {?} */ concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));
	            var /** @type {?} */ last$ = l.last.call(concatted$);
	            return rxjs_operator_map.map.call(last$, function () { return res; });
	        }
	        return rxjs_observable_of.of(res);
	    }
	    /**
	     * @param {?} observables
	     * @return {?}
	     */
	    function andObservables(observables) {
	        var /** @type {?} */ merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);
	        return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function wrapIntoObservable(value) {
	        if (isObservable(value)) {
	            return value;
	        }
	        if (isPromise(value)) {
	            return rxjs_observable_fromPromise.fromPromise(value);
	        }
	        return rxjs_observable_of.of(value);
	    }

	    /**
	     * @experimental
	     */
	    var /** @type {?} */ ROUTES = new _angular_core.OpaqueToken('ROUTES');
	    var LoadedRouterConfig = (function () {
	        /**
	         * @param {?} routes
	         * @param {?} injector
	         * @param {?} factoryResolver
	         * @param {?} injectorFactory
	         */
	        function LoadedRouterConfig(routes, injector, factoryResolver, injectorFactory) {
	            this.routes = routes;
	            this.injector = injector;
	            this.factoryResolver = factoryResolver;
	            this.injectorFactory = injectorFactory;
	        }
	        return LoadedRouterConfig;
	    }());
	    var RouterConfigLoader = (function () {
	        /**
	         * @param {?} loader
	         * @param {?} compiler
	         */
	        function RouterConfigLoader(loader, compiler) {
	            this.loader = loader;
	            this.compiler = compiler;
	        }
	        /**
	         * @param {?} parentInjector
	         * @param {?} loadChildren
	         * @return {?}
	         */
	        RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {
	            return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {
	                var /** @type {?} */ ref = r.create(parentInjector);
	                var /** @type {?} */ injectorFactory = function (parent) { return r.create(parent).injector; };
	                return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver, injectorFactory);
	            });
	        };
	        /**
	         * @param {?} loadChildren
	         * @return {?}
	         */
	        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {
	            var _this = this;
	            if (typeof loadChildren === 'string') {
	                return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));
	            }
	            else {
	                return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) {
	                    if (t instanceof _angular_core.NgModuleFactory) {
	                        return rxjs_observable_of.of(t);
	                    }
	                    else {
	                        return rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t));
	                    }
	                });
	            }
	        };
	        return RouterConfigLoader;
	    }());

	    /**
	     * @return {?}
	     */
	    function createEmptyUrlTree() {
	        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
	    }
	    /**
	     * @param {?} container
	     * @param {?} containee
	     * @param {?} exact
	     * @return {?}
	     */
	    function containsTree(container, containee, exact) {
	        if (exact) {
	            return equalQueryParams(container.queryParams, containee.queryParams) &&
	                equalSegmentGroups(container.root, containee.root);
	        }
	        return containsQueryParams(container.queryParams, containee.queryParams) &&
	            containsSegmentGroup(container.root, containee.root);
	    }
	    /**
	     * @param {?} container
	     * @param {?} containee
	     * @return {?}
	     */
	    function equalQueryParams(container, containee) {
	        return shallowEqual(container, containee);
	    }
	    /**
	     * @param {?} container
	     * @param {?} containee
	     * @return {?}
	     */
	    function equalSegmentGroups(container, containee) {
	        if (!equalPath(container.segments, containee.segments))
	            return false;
	        if (container.numberOfChildren !== containee.numberOfChildren)
	            return false;
	        for (var c in containee.children) {
	            if (!container.children[c])
	                return false;
	            if (!equalSegmentGroups(container.children[c], containee.children[c]))
	                return false;
	        }
	        return true;
	    }
	    /**
	     * @param {?} container
	     * @param {?} containee
	     * @return {?}
	     */
	    function containsQueryParams(container, containee) {
	        return Object.keys(containee).length <= Object.keys(container).length &&
	            Object.keys(containee).every(function (key) { return containee[key] === container[key]; });
	    }
	    /**
	     * @param {?} container
	     * @param {?} containee
	     * @return {?}
	     */
	    function containsSegmentGroup(container, containee) {
	        return containsSegmentGroupHelper(container, containee, containee.segments);
	    }
	    /**
	     * @param {?} container
	     * @param {?} containee
	     * @param {?} containeePaths
	     * @return {?}
	     */
	    function containsSegmentGroupHelper(container, containee, containeePaths) {
	        if (container.segments.length > containeePaths.length) {
	            var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);
	            if (!equalPath(current, containeePaths))
	                return false;
	            if (containee.hasChildren())
	                return false;
	            return true;
	        }
	        else if (container.segments.length === containeePaths.length) {
	            if (!equalPath(container.segments, containeePaths))
	                return false;
	            for (var c in containee.children) {
	                if (!container.children[c])
	                    return false;
	                if (!containsSegmentGroup(container.children[c], containee.children[c]))
	                    return false;
	            }
	            return true;
	        }
	        else {
	            var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);
	            var /** @type {?} */ next = containeePaths.slice(container.segments.length);
	            if (!equalPath(container.segments, current))
	                return false;
	            if (!container.children[PRIMARY_OUTLET])
	                return false;
	            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
	        }
	    }
	    /**
	     * \@whatItDoes Represents the parsed URL.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@Component({templateUrl:'template.html'})
	     * class MyComponent {
	     *   constructor(router: Router) {
	     *     const tree: UrlTree =
	     *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
	     *     const f = tree.fragment; // return 'fragment'
	     *     const q = tree.queryParams; // returns {debug: 'true'}
	     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
	     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
	     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
	     *     g.children['support'].segments; // return 1 segment 'help'
	     *   }
	     * }
	     * ```
	     *
	     * \@description
	     *
	     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
	     * serialized tree.
	     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
	     *
	     * \@stable
	     */
	    var UrlTree = (function () {
	        /**
	         * \@internal
	         * @param {?} root
	         * @param {?} queryParams
	         * @param {?} fragment
	         */
	        function UrlTree(root, queryParams, fragment) {
	            this.root = root;
	            this.queryParams = queryParams;
	            this.fragment = fragment;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };
	        return UrlTree;
	    }());
	    /**
	     * \@whatItDoes Represents the parsed URL segment group.
	     *
	     * See {\@link UrlTree} for more information.
	     *
	     * \@stable
	     */
	    var UrlSegmentGroup = (function () {
	        /**
	         * @param {?} segments
	         * @param {?} children
	         */
	        function UrlSegmentGroup(segments, children) {
	            var _this = this;
	            this.segments = segments;
	            this.children = children;
	            /** The parent node in the url tree */
	            this.parent = null;
	            forEach(children, function (v, k) { return v.parent = _this; });
	        }
	        /**
	         * Wether the segment has child segments
	         * @return {?}
	         */
	        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };
	        Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
	            /**
	             * Number of child segments
	             * @return {?}
	             */
	            get: function () { return Object.keys(this.children).length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };
	        return UrlSegmentGroup;
	    }());
	    /**
	     * \@whatItDoes Represents a single URL segment.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@Component({templateUrl:'template.html'})
	     * class MyComponent {
	     *   constructor(router: Router) {
	     *     const tree: UrlTree = router.parseUrl('/team;id=33');
	     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
	     *     const s: UrlSegment[] = g.segments;
	     *     s[0].path; // returns 'team'
	     *     s[0].parameters; // returns {id: 33}
	     *   }
	     * }
	     * ```
	     *
	     * \@description
	     *
	     * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
	     * parameters associated with the segment.
	     *
	     * \@stable
	     */
	    var UrlSegment = (function () {
	        /**
	         * @param {?} path
	         * @param {?} parameters
	         */
	        function UrlSegment(path, parameters) {
	            this.path = path;
	            this.parameters = parameters;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        UrlSegment.prototype.toString = function () { return serializePath(this); };
	        return UrlSegment;
	    }());
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function equalSegments(a, b) {
	        if (a.length !== b.length)
	            return false;
	        for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	            if (a[i].path !== b[i].path)
	                return false;
	            if (!shallowEqual(a[i].parameters, b[i].parameters))
	                return false;
	        }
	        return true;
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function equalPath(a, b) {
	        if (a.length !== b.length)
	            return false;
	        for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	            if (a[i].path !== b[i].path)
	                return false;
	        }
	        return true;
	    }
	    /**
	     * @param {?} segment
	     * @param {?} fn
	     * @return {?}
	     */
	    function mapChildrenIntoArray(segment, fn) {
	        var /** @type {?} */ res = [];
	        forEach(segment.children, function (child, childOutlet) {
	            if (childOutlet === PRIMARY_OUTLET) {
	                res = res.concat(fn(child, childOutlet));
	            }
	        });
	        forEach(segment.children, function (child, childOutlet) {
	            if (childOutlet !== PRIMARY_OUTLET) {
	                res = res.concat(fn(child, childOutlet));
	            }
	        });
	        return res;
	    }
	    /**
	     * \@whatItDoes Serializes and deserializes a URL string into a URL tree.
	     *
	     * \@description The url serialization strategy is customizable. You can
	     * make all URLs case insensitive by providing a custom UrlSerializer.
	     *
	     * See {\@link DefaultUrlSerializer} for an example of a URL serializer.
	     *
	     * \@stable
	     * @abstract
	     */
	    var UrlSerializer = (function () {
	        function UrlSerializer() {
	        }
	        /**
	         * Parse a url into a {\@link UrlTree}
	         * @abstract
	         * @param {?} url
	         * @return {?}
	         */
	        UrlSerializer.prototype.parse = function (url) { };
	        /**
	         * Converts a {\@link UrlTree} into a url
	         * @abstract
	         * @param {?} tree
	         * @return {?}
	         */
	        UrlSerializer.prototype.serialize = function (tree) { };
	        return UrlSerializer;
	    }());
	    /**
	     * \@whatItDoes A default implementation of the {\@link UrlSerializer}.
	     *
	     * \@description
	     *
	     * Example URLs:
	     *
	     * ```
	     * /inbox/33(popup:compose)
	     * /inbox/33;open=true/messages/44
	     * ```
	     *
	     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
	     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
	     * specify route specific parameters.
	     *
	     * \@stable
	     */
	    var DefaultUrlSerializer = (function () {
	        function DefaultUrlSerializer() {
	        }
	        /**
	         * Parses a url into a {\@link UrlTree}
	         * @param {?} url
	         * @return {?}
	         */
	        DefaultUrlSerializer.prototype.parse = function (url) {
	            var /** @type {?} */ p = new UrlParser(url);
	            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
	        };
	        /**
	         * Converts a {\@link UrlTree} into a url
	         * @param {?} tree
	         * @return {?}
	         */
	        DefaultUrlSerializer.prototype.serialize = function (tree) {
	            var /** @type {?} */ segment = "/" + serializeSegment(tree.root, true);
	            var /** @type {?} */ query = serializeQueryParams(tree.queryParams);
	            var /** @type {?} */ fragment = tree.fragment !== null && tree.fragment !== undefined ? "#" + encodeURI(tree.fragment) : '';
	            return "" + segment + query + fragment;
	        };
	        return DefaultUrlSerializer;
	    }());
	    /**
	     * @param {?} segment
	     * @return {?}
	     */
	    function serializePaths(segment) {
	        return segment.segments.map(function (p) { return serializePath(p); }).join('/');
	    }
	    /**
	     * @param {?} segment
	     * @param {?} root
	     * @return {?}
	     */
	    function serializeSegment(segment, root) {
	        if (segment.hasChildren() && root) {
	            var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?
	                serializeSegment(segment.children[PRIMARY_OUTLET], false) :
	                '';
	            var /** @type {?} */ children_1 = [];
	            forEach(segment.children, function (v, k) {
	                if (k !== PRIMARY_OUTLET) {
	                    children_1.push(k + ":" + serializeSegment(v, false));
	                }
	            });
	            if (children_1.length > 0) {
	                return primary + "(" + children_1.join('//') + ")";
	            }
	            else {
	                return "" + primary;
	            }
	        }
	        else if (segment.hasChildren() && !root) {
	            var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {
	                if (k === PRIMARY_OUTLET) {
	                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
	                }
	                else {
	                    return [(k + ":" + serializeSegment(v, false))];
	                }
	            });
	            return serializePaths(segment) + "/(" + children.join('//') + ")";
	        }
	        else {
	            return serializePaths(segment);
	        }
	    }
	    /**
	     * @param {?} s
	     * @return {?}
	     */
	    function encode(s) {
	        return encodeURIComponent(s);
	    }
	    /**
	     * @param {?} s
	     * @return {?}
	     */
	    function decode(s) {
	        return decodeURIComponent(s);
	    }
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    function serializePath(path) {
	        return "" + encode(path.path) + serializeParams(path.parameters);
	    }
	    /**
	     * @param {?} params
	     * @return {?}
	     */
	    function serializeParams(params) {
	        return pairs(params).map(function (p) { return (";" + encode(p.first) + "=" + encode(p.second)); }).join('');
	    }
	    /**
	     * @param {?} params
	     * @return {?}
	     */
	    function serializeQueryParams(params) {
	        var /** @type {?} */ strParams = Object.keys(params).map(function (name) {
	            var /** @type {?} */ value = params[name];
	            return Array.isArray(value) ? value.map(function (v) { return (encode(name) + "=" + encode(v)); }).join('&') :
	                encode(name) + "=" + encode(value);
	        });
	        return strParams.length ? "?" + strParams.join("&") : '';
	    }
	    var Pair = (function () {
	        /**
	         * @param {?} first
	         * @param {?} second
	         */
	        function Pair(first, second) {
	            this.first = first;
	            this.second = second;
	        }
	        return Pair;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function pairs(obj) {
	        var /** @type {?} */ res = [];
	        for (var prop in obj) {
	            if (obj.hasOwnProperty(prop)) {
	                res.push(new Pair(prop, obj[prop]));
	            }
	        }
	        return res;
	    }
	    var /** @type {?} */ SEGMENT_RE = /^[^\/()?;=&#]+/;
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function matchSegments(str) {
	        SEGMENT_RE.lastIndex = 0;
	        var /** @type {?} */ match = str.match(SEGMENT_RE);
	        return match ? match[0] : '';
	    }
	    var /** @type {?} */ QUERY_PARAM_RE = /^[^=?&#]+/;
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function matchQueryParams(str) {
	        QUERY_PARAM_RE.lastIndex = 0;
	        var /** @type {?} */ match = str.match(SEGMENT_RE);
	        return match ? match[0] : '';
	    }
	    var /** @type {?} */ QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    function matchUrlQueryParamValue(str) {
	        QUERY_PARAM_VALUE_RE.lastIndex = 0;
	        var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);
	        return match ? match[0] : '';
	    }
	    var UrlParser = (function () {
	        /**
	         * @param {?} url
	         */
	        function UrlParser(url) {
	            this.url = url;
	            this.remaining = url;
	        }
	        /**
	         * @param {?} str
	         * @return {?}
	         */
	        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
	        /**
	         * @param {?} str
	         * @return {?}
	         */
	        UrlParser.prototype.capture = function (str) {
	            if (!this.remaining.startsWith(str)) {
	                throw new Error("Expected \"" + str + "\".");
	            }
	            this.remaining = this.remaining.substring(str.length);
	        };
	        /**
	         * @return {?}
	         */
	        UrlParser.prototype.parseRootSegment = function () {
	            if (this.remaining.startsWith('/')) {
	                this.capture('/');
	            }
	            if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {
	                return new UrlSegmentGroup([], {});
	            }
	            return new UrlSegmentGroup([], this.parseChildren());
	        };
	        /**
	         * @return {?}
	         */
	        UrlParser.prototype.parseChildren = function () {
	            if (this.remaining.length == 0) {
	                return {};
	            }
	            if (this.peekStartsWith('/')) {
	                this.capture('/');
	            }
	            var /** @type {?} */ paths = [];
	            if (!this.peekStartsWith('(')) {
	                paths.push(this.parseSegments());
	            }
	            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
	                this.capture('/');
	                paths.push(this.parseSegments());
	            }
	            var /** @type {?} */ children = {};
	            if (this.peekStartsWith('/(')) {
	                this.capture('/');
	                children = this.parseParens(true);
	            }
	            var /** @type {?} */ res = {};
	            if (this.peekStartsWith('(')) {
	                res = this.parseParens(false);
	            }
	            if (paths.length > 0 || Object.keys(children).length > 0) {
	                res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);
	            }
	            return res;
	        };
	        /**
	         * @return {?}
	         */
	        UrlParser.prototype.parseSegments = function () {
	            var /** @type {?} */ path = matchSegments(this.remaining);
	            if (path === '' && this.peekStartsWith(';')) {
	                throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
	            }
	            this.capture(path);
	            var /** @type {?} */ matrixParams = {};
	            if (this.peekStartsWith(';')) {
	                matrixParams = this.parseMatrixParams();
	            }
	            return new UrlSegment(decode(path), matrixParams);
	        };
	        /**
	         * @return {?}
	         */
	        UrlParser.prototype.parseQueryParams = function () {
	            var /** @type {?} */ params = {};
	            if (this.peekStartsWith('?')) {
	                this.capture('?');
	                this.parseQueryParam(params);
	                while (this.remaining.length > 0 && this.peekStartsWith('&')) {
	                    this.capture('&');
	                    this.parseQueryParam(params);
	                }
	            }
	            return params;
	        };
	        /**
	         * @return {?}
	         */
	        UrlParser.prototype.parseFragment = function () {
	            if (this.peekStartsWith('#')) {
	                return decodeURI(this.remaining.substring(1));
	            }
	            return null;
	        };
	        /**
	         * @return {?}
	         */
	        UrlParser.prototype.parseMatrixParams = function () {
	            var /** @type {?} */ params = {};
	            while (this.remaining.length > 0 && this.peekStartsWith(';')) {
	                this.capture(';');
	                this.parseParam(params);
	            }
	            return params;
	        };
	        /**
	         * @param {?} params
	         * @return {?}
	         */
	        UrlParser.prototype.parseParam = function (params) {
	            var /** @type {?} */ key = matchSegments(this.remaining);
	            if (!key) {
	                return;
	            }
	            this.capture(key);
	            var /** @type {?} */ value = '';
	            if (this.peekStartsWith('=')) {
	                this.capture('=');
	                var /** @type {?} */ valueMatch = matchSegments(this.remaining);
	                if (valueMatch) {
	                    value = valueMatch;
	                    this.capture(value);
	                }
	            }
	            params[decode(key)] = decode(value);
	        };
	        /**
	         * @param {?} params
	         * @return {?}
	         */
	        UrlParser.prototype.parseQueryParam = function (params) {
	            var /** @type {?} */ key = matchQueryParams(this.remaining);
	            if (!key) {
	                return;
	            }
	            this.capture(key);
	            var /** @type {?} */ value = '';
	            if (this.peekStartsWith('=')) {
	                this.capture('=');
	                var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);
	                if (valueMatch) {
	                    value = valueMatch;
	                    this.capture(value);
	                }
	            }
	            var /** @type {?} */ decodedKey = decode(key);
	            var /** @type {?} */ decodedVal = decode(value);
	            if (params.hasOwnProperty(decodedKey)) {
	                // Append to existing values
	                var /** @type {?} */ currentVal = params[decodedKey];
	                if (!Array.isArray(currentVal)) {
	                    currentVal = [currentVal];
	                    params[decodedKey] = currentVal;
	                }
	                currentVal.push(decodedVal);
	            }
	            else {
	                // Create a new value
	                params[decodedKey] = decodedVal;
	            }
	        };
	        /**
	         * @param {?} allowPrimary
	         * @return {?}
	         */
	        UrlParser.prototype.parseParens = function (allowPrimary) {
	            var /** @type {?} */ segments = {};
	            this.capture('(');
	            while (!this.peekStartsWith(')') && this.remaining.length > 0) {
	                var /** @type {?} */ path = matchSegments(this.remaining);
	                var /** @type {?} */ next = this.remaining[path.length];
	                // if is is not one of these characters, then the segment was unescaped
	                // or the group was not closed
	                if (next !== '/' && next !== ')' && next !== ';') {
	                    throw new Error("Cannot parse url '" + this.url + "'");
	                }
	                var /** @type {?} */ outletName = void 0;
	                if (path.indexOf(':') > -1) {
	                    outletName = path.substr(0, path.indexOf(':'));
	                    this.capture(outletName);
	                    this.capture(':');
	                }
	                else if (allowPrimary) {
	                    outletName = PRIMARY_OUTLET;
	                }
	                var /** @type {?} */ children = this.parseChildren();
	                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :
	                    new UrlSegmentGroup([], children);
	                if (this.peekStartsWith('//')) {
	                    this.capture('//');
	                }
	            }
	            this.capture(')');
	            return segments;
	        };
	        return UrlParser;
	    }());

	    var NoMatch = (function () {
	        /**
	         * @param {?=} segmentGroup
	         */
	        function NoMatch(segmentGroup) {
	            if (segmentGroup === void 0) { segmentGroup = null; }
	            this.segmentGroup = segmentGroup;
	        }
	        return NoMatch;
	    }());
	    var AbsoluteRedirect = (function () {
	        /**
	         * @param {?} urlTree
	         */
	        function AbsoluteRedirect(urlTree) {
	            this.urlTree = urlTree;
	        }
	        return AbsoluteRedirect;
	    }());
	    /**
	     * @param {?} segmentGroup
	     * @return {?}
	     */
	    function noMatch(segmentGroup) {
	        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });
	    }
	    /**
	     * @param {?} newTree
	     * @return {?}
	     */
	    function absoluteRedirect(newTree) {
	        return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });
	    }
	    /**
	     * @param {?} redirectTo
	     * @return {?}
	     */
	    function namedOutletsRedirect(redirectTo) {
	        return new rxjs_Observable.Observable(function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    function canLoadFails(route) {
	        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });
	    }
	    /**
	     * @param {?} injector
	     * @param {?} configLoader
	     * @param {?} urlSerializer
	     * @param {?} urlTree
	     * @param {?} config
	     * @return {?}
	     */
	    function applyRedirects(injector, configLoader, urlSerializer, urlTree, config) {
	        return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();
	    }
	    var ApplyRedirects = (function () {
	        /**
	         * @param {?} injector
	         * @param {?} configLoader
	         * @param {?} urlSerializer
	         * @param {?} urlTree
	         * @param {?} config
	         */
	        function ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config) {
	            this.injector = injector;
	            this.configLoader = configLoader;
	            this.urlSerializer = urlSerializer;
	            this.urlTree = urlTree;
	            this.config = config;
	            this.allowRedirects = true;
	        }
	        /**
	         * @return {?}
	         */
	        ApplyRedirects.prototype.apply = function () {
	            var _this = this;
	            var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);
	            var /** @type {?} */ urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); });
	            return rxjs_operator_catch._catch.call(urlTrees$, function (e) {
	                if (e instanceof AbsoluteRedirect) {
	                    // after an absolute redirect we do not apply any more redirects!
	                    _this.allowRedirects = false;
	                    // we need to run matching, so we can fetch all lazy-loaded modules
	                    return _this.match(e.urlTree);
	                }
	                else if (e instanceof NoMatch) {
	                    throw _this.noMatchError(e);
	                }
	                else {
	                    throw e;
	                }
	            });
	        };
	        /**
	         * @param {?} tree
	         * @return {?}
	         */
	        ApplyRedirects.prototype.match = function (tree) {
	            var _this = this;
	            var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);
	            var /** @type {?} */ mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) {
	                return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);
	            });
	            return rxjs_operator_catch._catch.call(mapped$, function (e) {
	                if (e instanceof NoMatch) {
	                    throw _this.noMatchError(e);
	                }
	                else {
	                    throw e;
	                }
	            });
	        };
	        /**
	         * @param {?} e
	         * @return {?}
	         */
	        ApplyRedirects.prototype.noMatchError = function (e) {
	            return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");
	        };
	        /**
	         * @param {?} rootCandidate
	         * @param {?} queryParams
	         * @param {?} fragment
	         * @return {?}
	         */
	        ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {
	            var /** @type {?} */ root = rootCandidate.segments.length > 0 ?
	                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :
	                rootCandidate;
	            return new UrlTree(root, queryParams, fragment);
	            var _a;
	        };
	        /**
	         * @param {?} injector
	         * @param {?} routes
	         * @param {?} segmentGroup
	         * @param {?} outlet
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {
	            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
	                return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });
	            }
	            else {
	                return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);
	            }
	        };
	        /**
	         * @param {?} injector
	         * @param {?} routes
	         * @param {?} segmentGroup
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {
	            var _this = this;
	            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });
	        };
	        /**
	         * @param {?} injector
	         * @param {?} segmentGroup
	         * @param {?} routes
	         * @param {?} segments
	         * @param {?} outlet
	         * @param {?} allowRedirects
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {
	            var _this = this;
	            var /** @type {?} */ routes$ = rxjs_observable_of.of.apply(void 0, routes);
	            var /** @type {?} */ processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {
	                var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);
	                return rxjs_operator_catch._catch.call(expanded$, function (e) {
	                    if (e instanceof NoMatch)
	                        return rxjs_observable_of.of(null);
	                    else
	                        throw e;
	                });
	            });
	            var /** @type {?} */ concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);
	            var /** @type {?} */ first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });
	            return rxjs_operator_catch._catch.call(first$, function (e, _) {
	                if (e instanceof rxjs_util_EmptyError.EmptyError) {
	                    if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
	                        return rxjs_observable_of.of(new UrlSegmentGroup([], {}));
	                    }
	                    else {
	                        throw new NoMatch(segmentGroup);
	                    }
	                }
	                else {
	                    throw e;
	                }
	            });
	        };
	        /**
	         * @param {?} segmentGroup
	         * @param {?} segments
	         * @param {?} outlet
	         * @return {?}
	         */
	        ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
	            return segments.length === 0 && !segmentGroup.children[outlet];
	        };
	        /**
	         * @param {?} injector
	         * @param {?} segmentGroup
	         * @param {?} routes
	         * @param {?} route
	         * @param {?} paths
	         * @param {?} outlet
	         * @param {?} allowRedirects
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {
	            if (getOutlet$1(route) !== outlet)
	                return noMatch(segmentGroup);
	            if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))
	                return noMatch(segmentGroup);
	            if (route.redirectTo === undefined) {
	                return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);
	            }
	            else {
	                return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);
	            }
	        };
	        /**
	         * @param {?} injector
	         * @param {?} segmentGroup
	         * @param {?} routes
	         * @param {?} route
	         * @param {?} segments
	         * @param {?} outlet
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {
	            if (route.path === '**') {
	                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);
	            }
	            else {
	                return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);
	            }
	        };
	        /**
	         * @param {?} injector
	         * @param {?} routes
	         * @param {?} route
	         * @param {?} outlet
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {
	            var _this = this;
	            var /** @type {?} */ newTree = this.applyRedirectCommands([], route.redirectTo, {});
	            if (route.redirectTo.startsWith('/')) {
	                return absoluteRedirect(newTree);
	            }
	            else {
	                return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {
	                    var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});
	                    return _this.expandSegment(injector, group, routes, newSegments, outlet, false);
	                });
	            }
	        };
	        /**
	         * @param {?} injector
	         * @param {?} segmentGroup
	         * @param {?} routes
	         * @param {?} route
	         * @param {?} segments
	         * @param {?} outlet
	         * @return {?}
	         */
	        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {
	            var _this = this;
	            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
	            if (!matched)
	                return noMatch(segmentGroup);
	            var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, /** @type {?} */ (positionalParamSegments));
	            if (route.redirectTo.startsWith('/')) {
	                return absoluteRedirect(newTree);
	            }
	            else {
	                return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {
	                    return _this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
	                });
	            }
	        };
	        /**
	         * @param {?} injector
	         * @param {?} rawSegmentGroup
	         * @param {?} route
	         * @param {?} segments
	         * @return {?}
	         */
	        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {
	            var _this = this;
	            if (route.path === '**') {
	                if (route.loadChildren) {
	                    return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {
	                        ((route))._loadedConfig = r;
	                        return new UrlSegmentGroup(segments, {});
	                    });
	                }
	                else {
	                    return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));
	                }
	            }
	            else {
	                var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;
	                if (!matched)
	                    return noMatch(rawSegmentGroup);
	                var /** @type {?} */ rawSlicedSegments_1 = segments.slice(lastChild);
	                var /** @type {?} */ childConfig$ = this.getChildConfig(injector, route);
	                return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {
	                    var /** @type {?} */ childInjector = routerConfig.injector;
	                    var /** @type {?} */ childConfig = routerConfig.routes;
	                    var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
	                    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
	                        var /** @type {?} */ expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);
	                        return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });
	                    }
	                    else if (childConfig.length === 0 && slicedSegments.length === 0) {
	                        return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));
	                    }
	                    else {
	                        var /** @type {?} */ expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);
	                        return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });
	                    }
	                });
	            }
	        };
	        /**
	         * @param {?} injector
	         * @param {?} route
	         * @return {?}
	         */
	        ApplyRedirects.prototype.getChildConfig = function (injector, route) {
	            var _this = this;
	            if (route.children) {
	                return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null, null));
	            }
	            else if (route.loadChildren) {
	                return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {
	                    if (shouldLoad) {
	                        if (((route))._loadedConfig) {
	                            return rxjs_observable_of.of(((route))._loadedConfig);
	                        }
	                        else {
	                            return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {
	                                ((route))._loadedConfig = r;
	                                return r;
	                            });
	                        }
	                    }
	                    else {
	                        return canLoadFails(route);
	                    }
	                });
	            }
	            else {
	                return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null, null));
	            }
	        };
	        /**
	         * @param {?} route
	         * @param {?} urlTree
	         * @return {?}
	         */
	        ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {
	            var /** @type {?} */ res = [];
	            var /** @type {?} */ c = urlTree.root;
	            while (true) {
	                res = res.concat(c.segments);
	                if (c.numberOfChildren === 0) {
	                    return rxjs_observable_of.of(res);
	                }
	                else if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
	                    return namedOutletsRedirect(route.redirectTo);
	                }
	                else {
	                    c = c.children[PRIMARY_OUTLET];
	                }
	            }
	        };
	        /**
	         * @param {?} segments
	         * @param {?} redirectTo
	         * @param {?} posParams
	         * @return {?}
	         */
	        ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {
	            var /** @type {?} */ t = this.urlSerializer.parse(redirectTo);
	            return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
	        };
	        /**
	         * @param {?} redirectTo
	         * @param {?} urlTree
	         * @param {?} segments
	         * @param {?} posParams
	         * @return {?}
	         */
	        ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {
	            var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
	            return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
	        };
	        /**
	         * @param {?} redirectToParams
	         * @param {?} actualParams
	         * @return {?}
	         */
	        ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {
	            var /** @type {?} */ res = {};
	            forEach(redirectToParams, function (v, k) {
	                if (v.startsWith(':')) {
	                    res[k] = actualParams[v.substring(1)];
	                }
	                else {
	                    res[k] = v;
	                }
	            });
	            return res;
	        };
	        /**
	         * @param {?} redirectTo
	         * @param {?} group
	         * @param {?} segments
	         * @param {?} posParams
	         * @return {?}
	         */
	        ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {
	            var _this = this;
	            var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
	            var /** @type {?} */ children = {};
	            forEach(group.children, function (child, name) {
	                children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);
	            });
	            return new UrlSegmentGroup(updatedSegments, children);
	        };
	        /**
	         * @param {?} redirectTo
	         * @param {?} redirectToSegments
	         * @param {?} actualSegments
	         * @param {?} posParams
	         * @return {?}
	         */
	        ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {
	            var _this = this;
	            return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :
	                _this.findOrReturn(s, actualSegments); });
	        };
	        /**
	         * @param {?} redirectTo
	         * @param {?} redirectToUrlSegment
	         * @param {?} posParams
	         * @return {?}
	         */
	        ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {
	            var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];
	            if (!pos)
	                throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");
	            return pos;
	        };
	        /**
	         * @param {?} redirectToUrlSegment
	         * @param {?} actualSegments
	         * @return {?}
	         */
	        ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {
	            var /** @type {?} */ idx = 0;
	            for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {
	                var s = actualSegments_1[_i];
	                if (s.path === redirectToUrlSegment.path) {
	                    actualSegments.splice(idx);
	                    return s;
	                }
	                idx++;
	            }
	            return redirectToUrlSegment;
	        };
	        return ApplyRedirects;
	    }());
	    /**
	     * @param {?} injector
	     * @param {?} route
	     * @return {?}
	     */
	    function runGuards(injector, route) {
	        var /** @type {?} */ canLoad = route.canLoad;
	        if (!canLoad || canLoad.length === 0)
	            return rxjs_observable_of.of(true);
	        var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {
	            var /** @type {?} */ guard = injector.get(c);
	            if (guard.canLoad) {
	                return wrapIntoObservable(guard.canLoad(route));
	            }
	            else {
	                return wrapIntoObservable(guard(route));
	            }
	        });
	        return andObservables(obs);
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} route
	     * @param {?} segments
	     * @return {?}
	     */
	    function match(segmentGroup, route, segments) {
	        var /** @type {?} */ noMatch = { matched: false, consumedSegments: /** @type {?} */ ([]), lastChild: 0, positionalParamSegments: {} };
	        if (route.path === '') {
	            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {
	                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
	            }
	            else {
	                return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
	            }
	        }
	        var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;
	        var /** @type {?} */ res = matcher(segments, segmentGroup, route);
	        if (!res)
	            return noMatch;
	        return {
	            matched: true,
	            consumedSegments: res.consumed,
	            lastChild: res.consumed.length,
	            positionalParamSegments: res.posParams
	        };
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} consumedSegments
	     * @param {?} slicedSegments
	     * @param {?} config
	     * @return {?}
	     */
	    function split(segmentGroup, consumedSegments, slicedSegments, config) {
	        if (slicedSegments.length > 0 &&
	            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
	            var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
	            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };
	        }
	        else if (slicedSegments.length === 0 &&
	            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
	            var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
	            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };
	        }
	        else {
	            return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };
	        }
	    }
	    /**
	     * @param {?} s
	     * @return {?}
	     */
	    function mergeTrivialChildren(s) {
	        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
	            var /** @type {?} */ c = s.children[PRIMARY_OUTLET];
	            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
	        }
	        else {
	            return s;
	        }
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} routes
	     * @param {?} children
	     * @return {?}
	     */
	    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
	        var /** @type {?} */ res = {};
	        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
	            var r = routes_1[_i];
	            if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
	                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});
	            }
	        }
	        return merge(children, res);
	    }
	    /**
	     * @param {?} routes
	     * @param {?} primarySegmentGroup
	     * @return {?}
	     */
	    function createChildrenForEmptySegments(routes, primarySegmentGroup) {
	        var /** @type {?} */ res = {};
	        res[PRIMARY_OUTLET] = primarySegmentGroup;
	        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {
	            var r = routes_2[_i];
	            if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
	                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});
	            }
	        }
	        return res;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} routes
	     * @return {?}
	     */
	    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {
	        return routes
	            .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&
	            getOutlet$1(r) !== PRIMARY_OUTLET; })
	            .length > 0;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} routes
	     * @return {?}
	     */
	    function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {
	        return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} r
	     * @return {?}
	     */
	    function emptyPathRedirect(segmentGroup, slicedSegments, r) {
	        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')
	            return false;
	        return r.path === '' && r.redirectTo !== undefined;
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    function getOutlet$1(route) {
	        return route.outlet ? route.outlet : PRIMARY_OUTLET;
	    }

	    /**
	     * @param {?} config
	     * @param {?=} parentPath
	     * @return {?}
	     */
	    function validateConfig(config, parentPath) {
	        if (parentPath === void 0) { parentPath = ''; }
	        // forEach doesn't iterate undefined values
	        for (var /** @type {?} */ i = 0; i < config.length; i++) {
	            var /** @type {?} */ route = config[i];
	            var /** @type {?} */ fullPath = getFullPath(parentPath, route);
	            validateNode(route, fullPath);
	        }
	    }
	    /**
	     * @param {?} route
	     * @param {?} fullPath
	     * @return {?}
	     */
	    function validateNode(route, fullPath) {
	        if (!route) {
	            throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n       \n      Example: \n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");
	        }
	        if (Array.isArray(route)) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");
	        }
	        if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route cannot have a named outlet set");
	        }
	        if (route.redirectTo && route.children) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");
	        }
	        if (route.redirectTo && route.loadChildren) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");
	        }
	        if (route.children && route.loadChildren) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");
	        }
	        if (route.redirectTo && route.component) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");
	        }
	        if (route.path && route.matcher) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");
	        }
	        if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
	            throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");
	        }
	        if (route.path === void 0 && route.matcher === void 0) {
	            throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");
	        }
	        if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
	            throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");
	        }
	        if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
	            var /** @type {?} */ exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
	            throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);
	        }
	        if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
	            throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");
	        }
	        if (route.children) {
	            validateConfig(route.children, fullPath);
	        }
	    }
	    /**
	     * @param {?} parentPath
	     * @param {?} currentRoute
	     * @return {?}
	     */
	    function getFullPath(parentPath, currentRoute) {
	        if (!currentRoute) {
	            return parentPath;
	        }
	        if (!parentPath && !currentRoute.path) {
	            return '';
	        }
	        else if (parentPath && !currentRoute.path) {
	            return parentPath + "/";
	        }
	        else if (!parentPath && currentRoute.path) {
	            return currentRoute.path;
	        }
	        else {
	            return parentPath + "/" + currentRoute.path;
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var Tree = (function () {
	        /**
	         * @param {?} root
	         */
	        function Tree(root) {
	            this._root = root;
	        }
	        Object.defineProperty(Tree.prototype, "root", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._root.value; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} t
	         * @return {?}
	         */
	        Tree.prototype.parent = function (t) {
	            var /** @type {?} */ p = this.pathFromRoot(t);
	            return p.length > 1 ? p[p.length - 2] : null;
	        };
	        /**
	         * \@internal
	         * @param {?} t
	         * @return {?}
	         */
	        Tree.prototype.children = function (t) {
	            var /** @type {?} */ n = findNode(t, this._root);
	            return n ? n.children.map(function (t) { return t.value; }) : [];
	        };
	        /**
	         * \@internal
	         * @param {?} t
	         * @return {?}
	         */
	        Tree.prototype.firstChild = function (t) {
	            var /** @type {?} */ n = findNode(t, this._root);
	            return n && n.children.length > 0 ? n.children[0].value : null;
	        };
	        /**
	         * \@internal
	         * @param {?} t
	         * @return {?}
	         */
	        Tree.prototype.siblings = function (t) {
	            var /** @type {?} */ p = findPath(t, this._root, []);
	            if (p.length < 2)
	                return [];
	            var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });
	            return c.filter(function (cc) { return cc !== t; });
	        };
	        /**
	         * \@internal
	         * @param {?} t
	         * @return {?}
	         */
	        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };
	        return Tree;
	    }());
	    /**
	     * @param {?} expected
	     * @param {?} c
	     * @return {?}
	     */
	    function findNode(expected, c) {
	        if (expected === c.value)
	            return c;
	        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {
	            var cc = _a[_i];
	            var /** @type {?} */ r = findNode(expected, cc);
	            if (r)
	                return r;
	        }
	        return null;
	    }
	    /**
	     * @param {?} expected
	     * @param {?} c
	     * @param {?} collected
	     * @return {?}
	     */
	    function findPath(expected, c, collected) {
	        collected.push(c);
	        if (expected === c.value)
	            return collected;
	        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {
	            var cc = _a[_i];
	            var /** @type {?} */ cloned = collected.slice(0);
	            var /** @type {?} */ r = findPath(expected, cc, cloned);
	            if (r.length > 0)
	                return r;
	        }
	        return [];
	    }
	    var TreeNode = (function () {
	        /**
	         * @param {?} value
	         * @param {?} children
	         */
	        function TreeNode(value, children) {
	            this.value = value;
	            this.children = children;
	        }
	        /**
	         * @return {?}
	         */
	        TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
	        return TreeNode;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@whatItDoes Represents the state of the router.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@Component({templateUrl:'template.html'})
	     * class MyComponent {
	     *   constructor(router: Router) {
	     *     const state: RouterState = router.routerState;
	     *     const root: ActivatedRoute = state.root;
	     *     const child = root.firstChild;
	     *     const id: Observable<string> = child.params.map(p => p.id);
	     *     //...
	     *   }
	     * }
	     * ```
	     *
	     * \@description
	     * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
	     * segments,
	     * the extracted parameters, and the resolved data.
	     *
	     * See {\@link ActivatedRoute} for more information.
	     *
	     * \@stable
	     */
	    var RouterState = (function (_super) {
	        __extends$1(RouterState, _super);
	        /**
	         * \@internal
	         * @param {?} root
	         * @param {?} snapshot
	         */
	        function RouterState(root, snapshot) {
	            _super.call(this, root);
	            this.snapshot = snapshot;
	            setRouterStateSnapshot(this, root);
	        }
	        /**
	         * @return {?}
	         */
	        RouterState.prototype.toString = function () { return this.snapshot.toString(); };
	        return RouterState;
	    }(Tree));
	    /**
	     * @param {?} urlTree
	     * @param {?} rootComponent
	     * @return {?}
	     */
	    function createEmptyState(urlTree, rootComponent) {
	        var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
	        var /** @type {?} */ emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);
	        var /** @type {?} */ emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});
	        var /** @type {?} */ emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});
	        var /** @type {?} */ emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});
	        var /** @type {?} */ fragment = new rxjs_BehaviorSubject.BehaviorSubject('');
	        var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
	        activated.snapshot = snapshot.root;
	        return new RouterState(new TreeNode(activated, []), snapshot);
	    }
	    /**
	     * @param {?} urlTree
	     * @param {?} rootComponent
	     * @return {?}
	     */
	    function createEmptyStateSnapshot(urlTree, rootComponent) {
	        var /** @type {?} */ emptyParams = {};
	        var /** @type {?} */ emptyData = {};
	        var /** @type {?} */ emptyQueryParams = {};
	        var /** @type {?} */ fragment = '';
	        var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
	        return new RouterStateSnapshot('', new TreeNode(activated, []));
	    }
	    /**
	     * \@whatItDoes Contains the information about a route associated with a component loaded in an
	     * outlet.
	     * An `ActivatedRoute` can also be used to traverse the router state tree.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@Component({...})
	     * class MyComponent {
	     *   constructor(route: ActivatedRoute) {
	     *     const id: Observable<string> = route.params.map(p => p.id);
	     *     const url: Observable<string> = route.url.map(segments => segments.join(''));
	     *     // route.data includes both `data` and `resolve`
	     *     const user = route.data.map(d => d.user);
	     *   }
	     * }
	     * ```
	     *
	     * \@stable
	     */
	    var ActivatedRoute = (function () {
	        /**
	         * \@internal
	         * @param {?} url
	         * @param {?} params
	         * @param {?} queryParams
	         * @param {?} fragment
	         * @param {?} data
	         * @param {?} outlet
	         * @param {?} component
	         * @param {?} futureSnapshot
	         */
	        function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
	            this.url = url;
	            this.params = params;
	            this.queryParams = queryParams;
	            this.fragment = fragment;
	            this.data = data;
	            this.outlet = outlet;
	            this.component = component;
	            this._futureSnapshot = futureSnapshot;
	        }
	        Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {
	            /**
	             * The configuration used to match this route
	             * @return {?}
	             */
	            get: function () { return this._futureSnapshot.routeConfig; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRoute.prototype, "root", {
	            /**
	             * The root of the router state
	             * @return {?}
	             */
	            get: function () { return this._routerState.root; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRoute.prototype, "parent", {
	            /**
	             * The parent of this route in the router state tree
	             * @return {?}
	             */
	            get: function () { return this._routerState.parent(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRoute.prototype, "firstChild", {
	            /**
	             * The first child of this route in the router state tree
	             * @return {?}
	             */
	            get: function () { return this._routerState.firstChild(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRoute.prototype, "children", {
	            /**
	             * The children of this route in the router state tree
	             * @return {?}
	             */
	            get: function () { return this._routerState.children(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {
	            /**
	             * The path from the root of the router state tree to this route
	             * @return {?}
	             */
	            get: function () { return this._routerState.pathFromRoot(this); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ActivatedRoute.prototype.toString = function () {
	            return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
	        };
	        return ActivatedRoute;
	    }());
	    /**
	     * \@internal
	     * @param {?} route
	     * @return {?}
	     */
	    function inheritedParamsDataResolve(route) {
	        var /** @type {?} */ pathToRoot = route.pathFromRoot;
	        var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;
	        while (inhertingStartingFrom >= 1) {
	            var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];
	            var /** @type {?} */ parent_1 = pathToRoot[inhertingStartingFrom - 1];
	            // current route is an empty path => inherits its parent's params and data
	            if (current.routeConfig && current.routeConfig.path === '') {
	                inhertingStartingFrom--;
	            }
	            else if (!parent_1.component) {
	                inhertingStartingFrom--;
	            }
	            else {
	                break;
	            }
	        }
	        return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {
	            var /** @type {?} */ params = merge(res.params, curr.params);
	            var /** @type {?} */ data = merge(res.data, curr.data);
	            var /** @type {?} */ resolve = merge(res.resolve, curr._resolvedData);
	            return { params: params, data: data, resolve: resolve };
	        }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));
	    }
	    /**
	     * \@whatItDoes Contains the information about a route associated with a component loaded in an
	     * outlet
	     * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router
	     * state tree.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@Component({templateUrl:'./my-component.html'})
	     * class MyComponent {
	     *   constructor(route: ActivatedRoute) {
	     *     const id: string = route.snapshot.params.id;
	     *     const url: string = route.snapshot.url.join('');
	     *     const user = route.snapshot.data.user;
	     *   }
	     * }
	     * ```
	     *
	     * \@stable
	     */
	    var ActivatedRouteSnapshot = (function () {
	        /**
	         * \@internal
	         * @param {?} url
	         * @param {?} params
	         * @param {?} queryParams
	         * @param {?} fragment
	         * @param {?} data
	         * @param {?} outlet
	         * @param {?} component
	         * @param {?} routeConfig
	         * @param {?} urlSegment
	         * @param {?} lastPathIndex
	         * @param {?} resolve
	         */
	        function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {
	            this.url = url;
	            this.params = params;
	            this.queryParams = queryParams;
	            this.fragment = fragment;
	            this.data = data;
	            this.outlet = outlet;
	            this.component = component;
	            this._routeConfig = routeConfig;
	            this._urlSegment = urlSegment;
	            this._lastPathIndex = lastPathIndex;
	            this._resolve = resolve;
	        }
	        Object.defineProperty(ActivatedRouteSnapshot.prototype, "routeConfig", {
	            /**
	             * The configuration used to match this route
	             * @return {?}
	             */
	            get: function () { return this._routeConfig; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {
	            /**
	             * The root of the router state
	             * @return {?}
	             */
	            get: function () { return this._routerState.root; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {
	            /**
	             * The parent of this route in the router state tree
	             * @return {?}
	             */
	            get: function () { return this._routerState.parent(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {
	            /**
	             * The first child of this route in the router state tree
	             * @return {?}
	             */
	            get: function () { return this._routerState.firstChild(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {
	            /**
	             * The children of this route in the router state tree
	             * @return {?}
	             */
	            get: function () { return this._routerState.children(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {
	            /**
	             * The path from the root of the router state tree to this route
	             * @return {?}
	             */
	            get: function () { return this._routerState.pathFromRoot(this); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ActivatedRouteSnapshot.prototype.toString = function () {
	            var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');
	            var /** @type {?} */ matched = this._routeConfig ? this._routeConfig.path : '';
	            return "Route(url:'" + url + "', path:'" + matched + "')";
	        };
	        return ActivatedRouteSnapshot;
	    }());
	    /**
	     * \@whatItDoes Represents the state of the router at a moment in time.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@Component({templateUrl:'template.html'})
	     * class MyComponent {
	     *   constructor(router: Router) {
	     *     const state: RouterState = router.routerState;
	     *     const snapshot: RouterStateSnapshot = state.snapshot;
	     *     const root: ActivatedRouteSnapshot = snapshot.root;
	     *     const child = root.firstChild;
	     *     const id: Observable<string> = child.params.map(p => p.id);
	     *     //...
	     *   }
	     * }
	     * ```
	     *
	     * \@description
	     * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about
	     * the "consumed" URL segments, the extracted parameters, and the resolved data.
	     *
	     * \@stable
	     */
	    var RouterStateSnapshot = (function (_super) {
	        __extends$1(RouterStateSnapshot, _super);
	        /**
	         * \@internal
	         * @param {?} url
	         * @param {?} root
	         */
	        function RouterStateSnapshot(url, root) {
	            _super.call(this, root);
	            this.url = url;
	            setRouterStateSnapshot(this, root);
	        }
	        /**
	         * @return {?}
	         */
	        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
	        return RouterStateSnapshot;
	    }(Tree));
	    /**
	     * @param {?} state
	     * @param {?} node
	     * @return {?}
	     */
	    function setRouterStateSnapshot(state, node) {
	        node.value._routerState = state;
	        node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function serializeNode(node) {
	        var /** @type {?} */ c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(", ") + " } " : '';
	        return "" + node.value + c;
	    }
	    /**
	     * The expectation is that the activate route is created with the right set of parameters.
	     * So we push new values into the observables only when they are not the initial values.
	     * And we detect that by checking if the snapshot field is set.
	     * @param {?} route
	     * @return {?}
	     */
	    function advanceActivatedRoute(route) {
	        if (route.snapshot) {
	            var /** @type {?} */ currentSnapshot = route.snapshot;
	            route.snapshot = route._futureSnapshot;
	            if (!shallowEqual(currentSnapshot.queryParams, route._futureSnapshot.queryParams)) {
	                ((route.queryParams)).next(route._futureSnapshot.queryParams);
	            }
	            if (currentSnapshot.fragment !== route._futureSnapshot.fragment) {
	                ((route.fragment)).next(route._futureSnapshot.fragment);
	            }
	            if (!shallowEqual(currentSnapshot.params, route._futureSnapshot.params)) {
	                ((route.params)).next(route._futureSnapshot.params);
	            }
	            if (!shallowEqualArrays(currentSnapshot.url, route._futureSnapshot.url)) {
	                ((route.url)).next(route._futureSnapshot.url);
	            }
	            if (!equalParamsAndUrlSegments(currentSnapshot, route._futureSnapshot)) {
	                ((route.data)).next(route._futureSnapshot.data);
	            }
	        }
	        else {
	            route.snapshot = route._futureSnapshot;
	            // this is for resolved data
	            ((route.data)).next(route._futureSnapshot.data);
	        }
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function equalParamsAndUrlSegments(a, b) {
	        return shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
	    }

	    /**
	     * @param {?} routeReuseStrategy
	     * @param {?} curr
	     * @param {?} prevState
	     * @return {?}
	     */
	    function createRouterState(routeReuseStrategy, curr, prevState) {
	        var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
	        return new RouterState(root, curr);
	    }
	    /**
	     * @param {?} routeReuseStrategy
	     * @param {?} curr
	     * @param {?=} prevState
	     * @return {?}
	     */
	    function createNode(routeReuseStrategy, curr, prevState) {
	        // reuse an activated route that is currently displayed on the screen
	        if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
	            var /** @type {?} */ value = prevState.value;
	            value._futureSnapshot = curr.value;
	            var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
	            return new TreeNode(value, children);
	        }
	        else if (routeReuseStrategy.retrieve(curr.value)) {
	            var /** @type {?} */ tree = ((routeReuseStrategy.retrieve(curr.value))).route;
	            setFutureSnapshotsOfActivatedRoutes(curr, tree);
	            return tree;
	        }
	        else {
	            var /** @type {?} */ value = createActivatedRoute(curr.value);
	            var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });
	            return new TreeNode(value, children);
	        }
	    }
	    /**
	     * @param {?} curr
	     * @param {?} result
	     * @return {?}
	     */
	    function setFutureSnapshotsOfActivatedRoutes(curr, result) {
	        if (curr.value.routeConfig !== result.value.routeConfig) {
	            throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
	        }
	        if (curr.children.length !== result.children.length) {
	            throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
	        }
	        result.value._futureSnapshot = curr.value;
	        for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {
	            setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
	        }
	    }
	    /**
	     * @param {?} routeReuseStrategy
	     * @param {?} curr
	     * @param {?} prevState
	     * @return {?}
	     */
	    function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
	        return curr.children.map(function (child) {
	            for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {
	                var p = _a[_i];
	                if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
	                    return createNode(routeReuseStrategy, child, p);
	                }
	            }
	            return createNode(routeReuseStrategy, child);
	        });
	    }
	    /**
	     * @param {?} c
	     * @return {?}
	     */
	    function createActivatedRoute(c) {
	        return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);
	    }

	    /**
	     * @param {?} route
	     * @param {?} urlTree
	     * @param {?} commands
	     * @param {?} queryParams
	     * @param {?} fragment
	     * @return {?}
	     */
	    function createUrlTree(route, urlTree, commands, queryParams, fragment) {
	        if (commands.length === 0) {
	            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
	        }
	        var /** @type {?} */ nav = computeNavigation(commands);
	        if (nav.toRoot()) {
	            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
	        }
	        var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);
	        var /** @type {?} */ segmentGroup = startingPosition.processChildren ?
	            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :
	            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
	        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
	    }
	    /**
	     * @param {?} command
	     * @return {?}
	     */
	    function isMatrixParams(command) {
	        return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
	    }
	    /**
	     * @param {?} oldSegmentGroup
	     * @param {?} newSegmentGroup
	     * @param {?} urlTree
	     * @param {?} queryParams
	     * @param {?} fragment
	     * @return {?}
	     */
	    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
	        if (urlTree.root === oldSegmentGroup) {
	            return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);
	        }
	        return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);
	    }
	    /**
	     * @param {?} current
	     * @param {?} oldSegment
	     * @param {?} newSegment
	     * @return {?}
	     */
	    function replaceSegment(current, oldSegment, newSegment) {
	        var /** @type {?} */ children = {};
	        forEach(current.children, function (c, outletName) {
	            if (c === oldSegment) {
	                children[outletName] = newSegment;
	            }
	            else {
	                children[outletName] = replaceSegment(c, oldSegment, newSegment);
	            }
	        });
	        return new UrlSegmentGroup(current.segments, children);
	    }
	    var Navigation = (function () {
	        /**
	         * @param {?} isAbsolute
	         * @param {?} numberOfDoubleDots
	         * @param {?} commands
	         */
	        function Navigation(isAbsolute, numberOfDoubleDots, commands) {
	            this.isAbsolute = isAbsolute;
	            this.numberOfDoubleDots = numberOfDoubleDots;
	            this.commands = commands;
	            if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
	                throw new Error('Root segment cannot have matrix parameters');
	            }
	            var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });
	            if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {
	                throw new Error('{outlets:{}} has to be the last command');
	            }
	        }
	        /**
	         * @return {?}
	         */
	        Navigation.prototype.toRoot = function () {
	            return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
	        };
	        return Navigation;
	    }());
	    /**
	     * Transforms commands to a normalized `Navigation`
	     * @param {?} commands
	     * @return {?}
	     */
	    function computeNavigation(commands) {
	        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {
	            return new Navigation(true, 0, commands);
	        }
	        var /** @type {?} */ numberOfDoubleDots = 0;
	        var /** @type {?} */ isAbsolute = false;
	        var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {
	            if (typeof cmd === 'object' && cmd != null) {
	                if (cmd.outlets) {
	                    var /** @type {?} */ outlets_1 = {};
	                    forEach(cmd.outlets, function (commands, name) {
	                        outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;
	                    });
	                    return res.concat([{ outlets: outlets_1 }]);
	                }
	                if (cmd.segmentPath) {
	                    return res.concat([cmd.segmentPath]);
	                }
	            }
	            if (!(typeof cmd === 'string')) {
	                return res.concat([cmd]);
	            }
	            if (cmdIdx === 0) {
	                cmd.split('/').forEach(function (urlPart, partIndex) {
	                    if (partIndex == 0 && urlPart === '.') {
	                    }
	                    else if (partIndex == 0 && urlPart === '') {
	                        isAbsolute = true;
	                    }
	                    else if (urlPart === '..') {
	                        numberOfDoubleDots++;
	                    }
	                    else if (urlPart != '') {
	                        res.push(urlPart);
	                    }
	                });
	                return res;
	            }
	            return res.concat([cmd]);
	        }, []);
	        return new Navigation(isAbsolute, numberOfDoubleDots, res);
	    }
	    var Position = (function () {
	        /**
	         * @param {?} segmentGroup
	         * @param {?} processChildren
	         * @param {?} index
	         */
	        function Position(segmentGroup, processChildren, index) {
	            this.segmentGroup = segmentGroup;
	            this.processChildren = processChildren;
	            this.index = index;
	        }
	        return Position;
	    }());
	    /**
	     * @param {?} nav
	     * @param {?} tree
	     * @param {?} route
	     * @return {?}
	     */
	    function findStartingPosition(nav, tree, route) {
	        if (nav.isAbsolute) {
	            return new Position(tree.root, true, 0);
	        }
	        if (route.snapshot._lastPathIndex === -1) {
	            return new Position(route.snapshot._urlSegment, true, 0);
	        }
	        var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
	        var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;
	        return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
	    }
	    /**
	     * @param {?} group
	     * @param {?} index
	     * @param {?} numberOfDoubleDots
	     * @return {?}
	     */
	    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
	        var /** @type {?} */ g = group;
	        var /** @type {?} */ ci = index;
	        var /** @type {?} */ dd = numberOfDoubleDots;
	        while (dd > ci) {
	            dd -= ci;
	            g = g.parent;
	            if (!g) {
	                throw new Error('Invalid number of \'../\'');
	            }
	            ci = g.segments.length;
	        }
	        return new Position(g, false, ci - dd);
	    }
	    /**
	     * @param {?} command
	     * @return {?}
	     */
	    function getPath(command) {
	        if (typeof command === 'object' && command != null && command.outlets) {
	            return command.outlets[PRIMARY_OUTLET];
	        }
	        return "" + command;
	    }
	    /**
	     * @param {?} commands
	     * @return {?}
	     */
	    function getOutlets(commands) {
	        if (!(typeof commands[0] === 'object'))
	            return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);
	        if (commands[0].outlets === undefined)
	            return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);
	        return commands[0].outlets;
	        var _a, _b;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} startIndex
	     * @param {?} commands
	     * @return {?}
	     */
	    function updateSegmentGroup(segmentGroup, startIndex, commands) {
	        if (!segmentGroup) {
	            segmentGroup = new UrlSegmentGroup([], {});
	        }
	        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
	            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
	        }
	        var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);
	        var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);
	        if (m.match && m.pathIndex < segmentGroup.segments.length) {
	            var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
	            g.children[PRIMARY_OUTLET] =
	                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
	            return updateSegmentGroupChildren(g, 0, slicedCommands);
	        }
	        else if (m.match && slicedCommands.length === 0) {
	            return new UrlSegmentGroup(segmentGroup.segments, {});
	        }
	        else if (m.match && !segmentGroup.hasChildren()) {
	            return createNewSegmentGroup(segmentGroup, startIndex, commands);
	        }
	        else if (m.match) {
	            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
	        }
	        else {
	            return createNewSegmentGroup(segmentGroup, startIndex, commands);
	        }
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} startIndex
	     * @param {?} commands
	     * @return {?}
	     */
	    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
	        if (commands.length === 0) {
	            return new UrlSegmentGroup(segmentGroup.segments, {});
	        }
	        else {
	            var /** @type {?} */ outlets_2 = getOutlets(commands);
	            var /** @type {?} */ children_1 = {};
	            forEach(outlets_2, function (commands, outlet) {
	                if (commands !== null) {
	                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
	                }
	            });
	            forEach(segmentGroup.children, function (child, childOutlet) {
	                if (outlets_2[childOutlet] === undefined) {
	                    children_1[childOutlet] = child;
	                }
	            });
	            return new UrlSegmentGroup(segmentGroup.segments, children_1);
	        }
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} startIndex
	     * @param {?} commands
	     * @return {?}
	     */
	    function prefixedWith(segmentGroup, startIndex, commands) {
	        var /** @type {?} */ currentCommandIndex = 0;
	        var /** @type {?} */ currentPathIndex = startIndex;
	        var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };
	        while (currentPathIndex < segmentGroup.segments.length) {
	            if (currentCommandIndex >= commands.length)
	                return noMatch;
	            var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];
	            var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);
	            var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
	            if (currentPathIndex > 0 && curr === undefined)
	                break;
	            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {
	                if (!compare(curr, next, path))
	                    return noMatch;
	                currentCommandIndex += 2;
	            }
	            else {
	                if (!compare(curr, {}, path))
	                    return noMatch;
	                currentCommandIndex++;
	            }
	            currentPathIndex++;
	        }
	        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} startIndex
	     * @param {?} commands
	     * @return {?}
	     */
	    function createNewSegmentGroup(segmentGroup, startIndex, commands) {
	        var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);
	        var /** @type {?} */ i = 0;
	        while (i < commands.length) {
	            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
	                var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);
	                return new UrlSegmentGroup(paths, children);
	            }
	            // if we start with an object literal, we need to reuse the path part from the segment
	            if (i === 0 && isMatrixParams(commands[0])) {
	                var /** @type {?} */ p = segmentGroup.segments[startIndex];
	                paths.push(new UrlSegment(p.path, commands[0]));
	                i++;
	                continue;
	            }
	            var /** @type {?} */ curr = getPath(commands[i]);
	            var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;
	            if (curr && next && isMatrixParams(next)) {
	                paths.push(new UrlSegment(curr, stringify(next)));
	                i += 2;
	            }
	            else {
	                paths.push(new UrlSegment(curr, {}));
	                i++;
	            }
	        }
	        return new UrlSegmentGroup(paths, {});
	    }
	    /**
	     * @param {?} outlets
	     * @return {?}
	     */
	    function createNewSegmentChildren(outlets) {
	        var /** @type {?} */ children = {};
	        forEach(outlets, function (commands, outlet) {
	            if (commands !== null) {
	                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
	            }
	        });
	        return children;
	    }
	    /**
	     * @param {?} params
	     * @return {?}
	     */
	    function stringify(params) {
	        var /** @type {?} */ res = {};
	        forEach(params, function (v, k) { return res[k] = "" + v; });
	        return res;
	    }
	    /**
	     * @param {?} path
	     * @param {?} params
	     * @param {?} segment
	     * @return {?}
	     */
	    function compare(path, params, segment) {
	        return path == segment.path && shallowEqual(params, segment.parameters);
	    }

	    var NoMatch$1 = (function () {
	        function NoMatch() {
	        }
	        return NoMatch;
	    }());
	    /**
	     * @param {?} rootComponentType
	     * @param {?} config
	     * @param {?} urlTree
	     * @param {?} url
	     * @return {?}
	     */
	    function recognize(rootComponentType, config, urlTree, url) {
	        return new Recognizer(rootComponentType, config, urlTree, url).recognize();
	    }
	    var Recognizer = (function () {
	        /**
	         * @param {?} rootComponentType
	         * @param {?} config
	         * @param {?} urlTree
	         * @param {?} url
	         */
	        function Recognizer(rootComponentType, config, urlTree, url) {
	            this.rootComponentType = rootComponentType;
	            this.config = config;
	            this.urlTree = urlTree;
	            this.url = url;
	        }
	        /**
	         * @return {?}
	         */
	        Recognizer.prototype.recognize = function () {
	            try {
	                var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;
	                var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
	                var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
	                var /** @type {?} */ rootNode = new TreeNode(root, children);
	                var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);
	                this.inheriteParamsAndData(routeState._root);
	                return rxjs_observable_of.of(routeState);
	            }
	            catch (e) {
	                return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });
	            }
	        };
	        /**
	         * @param {?} routeNode
	         * @return {?}
	         */
	        Recognizer.prototype.inheriteParamsAndData = function (routeNode) {
	            var _this = this;
	            var /** @type {?} */ route = routeNode.value;
	            var /** @type {?} */ i = inheritedParamsDataResolve(route);
	            route.params = Object.freeze(i.params);
	            route.data = Object.freeze(i.data);
	            routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });
	        };
	        /**
	         * @param {?} config
	         * @param {?} segmentGroup
	         * @param {?} outlet
	         * @return {?}
	         */
	        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {
	            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
	                return this.processChildren(config, segmentGroup);
	            }
	            else {
	                return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
	            }
	        };
	        /**
	         * @param {?} config
	         * @param {?} segmentGroup
	         * @return {?}
	         */
	        Recognizer.prototype.processChildren = function (config, segmentGroup) {
	            var _this = this;
	            var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });
	            checkOutletNameUniqueness(children);
	            sortActivatedRouteSnapshots(children);
	            return children;
	        };
	        /**
	         * @param {?} config
	         * @param {?} segmentGroup
	         * @param {?} segments
	         * @param {?} outlet
	         * @return {?}
	         */
	        Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {
	            for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {
	                var r = config_1[_i];
	                try {
	                    return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
	                }
	                catch (e) {
	                    if (!(e instanceof NoMatch$1))
	                        throw e;
	                }
	            }
	            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
	                return [];
	            }
	            else {
	                throw new NoMatch$1();
	            }
	        };
	        /**
	         * @param {?} segmentGroup
	         * @param {?} segments
	         * @param {?} outlet
	         * @return {?}
	         */
	        Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
	            return segments.length === 0 && !segmentGroup.children[outlet];
	        };
	        /**
	         * @param {?} route
	         * @param {?} rawSegment
	         * @param {?} segments
	         * @param {?} outlet
	         * @return {?}
	         */
	        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {
	            if (route.redirectTo)
	                throw new NoMatch$1();
	            if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)
	                throw new NoMatch$1();
	            if (route.path === '**') {
	                var /** @type {?} */ params = segments.length > 0 ? last(segments).parameters : {};
	                var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
	                return [new TreeNode(snapshot_1, [])];
	            }
	            var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;
	            var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);
	            var /** @type {?} */ childConfig = getChildConfig(route);
	            var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;
	            var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
	            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
	                var /** @type {?} */ children = this.processChildren(childConfig, segmentGroup);
	                return [new TreeNode(snapshot, children)];
	            }
	            else if (childConfig.length === 0 && slicedSegments.length === 0) {
	                return [new TreeNode(snapshot, [])];
	            }
	            else {
	                var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
	                return [new TreeNode(snapshot, children)];
	            }
	        };
	        return Recognizer;
	    }());
	    /**
	     * @param {?} nodes
	     * @return {?}
	     */
	    function sortActivatedRouteSnapshots(nodes) {
	        nodes.sort(function (a, b) {
	            if (a.value.outlet === PRIMARY_OUTLET)
	                return -1;
	            if (b.value.outlet === PRIMARY_OUTLET)
	                return 1;
	            return a.value.outlet.localeCompare(b.value.outlet);
	        });
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    function getChildConfig(route) {
	        if (route.children) {
	            return route.children;
	        }
	        else if (route.loadChildren) {
	            return ((route))._loadedConfig.routes;
	        }
	        else {
	            return [];
	        }
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} route
	     * @param {?} segments
	     * @return {?}
	     */
	    function match$1(segmentGroup, route, segments) {
	        if (route.path === '') {
	            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
	                throw new NoMatch$1();
	            }
	            else {
	                return { consumedSegments: [], lastChild: 0, parameters: {} };
	            }
	        }
	        var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;
	        var /** @type {?} */ res = matcher(segments, segmentGroup, route);
	        if (!res)
	            throw new NoMatch$1();
	        var /** @type {?} */ posParams = {};
	        forEach(res.posParams, function (v, k) { posParams[k] = v.path; });
	        var /** @type {?} */ parameters = merge(posParams, res.consumed[res.consumed.length - 1].parameters);
	        return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };
	    }
	    /**
	     * @param {?} nodes
	     * @return {?}
	     */
	    function checkOutletNameUniqueness(nodes) {
	        var /** @type {?} */ names = {};
	        nodes.forEach(function (n) {
	            var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];
	            if (routeWithSameOutletName) {
	                var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
	                var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');
	                throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
	            }
	            names[n.value.outlet] = n.value;
	        });
	    }
	    /**
	     * @param {?} segmentGroup
	     * @return {?}
	     */
	    function getSourceSegmentGroup(segmentGroup) {
	        var /** @type {?} */ s = segmentGroup;
	        while (s._sourceSegment) {
	            s = s._sourceSegment;
	        }
	        return s;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @return {?}
	     */
	    function getPathIndexShift(segmentGroup) {
	        var /** @type {?} */ s = segmentGroup;
	        var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);
	        while (s._sourceSegment) {
	            s = s._sourceSegment;
	            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);
	        }
	        return res - 1;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} consumedSegments
	     * @param {?} slicedSegments
	     * @param {?} config
	     * @return {?}
	     */
	    function split$1(segmentGroup, consumedSegments, slicedSegments, config) {
	        if (slicedSegments.length > 0 &&
	            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
	            var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
	            s._sourceSegment = segmentGroup;
	            s._segmentIndexShift = consumedSegments.length;
	            return { segmentGroup: s, slicedSegments: [] };
	        }
	        else if (slicedSegments.length === 0 &&
	            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
	            var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
	            s._sourceSegment = segmentGroup;
	            s._segmentIndexShift = consumedSegments.length;
	            return { segmentGroup: s, slicedSegments: slicedSegments };
	        }
	        else {
	            var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
	            s._sourceSegment = segmentGroup;
	            s._segmentIndexShift = consumedSegments.length;
	            return { segmentGroup: s, slicedSegments: slicedSegments };
	        }
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} routes
	     * @param {?} children
	     * @return {?}
	     */
	    function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
	        var /** @type {?} */ res = {};
	        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
	            var r = routes_1[_i];
	            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {
	                var /** @type {?} */ s = new UrlSegmentGroup([], {});
	                s._sourceSegment = segmentGroup;
	                s._segmentIndexShift = segmentGroup.segments.length;
	                res[getOutlet$2(r)] = s;
	            }
	        }
	        return merge(children, res);
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} consumedSegments
	     * @param {?} routes
	     * @param {?} primarySegment
	     * @return {?}
	     */
	    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
	        var /** @type {?} */ res = {};
	        res[PRIMARY_OUTLET] = primarySegment;
	        primarySegment._sourceSegment = segmentGroup;
	        primarySegment._segmentIndexShift = consumedSegments.length;
	        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {
	            var r = routes_2[_i];
	            if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {
	                var /** @type {?} */ s = new UrlSegmentGroup([], {});
	                s._sourceSegment = segmentGroup;
	                s._segmentIndexShift = consumedSegments.length;
	                res[getOutlet$2(r)] = s;
	            }
	        }
	        return res;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} routes
	     * @return {?}
	     */
	    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
	        return routes
	            .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&
	            getOutlet$2(r) !== PRIMARY_OUTLET; })
	            .length > 0;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} routes
	     * @return {?}
	     */
	    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
	        return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;
	    }
	    /**
	     * @param {?} segmentGroup
	     * @param {?} slicedSegments
	     * @param {?} r
	     * @return {?}
	     */
	    function emptyPathMatch(segmentGroup, slicedSegments, r) {
	        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')
	            return false;
	        return r.path === '' && r.redirectTo === undefined;
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    function getOutlet$2(route) {
	        return route.outlet ? route.outlet : PRIMARY_OUTLET;
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    function getData(route) {
	        return route.data ? route.data : {};
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    function getResolve(route) {
	        return route.resolve ? route.resolve : {};
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * \@whatItDoes Contains all the router outlets created in a component.
	     *
	     * \@stable
	     */
	    var RouterOutletMap = (function () {
	        function RouterOutletMap() {
	            /** @internal */
	            this._outlets = {};
	        }
	        /**
	         * Adds an outlet to this map.
	         * @param {?} name
	         * @param {?} outlet
	         * @return {?}
	         */
	        RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };
	        /**
	         * Removes an outlet from this map.
	         * @param {?} name
	         * @return {?}
	         */
	        RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };
	        return RouterOutletMap;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * \@whatItDoes Provides a way to migrate Angular 1 applications to Angular 2.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var UrlHandlingStrategy = (function () {
	        function UrlHandlingStrategy() {
	        }
	        /**
	         * Tells the router if this URL should be processed.
	         *
	         * When it returns true, the router will execute the regular navigation.
	         * When it returns false, the router will set the router state to an empty state.
	         * As a result, all the active components will be destroyed.
	         *
	         * @abstract
	         * @param {?} url
	         * @return {?}
	         */
	        UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };
	        /**
	         * Extracts the part of the URL that should be handled by the router.
	         * The rest of the URL will remain untouched.
	         * @abstract
	         * @param {?} url
	         * @return {?}
	         */
	        UrlHandlingStrategy.prototype.extract = function (url) { };
	        /**
	         * Merges the URL fragment with the rest of the URL.
	         * @abstract
	         * @param {?} newUrlPart
	         * @param {?} rawUrl
	         * @return {?}
	         */
	        UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };
	        return UrlHandlingStrategy;
	    }());
	    /**
	     * \@experimental
	     */
	    var DefaultUrlHandlingStrategy = (function () {
	        function DefaultUrlHandlingStrategy() {
	        }
	        /**
	         * @param {?} url
	         * @return {?}
	         */
	        DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };
	        /**
	         * @param {?} url
	         * @return {?}
	         */
	        DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };
	        /**
	         * @param {?} newUrlPart
	         * @param {?} wholeUrl
	         * @return {?}
	         */
	        DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };
	        return DefaultUrlHandlingStrategy;
	    }());

	    /**
	     * \@whatItDoes Represents an event triggered when a navigation starts.
	     *
	     * \@stable
	     */
	    var NavigationStart = (function () {
	        /**
	         * @param {?} id
	         * @param {?} url
	         */
	        function NavigationStart(id, url) {
	            this.id = id;
	            this.url = url;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
	        return NavigationStart;
	    }());
	    /**
	     * \@whatItDoes Represents an event triggered when a navigation ends successfully.
	     *
	     * \@stable
	     */
	    var NavigationEnd = (function () {
	        /**
	         * @param {?} id
	         * @param {?} url
	         * @param {?} urlAfterRedirects
	         */
	        function NavigationEnd(id, url, urlAfterRedirects) {
	            this.id = id;
	            this.url = url;
	            this.urlAfterRedirects = urlAfterRedirects;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        NavigationEnd.prototype.toString = function () {
	            return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
	        };
	        return NavigationEnd;
	    }());
	    /**
	     * \@whatItDoes Represents an event triggered when a navigation is canceled.
	     *
	     * \@stable
	     */
	    var NavigationCancel = (function () {
	        /**
	         * @param {?} id
	         * @param {?} url
	         * @param {?} reason
	         */
	        function NavigationCancel(id, url, reason) {
	            this.id = id;
	            this.url = url;
	            this.reason = reason;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
	        return NavigationCancel;
	    }());
	    /**
	     * \@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.
	     *
	     * \@stable
	     */
	    var NavigationError = (function () {
	        /**
	         * @param {?} id
	         * @param {?} url
	         * @param {?} error
	         */
	        function NavigationError(id, url, error) {
	            this.id = id;
	            this.url = url;
	            this.error = error;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        NavigationError.prototype.toString = function () {
	            return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
	        };
	        return NavigationError;
	    }());
	    /**
	     * \@whatItDoes Represents an event triggered when routes are recognized.
	     *
	     * \@stable
	     */
	    var RoutesRecognized = (function () {
	        /**
	         * @param {?} id
	         * @param {?} url
	         * @param {?} urlAfterRedirects
	         * @param {?} state
	         */
	        function RoutesRecognized(id, url, urlAfterRedirects, state) {
	            this.id = id;
	            this.url = url;
	            this.urlAfterRedirects = urlAfterRedirects;
	            this.state = state;
	        }
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        RoutesRecognized.prototype.toString = function () {
	            return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
	        };
	        return RoutesRecognized;
	    }());
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    function defaultErrorHandler(error) {
	        throw error;
	    }
	    /**
	     * \@internal
	     * @param {?} snapshot
	     * @return {?}
	     */
	    function defaultRouterHook(snapshot) {
	        return rxjs_observable_of.of(null);
	    }
	    /**
	     * Does not detach any subtrees. Reuses routes as long as their route config is the same.
	     */
	    var DefaultRouteReuseStrategy = (function () {
	        function DefaultRouteReuseStrategy() {
	        }
	        /**
	         * @param {?} route
	         * @return {?}
	         */
	        DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };
	        /**
	         * @param {?} route
	         * @param {?} detachedTree
	         * @return {?}
	         */
	        DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };
	        /**
	         * @param {?} route
	         * @return {?}
	         */
	        DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };
	        /**
	         * @param {?} route
	         * @return {?}
	         */
	        DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };
	        /**
	         * @param {?} future
	         * @param {?} curr
	         * @return {?}
	         */
	        DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
	            return future.routeConfig === curr.routeConfig;
	        };
	        return DefaultRouteReuseStrategy;
	    }());
	    /**
	     * \@whatItDoes Provides the navigation and url manipulation capabilities.
	     *
	     * See {\@link Routes} for more details and examples.
	     *
	     * \@ngModule RouterModule
	     *
	     * \@stable
	     */
	    var Router = (function () {
	        /**
	         * @param {?} rootComponentType
	         * @param {?} urlSerializer
	         * @param {?} outletMap
	         * @param {?} location
	         * @param {?} injector
	         * @param {?} loader
	         * @param {?} compiler
	         * @param {?} config
	         */
	        function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {
	            this.rootComponentType = rootComponentType;
	            this.urlSerializer = urlSerializer;
	            this.outletMap = outletMap;
	            this.location = location;
	            this.injector = injector;
	            this.config = config;
	            this.navigations = new rxjs_BehaviorSubject.BehaviorSubject(null);
	            this.routerEvents = new rxjs_Subject.Subject();
	            this.navigationId = 0;
	            /**
	             * Error handler that is invoked when a navigation errors.
	             *
	             * See {@link ErrorHandler} for more information.
	             */
	            this.errorHandler = defaultErrorHandler;
	            /**
	             * Indicates if at least one navigation happened.
	             */
	            this.navigated = false;
	            /**
	             * Extracts and merges URLs. Used for Angular 1 to Angular 2 migrations.
	             * Used by RouterModule. This allows us to
	             * pause the navigation either before preactivation or after it.
	             * @internal
	             */
	            this.hooks = {
	                beforePreactivation: defaultRouterHook,
	                afterPreactivation: defaultRouterHook
	            };
	            /**
	             * Extracts and merges URLs. Used for AngularJS to Angular migrations.
	             */
	            this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
	            this.routeReuseStrategy = new DefaultRouteReuseStrategy();
	            this.resetConfig(config);
	            this.currentUrlTree = createEmptyUrlTree();
	            this.rawUrlTree = this.currentUrlTree;
	            this.configLoader = new RouterConfigLoader(loader, compiler);
	            this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);
	            this.processNavigations();
	        }
	        /**
	         * \@internal
	         * TODO: this should be removed once the constructor of the router made internal
	         * @param {?} rootComponentType
	         * @return {?}
	         */
	        Router.prototype.resetRootComponentType = function (rootComponentType) {
	            this.rootComponentType = rootComponentType;
	            // TODO: vsavkin router 4.0 should make the root component set to null
	            // this will simplify the lifecycle of the router.
	            this.currentRouterState.root.component = this.rootComponentType;
	        };
	        /**
	         * Sets up the location change listener and performs the initial navigation.
	         * @return {?}
	         */
	        Router.prototype.initialNavigation = function () {
	            this.setUpLocationChangeListener();
	            if (this.navigationId === 0) {
	                this.navigateByUrl(this.location.path(true), { replaceUrl: true });
	            }
	        };
	        /**
	         * Sets up the location change listener.
	         * @return {?}
	         */
	        Router.prototype.setUpLocationChangeListener = function () {
	            var _this = this;
	            // Zone.current.wrap is needed because of the issue with RxJS scheduler,
	            // which does not work properly with zone.js in IE and Safari
	            if (!this.locationSubscription) {
	                this.locationSubscription = (this.location.subscribe(Zone.current.wrap(function (change) {
	                    var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);
	                    var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
	                    setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);
	                })));
	            }
	        };
	        Object.defineProperty(Router.prototype, "routerState", {
	            /**
	             * The current route state
	             * @return {?}
	             */
	            get: function () { return this.currentRouterState; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Router.prototype, "url", {
	            /**
	             * The current url
	             * @return {?}
	             */
	            get: function () { return this.serializeUrl(this.currentUrlTree); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Router.prototype, "events", {
	            /**
	             * An observable of router events
	             * @return {?}
	             */
	            get: function () { return this.routerEvents; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Resets the configuration used for navigation and generating links.
	         *
	         * ### Usage
	         *
	         * ```
	         * router.resetConfig([
	         *  { path: 'team/:id', component: TeamCmp, children: [
	         *    { path: 'simple', component: SimpleCmp },
	         *    { path: 'user/:name', component: UserCmp }
	         *  ]}
	         * ]);
	         * ```
	         * @param {?} config
	         * @return {?}
	         */
	        Router.prototype.resetConfig = function (config) {
	            validateConfig(config);
	            this.config = config;
	        };
	        /**
	         * \@docsNotRequired
	         * @return {?}
	         */
	        Router.prototype.ngOnDestroy = function () { this.dispose(); };
	        /**
	         * Disposes of the router
	         * @return {?}
	         */
	        Router.prototype.dispose = function () {
	            if (this.locationSubscription) {
	                this.locationSubscription.unsubscribe();
	                this.locationSubscription = null;
	            }
	        };
	        /**
	         * Applies an array of commands to the current url tree and creates a new url tree.
	         *
	         * When given an activate route, applies the given commands starting from the route.
	         * When not given a route, applies the given command starting from the root.
	         *
	         * ### Usage
	         *
	         * ```
	         * // create /team/33/user/11
	         * router.createUrlTree(['/team', 33, 'user', 11]);
	         *
	         * // create /team/33;expand=true/user/11
	         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
	         *
	         * // you can collapse static segments like this (this works only with the first passed-in value):
	         * router.createUrlTree(['/team/33/user', userId]);
	         *
	         * // If the first segment can contain slashes, and you do not want the router to split it, you
	         * // can do the following:
	         *
	         * router.createUrlTree([{segmentPath: '/one/two'}]);
	         *
	         * // create /team/33/(user/11//right:chat)
	         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
	         *
	         * // remove the right secondary node
	         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
	         *
	         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
	         *
	         * // navigate to /team/33/user/11/details
	         * router.createUrlTree(['details'], {relativeTo: route});
	         *
	         * // navigate to /team/33/user/22
	         * router.createUrlTree(['../22'], {relativeTo: route});
	         *
	         * // navigate to /team/44/user/22
	         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
	         * ```
	         * @param {?} commands
	         * @param {?=} __1
	         * @return {?}
	         */
	        Router.prototype.createUrlTree = function (commands, _a) {
	            var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;
	            var /** @type {?} */ a = relativeTo || this.routerState.root;
	            var /** @type {?} */ q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;
	            var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;
	            return createUrlTree(a, this.currentUrlTree, commands, q, f);
	        };
	        /**
	         * Navigate based on the provided url. This navigation is always absolute.
	         *
	         * Returns a promise that:
	         * - resolves to 'true' when navigation succeeds,
	         * - resolves to 'false' when navigation fails,
	         * - is rejected when an error happens.
	         *
	         * ### Usage
	         *
	         * ```
	         * router.navigateByUrl("/team/33/user/11");
	         *
	         * // Navigate without updating the URL
	         * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
	         * ```
	         *
	         * In opposite to `navigate`, `navigateByUrl` takes a whole URL
	         * and does not apply any delta to the current one.
	         * @param {?} url
	         * @param {?=} extras
	         * @return {?}
	         */
	        Router.prototype.navigateByUrl = function (url, extras) {
	            if (extras === void 0) { extras = { skipLocationChange: false }; }
	            if (url instanceof UrlTree) {
	                return this.scheduleNavigation(this.urlHandlingStrategy.merge(url, this.rawUrlTree), 'imperative', extras);
	            }
	            var /** @type {?} */ urlTree = this.urlSerializer.parse(url);
	            return this.scheduleNavigation(this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree), 'imperative', extras);
	        };
	        /**
	         * Navigate based on the provided array of commands and a starting point.
	         * If no starting route is provided, the navigation is absolute.
	         *
	         * Returns a promise that:
	         * - resolves to 'true' when navigation succeeds,
	         * - resolves to 'false' when navigation fails,
	         * - is rejected when an error happens.
	         *
	         * ### Usage
	         *
	         * ```
	         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
	         *
	         * // Navigate without updating the URL
	         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
	         * ```
	         *
	         * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current
	         * URL.
	         * @param {?} commands
	         * @param {?=} extras
	         * @return {?}
	         */
	        Router.prototype.navigate = function (commands, extras) {
	            if (extras === void 0) { extras = { skipLocationChange: false }; }
	            validateCommands(commands);
	            if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {
	                extras.queryParams = this.removeEmptyProps(extras.queryParams);
	            }
	            return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
	        };
	        /**
	         * Serializes a {\@link UrlTree} into a string
	         * @param {?} url
	         * @return {?}
	         */
	        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
	        /**
	         * Parses a string into a {\@link UrlTree}
	         * @param {?} url
	         * @return {?}
	         */
	        Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };
	        /**
	         * Returns whether the url is activated
	         * @param {?} url
	         * @param {?} exact
	         * @return {?}
	         */
	        Router.prototype.isActive = function (url, exact) {
	            if (url instanceof UrlTree) {
	                return containsTree(this.currentUrlTree, url, exact);
	            }
	            else {
	                var /** @type {?} */ urlTree = this.urlSerializer.parse(url);
	                return containsTree(this.currentUrlTree, urlTree, exact);
	            }
	        };
	        /**
	         * @param {?} params
	         * @return {?}
	         */
	        Router.prototype.removeEmptyProps = function (params) {
	            return Object.keys(params).reduce(function (result, key) {
	                var /** @type {?} */ value = params[key];
	                if (value !== null && value !== undefined) {
	                    result[key] = value;
	                }
	                return result;
	            }, {});
	        };
	        /**
	         * @return {?}
	         */
	        Router.prototype.processNavigations = function () {
	            var _this = this;
	            rxjs_operator_concatMap.concatMap
	                .call(this.navigations, function (nav) {
	                if (nav) {
	                    _this.executeScheduledNavigation(nav);
	                    // a failed navigation should not stop the router from processing
	                    // further navigations => the catch
	                    return nav.promise.catch(function () { });
	                }
	                else {
	                    return (rxjs_observable_of.of(null));
	                }
	            })
	                .subscribe(function () { });
	        };
	        /**
	         * @param {?} rawUrl
	         * @param {?} source
	         * @param {?} extras
	         * @return {?}
	         */
	        Router.prototype.scheduleNavigation = function (rawUrl, source, extras) {
	            var /** @type {?} */ lastNavigation = this.navigations.value;
	            // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
	            // and that navigation results in 'replaceState' that leads to the same URL,
	            // we should skip those.
	            if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&
	                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
	                return null; // return value is not used
	            }
	            // Because of a bug in IE and Edge, the location class fires two events (popstate and
	            // hashchange)
	            // every single time. The second one should be ignored. Otherwise, the URL will flicker.
	            if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&
	                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
	                return null; // return value is not used
	            }
	            var /** @type {?} */ resolve = null;
	            var /** @type {?} */ reject = null;
	            var /** @type {?} */ promise = new Promise(function (res, rej) {
	                resolve = res;
	                reject = rej;
	            });
	            var /** @type {?} */ id = ++this.navigationId;
	            this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });
	            // Make sure that the error is propagated even though `processNavigations` catch
	            // handler does not rethrow
	            return promise.catch(function (e) { return Promise.reject(e); });
	        };
	        /**
	         * @param {?} __0
	         * @return {?}
	         */
	        Router.prototype.executeScheduledNavigation = function (_a) {
	            var _this = this;
	            var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;
	            var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);
	            var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();
	            if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {
	                this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
	                Promise.resolve()
	                    .then(function (_) { return _this.runNavigate(url, rawUrl, extras.skipLocationChange, extras.replaceUrl, id, null); })
	                    .then(resolve, reject);
	            }
	            else if (urlTransition && this.rawUrlTree &&
	                this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {
	                this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
	                Promise.resolve()
	                    .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })
	                    .then(resolve, reject);
	            }
	            else {
	                this.rawUrlTree = rawUrl;
	                resolve(null);
	            }
	        };
	        /**
	         * @param {?} url
	         * @param {?} rawUrl
	         * @param {?} shouldPreventPushState
	         * @param {?} shouldReplaceUrl
	         * @param {?} id
	         * @param {?} precreatedState
	         * @return {?}
	         */
	        Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {
	            var _this = this;
	            if (id !== this.navigationId) {
	                this.location.go(this.urlSerializer.serialize(this.currentUrlTree));
	                this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), "Navigation ID " + id + " is not equal to the current navigation id " + this.navigationId));
	                return Promise.resolve(false);
	            }
	            return new Promise(function (resolvePromise, rejectPromise) {
	                // create an observable of the url and route state snapshot
	                // this operation do not result in any side effects
	                var /** @type {?} */ urlAndSnapshot$;
	                if (!precreatedState) {
	                    var /** @type {?} */ redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, _this.urlSerializer, url, _this.config);
	                    urlAndSnapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (appliedUrl) {
	                        return rxjs_operator_map.map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {
	                            _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));
	                            return { appliedUrl: appliedUrl, snapshot: snapshot };
	                        });
	                    });
	                }
	                else {
	                    urlAndSnapshot$ = rxjs_observable_of.of({ appliedUrl: url, snapshot: precreatedState });
	                }
	                var /** @type {?} */ beforePreactivationDone$ = rxjs_operator_mergeMap.mergeMap.call(urlAndSnapshot$, function (p) {
	                    return rxjs_operator_map.map.call(_this.hooks.beforePreactivation(p.snapshot), function () { return p; });
	                });
	                // run preactivation: guards and data resolvers
	                var /** @type {?} */ preActivation;
	                var /** @type {?} */ preactivationTraverse$ = rxjs_operator_map.map.call(beforePreactivationDone$, function (_a) {
	                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;
	                    preActivation =
	                        new PreActivation(snapshot, _this.currentRouterState.snapshot, _this.injector);
	                    preActivation.traverse(_this.outletMap);
	                    return { appliedUrl: appliedUrl, snapshot: snapshot };
	                });
	                var /** @type {?} */ preactivationCheckGuards$ = rxjs_operator_mergeMap.mergeMap.call(preactivationTraverse$, function (_a) {
	                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;
	                    if (_this.navigationId !== id)
	                        return rxjs_observable_of.of(false);
	                    return rxjs_operator_map.map.call(preActivation.checkGuards(), function (shouldActivate) {
	                        return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };
	                    });
	                });
	                var /** @type {?} */ preactivationResolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivationCheckGuards$, function (p) {
	                    if (_this.navigationId !== id)
	                        return rxjs_observable_of.of(false);
	                    if (p.shouldActivate) {
	                        return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return p; });
	                    }
	                    else {
	                        return rxjs_observable_of.of(p);
	                    }
	                });
	                var /** @type {?} */ preactivationDone$ = rxjs_operator_mergeMap.mergeMap.call(preactivationResolveData$, function (p) {
	                    return rxjs_operator_map.map.call(_this.hooks.afterPreactivation(p.snapshot), function () { return p; });
	                });
	                // create router state
	                // this operation has side effects => route state is being affected
	                var /** @type {?} */ routerState$ = rxjs_operator_map.map.call(preactivationDone$, function (_a) {
	                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;
	                    if (shouldActivate) {
	                        var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.currentRouterState);
	                        return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };
	                    }
	                    else {
	                        return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };
	                    }
	                });
	                // applied the new router state
	                // this operation has side effects
	                var /** @type {?} */ navigationIsSuccessful;
	                var /** @type {?} */ storedState = _this.currentRouterState;
	                var /** @type {?} */ storedUrl = _this.currentUrlTree;
	                routerState$
	                    .forEach(function (_a) {
	                    var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;
	                    if (!shouldActivate || id !== _this.navigationId) {
	                        navigationIsSuccessful = false;
	                        return;
	                    }
	                    _this.currentUrlTree = appliedUrl;
	                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
	                    _this.currentRouterState = state;
	                    if (!shouldPreventPushState) {
	                        var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);
	                        if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {
	                            _this.location.replaceState(path);
	                        }
	                        else {
	                            _this.location.go(path);
	                        }
	                    }
	                    new ActivateRoutes(_this.routeReuseStrategy, state, storedState)
	                        .activate(_this.outletMap);
	                    navigationIsSuccessful = true;
	                })
	                    .then(function () {
	                    if (navigationIsSuccessful) {
	                        _this.navigated = true;
	                        _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));
	                        resolvePromise(true);
	                    }
	                    else {
	                        _this.resetUrlToCurrentUrlTree();
	                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));
	                        resolvePromise(false);
	                    }
	                }, function (e) {
	                    if (e instanceof NavigationCancelingError) {
	                        _this.resetUrlToCurrentUrlTree();
	                        _this.navigated = true;
	                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));
	                        resolvePromise(false);
	                    }
	                    else {
	                        _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));
	                        try {
	                            resolvePromise(_this.errorHandler(e));
	                        }
	                        catch (ee) {
	                            rejectPromise(ee);
	                        }
	                    }
	                    _this.currentRouterState = storedState;
	                    _this.currentUrlTree = storedUrl;
	                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
	                    _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));
	                });
	            });
	        };
	        /**
	         * @return {?}
	         */
	        Router.prototype.resetUrlToCurrentUrlTree = function () {
	            var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);
	            this.location.replaceState(path);
	        };
	        return Router;
	    }());
	    var CanActivate = (function () {
	        /**
	         * @param {?} path
	         */
	        function CanActivate(path) {
	            this.path = path;
	        }
	        Object.defineProperty(CanActivate.prototype, "route", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.path[this.path.length - 1]; },
	            enumerable: true,
	            configurable: true
	        });
	        return CanActivate;
	    }());
	    var CanDeactivate = (function () {
	        /**
	         * @param {?} component
	         * @param {?} route
	         */
	        function CanDeactivate(component, route) {
	            this.component = component;
	            this.route = route;
	        }
	        return CanDeactivate;
	    }());
	    var PreActivation = (function () {
	        /**
	         * @param {?} future
	         * @param {?} curr
	         * @param {?} injector
	         */
	        function PreActivation(future, curr, injector) {
	            this.future = future;
	            this.curr = curr;
	            this.injector = injector;
	            this.checks = [];
	        }
	        /**
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        PreActivation.prototype.traverse = function (parentOutletMap) {
	            var /** @type {?} */ futureRoot = this.future._root;
	            var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;
	            this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);
	        };
	        /**
	         * @return {?}
	         */
	        PreActivation.prototype.checkGuards = function () {
	            var _this = this;
	            if (this.checks.length === 0)
	                return rxjs_observable_of.of(true);
	            var /** @type {?} */ checks$ = rxjs_observable_from.from(this.checks);
	            var /** @type {?} */ runningChecks$ = rxjs_operator_mergeMap.mergeMap.call(checks$, function (s) {
	                if (s instanceof CanActivate) {
	                    return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));
	                }
	                else if (s instanceof CanDeactivate) {
	                    // workaround https://github.com/Microsoft/TypeScript/issues/7271
	                    var /** @type {?} */ s2 = (s);
	                    return _this.runCanDeactivate(s2.component, s2.route);
	                }
	                else {
	                    throw new Error('Cannot be reached');
	                }
	            });
	            return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });
	        };
	        /**
	         * @return {?}
	         */
	        PreActivation.prototype.resolveData = function () {
	            var _this = this;
	            if (this.checks.length === 0)
	                return rxjs_observable_of.of(null);
	            var /** @type {?} */ checks$ = rxjs_observable_from.from(this.checks);
	            var /** @type {?} */ runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {
	                if (s instanceof CanActivate) {
	                    return _this.runResolve(s.route);
	                }
	                else {
	                    return rxjs_observable_of.of(null);
	                }
	            });
	            return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });
	        };
	        /**
	         * @param {?} futureNode
	         * @param {?} currNode
	         * @param {?} outletMap
	         * @param {?} futurePath
	         * @return {?}
	         */
	        PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {
	            var _this = this;
	            var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);
	            futureNode.children.forEach(function (c) {
	                _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));
	                delete prevChildren[c.value.outlet];
	            });
	            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });
	        };
	        /**
	         * @param {?} futureNode
	         * @param {?} currNode
	         * @param {?} parentOutletMap
	         * @param {?} futurePath
	         * @return {?}
	         */
	        PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {
	            var /** @type {?} */ future = futureNode.value;
	            var /** @type {?} */ curr = currNode ? currNode.value : null;
	            var /** @type {?} */ outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;
	            // reusing the node
	            if (curr && future._routeConfig === curr._routeConfig) {
	                if (!equalParamsAndUrlSegments(future, curr)) {
	                    this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));
	                }
	                else {
	                    // we need to set the data
	                    future.data = curr.data;
	                    future._resolvedData = curr._resolvedData;
	                }
	                // If we have a component, we need to go through an outlet.
	                if (future.component) {
	                    this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);
	                }
	                else {
	                    this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);
	                }
	            }
	            else {
	                if (curr) {
	                    this.deactiveRouteAndItsChildren(currNode, outlet);
	                }
	                this.checks.push(new CanActivate(futurePath));
	                // If we have a component, we need to go through an outlet.
	                if (future.component) {
	                    this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);
	                }
	                else {
	                    this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);
	                }
	            }
	        };
	        /**
	         * @param {?} route
	         * @param {?} outlet
	         * @return {?}
	         */
	        PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {
	            var _this = this;
	            var /** @type {?} */ prevChildren = nodeChildrenAsMap(route);
	            var /** @type {?} */ r = route.value;
	            forEach(prevChildren, function (v, k) {
	                if (!r.component) {
	                    _this.deactiveRouteAndItsChildren(v, outlet);
	                }
	                else if (!!outlet) {
	                    _this.deactiveRouteAndItsChildren(v, outlet.outletMap._outlets[k]);
	                }
	                else {
	                    _this.deactiveRouteAndItsChildren(v, null);
	                }
	            });
	            if (!r.component) {
	                this.checks.push(new CanDeactivate(null, r));
	            }
	            else if (outlet && outlet.isActivated) {
	                this.checks.push(new CanDeactivate(outlet.component, r));
	            }
	            else {
	                this.checks.push(new CanDeactivate(null, r));
	            }
	        };
	        /**
	         * @param {?} future
	         * @return {?}
	         */
	        PreActivation.prototype.runCanActivate = function (future) {
	            var _this = this;
	            var /** @type {?} */ canActivate = future._routeConfig ? future._routeConfig.canActivate : null;
	            if (!canActivate || canActivate.length === 0)
	                return rxjs_observable_of.of(true);
	            var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {
	                var /** @type {?} */ guard = _this.getToken(c, future);
	                var /** @type {?} */ observable;
	                if (guard.canActivate) {
	                    observable = wrapIntoObservable(guard.canActivate(future, _this.future));
	                }
	                else {
	                    observable = wrapIntoObservable(guard(future, _this.future));
	                }
	                return rxjs_operator_first.first.call(observable);
	            });
	            return andObservables(obs);
	        };
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        PreActivation.prototype.runCanActivateChild = function (path) {
	            var _this = this;
	            var /** @type {?} */ future = path[path.length - 1];
	            var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)
	                .reverse()
	                .map(function (p) { return _this.extractCanActivateChild(p); })
	                .filter(function (_) { return _ !== null; });
	            return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {
	                var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {
	                    var /** @type {?} */ guard = _this.getToken(c, d.node);
	                    var /** @type {?} */ observable;
	                    if (guard.canActivateChild) {
	                        observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));
	                    }
	                    else {
	                        observable = wrapIntoObservable(guard(future, _this.future));
	                    }
	                    return rxjs_operator_first.first.call(observable);
	                });
	                return andObservables(obs);
	            }));
	        };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        PreActivation.prototype.extractCanActivateChild = function (p) {
	            var /** @type {?} */ canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;
	            if (!canActivateChild || canActivateChild.length === 0)
	                return null;
	            return { node: p, guards: canActivateChild };
	        };
	        /**
	         * @param {?} component
	         * @param {?} curr
	         * @return {?}
	         */
	        PreActivation.prototype.runCanDeactivate = function (component, curr) {
	            var _this = this;
	            var /** @type {?} */ canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;
	            if (!canDeactivate || canDeactivate.length === 0)
	                return rxjs_observable_of.of(true);
	            var /** @type {?} */ canDeactivate$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(canDeactivate), function (c) {
	                var /** @type {?} */ guard = _this.getToken(c, curr);
	                var /** @type {?} */ observable;
	                if (guard.canDeactivate) {
	                    observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));
	                }
	                else {
	                    observable = wrapIntoObservable(guard(component, curr, _this.curr));
	                }
	                return rxjs_operator_first.first.call(observable);
	            });
	            return rxjs_operator_every.every.call(canDeactivate$, function (result) { return result === true; });
	        };
	        /**
	         * @param {?} future
	         * @return {?}
	         */
	        PreActivation.prototype.runResolve = function (future) {
	            var /** @type {?} */ resolve = future._resolve;
	            return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {
	                future._resolvedData = resolvedData;
	                future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);
	                return null;
	            });
	        };
	        /**
	         * @param {?} resolve
	         * @param {?} future
	         * @return {?}
	         */
	        PreActivation.prototype.resolveNode = function (resolve, future) {
	            var _this = this;
	            return waitForMap(resolve, function (k, v) {
	                var /** @type {?} */ resolver = _this.getToken(v, future);
	                return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :
	                    wrapIntoObservable(resolver(future, _this.future));
	            });
	        };
	        /**
	         * @param {?} token
	         * @param {?} snapshot
	         * @return {?}
	         */
	        PreActivation.prototype.getToken = function (token, snapshot) {
	            var /** @type {?} */ config = closestLoadedConfig(snapshot);
	            var /** @type {?} */ injector = config ? config.injector : this.injector;
	            return injector.get(token);
	        };
	        return PreActivation;
	    }());
	    var ActivateRoutes = (function () {
	        /**
	         * @param {?} routeReuseStrategy
	         * @param {?} futureState
	         * @param {?} currState
	         */
	        function ActivateRoutes(routeReuseStrategy, futureState, currState) {
	            this.routeReuseStrategy = routeReuseStrategy;
	            this.futureState = futureState;
	            this.currState = currState;
	        }
	        /**
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.activate = function (parentOutletMap) {
	            var /** @type {?} */ futureRoot = this.futureState._root;
	            var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;
	            this.deactivateChildRoutes(futureRoot, currRoot, parentOutletMap);
	            advanceActivatedRoute(this.futureState.root);
	            this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);
	        };
	        /**
	         * @param {?} futureNode
	         * @param {?} currNode
	         * @param {?} outletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, outletMap) {
	            var _this = this;
	            var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);
	            futureNode.children.forEach(function (c) {
	                _this.deactivateRoutes(c, prevChildren[c.value.outlet], outletMap);
	                delete prevChildren[c.value.outlet];
	            });
	            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });
	        };
	        /**
	         * @param {?} futureNode
	         * @param {?} currNode
	         * @param {?} outletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {
	            var _this = this;
	            var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);
	            futureNode.children.forEach(function (c) { _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap); });
	        };
	        /**
	         * @param {?} futureNode
	         * @param {?} currNode
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentOutletMap) {
	            var /** @type {?} */ future = futureNode.value;
	            var /** @type {?} */ curr = currNode ? currNode.value : null;
	            // reusing the node
	            if (future === curr) {
	                // If we have a normal route, we need to go through an outlet.
	                if (future.component) {
	                    var /** @type {?} */ outlet = getOutlet(parentOutletMap, future);
	                    this.deactivateChildRoutes(futureNode, currNode, outlet.outletMap);
	                }
	                else {
	                    this.deactivateChildRoutes(futureNode, currNode, parentOutletMap);
	                }
	            }
	            else {
	                if (curr) {
	                    this.deactiveRouteAndItsChildren(currNode, parentOutletMap);
	                }
	            }
	        };
	        /**
	         * @param {?} futureNode
	         * @param {?} currNode
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {
	            var /** @type {?} */ future = futureNode.value;
	            var /** @type {?} */ curr = currNode ? currNode.value : null;
	            // reusing the node
	            if (future === curr) {
	                // advance the route to push the parameters
	                advanceActivatedRoute(future);
	                // If we have a normal route, we need to go through an outlet.
	                if (future.component) {
	                    var /** @type {?} */ outlet = getOutlet(parentOutletMap, future);
	                    this.activateChildRoutes(futureNode, currNode, outlet.outletMap);
	                }
	                else {
	                    this.activateChildRoutes(futureNode, currNode, parentOutletMap);
	                }
	            }
	            else {
	                // if we have a normal route, we need to advance the route
	                // and place the component into the outlet. After that recurse.
	                if (future.component) {
	                    advanceActivatedRoute(future);
	                    var /** @type {?} */ outlet = getOutlet(parentOutletMap, futureNode.value);
	                    if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
	                        var /** @type {?} */ stored = ((this.routeReuseStrategy.retrieve(future.snapshot)));
	                        this.routeReuseStrategy.store(future.snapshot, null);
	                        outlet.attach(stored.componentRef, stored.route.value);
	                        advanceActivatedRouteNodeAndItsChildren(stored.route);
	                    }
	                    else {
	                        var /** @type {?} */ outletMap = new RouterOutletMap();
	                        this.placeComponentIntoOutlet(outletMap, future, outlet);
	                        this.activateChildRoutes(futureNode, null, outletMap);
	                    }
	                }
	                else {
	                    advanceActivatedRoute(future);
	                    this.activateChildRoutes(futureNode, null, parentOutletMap);
	                }
	            }
	        };
	        /**
	         * @param {?} outletMap
	         * @param {?} future
	         * @param {?} outlet
	         * @return {?}
	         */
	        ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {
	            var /** @type {?} */ resolved = ([{ provide: ActivatedRoute, useValue: future }, {
	                    provide: RouterOutletMap,
	                    useValue: outletMap
	                }]);
	            var /** @type {?} */ config = parentLoadedConfig(future.snapshot);
	            var /** @type {?} */ resolver = null;
	            var /** @type {?} */ injector = null;
	            if (config) {
	                injector = config.injectorFactory(outlet.locationInjector);
	                resolver = config.factoryResolver;
	                resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: resolver });
	            }
	            else {
	                injector = outlet.locationInjector;
	                resolver = outlet.locationFactoryResolver;
	            }
	            outlet.activate(future, resolver, injector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);
	        };
	        /**
	         * @param {?} route
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {
	            if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
	                this.detachAndStoreRouteSubtree(route, parentOutletMap);
	            }
	            else {
	                this.deactiveRouteAndOutlet(route, parentOutletMap);
	            }
	        };
	        /**
	         * @param {?} route
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentOutletMap) {
	            var /** @type {?} */ outlet = getOutlet(parentOutletMap, route.value);
	            var /** @type {?} */ componentRef = outlet.detach();
	            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route });
	        };
	        /**
	         * @param {?} route
	         * @param {?} parentOutletMap
	         * @return {?}
	         */
	        ActivateRoutes.prototype.deactiveRouteAndOutlet = function (route, parentOutletMap) {
	            var _this = this;
	            var /** @type {?} */ prevChildren = nodeChildrenAsMap(route);
	            var /** @type {?} */ outlet = null;
	            // getOutlet throws when cannot find the right outlet,
	            // which can happen if an outlet was in an NgIf and was removed
	            try {
	                outlet = getOutlet(parentOutletMap, route.value);
	            }
	            catch (e) {
	                return;
	            }
	            var /** @type {?} */ childOutletMap = outlet.outletMap;
	            forEach(prevChildren, function (v, k) {
	                if (route.value.component) {
	                    _this.deactiveRouteAndItsChildren(v, childOutletMap);
	                }
	                else {
	                    _this.deactiveRouteAndItsChildren(v, parentOutletMap);
	                }
	            });
	            if (outlet && outlet.isActivated) {
	                outlet.deactivate();
	            }
	        };
	        return ActivateRoutes;
	    }());
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function advanceActivatedRouteNodeAndItsChildren(node) {
	        advanceActivatedRoute(node.value);
	        node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
	    }
	    /**
	     * @param {?} snapshot
	     * @return {?}
	     */
	    function parentLoadedConfig(snapshot) {
	        var /** @type {?} */ s = snapshot.parent;
	        while (s) {
	            var /** @type {?} */ c = s._routeConfig;
	            if (c && c._loadedConfig)
	                return c._loadedConfig;
	            if (c && c.component)
	                return null;
	            s = s.parent;
	        }
	        return null;
	    }
	    /**
	     * @param {?} snapshot
	     * @return {?}
	     */
	    function closestLoadedConfig(snapshot) {
	        if (!snapshot)
	            return null;
	        var /** @type {?} */ s = snapshot.parent;
	        while (s) {
	            var /** @type {?} */ c = s._routeConfig;
	            if (c && c._loadedConfig)
	                return c._loadedConfig;
	            s = s.parent;
	        }
	        return null;
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function nodeChildrenAsMap(node) {
	        return node ? node.children.reduce(function (m, c) {
	            m[c.value.outlet] = c;
	            return m;
	        }, {}) : {};
	    }
	    /**
	     * @param {?} outletMap
	     * @param {?} route
	     * @return {?}
	     */
	    function getOutlet(outletMap, route) {
	        var /** @type {?} */ outlet = outletMap._outlets[route.outlet];
	        if (!outlet) {
	            var /** @type {?} */ componentName = ((route.component)).name;
	            if (route.outlet === PRIMARY_OUTLET) {
	                throw new Error("Cannot find primary outlet to load '" + componentName + "'");
	            }
	            else {
	                throw new Error("Cannot find the outlet " + route.outlet + " to load '" + componentName + "'");
	            }
	        }
	        return outlet;
	    }
	    /**
	     * @param {?} commands
	     * @return {?}
	     */
	    function validateCommands(commands) {
	        for (var /** @type {?} */ i = 0; i < commands.length; i++) {
	            var /** @type {?} */ cmd = commands[i];
	            if (cmd == null) {
	                throw new Error("The requested path contains " + cmd + " segment at index " + i);
	            }
	        }
	    }

	    /**
	     * \@whatItDoes Lets you link to specific parts of your app.
	     *
	     * \@howToUse
	     *
	     * Consider the following route configuration:
	     * `[{ path: 'user/:name', component: UserCmp }]`
	     *
	     * When linking to this `user/:name` route, you can write:
	     * `<a routerLink='/user/bob'>link to user component</a>`
	     *
	     * \@description
	     *
	     * The RouterLink directives let you link to specific parts of your app.
	     *
	     * When the link is static, you can use the directive as follows:
	     * `<a routerLink="/user/bob">link to user component</a>`
	     *
	     * If you use dynamic values to generate the link, you can pass an array of path
	     * segments, followed by the params for each segment.
	     *
	     * For instance `['/team', teamId, 'user', userName, {details: true}]`
	     * means that we want to generate a link to `/team/11/user/bob;details=true`.
	     *
	     * Multiple static segments can be merged into one
	     * (e.g., `['/team/11/user', userName, {details: true}]`).
	     *
	     * The first segment name can be prepended with `/`, `./`, or `../`:
	     * * If the first segment begins with `/`, the router will look up the route from the root of the
	     *   app.
	     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
	     *   instead look in the children of the current activated route.
	     * * And if the first segment begins with `../`, the router will go up one level.
	     *
	     * You can set query params and fragment as follows:
	     *
	     * ```
	     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
	     *   link to user component
	     * </a>
	     * ```
	     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
	     *
	     * You can also tell the directive to preserve the current query params and fragment:
	     *
	     * ```
	     * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
	     *   link to user component
	     * </a>
	     * ```
	     *
	     * The router link directive always treats the provided input as a delta to the current url.
	     *
	     * For instance, if the current url is `/user/(box//aux:team)`.
	     *
	     * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
	     * `/user/(jim//aux:team)`.
	     *
	     * \@ngModule RouterModule
	     *
	     * See {\@link Router.createUrlTree} for more information.
	     *
	     * \@stable
	     */
	    var RouterLink = (function () {
	        /**
	         * @param {?} router
	         * @param {?} route
	         */
	        function RouterLink(router, route) {
	            this.router = router;
	            this.route = route;
	            this.commands = [];
	        }
	        Object.defineProperty(RouterLink.prototype, "routerLink", {
	            /**
	             * @param {?} commands
	             * @return {?}
	             */
	            set: function (commands) {
	                if (commands != null) {
	                    this.commands = Array.isArray(commands) ? commands : [commands];
	                }
	                else {
	                    this.commands = [];
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        RouterLink.prototype.onClick = function () {
	            var /** @type {?} */ extras = {
	                skipLocationChange: attrBoolValue(this.skipLocationChange),
	                replaceUrl: attrBoolValue(this.replaceUrl),
	            };
	            this.router.navigateByUrl(this.urlTree, extras);
	            return true;
	        };
	        Object.defineProperty(RouterLink.prototype, "urlTree", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this.router.createUrlTree(this.commands, {
	                    relativeTo: this.route,
	                    queryParams: this.queryParams,
	                    fragment: this.fragment,
	                    preserveQueryParams: attrBoolValue(this.preserveQueryParams),
	                    preserveFragment: attrBoolValue(this.preserveFragment),
	                });
	            },
	            enumerable: true,
	            configurable: true
	        });
	        RouterLink.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },
	        ];
	        /** @nocollapse */
	        RouterLink.ctorParameters = function () { return [
	            { type: Router, },
	            { type: ActivatedRoute, },
	        ]; };
	        RouterLink.propDecorators = {
	            'queryParams': [{ type: _angular_core.Input },],
	            'fragment': [{ type: _angular_core.Input },],
	            'preserveQueryParams': [{ type: _angular_core.Input },],
	            'preserveFragment': [{ type: _angular_core.Input },],
	            'skipLocationChange': [{ type: _angular_core.Input },],
	            'replaceUrl': [{ type: _angular_core.Input },],
	            'routerLink': [{ type: _angular_core.Input },],
	            'onClick': [{ type: _angular_core.HostListener, args: ['click',] },],
	        };
	        return RouterLink;
	    }());
	    /**
	     * \@whatItDoes Lets you link to specific parts of your app.
	     *
	     * See {\@link RouterLink} for more information.
	     *
	     * \@ngModule RouterModule
	     *
	     * \@stable
	     */
	    var RouterLinkWithHref = (function () {
	        /**
	         * @param {?} router
	         * @param {?} route
	         * @param {?} locationStrategy
	         */
	        function RouterLinkWithHref(router, route, locationStrategy) {
	            var _this = this;
	            this.router = router;
	            this.route = route;
	            this.locationStrategy = locationStrategy;
	            this.commands = [];
	            this.subscription = router.events.subscribe(function (s) {
	                if (s instanceof NavigationEnd) {
	                    _this.updateTargetUrlAndHref();
	                }
	            });
	        }
	        Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {
	            /**
	             * @param {?} commands
	             * @return {?}
	             */
	            set: function (commands) {
	                if (commands != null) {
	                    this.commands = Array.isArray(commands) ? commands : [commands];
	                }
	                else {
	                    this.commands = [];
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
	        /**
	         * @return {?}
	         */
	        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	        /**
	         * @param {?} button
	         * @param {?} ctrlKey
	         * @param {?} metaKey
	         * @return {?}
	         */
	        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {
	            if (button !== 0 || ctrlKey || metaKey) {
	                return true;
	            }
	            if (typeof this.target === 'string' && this.target != '_self') {
	                return true;
	            }
	            var /** @type {?} */ extras = {
	                skipLocationChange: attrBoolValue(this.skipLocationChange),
	                replaceUrl: attrBoolValue(this.replaceUrl),
	            };
	            this.router.navigateByUrl(this.urlTree, extras);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {
	            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
	        };
	        Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this.router.createUrlTree(this.commands, {
	                    relativeTo: this.route,
	                    queryParams: this.queryParams,
	                    fragment: this.fragment,
	                    preserveQueryParams: attrBoolValue(this.preserveQueryParams),
	                    preserveFragment: attrBoolValue(this.preserveFragment),
	                });
	            },
	            enumerable: true,
	            configurable: true
	        });
	        RouterLinkWithHref.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },
	        ];
	        /** @nocollapse */
	        RouterLinkWithHref.ctorParameters = function () { return [
	            { type: Router, },
	            { type: ActivatedRoute, },
	            { type: _angular_common.LocationStrategy, },
	        ]; };
	        RouterLinkWithHref.propDecorators = {
	            'target': [{ type: _angular_core.HostBinding, args: ['attr.target',] }, { type: _angular_core.Input },],
	            'queryParams': [{ type: _angular_core.Input },],
	            'fragment': [{ type: _angular_core.Input },],
	            'preserveQueryParams': [{ type: _angular_core.Input },],
	            'preserveFragment': [{ type: _angular_core.Input },],
	            'skipLocationChange': [{ type: _angular_core.Input },],
	            'replaceUrl': [{ type: _angular_core.Input },],
	            'href': [{ type: _angular_core.HostBinding },],
	            'routerLink': [{ type: _angular_core.Input },],
	            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],
	        };
	        return RouterLinkWithHref;
	    }());
	    /**
	     * @param {?} s
	     * @return {?}
	     */
	    function attrBoolValue(s) {
	        return s === '' || !!s;
	    }

	    /**
	     * \@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.
	     *
	     * \@howToUse
	     *
	     * ```
	     * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
	     * ```
	     *
	     * \@description
	     *
	     * The RouterLinkActive directive lets you add a CSS class to an element when the link's route
	     * becomes active.
	     *
	     * Consider the following example:
	     *
	     * ```
	     * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
	     * ```
	     *
	     * When the url is either '/user' or '/user/bob', the active-link class will
	     * be added to the `a` tag. If the url changes, the class will be removed.
	     *
	     * You can set more than one class, as follows:
	     *
	     * ```
	     * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
	     * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
	     * ```
	     *
	     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
	     * only when the url matches the link exactly.
	     *
	     * ```
	     * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
	     * true}">Bob</a>
	     * ```
	     *
	     * You can assign the RouterLinkActive instance to a template variable and directly check
	     * the `isActive` status.
	     * ```
	     * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
	     *   Bob {{ rla.isActive ? '(already open)' : ''}}
	     * </a>
	     * ```
	     *
	     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
	     *
	     * ```
	     * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
	     *   <a routerLink="/user/jim">Jim</a>
	     *   <a routerLink="/user/bob">Bob</a>
	     * </div>
	     * ```
	     *
	     * This will set the active-link class on the div tag if the url is either '/user/jim' or
	     * '/user/bob'.
	     *
	     * \@ngModule RouterModule
	     *
	     * \@stable
	     */
	    var RouterLinkActive = (function () {
	        /**
	         * @param {?} router
	         * @param {?} element
	         * @param {?} renderer
	         * @param {?} cdr
	         */
	        function RouterLinkActive(router, element, renderer, cdr) {
	            var _this = this;
	            this.router = router;
	            this.element = element;
	            this.renderer = renderer;
	            this.cdr = cdr;
	            this.classes = [];
	            this.active = false;
	            this.routerLinkActiveOptions = { exact: false };
	            this.subscription = router.events.subscribe(function (s) {
	                if (s instanceof NavigationEnd) {
	                    _this.update();
	                }
	            });
	        }
	        Object.defineProperty(RouterLinkActive.prototype, "isActive", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.active; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        RouterLinkActive.prototype.ngAfterContentInit = function () {
	            var _this = this;
	            this.links.changes.subscribe(function (_) { return _this.update(); });
	            this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
	            this.update();
	        };
	        Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
	            /**
	             * @param {?} data
	             * @return {?}
	             */
	            set: function (data) {
	                var /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');
	                this.classes = classes.filter(function (c) { return !!c; });
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
	        /**
	         * @return {?}
	         */
	        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	        /**
	         * @return {?}
	         */
	        RouterLinkActive.prototype.update = function () {
	            var _this = this;
	            if (!this.links || !this.linksWithHrefs || !this.router.navigated)
	                return;
	            var /** @type {?} */ hasActiveLinks = this.hasActiveLinks();
	            // react only when status has changed to prevent unnecessary dom updates
	            if (this.active !== hasActiveLinks) {
	                this.active = hasActiveLinks;
	                this.classes.forEach(function (c) { return _this.renderer.setElementClass(_this.element.nativeElement, c, hasActiveLinks); });
	                this.cdr.detectChanges();
	            }
	        };
	        /**
	         * @param {?} router
	         * @return {?}
	         */
	        RouterLinkActive.prototype.isLinkActive = function (router) {
	            var _this = this;
	            return function (link) {
	                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);
	            };
	        };
	        /**
	         * @return {?}
	         */
	        RouterLinkActive.prototype.hasActiveLinks = function () {
	            return this.links.some(this.isLinkActive(this.router)) ||
	                this.linksWithHrefs.some(this.isLinkActive(this.router));
	        };
	        RouterLinkActive.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[routerLinkActive]',
	                        exportAs: 'routerLinkActive',
	                    },] },
	        ];
	        /** @nocollapse */
	        RouterLinkActive.ctorParameters = function () { return [
	            { type: Router, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ChangeDetectorRef, },
	        ]; };
	        RouterLinkActive.propDecorators = {
	            'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],
	            'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],
	            'routerLinkActiveOptions': [{ type: _angular_core.Input },],
	            'routerLinkActive': [{ type: _angular_core.Input },],
	        };
	        return RouterLinkActive;
	    }());

	    /**
	     * \@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router
	     * state.
	     *
	     * \@howToUse
	     *
	     * ```
	     * <router-outlet></router-outlet>
	     * <router-outlet name='left'></router-outlet>
	     * <router-outlet name='right'></router-outlet>
	     * ```
	     *
	     * A router outlet will emit an activate event any time a new component is being instantiated,
	     * and a deactivate event when it is being destroyed.
	     *
	     * ```
	     * <router-outlet
	     *   (activate)='onActivate($event)'
	     *   (deactivate)='onDeactivate($event)'></router-outlet>
	     * ```
	     * \@ngModule RouterModule
	     *
	     * \@stable
	     */
	    var RouterOutlet = (function () {
	        /**
	         * @param {?} parentOutletMap
	         * @param {?} location
	         * @param {?} resolver
	         * @param {?} name
	         */
	        function RouterOutlet(parentOutletMap, location, resolver, name) {
	            this.parentOutletMap = parentOutletMap;
	            this.location = location;
	            this.resolver = resolver;
	            this.name = name;
	            this.activateEvents = new _angular_core.EventEmitter();
	            this.deactivateEvents = new _angular_core.EventEmitter();
	            parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);
	        }
	        /**
	         * @return {?}
	         */
	        RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };
	        Object.defineProperty(RouterOutlet.prototype, "locationInjector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.location.injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RouterOutlet.prototype, "locationFactoryResolver", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.resolver; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RouterOutlet.prototype, "isActivated", {
	            /**
	             * @return {?}
	             */
	            get: function () { return !!this.activated; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RouterOutlet.prototype, "component", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                if (!this.activated)
	                    throw new Error('Outlet is not activated');
	                return this.activated.instance;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                if (!this.activated)
	                    throw new Error('Outlet is not activated');
	                return this._activatedRoute;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        RouterOutlet.prototype.detach = function () {
	            if (!this.activated)
	                throw new Error('Outlet is not activated');
	            this.location.detach();
	            var /** @type {?} */ r = this.activated;
	            this.activated = null;
	            this._activatedRoute = null;
	            return r;
	        };
	        /**
	         * @param {?} ref
	         * @param {?} activatedRoute
	         * @return {?}
	         */
	        RouterOutlet.prototype.attach = function (ref, activatedRoute) {
	            this.activated = ref;
	            this._activatedRoute = activatedRoute;
	            this.location.insert(ref.hostView);
	        };
	        /**
	         * @return {?}
	         */
	        RouterOutlet.prototype.deactivate = function () {
	            if (this.activated) {
	                var /** @type {?} */ c = this.component;
	                this.activated.destroy();
	                this.activated = null;
	                this._activatedRoute = null;
	                this.deactivateEvents.emit(c);
	            }
	        };
	        /**
	         * @param {?} activatedRoute
	         * @param {?} resolver
	         * @param {?} injector
	         * @param {?} providers
	         * @param {?} outletMap
	         * @return {?}
	         */
	        RouterOutlet.prototype.activate = function (activatedRoute, resolver, injector, providers, outletMap) {
	            if (this.isActivated) {
	                throw new Error('Cannot activate an already activated outlet');
	            }
	            this.outletMap = outletMap;
	            this._activatedRoute = activatedRoute;
	            var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;
	            var /** @type {?} */ component = (snapshot._routeConfig.component);
	            var /** @type {?} */ factory = resolver.resolveComponentFactory(component);
	            var /** @type {?} */ inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);
	            this.activated = this.location.createComponent(factory, this.location.length, inj, []);
	            this.activated.changeDetectorRef.detectChanges();
	            this.activateEvents.emit(this.activated.instance);
	        };
	        RouterOutlet.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },
	        ];
	        /** @nocollapse */
	        RouterOutlet.ctorParameters = function () { return [
	            { type: RouterOutletMap, },
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.ComponentFactoryResolver, },
	            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },
	        ]; };
	        RouterOutlet.propDecorators = {
	            'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],
	            'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],
	        };
	        return RouterOutlet;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * \@whatItDoes Provides a way to customize when activated routes get reused.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var RouteReuseStrategy = (function () {
	        function RouteReuseStrategy() {
	        }
	        /**
	         * Determines if this route (and its subtree) should be detached to be reused later
	         * @abstract
	         * @param {?} route
	         * @return {?}
	         */
	        RouteReuseStrategy.prototype.shouldDetach = function (route) { };
	        /**
	         * Stores the detached route
	         * @abstract
	         * @param {?} route
	         * @param {?} handle
	         * @return {?}
	         */
	        RouteReuseStrategy.prototype.store = function (route, handle) { };
	        /**
	         * Determines if this route (and its subtree) should be reattached
	         * @abstract
	         * @param {?} route
	         * @return {?}
	         */
	        RouteReuseStrategy.prototype.shouldAttach = function (route) { };
	        /**
	         * Retrieves the previously stored route
	         * @abstract
	         * @param {?} route
	         * @return {?}
	         */
	        RouteReuseStrategy.prototype.retrieve = function (route) { };
	        /**
	         * Determines if a route should be reused
	         * @abstract
	         * @param {?} future
	         * @param {?} curr
	         * @return {?}
	         */
	        RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };
	        return RouteReuseStrategy;
	    }());

	    var /** @type {?} */ getDOM = _angular_platformBrowser.__platform_browser_private__.getDOM;

	    /**
	     * \@whatItDoes Provides a preloading strategy.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var PreloadingStrategy = (function () {
	        function PreloadingStrategy() {
	        }
	        /**
	         * @abstract
	         * @param {?} route
	         * @param {?} fn
	         * @return {?}
	         */
	        PreloadingStrategy.prototype.preload = function (route, fn) { };
	        return PreloadingStrategy;
	    }());
	    /**
	     * \@whatItDoes Provides a preloading strategy that preloads all modules as quicky as possible.
	     *
	     * \@howToUse
	     *
	     * ```
	     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
	     * ```
	     *
	     * \@experimental
	     */
	    var PreloadAllModules = (function () {
	        function PreloadAllModules() {
	        }
	        /**
	         * @param {?} route
	         * @param {?} fn
	         * @return {?}
	         */
	        PreloadAllModules.prototype.preload = function (route, fn) {
	            return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });
	        };
	        return PreloadAllModules;
	    }());
	    /**
	     * \@whatItDoes Provides a preloading strategy that does not preload any modules.
	     *
	     * \@description
	     *
	     * This strategy is enabled by default.
	     *
	     * \@experimental
	     */
	    var NoPreloading = (function () {
	        function NoPreloading() {
	        }
	        /**
	         * @param {?} route
	         * @param {?} fn
	         * @return {?}
	         */
	        NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };
	        return NoPreloading;
	    }());
	    /**
	     * The preloader optimistically loads all router configurations to
	     * make navigations into lazily-loaded sections of the application faster.
	     *
	     * The preloader runs in the background. When the router bootstraps, the preloader
	     * starts listening to all navigation events. After every such event, the preloader
	     * will check if any configurations can be loaded lazily.
	     *
	     * If a route is protected by `canLoad` guards, the preloaded will not load it.
	     *
	     * \@stable
	     */
	    var RouterPreloader = (function () {
	        /**
	         * @param {?} router
	         * @param {?} moduleLoader
	         * @param {?} compiler
	         * @param {?} injector
	         * @param {?} preloadingStrategy
	         */
	        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
	            this.router = router;
	            this.injector = injector;
	            this.preloadingStrategy = preloadingStrategy;
	            this.loader = new RouterConfigLoader(moduleLoader, compiler);
	        }
	        ;
	        /**
	         * @return {?}
	         */
	        RouterPreloader.prototype.setUpPreloading = function () {
	            var _this = this;
	            var /** @type {?} */ navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });
	            this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });
	        };
	        /**
	         * @return {?}
	         */
	        RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };
	        /**
	         * @return {?}
	         */
	        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	        /**
	         * @param {?} injector
	         * @param {?} routes
	         * @return {?}
	         */
	        RouterPreloader.prototype.processRoutes = function (injector, routes) {
	            var /** @type {?} */ res = [];
	            for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
	                var c = routes_1[_i];
	                // we already have the config loaded, just recurse
	                if (c.loadChildren && !c.canLoad && ((c))._loadedConfig) {
	                    var /** @type {?} */ childConfig = ((c))._loadedConfig;
	                    res.push(this.processRoutes(childConfig.injector, childConfig.routes));
	                }
	                else if (c.loadChildren && !c.canLoad) {
	                    res.push(this.preloadConfig(injector, c));
	                }
	                else if (c.children) {
	                    res.push(this.processRoutes(injector, c.children));
	                }
	            }
	            return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));
	        };
	        /**
	         * @param {?} injector
	         * @param {?} route
	         * @return {?}
	         */
	        RouterPreloader.prototype.preloadConfig = function (injector, route) {
	            var _this = this;
	            return this.preloadingStrategy.preload(route, function () {
	                var /** @type {?} */ loaded = _this.loader.load(injector, route.loadChildren);
	                return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {
	                    var /** @type {?} */ c = route;
	                    c._loadedConfig = config;
	                    return _this.processRoutes(config.injector, config.routes);
	                });
	            });
	        };
	        RouterPreloader.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RouterPreloader.ctorParameters = function () { return [
	            { type: Router, },
	            { type: _angular_core.NgModuleFactoryLoader, },
	            { type: _angular_core.Compiler, },
	            { type: _angular_core.Injector, },
	            { type: PreloadingStrategy, },
	        ]; };
	        return RouterPreloader;
	    }());

	    /**
	     * @whatItDoes Contains a list of directives
	     * @stable
	     */
	    var /** @type {?} */ ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];
	    /**
	     * @whatItDoes Is used in DI to configure the router.
	     * @stable
	     */
	    var /** @type {?} */ ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');
	    /**
	     * @docsNotRequired
	     */
	    var /** @type {?} */ ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');
	    var /** @type {?} */ ROUTER_PROVIDERS = [
	        _angular_common.Location,
	        { provide: UrlSerializer, useClass: DefaultUrlSerializer },
	        {
	            provide: Router,
	            useFactory: setupRouter,
	            deps: [
	                _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,
	                _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new _angular_core.Optional()],
	                [RouteReuseStrategy, new _angular_core.Optional()]
	            ]
	        },
	        RouterOutletMap,
	        { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
	        { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader },
	        RouterPreloader,
	        NoPreloading,
	        PreloadAllModules,
	        { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },
	    ];
	    /**
	     * @return {?}
	     */
	    function routerNgProbeToken() {
	        return new _angular_core.NgProbeToken('Router', Router);
	    }
	    /**
	     * \@whatItDoes Adds router directives and providers.
	     *
	     * \@howToUse
	     *
	     * RouterModule can be imported multiple times: once per lazily-loaded bundle.
	     * Since the router deals with a global shared resource--location, we cannot have
	     * more than one router service active.
	     *
	     * That is why there are two ways to create the module: `RouterModule.forRoot` and
	     * `RouterModule.forChild`.
	     *
	     * * `forRoot` creates a module that contains all the directives, the given routes, and the router
	     *   service itself.
	     * * `forChild` creates a module that contains all the directives and the given routes, but does not
	     *   include the router service.
	     *
	     * When registered at the root, the module should be used as follows
	     *
	     * ```
	     * \@NgModule({
	     *   imports: [RouterModule.forRoot(ROUTES)]
	     * })
	     * class MyNgModule {}
	     * ```
	     *
	     * For submodules and lazy loaded submodules the module should be used as follows:
	     *
	     * ```
	     * \@NgModule({
	     *   imports: [RouterModule.forChild(ROUTES)]
	     * })
	     * class MyNgModule {}
	     * ```
	     *
	     * \@description
	     *
	     * Managing state transitions is one of the hardest parts of building applications. This is
	     * especially true on the web, where you also need to ensure that the state is reflected in the URL.
	     * In addition, we often want to split applications into multiple bundles and load them on demand.
	     * Doing this transparently is not trivial.
	     *
	     * The Angular 2 router solves these problems. Using the router, you can declaratively specify
	     * application states, manage state transitions while taking care of the URL, and load bundles on
	     * demand.
	     *
	     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
	     * overview of how the router should be used.
	     *
	     * \@stable
	     */
	    var RouterModule = (function () {
	        /**
	         * @param {?} guard
	         */
	        function RouterModule(guard) {
	        }
	        /**
	         * Creates a module with all the router providers and directives. It also optionally sets up an
	         * application listener to perform an initial navigation.
	         *
	         * Options:
	         * * `enableTracing` makes the router log all its internal events to the console.
	         * * `useHash` enables the location strategy that uses the URL fragment instead of the history
	         * API.
	         * * `initialNavigation` disables the initial navigation.
	         * * `errorHandler` provides a custom error handler.
	         * @param {?} routes
	         * @param {?=} config
	         * @return {?}
	         */
	        RouterModule.forRoot = function (routes, config) {
	            return {
	                ngModule: RouterModule,
	                providers: [
	                    ROUTER_PROVIDERS,
	                    provideRoutes(routes),
	                    {
	                        provide: ROUTER_FORROOT_GUARD,
	                        useFactory: provideForRootGuard,
	                        deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]
	                    },
	                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
	                    {
	                        provide: _angular_common.LocationStrategy,
	                        useFactory: provideLocationStrategy,
	                        deps: [
	                            _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION
	                        ]
	                    },
	                    {
	                        provide: PreloadingStrategy,
	                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :
	                            NoPreloading
	                    },
	                    { provide: _angular_core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },
	                    provideRouterInitializer(),
	                ],
	            };
	        };
	        /**
	         * Creates a module with all the router directives and a provider registering routes.
	         * @param {?} routes
	         * @return {?}
	         */
	        RouterModule.forChild = function (routes) {
	            return { ngModule: RouterModule, providers: [provideRoutes(routes)] };
	        };
	        RouterModule.decorators = [
	            { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },
	        ];
	        /** @nocollapse */
	        RouterModule.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },
	        ]; };
	        return RouterModule;
	    }());
	    /**
	     * @param {?} platformLocationStrategy
	     * @param {?} baseHref
	     * @param {?=} options
	     * @return {?}
	     */
	    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
	        if (options === void 0) { options = {}; }
	        return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :
	            new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);
	    }
	    /**
	     * @param {?} router
	     * @return {?}
	     */
	    function provideForRootGuard(router) {
	        if (router) {
	            throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
	        }
	        return 'guarded';
	    }
	    /**
	     * \@whatItDoes Registers routes.
	     *
	     * \@howToUse
	     *
	     * ```
	     * \@NgModule({
	     *   imports: [RouterModule.forChild(ROUTES)],
	     *   providers: [provideRoutes(EXTRA_ROUTES)]
	     * })
	     * class MyNgModule {}
	     * ```
	     *
	     * \@stable
	     * @param {?} routes
	     * @return {?}
	     */
	    function provideRoutes(routes) {
	        return [
	            { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
	            { provide: ROUTES, multi: true, useValue: routes },
	        ];
	    }
	    /**
	     * @param {?} ref
	     * @param {?} urlSerializer
	     * @param {?} outletMap
	     * @param {?} location
	     * @param {?} injector
	     * @param {?} loader
	     * @param {?} compiler
	     * @param {?} config
	     * @param {?=} opts
	     * @param {?=} urlHandlingStrategy
	     * @param {?=} routeReuseStrategy
	     * @return {?}
	     */
	    function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
	        if (opts === void 0) { opts = {}; }
	        var /** @type {?} */ router = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));
	        if (urlHandlingStrategy) {
	            router.urlHandlingStrategy = urlHandlingStrategy;
	        }
	        if (routeReuseStrategy) {
	            router.routeReuseStrategy = routeReuseStrategy;
	        }
	        if (opts.errorHandler) {
	            router.errorHandler = opts.errorHandler;
	        }
	        if (opts.enableTracing) {
	            var /** @type {?} */ dom_1 = getDOM();
	            router.events.subscribe(function (e) {
	                dom_1.logGroup("Router Event: " + ((e.constructor)).name);
	                dom_1.log(e.toString());
	                dom_1.log(e);
	                dom_1.logGroupEnd();
	            });
	        }
	        return router;
	    }
	    /**
	     * @param {?} router
	     * @return {?}
	     */
	    function rootRoute(router) {
	        return router.routerState.root;
	    }
	    /**
	     * To initialize the router properly we need to do in two steps:
	     *
	     * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
	     * a resolver or a guards executes asynchronously. Second, we need to actually run
	     * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
	     * hook provided by the router to do that.
	     *
	     * The router navigation starts, reaches the point when preactivation is done, and then
	     * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
	     */
	    var RouterInitializer = (function () {
	        /**
	         * @param {?} injector
	         */
	        function RouterInitializer(injector) {
	            this.injector = injector;
	            this.initNavigation = false;
	            this.resultOfPreactivationDone = new rxjs_Subject.Subject();
	        }
	        /**
	         * @return {?}
	         */
	        RouterInitializer.prototype.appInitializer = function () {
	            var _this = this;
	            var /** @type {?} */ p = this.injector.get(_angular_common.LOCATION_INITIALIZED, Promise.resolve(null));
	            return p.then(function () {
	                var /** @type {?} */ resolve = null;
	                var /** @type {?} */ res = new Promise(function (r) { return resolve = r; });
	                var /** @type {?} */ router = _this.injector.get(Router);
	                var /** @type {?} */ opts = _this.injector.get(ROUTER_CONFIGURATION);
	                if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
	                    resolve(true);
	                }
	                else if (opts.initialNavigation === 'disabled') {
	                    router.setUpLocationChangeListener();
	                    resolve(true);
	                }
	                else if (opts.initialNavigation === 'enabled') {
	                    router.hooks.afterPreactivation = function () {
	                        // only the initial navigation should be delayed
	                        if (!_this.initNavigation) {
	                            _this.initNavigation = true;
	                            resolve(true);
	                            return _this.resultOfPreactivationDone;
	                        }
	                        else {
	                            return rxjs_observable_of.of(null);
	                        }
	                    };
	                    router.initialNavigation();
	                }
	                else {
	                    throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
	                }
	                return res;
	            });
	        };
	        /**
	         * @param {?} bootstrappedComponentRef
	         * @return {?}
	         */
	        RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
	            var /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);
	            var /** @type {?} */ preloader = this.injector.get(RouterPreloader);
	            var /** @type {?} */ router = this.injector.get(Router);
	            var /** @type {?} */ ref = this.injector.get(_angular_core.ApplicationRef);
	            if (bootstrappedComponentRef !== ref.components[0]) {
	                return;
	            }
	            if (this.isLegacyEnabled(opts)) {
	                router.initialNavigation();
	            }
	            else if (this.isLegacyDisabled(opts)) {
	                router.setUpLocationChangeListener();
	            }
	            preloader.setUpPreloading();
	            router.resetRootComponentType(ref.componentTypes[0]);
	            this.resultOfPreactivationDone.next(null);
	            this.resultOfPreactivationDone.complete();
	        };
	        /**
	         * @param {?} opts
	         * @return {?}
	         */
	        RouterInitializer.prototype.isLegacyEnabled = function (opts) {
	            return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||
	                opts.initialNavigation === undefined;
	        };
	        /**
	         * @param {?} opts
	         * @return {?}
	         */
	        RouterInitializer.prototype.isLegacyDisabled = function (opts) {
	            return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
	        };
	        RouterInitializer.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RouterInitializer.ctorParameters = function () { return [
	            { type: _angular_core.Injector, },
	        ]; };
	        return RouterInitializer;
	    }());
	    /**
	     * @param {?} r
	     * @return {?}
	     */
	    function getAppInitializer(r) {
	        return r.appInitializer.bind(r);
	    }
	    /**
	     * @param {?} r
	     * @return {?}
	     */
	    function getBootstrapListener(r) {
	        return r.bootstrapListener.bind(r);
	    }
	    /**
	     * A token for the router initializer that will be called after the app is bootstrapped.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ ROUTER_INITIALIZER = new _angular_core.OpaqueToken('Router Initializer');
	    /**
	     * @return {?}
	     */
	    function provideRouterInitializer() {
	        return [
	            RouterInitializer,
	            {
	                provide: _angular_core.APP_INITIALIZER,
	                multi: true,
	                useFactory: getAppInitializer,
	                deps: [RouterInitializer]
	            },
	            { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
	            { provide: _angular_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },
	        ];
	    }

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('3.4.10');

	    var /** @type {?} */ __router_private__ = {
	        ROUTER_PROVIDERS: ROUTER_PROVIDERS,
	        ROUTES: ROUTES,
	        flatten: flatten,
	    };

	    exports.RouterLink = RouterLink;
	    exports.RouterLinkWithHref = RouterLinkWithHref;
	    exports.RouterLinkActive = RouterLinkActive;
	    exports.RouterOutlet = RouterOutlet;
	    exports.RouteReuseStrategy = RouteReuseStrategy;
	    exports.NavigationCancel = NavigationCancel;
	    exports.NavigationEnd = NavigationEnd;
	    exports.NavigationError = NavigationError;
	    exports.NavigationStart = NavigationStart;
	    exports.Router = Router;
	    exports.RoutesRecognized = RoutesRecognized;
	    exports.ROUTER_CONFIGURATION = ROUTER_CONFIGURATION;
	    exports.ROUTER_INITIALIZER = ROUTER_INITIALIZER;
	    exports.RouterModule = RouterModule;
	    exports.provideRoutes = provideRoutes;
	    exports.RouterOutletMap = RouterOutletMap;
	    exports.NoPreloading = NoPreloading;
	    exports.PreloadAllModules = PreloadAllModules;
	    exports.PreloadingStrategy = PreloadingStrategy;
	    exports.RouterPreloader = RouterPreloader;
	    exports.ActivatedRoute = ActivatedRoute;
	    exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;
	    exports.RouterState = RouterState;
	    exports.RouterStateSnapshot = RouterStateSnapshot;
	    exports.PRIMARY_OUTLET = PRIMARY_OUTLET;
	    exports.UrlHandlingStrategy = UrlHandlingStrategy;
	    exports.DefaultUrlSerializer = DefaultUrlSerializer;
	    exports.UrlSegment = UrlSegment;
	    exports.UrlSegmentGroup = UrlSegmentGroup;
	    exports.UrlSerializer = UrlSerializer;
	    exports.UrlTree = UrlTree;
	    exports.VERSION = VERSION;
	    exports.__router_private__ = __router_private__;

	}));

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var ObjectUnsubscribedError_1 = __webpack_require__(19);
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.closed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasError) {
	            throw this.thrownError;
	        }
	        else if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return this._value;
	        }
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, this._value = value);
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	exports.BehaviorSubject = BehaviorSubject;
	//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var FromObservable_1 = __webpack_require__(94);
	exports.from = FromObservable_1.FromObservable.create;
	//# sourceMappingURL=from.js.map

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(12);
	var isPromise_1 = __webpack_require__(40);
	var PromiseObservable_1 = __webpack_require__(64);
	var IteratorObservable_1 = __webpack_require__(95);
	var ArrayObservable_1 = __webpack_require__(29);
	var ArrayLikeObservable_1 = __webpack_require__(96);
	var iterator_1 = __webpack_require__(41);
	var Observable_1 = __webpack_require__(7);
	var observeOn_1 = __webpack_require__(97);
	var observable_1 = __webpack_require__(4);
	var isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromObservable = (function (_super) {
	    __extends(FromObservable, _super);
	    function FromObservable(ish, scheduler) {
	        _super.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable from an Array, an array-like object, a Promise, an
	     * iterable object, or an Observable-like object.
	     *
	     * <span class="informal">Converts almost anything to an Observable.</span>
	     *
	     * <img src="./img/from.png" width="100%">
	     *
	     * Convert various other objects and data types into Observables. `from`
	     * converts a Promise or an array-like or an
	     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	     * object into an Observable that emits the items in that promise or array or
	     * iterable. A String, in this context, is treated as an array of characters.
	     * Observable-like objects (contains a function named with the ES2015 Symbol
	     * for Observable) can also be converted through this operator.
	     *
	     * @example <caption>Converts an array to an Observable</caption>
	     * var array = [10, 20, 30];
	     * var result = Rx.Observable.from(array);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 10 20 30
	     *
	     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
	     * function* generateDoubles(seed) {
	     *   var i = seed;
	     *   while (true) {
	     *     yield i;
	     *     i = 2 * i; // double it
	     *   }
	     * }
	     *
	     * var iterator = generateDoubles(3);
	     * var result = Rx.Observable.from(iterator).take(10);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 3 6 12 24 48 96 192 384 768 1536
	     *
	     * @see {@link create}
	     * @see {@link fromEvent}
	     * @see {@link fromEventPattern}
	     * @see {@link fromPromise}
	     *
	     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
	     * Observable-like, an Array, an iterable or an array-like object to be
	     * converted.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * emissions of values.
	     * @return {Observable<T>} The Observable whose values are originally from the
	     * input object that was converted.
	     * @static true
	     * @name from
	     * @owner Observable
	     */
	    FromObservable.create = function (ish, scheduler) {
	        if (ish != null) {
	            if (typeof ish[observable_1.$$observable] === 'function') {
	                if (ish instanceof Observable_1.Observable && !scheduler) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            }
	            else if (isArray_1.isArray(ish)) {
	                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
	            }
	            else if (isPromise_1.isPromise(ish)) {
	                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
	            }
	            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
	                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
	            }
	            else if (isArrayLike(ish)) {
	                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
	            }
	        }
	        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
	    };
	    FromObservable.prototype._subscribe = function (subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            return ish[observable_1.$$observable]().subscribe(subscriber);
	        }
	        else {
	            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	    return FromObservable;
	}(Observable_1.Observable));
	exports.FromObservable = FromObservable;
	//# sourceMappingURL=FromObservable.js.map

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(5);
	var Observable_1 = __webpack_require__(7);
	var iterator_1 = __webpack_require__(41);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IteratorObservable = (function (_super) {
	    __extends(IteratorObservable, _super);
	    function IteratorObservable(iterator, scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        this.iterator = getIterator(iterator);
	    }
	    IteratorObservable.create = function (iterator, scheduler) {
	        return new IteratorObservable(iterator, scheduler);
	    };
	    IteratorObservable.dispatch = function (state) {
	        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(result.value);
	        state.index = index + 1;
	        if (subscriber.closed) {
	            if (typeof iterator.return === 'function') {
	                iterator.return();
	            }
	            return;
	        }
	        this.schedule(state);
	    };
	    IteratorObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, iterator: iterator, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                }
	                else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.closed) {
	                    if (typeof iterator.return === 'function') {
	                        iterator.return();
	                    }
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return IteratorObservable;
	}(Observable_1.Observable));
	exports.IteratorObservable = IteratorObservable;
	var StringIterator = (function () {
	    function StringIterator(str, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = str.length; }
	        this.str = str;
	        this.idx = idx;
	        this.len = len;
	    }
	    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };
	    StringIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return StringIterator;
	}());
	var ArrayIterator = (function () {
	    function ArrayIterator(arr, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = toLength(arr); }
	        this.arr = arr;
	        this.idx = idx;
	        this.len = len;
	    }
	    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };
	    ArrayIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return ArrayIterator;
	}());
	function getIterator(obj) {
	    var i = obj[iterator_1.$$iterator];
	    if (!i && typeof obj === 'string') {
	        return new StringIterator(obj);
	    }
	    if (!i && obj.length !== undefined) {
	        return new ArrayIterator(obj);
	    }
	    if (!i) {
	        throw new TypeError('object is not iterable');
	    }
	    return obj[iterator_1.$$iterator]();
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && root_1.root.isFinite(value);
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	//# sourceMappingURL=IteratorObservable.js.map

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var ScalarObservable_1 = __webpack_require__(30);
	var EmptyObservable_1 = __webpack_require__(31);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayLikeObservable = (function (_super) {
	    __extends(ArrayLikeObservable, _super);
	    function ArrayLikeObservable(arrayLike, scheduler) {
	        _super.call(this);
	        this.arrayLike = arrayLike;
	        this.scheduler = scheduler;
	        if (!scheduler && arrayLike.length === 1) {
	            this._isScalar = true;
	            this.value = arrayLike[0];
	        }
	    }
	    ArrayLikeObservable.create = function (arrayLike, scheduler) {
	        var length = arrayLike.length;
	        if (length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        else if (length === 1) {
	            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
	        }
	        else {
	            return new ArrayLikeObservable(arrayLike, scheduler);
	        }
	    };
	    ArrayLikeObservable.dispatch = function (state) {
	        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
	        if (subscriber.closed) {
	            return;
	        }
	        if (index >= length) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(arrayLike[index]);
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
	        var length = arrayLike.length;
	        if (scheduler) {
	            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
	                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < length && !subscriber.closed; i++) {
	                subscriber.next(arrayLike[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayLikeObservable;
	}(Observable_1.Observable));
	exports.ArrayLikeObservable = ArrayLikeObservable;
	//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var Notification_1 = __webpack_require__(98);
	/**
	 * @see {@link Notification}
	 *
	 * @param scheduler
	 * @param delay
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method observeOn
	 * @owner Observable
	 */
	function observeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new ObserveOnOperator(scheduler, delay));
	}
	exports.observeOn = observeOn;
	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
	    };
	    return ObserveOnOperator;
	}());
	exports.ObserveOnOperator = ObserveOnOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ObserveOnSubscriber = (function (_super) {
	    __extends(ObserveOnSubscriber, _super);
	    function ObserveOnSubscriber(destination, scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnSubscriber.dispatch = function (arg) {
	        var notification = arg.notification, destination = arg.destination, subscription = arg.subscription;
	        notification.observe(destination);
	        if (subscription) {
	            subscription.unsubscribe();
	        }
	    };
	    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	        var message = new ObserveOnMessage(notification, this.destination);
	        message.subscription = this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, message));
	    };
	    ObserveOnSubscriber.prototype._next = function (value) {
	        this.scheduleMessage(Notification_1.Notification.createNext(value));
	    };
	    ObserveOnSubscriber.prototype._error = function (err) {
	        this.scheduleMessage(Notification_1.Notification.createError(err));
	    };
	    ObserveOnSubscriber.prototype._complete = function () {
	        this.scheduleMessage(Notification_1.Notification.createComplete());
	    };
	    return ObserveOnSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ObserveOnSubscriber = ObserveOnSubscriber;
	var ObserveOnMessage = (function () {
	    function ObserveOnMessage(notification, destination) {
	        this.notification = notification;
	        this.destination = destination;
	    }
	    return ObserveOnMessage;
	}());
	exports.ObserveOnMessage = ObserveOnMessage;
	//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	/**
	 * Represents a push-based event or value that an {@link Observable} can emit.
	 * This class is particularly useful for operators that manage notifications,
	 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
	 * others. Besides wrapping the actual delivered value, it also annotates it
	 * with metadata of, for instance, what type of push message it is (`next`,
	 * `error`, or `complete`).
	 *
	 * @see {@link materialize}
	 * @see {@link dematerialize}
	 * @see {@link observeOn}
	 *
	 * @class Notification<T>
	 */
	var Notification = (function () {
	    function Notification(kind, value, error) {
	        this.kind = kind;
	        this.value = value;
	        this.error = error;
	        this.hasValue = kind === 'N';
	    }
	    /**
	     * Delivers to the given `observer` the value wrapped by this Notification.
	     * @param {Observer} observer
	     * @return
	     */
	    Notification.prototype.observe = function (observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next && observer.next(this.value);
	            case 'E':
	                return observer.error && observer.error(this.error);
	            case 'C':
	                return observer.complete && observer.complete();
	        }
	    };
	    /**
	     * Given some {@link Observer} callbacks, deliver the value represented by the
	     * current Notification to the correctly corresponding callback.
	     * @param {function(value: T): void} next An Observer `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.do = function (next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next && next(this.value);
	            case 'E':
	                return error && error(this.error);
	            case 'C':
	                return complete && complete();
	        }
	    };
	    /**
	     * Takes an Observer or its individual callback functions, and calls `observe`
	     * or `do` methods accordingly.
	     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
	     * the `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        }
	        else {
	            return this.do(nextOrObserver, error, complete);
	        }
	    };
	    /**
	     * Returns a simple Observable that just delivers the notification represented
	     * by this Notification instance.
	     * @return {any}
	     */
	    Notification.prototype.toObservable = function () {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return Observable_1.Observable.of(this.value);
	            case 'E':
	                return Observable_1.Observable.throw(this.error);
	            case 'C':
	                return Observable_1.Observable.empty();
	        }
	        throw new Error('unexpected notification kind value');
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `next` from a
	     * given value.
	     * @param {T} value The `next` value.
	     * @return {Notification<T>} The "next" Notification representing the
	     * argument.
	     */
	    Notification.createNext = function (value) {
	        if (typeof value !== 'undefined') {
	            return new Notification('N', value);
	        }
	        return this.undefinedValueNotification;
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `error` from a
	     * given error.
	     * @param {any} [err] The `error` error.
	     * @return {Notification<T>} The "error" Notification representing the
	     * argument.
	     */
	    Notification.createError = function (err) {
	        return new Notification('E', undefined, err);
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `complete`.
	     * @return {Notification<any>} The valueless "complete" Notification.
	     */
	    Notification.createComplete = function () {
	        return this.completeNotification;
	    };
	    Notification.completeNotification = new Notification('C');
	    Notification.undefinedValueNotification = new Notification('N', undefined);
	    return Notification;
	}());
	exports.Notification = Notification;
	//# sourceMappingURL=Notification.js.map

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMap_1 = __webpack_require__(100);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, in a serialized fashion waiting for each one to complete before
	 * merging the next.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link concatAll}.</span>
	 *
	 * <img src="./img/concatMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each new inner Observable is
	 * concatenated with the previous inner Observable.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMapTo}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} an observable of values merged from the projected
	 * Observables as they were subscribed to, one at a time. Optionally, these
	 * values may have been projected from a passed `projectResult` argument.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking values from each projected inner
	 * Observable sequentially.
	 * @method concatMap
	 * @owner Observable
	 */
	function concatMap(project, resultSelector) {
	    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
	}
	exports.concatMap = concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link mergeAll}.</span>
	 *
	 * <img src="./img/mergeMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger.
	 *
	 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
	 * var letters = Rx.Observable.of('a', 'b', 'c');
	 * var result = letters.mergeMap(x =>
	 *   Rx.Observable.interval(1000).map(i => x+i)
	 * );
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // a0
	 * // b0
	 * // c0
	 * // a1
	 * // b1
	 * // c1
	 * // continues to list a,b,c with respective ascending integers
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and merging the results of the Observables obtained
	 * from this transformation.
	 * @method mergeMap
	 * @owner Observable
	 */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
	}
	exports.mergeMap = mergeMap;
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	exports.MergeMapOperator = MergeMapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapSubscriber = (function (_super) {
	    __extends(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapSubscriber = MergeMapSubscriber;
	//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
	 *
	 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
	 *  Observable.of(1, 2, 3, 4, 5, 6)
	 *     .every(x => x < 5)
	 *     .subscribe(x => console.log(x)); // -> false
	 *
	 * @param {function} predicate a function for determining if an item meets a specified condition.
	 * @param {any} [thisArg] optional object to use for `this` in the callback
	 * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.
	 * @method every
	 * @owner Observable
	 */
	function every(predicate, thisArg) {
	    return this.lift(new EveryOperator(predicate, thisArg, this));
	}
	exports.every = every;
	var EveryOperator = (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	    EveryOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
	    };
	    return EveryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var EverySubscriber = (function (_super) {
	    __extends(EverySubscriber, _super);
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	        this.index = 0;
	        this.thisArg = thisArg || this;
	    }
	    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	    EverySubscriber.prototype._next = function (value) {
	        var result = false;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	    EverySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return EverySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=every.js.map

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var EmptyError_1 = __webpack_require__(103);
	/**
	 * Emits only the first value (or the first value that meets some condition)
	 * emitted by the source Observable.
	 *
	 * <span class="informal">Emits only the first value. Or emits only the first
	 * value that passes some test.</span>
	 *
	 * <img src="./img/first.png" width="100%">
	 *
	 * If called with no arguments, `first` emits the first value of the source
	 * Observable, then completes. If called with a `predicate` function, `first`
	 * emits the first value of the source that matches the specified condition. It
	 * may also take a `resultSelector` function to produce the output value from
	 * the input value, and a `defaultValue` to emit in case the source completes
	 * before it is able to emit a valid value. Throws an error if `defaultValue`
	 * was not provided and a matching element is not found.
	 *
	 * @example <caption>Emit only the first click that happens on the DOM</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Emits the first click that happens on a DIV</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link take}
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
	 * An optional function called with each item to test for condition matching.
	 * @param {function(value: T, index: number): R} [resultSelector] A function to
	 * produce the value on the output Observable based on the values
	 * and the indices of the source Observable. The arguments passed to this
	 * function are:
	 * - `value`: the value that was emitted on the source.
	 * - `index`: the "index" of the value from the source.
	 * @param {R} [defaultValue] The default value emitted in case no valid value
	 * was found on the source.
	 * @return {Observable<T|R>} an Observable of the first item that matches the
	 * condition.
	 * @method first
	 * @owner Observable
	 */
	function first(predicate, resultSelector, defaultValue) {
	    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.first = first;
	var FirstOperator = (function () {
	    function FirstOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    FirstOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return FirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FirstSubscriber = (function (_super) {
	    __extends(FirstSubscriber, _super);
	    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.index = 0;
	        this.hasCompleted = false;
	        this._emitted = false;
	    }
	    FirstSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._emit = function (value, index) {
	        if (this.resultSelector) {
	            this._tryResultSelector(value, index);
	            return;
	        }
	        this._emitFinal(value);
	    };
	    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this._emitFinal(result);
	    };
	    FirstSubscriber.prototype._emitFinal = function (value) {
	        var destination = this.destination;
	        if (!this._emitted) {
	            this._emitted = true;
	            destination.next(value);
	            destination.complete();
	            this.hasCompleted = true;
	        }
	    };
	    FirstSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
	            destination.next(this.defaultValue);
	            destination.complete();
	        }
	        else if (!this.hasCompleted) {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return FirstSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=first.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an Observable or a sequence was queried but has no
	 * elements.
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link single}
	 *
	 * @class EmptyError
	 */
	var EmptyError = (function (_super) {
	    __extends(EmptyError, _super);
	    function EmptyError() {
	        var err = _super.call(this, 'no elements in sequence');
	        this.name = err.name = 'EmptyError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return EmptyError;
	}(Error));
	exports.EmptyError = EmptyError;
	//# sourceMappingURL=EmptyError.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/* tslint:disable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns the
	 * accumulated result when the source completes, given an optional seed value.
	 *
	 * <span class="informal">Combines together all values emitted on the source,
	 * using an accumulator function that knows how to join a new source value into
	 * the accumulation from the past.</span>
	 *
	 * <img src="./img/reduce.png" width="100%">
	 *
	 * Like
	 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
	 * `reduce` applies an `accumulator` function against an accumulation and each
	 * value of the source Observable (from the past) to reduce it to a single
	 * value, emitted on the output Observable. Note that `reduce` will only emit
	 * one value, only when the source Observable completes. It is equivalent to
	 * applying operator {@link scan} followed by operator {@link last}.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
	 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
	 *   .takeUntil(Rx.Observable.interval(5000));
	 * var ones = clicksInFiveSeconds.mapTo(1);
	 * var seed = 0;
	 * var count = ones.reduce((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link count}
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link scan}
	 *
	 * @param {function(acc: R, value: T): R} accumulator The accumulator function
	 * called on each source value.
	 * @param {R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @return {Observable<R>} An Observable that emits a single value that is the
	 * result of accumulating the values emitted by the source Observable.
	 * @method reduce
	 * @owner Observable
	 */
	function reduce(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
	}
	exports.reduce = reduce;
	var ReduceOperator = (function () {
	    function ReduceOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ReduceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ReduceOperator;
	}());
	exports.ReduceOperator = ReduceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ReduceSubscriber = (function (_super) {
	    __extends(ReduceSubscriber, _super);
	    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.hasSeed = hasSeed;
	        this.hasValue = false;
	        this.acc = seed;
	    }
	    ReduceSubscriber.prototype._next = function (value) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            this._tryReduce(value);
	        }
	        else {
	            this.acc = value;
	            this.hasValue = true;
	        }
	    };
	    ReduceSubscriber.prototype._tryReduce = function (value) {
	        var result;
	        try {
	            result = this.accumulator(this.acc, value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.acc = result;
	    };
	    ReduceSubscriber.prototype._complete = function () {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	    return ReduceSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ReduceSubscriber = ReduceSubscriber;
	//# sourceMappingURL=reduce.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var mergeAll_1 = __webpack_require__(106);
	/* tslint:disable:max-line-length */
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * concatenating the inner Observables in order.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by putting one
	 * inner Observable after the other.</span>
	 *
	 * <img src="./img/concatAll.png" width="100%">
	 *
	 * Joins every Observable emitted by the source (a higher-order Observable), in
	 * a serial fashion. It subscribes to each inner Observable only after the
	 * previous inner Observable has completed, and merges all of their values into
	 * the returned observable.
	 *
	 * __Warning:__ If the source Observable emits Observables quickly and
	 * endlessly, and the inner Observables it emits generally complete slower than
	 * the source emits, you can run into memory issues as the incoming Observables
	 * collect in an unbounded buffer.
	 *
	 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
	 * var firstOrder = higherOrder.concatAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link combineAll}
	 * @see {@link concat}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable emitting values from all the inner
	 * Observables concatenated.
	 * @method concatAll
	 * @owner Observable
	 */
	function concatAll() {
	    return this.lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatAll = concatAll;
	//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	exports.mergeAll = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	exports.MergeAllOperator = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeAllSubscriber = MergeAllSubscriber;
	//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var EmptyError_1 = __webpack_require__(103);
	/* tslint:disable:max-line-length */
	/**
	 * Returns an Observable that emits only the last item emitted by the source Observable.
	 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
	 * the last item from the source Observable, the resulting Observable will emit the last item
	 * from the source Observable that satisfies the predicate.
	 *
	 * <img src="./img/last.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {function} predicate - the condition any source emitted item has to satisfy.
	 * @return {Observable} an Observable that emits only the last item satisfying the given condition
	 * from the source, or an NoSuchElementException if no such items are emitted.
	 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
	 * @method last
	 * @owner Observable
	 */
	function last(predicate, resultSelector, defaultValue) {
	    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.last = last;
	var LastOperator = (function () {
	    function LastOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    LastOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return LastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var LastSubscriber = (function (_super) {
	    __extends(LastSubscriber, _super);
	    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.hasValue = false;
	        this.index = 0;
	        if (typeof defaultValue !== 'undefined') {
	            this.lastValue = defaultValue;
	            this.hasValue = true;
	        }
	    }
	    LastSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.lastValue = result;
	        this.hasValue = true;
	    };
	    LastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.hasValue) {
	            destination.next(this.lastValue);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return LastSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=last.js.map

/***/ }),
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */
/***/ (function(module, exports) {

	/*!
	    localForage -- Offline Storage, Improved
	    Version 1.4.3
	    https://mozilla.github.io/localForage
	    (c) 2013-2016 Mozilla, Apache License 2.0
	*/
	(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	'use strict';
	var immediate = _dereq_(2);

	/* istanbul ignore next */
	function INTERNAL() {}

	var handlers = {};

	var REJECTED = ['REJECTED'];
	var FULFILLED = ['FULFILLED'];
	var PENDING = ['PENDING'];

	module.exports = exports = Promise;

	function Promise(resolver) {
	  if (typeof resolver !== 'function') {
	    throw new TypeError('resolver must be a function');
	  }
	  this.state = PENDING;
	  this.queue = [];
	  this.outcome = void 0;
	  if (resolver !== INTERNAL) {
	    safelyResolveThenable(this, resolver);
	  }
	}

	Promise.prototype["catch"] = function (onRejected) {
	  return this.then(null, onRejected);
	};
	Promise.prototype.then = function (onFulfilled, onRejected) {
	  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
	    typeof onRejected !== 'function' && this.state === REJECTED) {
	    return this;
	  }
	  var promise = new this.constructor(INTERNAL);
	  if (this.state !== PENDING) {
	    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
	    unwrap(promise, resolver, this.outcome);
	  } else {
	    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
	  }

	  return promise;
	};
	function QueueItem(promise, onFulfilled, onRejected) {
	  this.promise = promise;
	  if (typeof onFulfilled === 'function') {
	    this.onFulfilled = onFulfilled;
	    this.callFulfilled = this.otherCallFulfilled;
	  }
	  if (typeof onRejected === 'function') {
	    this.onRejected = onRejected;
	    this.callRejected = this.otherCallRejected;
	  }
	}
	QueueItem.prototype.callFulfilled = function (value) {
	  handlers.resolve(this.promise, value);
	};
	QueueItem.prototype.otherCallFulfilled = function (value) {
	  unwrap(this.promise, this.onFulfilled, value);
	};
	QueueItem.prototype.callRejected = function (value) {
	  handlers.reject(this.promise, value);
	};
	QueueItem.prototype.otherCallRejected = function (value) {
	  unwrap(this.promise, this.onRejected, value);
	};

	function unwrap(promise, func, value) {
	  immediate(function () {
	    var returnValue;
	    try {
	      returnValue = func(value);
	    } catch (e) {
	      return handlers.reject(promise, e);
	    }
	    if (returnValue === promise) {
	      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
	    } else {
	      handlers.resolve(promise, returnValue);
	    }
	  });
	}

	handlers.resolve = function (self, value) {
	  var result = tryCatch(getThen, value);
	  if (result.status === 'error') {
	    return handlers.reject(self, result.value);
	  }
	  var thenable = result.value;

	  if (thenable) {
	    safelyResolveThenable(self, thenable);
	  } else {
	    self.state = FULFILLED;
	    self.outcome = value;
	    var i = -1;
	    var len = self.queue.length;
	    while (++i < len) {
	      self.queue[i].callFulfilled(value);
	    }
	  }
	  return self;
	};
	handlers.reject = function (self, error) {
	  self.state = REJECTED;
	  self.outcome = error;
	  var i = -1;
	  var len = self.queue.length;
	  while (++i < len) {
	    self.queue[i].callRejected(error);
	  }
	  return self;
	};

	function getThen(obj) {
	  // Make sure we only access the accessor once as required by the spec
	  var then = obj && obj.then;
	  if (obj && typeof obj === 'object' && typeof then === 'function') {
	    return function appyThen() {
	      then.apply(obj, arguments);
	    };
	  }
	}

	function safelyResolveThenable(self, thenable) {
	  // Either fulfill, reject or reject with error
	  var called = false;
	  function onError(value) {
	    if (called) {
	      return;
	    }
	    called = true;
	    handlers.reject(self, value);
	  }

	  function onSuccess(value) {
	    if (called) {
	      return;
	    }
	    called = true;
	    handlers.resolve(self, value);
	  }

	  function tryToUnwrap() {
	    thenable(onSuccess, onError);
	  }

	  var result = tryCatch(tryToUnwrap);
	  if (result.status === 'error') {
	    onError(result.value);
	  }
	}

	function tryCatch(func, value) {
	  var out = {};
	  try {
	    out.value = func(value);
	    out.status = 'success';
	  } catch (e) {
	    out.status = 'error';
	    out.value = e;
	  }
	  return out;
	}

	exports.resolve = resolve;
	function resolve(value) {
	  if (value instanceof this) {
	    return value;
	  }
	  return handlers.resolve(new this(INTERNAL), value);
	}

	exports.reject = reject;
	function reject(reason) {
	  var promise = new this(INTERNAL);
	  return handlers.reject(promise, reason);
	}

	exports.all = all;
	function all(iterable) {
	  var self = this;
	  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
	    return this.reject(new TypeError('must be an array'));
	  }

	  var len = iterable.length;
	  var called = false;
	  if (!len) {
	    return this.resolve([]);
	  }

	  var values = new Array(len);
	  var resolved = 0;
	  var i = -1;
	  var promise = new this(INTERNAL);

	  while (++i < len) {
	    allResolver(iterable[i], i);
	  }
	  return promise;
	  function allResolver(value, i) {
	    self.resolve(value).then(resolveFromAll, function (error) {
	      if (!called) {
	        called = true;
	        handlers.reject(promise, error);
	      }
	    });
	    function resolveFromAll(outValue) {
	      values[i] = outValue;
	      if (++resolved === len && !called) {
	        called = true;
	        handlers.resolve(promise, values);
	      }
	    }
	  }
	}

	exports.race = race;
	function race(iterable) {
	  var self = this;
	  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
	    return this.reject(new TypeError('must be an array'));
	  }

	  var len = iterable.length;
	  var called = false;
	  if (!len) {
	    return this.resolve([]);
	  }

	  var i = -1;
	  var promise = new this(INTERNAL);

	  while (++i < len) {
	    resolver(iterable[i]);
	  }
	  return promise;
	  function resolver(value) {
	    self.resolve(value).then(function (response) {
	      if (!called) {
	        called = true;
	        handlers.resolve(promise, response);
	      }
	    }, function (error) {
	      if (!called) {
	        called = true;
	        handlers.reject(promise, error);
	      }
	    });
	  }
	}

	},{"2":2}],2:[function(_dereq_,module,exports){
	(function (global){
	'use strict';
	var Mutation = global.MutationObserver || global.WebKitMutationObserver;

	var scheduleDrain;

	{
	  if (Mutation) {
	    var called = 0;
	    var observer = new Mutation(nextTick);
	    var element = global.document.createTextNode('');
	    observer.observe(element, {
	      characterData: true
	    });
	    scheduleDrain = function () {
	      element.data = (called = ++called % 2);
	    };
	  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
	    var channel = new global.MessageChannel();
	    channel.port1.onmessage = nextTick;
	    scheduleDrain = function () {
	      channel.port2.postMessage(0);
	    };
	  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
	    scheduleDrain = function () {

	      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	      var scriptEl = global.document.createElement('script');
	      scriptEl.onreadystatechange = function () {
	        nextTick();

	        scriptEl.onreadystatechange = null;
	        scriptEl.parentNode.removeChild(scriptEl);
	        scriptEl = null;
	      };
	      global.document.documentElement.appendChild(scriptEl);
	    };
	  } else {
	    scheduleDrain = function () {
	      setTimeout(nextTick, 0);
	    };
	  }
	}

	var draining;
	var queue = [];
	//named nextTick for less confusing stack traces
	function nextTick() {
	  draining = true;
	  var i, oldQueue;
	  var len = queue.length;
	  while (len) {
	    oldQueue = queue;
	    queue = [];
	    i = -1;
	    while (++i < len) {
	      oldQueue[i]();
	    }
	    len = queue.length;
	  }
	  draining = false;
	}

	module.exports = immediate;
	function immediate(task) {
	  if (queue.push(task) === 1 && !draining) {
	    scheduleDrain();
	  }
	}

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],3:[function(_dereq_,module,exports){
	(function (global){
	'use strict';
	if (typeof global.Promise !== 'function') {
	  global.Promise = _dereq_(1);
	}

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"1":1}],4:[function(_dereq_,module,exports){
	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function getIDB() {
	    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
	    try {
	        if (typeof indexedDB !== 'undefined') {
	            return indexedDB;
	        }
	        if (typeof webkitIndexedDB !== 'undefined') {
	            return webkitIndexedDB;
	        }
	        if (typeof mozIndexedDB !== 'undefined') {
	            return mozIndexedDB;
	        }
	        if (typeof OIndexedDB !== 'undefined') {
	            return OIndexedDB;
	        }
	        if (typeof msIndexedDB !== 'undefined') {
	            return msIndexedDB;
	        }
	    } catch (e) {}
	}

	var idb = getIDB();

	function isIndexedDBValid() {
	    try {
	        // Initialize IndexedDB; fall back to vendor-prefixed versions
	        // if needed.
	        if (!idb) {
	            return false;
	        }
	        // We mimic PouchDB here; just UA test for Safari (which, as of
	        // iOS 8/Yosemite, doesn't properly support IndexedDB).
	        // IndexedDB support is broken and different from Blink's.
	        // This is faster than the test case (and it's sync), so we just
	        // do this. *SIGH*
	        // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/
	        //
	        // We test for openDatabase because IE Mobile identifies itself
	        // as Safari. Oh the lulz...
	        if (typeof openDatabase !== 'undefined' && typeof navigator !== 'undefined' && navigator.userAgent && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)) {
	            return false;
	        }

	        return idb && typeof idb.open === 'function' &&
	        // Some Samsung/HTC Android 4.0-4.3 devices
	        // have older IndexedDB specs; if this isn't available
	        // their IndexedDB is too old for us to use.
	        // (Replaces the onupgradeneeded test.)
	        typeof IDBKeyRange !== 'undefined';
	    } catch (e) {
	        return false;
	    }
	}

	function isWebSQLValid() {
	    return typeof openDatabase === 'function';
	}

	function isLocalStorageValid() {
	    try {
	        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;
	    } catch (e) {
	        return false;
	    }
	}

	// Abstracts constructing a Blob object, so it also works in older
	// browsers that don't support the native Blob constructor. (i.e.
	// old QtWebKit versions, at least).
	// Abstracts constructing a Blob object, so it also works in older
	// browsers that don't support the native Blob constructor. (i.e.
	// old QtWebKit versions, at least).
	function createBlob(parts, properties) {
	    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
	    parts = parts || [];
	    properties = properties || {};
	    try {
	        return new Blob(parts, properties);
	    } catch (e) {
	        if (e.name !== 'TypeError') {
	            throw e;
	        }
	        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
	        var builder = new Builder();
	        for (var i = 0; i < parts.length; i += 1) {
	            builder.append(parts[i]);
	        }
	        return builder.getBlob(properties.type);
	    }
	}

	// This is CommonJS because lie is an external dependency, so Rollup
	// can just ignore it.
	if (typeof Promise === 'undefined' && typeof _dereq_ !== 'undefined') {
	    _dereq_(3);
	}
	var Promise$1 = Promise;

	function executeCallback(promise, callback) {
	    if (callback) {
	        promise.then(function (result) {
	            callback(null, result);
	        }, function (error) {
	            callback(error);
	        });
	    }
	}

	function executeTwoCallbacks(promise, callback, errorCallback) {
	    if (typeof callback === 'function') {
	        promise.then(callback);
	    }

	    if (typeof errorCallback === 'function') {
	        promise["catch"](errorCallback);
	    }
	}

	// Some code originally from async_storage.js in
	// [Gaia](https://github.com/mozilla-b2g/gaia).

	var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
	var supportsBlobs;
	var dbContexts;
	var toString = Object.prototype.toString;

	// Transform a binary string to an array buffer, because otherwise
	// weird stuff happens when you try to work with the binary string directly.
	// It is known.
	// From http://stackoverflow.com/questions/14967647/ (continues on next line)
	// encode-decode-image-with-base64-breaks-image (2013-04-21)
	function _binStringToArrayBuffer(bin) {
	    var length = bin.length;
	    var buf = new ArrayBuffer(length);
	    var arr = new Uint8Array(buf);
	    for (var i = 0; i < length; i++) {
	        arr[i] = bin.charCodeAt(i);
	    }
	    return buf;
	}

	//
	// Blobs are not supported in all versions of IndexedDB, notably
	// Chrome <37 and Android <5. In those versions, storing a blob will throw.
	//
	// Various other blob bugs exist in Chrome v37-42 (inclusive).
	// Detecting them is expensive and confusing to users, and Chrome 37-42
	// is at very low usage worldwide, so we do a hacky userAgent check instead.
	//
	// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
	// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
	// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
	//
	// Code borrowed from PouchDB. See:
	// https://github.com/pouchdb/pouchdb/blob/9c25a23/src/adapters/idb/blobSupport.js
	//
	function _checkBlobSupportWithoutCaching(txn) {
	    return new Promise$1(function (resolve) {
	        var blob = createBlob(['']);
	        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

	        txn.onabort = function (e) {
	            // If the transaction aborts now its due to not being able to
	            // write to the database, likely due to the disk being full
	            e.preventDefault();
	            e.stopPropagation();
	            resolve(false);
	        };

	        txn.oncomplete = function () {
	            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
	            var matchedEdge = navigator.userAgent.match(/Edge\//);
	            // MS Edge pretends to be Chrome 42:
	            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
	            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
	        };
	    })["catch"](function () {
	        return false; // error, so assume unsupported
	    });
	}

	function _checkBlobSupport(idb) {
	    if (typeof supportsBlobs === 'boolean') {
	        return Promise$1.resolve(supportsBlobs);
	    }
	    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
	        supportsBlobs = value;
	        return supportsBlobs;
	    });
	}

	function _deferReadiness(dbInfo) {
	    var dbContext = dbContexts[dbInfo.name];

	    // Create a deferred object representing the current database operation.
	    var deferredOperation = {};

	    deferredOperation.promise = new Promise$1(function (resolve) {
	        deferredOperation.resolve = resolve;
	    });

	    // Enqueue the deferred operation.
	    dbContext.deferredOperations.push(deferredOperation);

	    // Chain its promise to the database readiness.
	    if (!dbContext.dbReady) {
	        dbContext.dbReady = deferredOperation.promise;
	    } else {
	        dbContext.dbReady = dbContext.dbReady.then(function () {
	            return deferredOperation.promise;
	        });
	    }
	}

	function _advanceReadiness(dbInfo) {
	    var dbContext = dbContexts[dbInfo.name];

	    // Dequeue a deferred operation.
	    var deferredOperation = dbContext.deferredOperations.pop();

	    // Resolve its promise (which is part of the database readiness
	    // chain of promises).
	    if (deferredOperation) {
	        deferredOperation.resolve();
	    }
	}

	function _getConnection(dbInfo, upgradeNeeded) {
	    return new Promise$1(function (resolve, reject) {

	        if (dbInfo.db) {
	            if (upgradeNeeded) {
	                _deferReadiness(dbInfo);
	                dbInfo.db.close();
	            } else {
	                return resolve(dbInfo.db);
	            }
	        }

	        var dbArgs = [dbInfo.name];

	        if (upgradeNeeded) {
	            dbArgs.push(dbInfo.version);
	        }

	        var openreq = idb.open.apply(idb, dbArgs);

	        if (upgradeNeeded) {
	            openreq.onupgradeneeded = function (e) {
	                var db = openreq.result;
	                try {
	                    db.createObjectStore(dbInfo.storeName);
	                    if (e.oldVersion <= 1) {
	                        // Added when support for blob shims was added
	                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
	                    }
	                } catch (ex) {
	                    if (ex.name === 'ConstraintError') {
	                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
	                    } else {
	                        throw ex;
	                    }
	                }
	            };
	        }

	        openreq.onerror = function () {
	            reject(openreq.error);
	        };

	        openreq.onsuccess = function () {
	            resolve(openreq.result);
	            _advanceReadiness(dbInfo);
	        };
	    });
	}

	function _getOriginalConnection(dbInfo) {
	    return _getConnection(dbInfo, false);
	}

	function _getUpgradedConnection(dbInfo) {
	    return _getConnection(dbInfo, true);
	}

	function _isUpgradeNeeded(dbInfo, defaultVersion) {
	    if (!dbInfo.db) {
	        return true;
	    }

	    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
	    var isDowngrade = dbInfo.version < dbInfo.db.version;
	    var isUpgrade = dbInfo.version > dbInfo.db.version;

	    if (isDowngrade) {
	        // If the version is not the default one
	        // then warn for impossible downgrade.
	        if (dbInfo.version !== defaultVersion) {
	            console.warn('The database "' + dbInfo.name + '"' + ' can\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
	        }
	        // Align the versions to prevent errors.
	        dbInfo.version = dbInfo.db.version;
	    }

	    if (isUpgrade || isNewStore) {
	        // If the store is new then increment the version (if needed).
	        // This will trigger an "upgradeneeded" event which is required
	        // for creating a store.
	        if (isNewStore) {
	            var incVersion = dbInfo.db.version + 1;
	            if (incVersion > dbInfo.version) {
	                dbInfo.version = incVersion;
	            }
	        }

	        return true;
	    }

	    return false;
	}

	// encode a blob for indexeddb engines that don't support blobs
	function _encodeBlob(blob) {
	    return new Promise$1(function (resolve, reject) {
	        var reader = new FileReader();
	        reader.onerror = reject;
	        reader.onloadend = function (e) {
	            var base64 = btoa(e.target.result || '');
	            resolve({
	                __local_forage_encoded_blob: true,
	                data: base64,
	                type: blob.type
	            });
	        };
	        reader.readAsBinaryString(blob);
	    });
	}

	// decode an encoded blob
	function _decodeBlob(encodedBlob) {
	    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
	    return createBlob([arrayBuff], { type: encodedBlob.type });
	}

	// is this one of our fancy encoded blobs?
	function _isEncodedBlob(value) {
	    return value && value.__local_forage_encoded_blob;
	}

	// Specialize the default `ready()` function by making it dependent
	// on the current database operations. Thus, the driver will be actually
	// ready when it's been initialized (default) *and* there are no pending
	// operations on the database (initiated by some other instances).
	function _fullyReady(callback) {
	    var self = this;

	    var promise = self._initReady().then(function () {
	        var dbContext = dbContexts[self._dbInfo.name];

	        if (dbContext && dbContext.dbReady) {
	            return dbContext.dbReady;
	        }
	    });

	    executeTwoCallbacks(promise, callback, callback);
	    return promise;
	}

	// Open the IndexedDB database (automatically creates one if one didn't
	// previously exist), using any options set in the config.
	function _initStorage(options) {
	    var self = this;
	    var dbInfo = {
	        db: null
	    };

	    if (options) {
	        for (var i in options) {
	            dbInfo[i] = options[i];
	        }
	    }

	    // Initialize a singleton container for all running localForages.
	    if (!dbContexts) {
	        dbContexts = {};
	    }

	    // Get the current context of the database;
	    var dbContext = dbContexts[dbInfo.name];

	    // ...or create a new context.
	    if (!dbContext) {
	        dbContext = {
	            // Running localForages sharing a database.
	            forages: [],
	            // Shared database.
	            db: null,
	            // Database readiness (promise).
	            dbReady: null,
	            // Deferred operations on the database.
	            deferredOperations: []
	        };
	        // Register the new context in the global container.
	        dbContexts[dbInfo.name] = dbContext;
	    }

	    // Register itself as a running localForage in the current context.
	    dbContext.forages.push(self);

	    // Replace the default `ready()` function with the specialized one.
	    if (!self._initReady) {
	        self._initReady = self.ready;
	        self.ready = _fullyReady;
	    }

	    // Create an array of initialization states of the related localForages.
	    var initPromises = [];

	    function ignoreErrors() {
	        // Don't handle errors here,
	        // just makes sure related localForages aren't pending.
	        return Promise$1.resolve();
	    }

	    for (var j = 0; j < dbContext.forages.length; j++) {
	        var forage = dbContext.forages[j];
	        if (forage !== self) {
	            // Don't wait for itself...
	            initPromises.push(forage._initReady()["catch"](ignoreErrors));
	        }
	    }

	    // Take a snapshot of the related localForages.
	    var forages = dbContext.forages.slice(0);

	    // Initialize the connection process only when
	    // all the related localForages aren't pending.
	    return Promise$1.all(initPromises).then(function () {
	        dbInfo.db = dbContext.db;
	        // Get the connection or open a new one without upgrade.
	        return _getOriginalConnection(dbInfo);
	    }).then(function (db) {
	        dbInfo.db = db;
	        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
	            // Reopen the database for upgrading.
	            return _getUpgradedConnection(dbInfo);
	        }
	        return db;
	    }).then(function (db) {
	        dbInfo.db = dbContext.db = db;
	        self._dbInfo = dbInfo;
	        // Share the final connection amongst related localForages.
	        for (var k = 0; k < forages.length; k++) {
	            var forage = forages[k];
	            if (forage !== self) {
	                // Self is already up-to-date.
	                forage._dbInfo.db = dbInfo.db;
	                forage._dbInfo.version = dbInfo.version;
	            }
	        }
	    });
	}

	function getItem(key, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
	            var req = store.get(key);

	            req.onsuccess = function () {
	                var value = req.result;
	                if (value === undefined) {
	                    value = null;
	                }
	                if (_isEncodedBlob(value)) {
	                    value = _decodeBlob(value);
	                }
	                resolve(value);
	            };

	            req.onerror = function () {
	                reject(req.error);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Iterate over all items stored in database.
	function iterate(iterator, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);

	            var req = store.openCursor();
	            var iterationNumber = 1;

	            req.onsuccess = function () {
	                var cursor = req.result;

	                if (cursor) {
	                    var value = cursor.value;
	                    if (_isEncodedBlob(value)) {
	                        value = _decodeBlob(value);
	                    }
	                    var result = iterator(value, cursor.key, iterationNumber++);

	                    if (result !== void 0) {
	                        resolve(result);
	                    } else {
	                        cursor["continue"]();
	                    }
	                } else {
	                    resolve();
	                }
	            };

	            req.onerror = function () {
	                reject(req.error);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);

	    return promise;
	}

	function setItem(key, value, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = new Promise$1(function (resolve, reject) {
	        var dbInfo;
	        self.ready().then(function () {
	            dbInfo = self._dbInfo;
	            if (toString.call(value) === '[object Blob]') {
	                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
	                    if (blobSupport) {
	                        return value;
	                    }
	                    return _encodeBlob(value);
	                });
	            }
	            return value;
	        }).then(function (value) {
	            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
	            var store = transaction.objectStore(dbInfo.storeName);

	            // The reason we don't _save_ null is because IE 10 does
	            // not support saving the `null` type in IndexedDB. How
	            // ironic, given the bug below!
	            // See: https://github.com/mozilla/localForage/issues/161
	            if (value === null) {
	                value = undefined;
	            }

	            transaction.oncomplete = function () {
	                // Cast to undefined so the value passed to
	                // callback/promise is the same as what one would get out
	                // of `getItem()` later. This leads to some weirdness
	                // (setItem('foo', undefined) will return `null`), but
	                // it's not my fault localStorage is our baseline and that
	                // it's weird.
	                if (value === undefined) {
	                    value = null;
	                }

	                resolve(value);
	            };
	            transaction.onabort = transaction.onerror = function () {
	                var err = req.error ? req.error : req.transaction.error;
	                reject(err);
	            };

	            var req = store.put(value, key);
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function removeItem(key, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
	            var store = transaction.objectStore(dbInfo.storeName);

	            // We use a Grunt task to make this safe for IE and some
	            // versions of Android (including those used by Cordova).
	            // Normally IE won't like `.delete()` and will insist on
	            // using `['delete']()`, but we have a build step that
	            // fixes this for us now.
	            var req = store["delete"](key);
	            transaction.oncomplete = function () {
	                resolve();
	            };

	            transaction.onerror = function () {
	                reject(req.error);
	            };

	            // The request will be also be aborted if we've exceeded our storage
	            // space.
	            transaction.onabort = function () {
	                var err = req.error ? req.error : req.transaction.error;
	                reject(err);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function clear(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
	            var store = transaction.objectStore(dbInfo.storeName);
	            var req = store.clear();

	            transaction.oncomplete = function () {
	                resolve();
	            };

	            transaction.onabort = transaction.onerror = function () {
	                var err = req.error ? req.error : req.transaction.error;
	                reject(err);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function length(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
	            var req = store.count();

	            req.onsuccess = function () {
	                resolve(req.result);
	            };

	            req.onerror = function () {
	                reject(req.error);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function key(n, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        if (n < 0) {
	            resolve(null);

	            return;
	        }

	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);

	            var advanced = false;
	            var req = store.openCursor();
	            req.onsuccess = function () {
	                var cursor = req.result;
	                if (!cursor) {
	                    // this means there weren't enough keys
	                    resolve(null);

	                    return;
	                }

	                if (n === 0) {
	                    // We have the first key, return it if that's what they
	                    // wanted.
	                    resolve(cursor.key);
	                } else {
	                    if (!advanced) {
	                        // Otherwise, ask the cursor to skip ahead n
	                        // records.
	                        advanced = true;
	                        cursor.advance(n);
	                    } else {
	                        // When we get here, we've got the nth key.
	                        resolve(cursor.key);
	                    }
	                }
	            };

	            req.onerror = function () {
	                reject(req.error);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function keys(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);

	            var req = store.openCursor();
	            var keys = [];

	            req.onsuccess = function () {
	                var cursor = req.result;

	                if (!cursor) {
	                    resolve(keys);
	                    return;
	                }

	                keys.push(cursor.key);
	                cursor["continue"]();
	            };

	            req.onerror = function () {
	                reject(req.error);
	            };
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	var asyncStorage = {
	    _driver: 'asyncStorage',
	    _initStorage: _initStorage,
	    iterate: iterate,
	    getItem: getItem,
	    setItem: setItem,
	    removeItem: removeItem,
	    clear: clear,
	    length: length,
	    key: key,
	    keys: keys
	};

	// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
	// it to Base64, so this is how we store it to prevent very strange errors with less
	// verbose ways of binary <-> string data storage.
	var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	var BLOB_TYPE_PREFIX = '~~local_forage_type~';
	var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

	var SERIALIZED_MARKER = '__lfsc__:';
	var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

	// OMG the serializations!
	var TYPE_ARRAYBUFFER = 'arbf';
	var TYPE_BLOB = 'blob';
	var TYPE_INT8ARRAY = 'si08';
	var TYPE_UINT8ARRAY = 'ui08';
	var TYPE_UINT8CLAMPEDARRAY = 'uic8';
	var TYPE_INT16ARRAY = 'si16';
	var TYPE_INT32ARRAY = 'si32';
	var TYPE_UINT16ARRAY = 'ur16';
	var TYPE_UINT32ARRAY = 'ui32';
	var TYPE_FLOAT32ARRAY = 'fl32';
	var TYPE_FLOAT64ARRAY = 'fl64';
	var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

	var toString$1 = Object.prototype.toString;

	function stringToBuffer(serializedString) {
	    // Fill the string into a ArrayBuffer.
	    var bufferLength = serializedString.length * 0.75;
	    var len = serializedString.length;
	    var i;
	    var p = 0;
	    var encoded1, encoded2, encoded3, encoded4;

	    if (serializedString[serializedString.length - 1] === '=') {
	        bufferLength--;
	        if (serializedString[serializedString.length - 2] === '=') {
	            bufferLength--;
	        }
	    }

	    var buffer = new ArrayBuffer(bufferLength);
	    var bytes = new Uint8Array(buffer);

	    for (i = 0; i < len; i += 4) {
	        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
	        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
	        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
	        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

	        /*jslint bitwise: true */
	        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
	        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
	        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	    }
	    return buffer;
	}

	// Converts a buffer to a string to store, serialized, in the backend
	// storage library.
	function bufferToString(buffer) {
	    // base64-arraybuffer
	    var bytes = new Uint8Array(buffer);
	    var base64String = '';
	    var i;

	    for (i = 0; i < bytes.length; i += 3) {
	        /*jslint bitwise: true */
	        base64String += BASE_CHARS[bytes[i] >> 2];
	        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
	        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
	        base64String += BASE_CHARS[bytes[i + 2] & 63];
	    }

	    if (bytes.length % 3 === 2) {
	        base64String = base64String.substring(0, base64String.length - 1) + '=';
	    } else if (bytes.length % 3 === 1) {
	        base64String = base64String.substring(0, base64String.length - 2) + '==';
	    }

	    return base64String;
	}

	// Serialize a value, afterwards executing a callback (which usually
	// instructs the `setItem()` callback/promise to be executed). This is how
	// we store binary data with localStorage.
	function serialize(value, callback) {
	    var valueType = '';
	    if (value) {
	        valueType = toString$1.call(value);
	    }

	    // Cannot use `value instanceof ArrayBuffer` or such here, as these
	    // checks fail when running the tests using casper.js...
	    //
	    // TODO: See why those tests fail and use a better solution.
	    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
	        // Convert binary arrays to a string and prefix the string with
	        // a special marker.
	        var buffer;
	        var marker = SERIALIZED_MARKER;

	        if (value instanceof ArrayBuffer) {
	            buffer = value;
	            marker += TYPE_ARRAYBUFFER;
	        } else {
	            buffer = value.buffer;

	            if (valueType === '[object Int8Array]') {
	                marker += TYPE_INT8ARRAY;
	            } else if (valueType === '[object Uint8Array]') {
	                marker += TYPE_UINT8ARRAY;
	            } else if (valueType === '[object Uint8ClampedArray]') {
	                marker += TYPE_UINT8CLAMPEDARRAY;
	            } else if (valueType === '[object Int16Array]') {
	                marker += TYPE_INT16ARRAY;
	            } else if (valueType === '[object Uint16Array]') {
	                marker += TYPE_UINT16ARRAY;
	            } else if (valueType === '[object Int32Array]') {
	                marker += TYPE_INT32ARRAY;
	            } else if (valueType === '[object Uint32Array]') {
	                marker += TYPE_UINT32ARRAY;
	            } else if (valueType === '[object Float32Array]') {
	                marker += TYPE_FLOAT32ARRAY;
	            } else if (valueType === '[object Float64Array]') {
	                marker += TYPE_FLOAT64ARRAY;
	            } else {
	                callback(new Error('Failed to get type for BinaryArray'));
	            }
	        }

	        callback(marker + bufferToString(buffer));
	    } else if (valueType === '[object Blob]') {
	        // Conver the blob to a binaryArray and then to a string.
	        var fileReader = new FileReader();

	        fileReader.onload = function () {
	            // Backwards-compatible prefix for the blob type.
	            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

	            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
	        };

	        fileReader.readAsArrayBuffer(value);
	    } else {
	        try {
	            callback(JSON.stringify(value));
	        } catch (e) {
	            console.error("Couldn't convert value into a JSON string: ", value);

	            callback(null, e);
	        }
	    }
	}

	// Deserialize data we've inserted into a value column/field. We place
	// special markers into our strings to mark them as encoded; this isn't
	// as nice as a meta field, but it's the only sane thing we can do whilst
	// keeping localStorage support intact.
	//
	// Oftentimes this will just deserialize JSON content, but if we have a
	// special marker (SERIALIZED_MARKER, defined above), we will extract
	// some kind of arraybuffer/binary data/typed array out of the string.
	function deserialize(value) {
	    // If we haven't marked this string as being specially serialized (i.e.
	    // something other than serialized JSON), we can just return it and be
	    // done with it.
	    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
	        return JSON.parse(value);
	    }

	    // The following code deals with deserializing some kind of Blob or
	    // TypedArray. First we separate out the type of data we're dealing
	    // with from the data itself.
	    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
	    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

	    var blobType;
	    // Backwards-compatible blob type serialization strategy.
	    // DBs created with older versions of localForage will simply not have the blob type.
	    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
	        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
	        blobType = matcher[1];
	        serializedString = serializedString.substring(matcher[0].length);
	    }
	    var buffer = stringToBuffer(serializedString);

	    // Return the right type based on the code/type set during
	    // serialization.
	    switch (type) {
	        case TYPE_ARRAYBUFFER:
	            return buffer;
	        case TYPE_BLOB:
	            return createBlob([buffer], { type: blobType });
	        case TYPE_INT8ARRAY:
	            return new Int8Array(buffer);
	        case TYPE_UINT8ARRAY:
	            return new Uint8Array(buffer);
	        case TYPE_UINT8CLAMPEDARRAY:
	            return new Uint8ClampedArray(buffer);
	        case TYPE_INT16ARRAY:
	            return new Int16Array(buffer);
	        case TYPE_UINT16ARRAY:
	            return new Uint16Array(buffer);
	        case TYPE_INT32ARRAY:
	            return new Int32Array(buffer);
	        case TYPE_UINT32ARRAY:
	            return new Uint32Array(buffer);
	        case TYPE_FLOAT32ARRAY:
	            return new Float32Array(buffer);
	        case TYPE_FLOAT64ARRAY:
	            return new Float64Array(buffer);
	        default:
	            throw new Error('Unkown type: ' + type);
	    }
	}

	var localforageSerializer = {
	    serialize: serialize,
	    deserialize: deserialize,
	    stringToBuffer: stringToBuffer,
	    bufferToString: bufferToString
	};

	/*
	 * Includes code from:
	 *
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	// Open the WebSQL database (automatically creates one if one didn't
	// previously exist), using any options set in the config.
	function _initStorage$1(options) {
	    var self = this;
	    var dbInfo = {
	        db: null
	    };

	    if (options) {
	        for (var i in options) {
	            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
	        }
	    }

	    var dbInfoPromise = new Promise$1(function (resolve, reject) {
	        // Open the database; the openDatabase API will automatically
	        // create it for us if it doesn't exist.
	        try {
	            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
	        } catch (e) {
	            return reject(e);
	        }

	        // Create our key/value table if it doesn't exist.
	        dbInfo.db.transaction(function (t) {
	            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {
	                self._dbInfo = dbInfo;
	                resolve();
	            }, function (t, error) {
	                reject(error);
	            });
	        });
	    });

	    dbInfo.serializer = localforageSerializer;
	    return dbInfoPromise;
	}

	function getItem$1(key, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
	                    var result = results.rows.length ? results.rows.item(0).value : null;

	                    // Check to see if this is serialized content we need to
	                    // unpack.
	                    if (result) {
	                        result = dbInfo.serializer.deserialize(result);
	                    }

	                    resolve(result);
	                }, function (t, error) {

	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function iterate$1(iterator, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;

	            dbInfo.db.transaction(function (t) {
	                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
	                    var rows = results.rows;
	                    var length = rows.length;

	                    for (var i = 0; i < length; i++) {
	                        var item = rows.item(i);
	                        var result = item.value;

	                        // Check to see if this is serialized content
	                        // we need to unpack.
	                        if (result) {
	                            result = dbInfo.serializer.deserialize(result);
	                        }

	                        result = iterator(result, item.key, i + 1);

	                        // void(0) prevents problems with redefinition
	                        // of `undefined`.
	                        if (result !== void 0) {
	                            resolve(result);
	                            return;
	                        }
	                    }

	                    resolve();
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function setItem$1(key, value, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            // The localStorage API doesn't return undefined values in an
	            // "expected" way, so undefined is always cast to null in all
	            // drivers. See: https://github.com/mozilla/localForage/pull/42
	            if (value === undefined) {
	                value = null;
	            }

	            // Save the original value to pass to the callback.
	            var originalValue = value;

	            var dbInfo = self._dbInfo;
	            dbInfo.serializer.serialize(value, function (value, error) {
	                if (error) {
	                    reject(error);
	                } else {
	                    dbInfo.db.transaction(function (t) {
	                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {
	                            resolve(originalValue);
	                        }, function (t, error) {
	                            reject(error);
	                        });
	                    }, function (sqlError) {
	                        // The transaction failed; check
	                        // to see if it's a quota error.
	                        if (sqlError.code === sqlError.QUOTA_ERR) {
	                            // We reject the callback outright for now, but
	                            // it's worth trying to re-run the transaction.
	                            // Even if the user accepts the prompt to use
	                            // more storage on Safari, this error will
	                            // be called.
	                            //
	                            // TODO: Try to re-run the transaction.
	                            reject(sqlError);
	                        }
	                    });
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function removeItem$1(key, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
	                    resolve();
	                }, function (t, error) {

	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Deletes every item in the table.
	// TODO: Find out if this resets the AUTO_INCREMENT number.
	function clear$1(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {
	                    resolve();
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Does a simple `COUNT(key)` to get the number of items stored in
	// localForage.
	function length$1(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                // Ahhh, SQL makes this one soooooo easy.
	                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
	                    var result = results.rows.item(0).c;

	                    resolve(result);
	                }, function (t, error) {

	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Return the key located at key index X; essentially gets the key from a
	// `WHERE id = ?`. This is the most efficient way I can think to implement
	// this rarely-used (in my experience) part of the API, but it can seem
	// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
	// the ID of each key will change every time it's updated. Perhaps a stored
	// procedure for the `setItem()` SQL would solve this problem?
	// TODO: Don't change ID on `setItem()`.
	function key$1(n, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
	                    var result = results.rows.length ? results.rows.item(0).key : null;
	                    resolve(result);
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function keys$1(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
	                    var keys = [];

	                    for (var i = 0; i < results.rows.length; i++) {
	                        keys.push(results.rows.item(i).key);
	                    }

	                    resolve(keys);
	                }, function (t, error) {

	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	var webSQLStorage = {
	    _driver: 'webSQLStorage',
	    _initStorage: _initStorage$1,
	    iterate: iterate$1,
	    getItem: getItem$1,
	    setItem: setItem$1,
	    removeItem: removeItem$1,
	    clear: clear$1,
	    length: length$1,
	    key: key$1,
	    keys: keys$1
	};

	// Config the localStorage backend, using options set in the config.
	function _initStorage$2(options) {
	    var self = this;
	    var dbInfo = {};
	    if (options) {
	        for (var i in options) {
	            dbInfo[i] = options[i];
	        }
	    }

	    dbInfo.keyPrefix = dbInfo.name + '/';

	    if (dbInfo.storeName !== self._defaultConfig.storeName) {
	        dbInfo.keyPrefix += dbInfo.storeName + '/';
	    }

	    self._dbInfo = dbInfo;
	    dbInfo.serializer = localforageSerializer;

	    return Promise$1.resolve();
	}

	// Remove all keys from the datastore, effectively destroying all data in
	// the app's key/value store!
	function clear$2(callback) {
	    var self = this;
	    var promise = self.ready().then(function () {
	        var keyPrefix = self._dbInfo.keyPrefix;

	        for (var i = localStorage.length - 1; i >= 0; i--) {
	            var key = localStorage.key(i);

	            if (key.indexOf(keyPrefix) === 0) {
	                localStorage.removeItem(key);
	            }
	        }
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Retrieve an item from the store. Unlike the original async_storage
	// library in Gaia, we don't modify return values at all. If a key's value
	// is `undefined`, we pass that value to the callback function.
	function getItem$2(key, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var result = localStorage.getItem(dbInfo.keyPrefix + key);

	        // If a result was found, parse it from the serialized
	        // string into a JS object. If result isn't truthy, the key
	        // is likely undefined and we'll pass it straight to the
	        // callback.
	        if (result) {
	            result = dbInfo.serializer.deserialize(result);
	        }

	        return result;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Iterate over all items in the store.
	function iterate$2(iterator, callback) {
	    var self = this;

	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var keyPrefix = dbInfo.keyPrefix;
	        var keyPrefixLength = keyPrefix.length;
	        var length = localStorage.length;

	        // We use a dedicated iterator instead of the `i` variable below
	        // so other keys we fetch in localStorage aren't counted in
	        // the `iterationNumber` argument passed to the `iterate()`
	        // callback.
	        //
	        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
	        var iterationNumber = 1;

	        for (var i = 0; i < length; i++) {
	            var key = localStorage.key(i);
	            if (key.indexOf(keyPrefix) !== 0) {
	                continue;
	            }
	            var value = localStorage.getItem(key);

	            // If a result was found, parse it from the serialized
	            // string into a JS object. If result isn't truthy, the
	            // key is likely undefined and we'll pass it straight
	            // to the iterator.
	            if (value) {
	                value = dbInfo.serializer.deserialize(value);
	            }

	            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

	            if (value !== void 0) {
	                return value;
	            }
	        }
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Same as localStorage's key() method, except takes a callback.
	function key$2(n, callback) {
	    var self = this;
	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var result;
	        try {
	            result = localStorage.key(n);
	        } catch (error) {
	            result = null;
	        }

	        // Remove the prefix from the key, if a key is found.
	        if (result) {
	            result = result.substring(dbInfo.keyPrefix.length);
	        }

	        return result;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function keys$2(callback) {
	    var self = this;
	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var length = localStorage.length;
	        var keys = [];

	        for (var i = 0; i < length; i++) {
	            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {
	                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));
	            }
	        }

	        return keys;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Supply the number of keys in the datastore to the callback function.
	function length$2(callback) {
	    var self = this;
	    var promise = self.keys().then(function (keys) {
	        return keys.length;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Remove an item from the store, nice and simple.
	function removeItem$2(key, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        localStorage.removeItem(dbInfo.keyPrefix + key);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Set a key's value and run an optional callback once the value is set.
	// Unlike Gaia's implementation, the callback function is passed the value,
	// in case you want to operate on that value only after you're sure it
	// saved, or something like that.
	function setItem$2(key, value, callback) {
	    var self = this;

	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    var promise = self.ready().then(function () {
	        // Convert undefined values to null.
	        // https://github.com/mozilla/localForage/pull/42
	        if (value === undefined) {
	            value = null;
	        }

	        // Save the original value to pass to the callback.
	        var originalValue = value;

	        return new Promise$1(function (resolve, reject) {
	            var dbInfo = self._dbInfo;
	            dbInfo.serializer.serialize(value, function (value, error) {
	                if (error) {
	                    reject(error);
	                } else {
	                    try {
	                        localStorage.setItem(dbInfo.keyPrefix + key, value);
	                        resolve(originalValue);
	                    } catch (e) {
	                        // localStorage capacity exceeded.
	                        // TODO: Make this a specific error/event.
	                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
	                            reject(e);
	                        }
	                        reject(e);
	                    }
	                }
	            });
	        });
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	var localStorageWrapper = {
	    _driver: 'localStorageWrapper',
	    _initStorage: _initStorage$2,
	    // Default API, from Gaia/localStorage.
	    iterate: iterate$2,
	    getItem: getItem$2,
	    setItem: setItem$2,
	    removeItem: removeItem$2,
	    clear: clear$2,
	    length: length$2,
	    key: key$2,
	    keys: keys$2
	};

	// Custom drivers are stored here when `defineDriver()` is called.
	// They are shared across all instances of localForage.
	var CustomDrivers = {};

	var DriverType = {
	    INDEXEDDB: 'asyncStorage',
	    LOCALSTORAGE: 'localStorageWrapper',
	    WEBSQL: 'webSQLStorage'
	};

	var DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];

	var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];

	var DefaultConfig = {
	    description: '',
	    driver: DefaultDriverOrder.slice(),
	    name: 'localforage',
	    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
	    // we can use without a prompt.
	    size: 4980736,
	    storeName: 'keyvaluepairs',
	    version: 1.0
	};

	var driverSupport = {};
	// Check to see if IndexedDB is available and if it is the latest
	// implementation; it's our preferred backend library. We use "_spec_test"
	// as the name of the database because it's not the one we'll operate on,
	// but it's useful to make sure its using the right spec.
	// See: https://github.com/mozilla/localForage/issues/128
	driverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();

	driverSupport[DriverType.WEBSQL] = isWebSQLValid();

	driverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();

	var isArray = Array.isArray || function (arg) {
	    return Object.prototype.toString.call(arg) === '[object Array]';
	};

	function callWhenReady(localForageInstance, libraryMethod) {
	    localForageInstance[libraryMethod] = function () {
	        var _args = arguments;
	        return localForageInstance.ready().then(function () {
	            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
	        });
	    };
	}

	function extend() {
	    for (var i = 1; i < arguments.length; i++) {
	        var arg = arguments[i];

	        if (arg) {
	            for (var key in arg) {
	                if (arg.hasOwnProperty(key)) {
	                    if (isArray(arg[key])) {
	                        arguments[0][key] = arg[key].slice();
	                    } else {
	                        arguments[0][key] = arg[key];
	                    }
	                }
	            }
	        }
	    }

	    return arguments[0];
	}

	function isLibraryDriver(driverName) {
	    for (var driver in DriverType) {
	        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {
	            return true;
	        }
	    }

	    return false;
	}

	var LocalForage = function () {
	    function LocalForage(options) {
	        _classCallCheck(this, LocalForage);

	        this.INDEXEDDB = DriverType.INDEXEDDB;
	        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;
	        this.WEBSQL = DriverType.WEBSQL;

	        this._defaultConfig = extend({}, DefaultConfig);
	        this._config = extend({}, this._defaultConfig, options);
	        this._driverSet = null;
	        this._initDriver = null;
	        this._ready = false;
	        this._dbInfo = null;

	        this._wrapLibraryMethodsWithReady();
	        this.setDriver(this._config.driver);
	    }

	    // Set any config values for localForage; can be called anytime before
	    // the first API call (e.g. `getItem`, `setItem`).
	    // We loop through options so we don't overwrite existing config
	    // values.


	    LocalForage.prototype.config = function config(options) {
	        // If the options argument is an object, we use it to set values.
	        // Otherwise, we return either a specified config value or all
	        // config values.
	        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	            // If localforage is ready and fully initialized, we can't set
	            // any new configuration values. Instead, we return an error.
	            if (this._ready) {
	                return new Error("Can't call config() after localforage " + 'has been used.');
	            }

	            for (var i in options) {
	                if (i === 'storeName') {
	                    options[i] = options[i].replace(/\W/g, '_');
	                }

	                this._config[i] = options[i];
	            }

	            // after all config options are set and
	            // the driver option is used, try setting it
	            if ('driver' in options && options.driver) {
	                this.setDriver(this._config.driver);
	            }

	            return true;
	        } else if (typeof options === 'string') {
	            return this._config[options];
	        } else {
	            return this._config;
	        }
	    };

	    // Used to define a custom driver, shared across all instances of
	    // localForage.


	    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
	        var promise = new Promise$1(function (resolve, reject) {
	            try {
	                var driverName = driverObject._driver;
	                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');
	                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);

	                // A driver name should be defined and not overlap with the
	                // library-defined, default drivers.
	                if (!driverObject._driver) {
	                    reject(complianceError);
	                    return;
	                }
	                if (isLibraryDriver(driverObject._driver)) {
	                    reject(namingError);
	                    return;
	                }

	                var customDriverMethods = LibraryMethods.concat('_initStorage');
	                for (var i = 0; i < customDriverMethods.length; i++) {
	                    var customDriverMethod = customDriverMethods[i];
	                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {
	                        reject(complianceError);
	                        return;
	                    }
	                }

	                var supportPromise = Promise$1.resolve(true);
	                if ('_support' in driverObject) {
	                    if (driverObject._support && typeof driverObject._support === 'function') {
	                        supportPromise = driverObject._support();
	                    } else {
	                        supportPromise = Promise$1.resolve(!!driverObject._support);
	                    }
	                }

	                supportPromise.then(function (supportResult) {
	                    driverSupport[driverName] = supportResult;
	                    CustomDrivers[driverName] = driverObject;
	                    resolve();
	                }, reject);
	            } catch (e) {
	                reject(e);
	            }
	        });

	        executeTwoCallbacks(promise, callback, errorCallback);
	        return promise;
	    };

	    LocalForage.prototype.driver = function driver() {
	        return this._driver || null;
	    };

	    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
	        var self = this;
	        var getDriverPromise = Promise$1.resolve().then(function () {
	            if (isLibraryDriver(driverName)) {
	                switch (driverName) {
	                    case self.INDEXEDDB:
	                        return asyncStorage;
	                    case self.LOCALSTORAGE:
	                        return localStorageWrapper;
	                    case self.WEBSQL:
	                        return webSQLStorage;
	                }
	            } else if (CustomDrivers[driverName]) {
	                return CustomDrivers[driverName];
	            } else {
	                throw new Error('Driver not found.');
	            }
	        });
	        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
	        return getDriverPromise;
	    };

	    LocalForage.prototype.getSerializer = function getSerializer(callback) {
	        var serializerPromise = Promise$1.resolve(localforageSerializer);
	        executeTwoCallbacks(serializerPromise, callback);
	        return serializerPromise;
	    };

	    LocalForage.prototype.ready = function ready(callback) {
	        var self = this;

	        var promise = self._driverSet.then(function () {
	            if (self._ready === null) {
	                self._ready = self._initDriver();
	            }

	            return self._ready;
	        });

	        executeTwoCallbacks(promise, callback, callback);
	        return promise;
	    };

	    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
	        var self = this;

	        if (!isArray(drivers)) {
	            drivers = [drivers];
	        }

	        var supportedDrivers = this._getSupportedDrivers(drivers);

	        function setDriverToConfig() {
	            self._config.driver = self.driver();
	        }

	        function initDriver(supportedDrivers) {
	            return function () {
	                var currentDriverIndex = 0;

	                function driverPromiseLoop() {
	                    while (currentDriverIndex < supportedDrivers.length) {
	                        var driverName = supportedDrivers[currentDriverIndex];
	                        currentDriverIndex++;

	                        self._dbInfo = null;
	                        self._ready = null;

	                        return self.getDriver(driverName).then(function (driver) {
	                            self._extend(driver);
	                            setDriverToConfig();

	                            self._ready = self._initStorage(self._config);
	                            return self._ready;
	                        })["catch"](driverPromiseLoop);
	                    }

	                    setDriverToConfig();
	                    var error = new Error('No available storage method found.');
	                    self._driverSet = Promise$1.reject(error);
	                    return self._driverSet;
	                }

	                return driverPromiseLoop();
	            };
	        }

	        // There might be a driver initialization in progress
	        // so wait for it to finish in order to avoid a possible
	        // race condition to set _dbInfo
	        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
	            return Promise$1.resolve();
	        }) : Promise$1.resolve();

	        this._driverSet = oldDriverSetDone.then(function () {
	            var driverName = supportedDrivers[0];
	            self._dbInfo = null;
	            self._ready = null;

	            return self.getDriver(driverName).then(function (driver) {
	                self._driver = driver._driver;
	                setDriverToConfig();
	                self._wrapLibraryMethodsWithReady();
	                self._initDriver = initDriver(supportedDrivers);
	            });
	        })["catch"](function () {
	            setDriverToConfig();
	            var error = new Error('No available storage method found.');
	            self._driverSet = Promise$1.reject(error);
	            return self._driverSet;
	        });

	        executeTwoCallbacks(this._driverSet, callback, errorCallback);
	        return this._driverSet;
	    };

	    LocalForage.prototype.supports = function supports(driverName) {
	        return !!driverSupport[driverName];
	    };

	    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
	        extend(this, libraryMethodsAndProperties);
	    };

	    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
	        var supportedDrivers = [];
	        for (var i = 0, len = drivers.length; i < len; i++) {
	            var driverName = drivers[i];
	            if (this.supports(driverName)) {
	                supportedDrivers.push(driverName);
	            }
	        }
	        return supportedDrivers;
	    };

	    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
	        // Add a stub for each driver API method that delays the call to the
	        // corresponding driver method until localForage is ready. These stubs
	        // will be replaced by the driver methods as soon as the driver is
	        // loaded, so there is no performance impact.
	        for (var i = 0; i < LibraryMethods.length; i++) {
	            callWhenReady(this, LibraryMethods[i]);
	        }
	    };

	    LocalForage.prototype.createInstance = function createInstance(options) {
	        return new LocalForage(options);
	    };

	    return LocalForage;
	}();

	// The actual localForage object that we expose as a module or via a
	// global. It's extended by pulling in one of our other libraries.


	var localforage_js = new LocalForage();

	module.exports = localforage_js;

	},{"3":3}]},{},[4])(4)
	});

/***/ }),
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.19.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, (function () { 'use strict';

	var hookCallback;

	function hooks () {
	    return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}

	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}

	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}

	function isObjectEmpty(obj) {
	    if (Object.getOwnPropertyNames) {
	        return (Object.getOwnPropertyNames(obj).length === 0);
	    } else {
	        var k;
	        for (k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                return false;
	            }
	        }
	        return true;
	    }
	}

	function isUndefined(input) {
	    return input === void 0;
	}

	function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}

	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}

	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}

	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }

	    if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	    }

	    if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	    }

	    return a;
	}

	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null,
	        rfc2822         : false,
	        weekdayMismatch : false
	    };
	}

	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}

	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;

	        for (var i = 0; i < len; i++) {
	            if (i in t && fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }

	        return false;
	    };
	}

	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &&
	            flags.overflow < 0 &&
	            !flags.empty &&
	            !flags.invalidMonth &&
	            !flags.invalidWeekday &&
	            !flags.weekdayMismatch &&
	            !flags.nullInput &&
	            !flags.invalidFormat &&
	            !flags.userInvalidated &&
	            (!flags.meridiem || (flags.meridiem && parsedParts));

	        if (m._strict) {
	            isNowValid = isNowValid &&
	                flags.charsLeftOver === 0 &&
	                flags.unusedTokens.length === 0 &&
	                flags.bigHour === undefined;
	        }

	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}

	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }

	    return m;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];

	function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }

	    if (momentProperties.length > 0) {
	        for (i = 0; i < momentProperties.length; i++) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }

	    return to;
	}

	var updateInProgress = false;

	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}

	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}

	function absFloor (number) {
	    if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}

	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;

	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }

	    return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i < len; i++) {
	        if ((dontConvert && array1[i] !== array2[i]) ||
	            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}

	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &&
	            (typeof console !==  'undefined') && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	    }
	}

	function deprecate(msg, fn) {
	    var firstTime = true;

	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i < arguments.length; i++) {
	                arg = '';
	                if (typeof arguments[i] === 'object') {
	                    arg += '\n[' + i + '] ';
	                    for (var key in arguments[0]) {
	                        arg += key + ': ' + arguments[0][key] + ', ';
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}

	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}

	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this['_' + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    this._dayOfMonthOrdinalParseLenient = new RegExp(
	        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	            '|' + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don't modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}

	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}

	var keys;

	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}

	var defaultCalendar = {
	    sameDay : '[Today at] LT',
	    nextDay : '[Tomorrow at] LT',
	    nextWeek : 'dddd [at] LT',
	    lastDay : '[Yesterday at] LT',
	    lastWeek : '[Last] dddd [at] LT',
	    sameElse : 'L'
	};

	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
	    LTS  : 'h:mm:ss A',
	    LT   : 'h:mm A',
	    L    : 'MM/DD/YYYY',
	    LL   : 'MMMM D, YYYY',
	    LLL  : 'MMMM D, YYYY h:mm A',
	    LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};

	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	        return format;
	    }

	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });

	    return this._longDateFormat[key];
	}

	var defaultInvalidDate = 'Invalid date';

	function invalidDate () {
	    return this._invalidDate;
	}

	var defaultOrdinal = '%d';
	var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	function ordinal (number) {
	    return this._ordinal.replace('%d', number);
	}

	var defaultRelativeTime = {
	    future : 'in %s',
	    past   : '%s ago',
	    s  : 'a few seconds',
	    ss : '%d seconds',
	    m  : 'a minute',
	    mm : '%d minutes',
	    h  : 'an hour',
	    hh : '%d hours',
	    d  : 'a day',
	    dd : '%d days',
	    M  : 'a month',
	    MM : '%d months',
	    y  : 'a year',
	    yy : '%d years'
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases = {};

	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }

	    return normalizedInput;
	}

	var priorities = {};

	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}

	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}

	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? (forceSign ? '+' : '') : '-') +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === 'string') {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}

	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	    }
	    return input.replace(/\\/g, '');
	}

	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;

	    for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }

	    return function (mom) {
	        var output = '', i;
	        for (i = 0; i < length; i++) {
	            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}

	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }

	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	    return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
	    var i = 5;

	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex = 0;
	    while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }

	    return format;
	}

	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


	var regexes = {};

	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict && strictRegex) ? strictRegex : regex;
	    };
	}

	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}

	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}

	var tokens = {};

	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === 'string') {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}

	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}

	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	// FORMATTING

	addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	});

	addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	});

	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	// ALIASES

	addUnitAlias('year', 'y');

	// PRIORITIES

	addUnitPriority('year', 1);

	// PARSING

	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);

	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear = makeGetSet('FullYear', true);

	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}

	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}

	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
	    if (mom.isValid() && !isNaN(value)) {
	        if (unit === 'FullYear' && isLeapYear(mom.year())) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
	        }
	        else {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }
	}

	// MOMENTS

	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}


	function stringSet (units, value) {
	    if (typeof units === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i < prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}

	function mod(n, x) {
	    return ((n % x) + x) % x;
	}

	var indexOf;

	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i < this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}

	function daysInMonth(year, month) {
	    if (isNaN(year) || isNaN(month)) {
	        return NaN;
	    }
	    var modMonth = mod(month, 12);
	    year += (month - modMonth) / 12;
	    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
	}

	// FORMATTING

	addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	});

	addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});

	addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias('month', 'M');

	// PRIORITY

	addUnitPriority('month', 8);

	// PARSING

	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});

	addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});

	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn't find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});

	// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
	    if (!m) {
	        return isArray(this._months) ? this._months :
	            this._months['standalone'];
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}

	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return isArray(this._monthsShort) ? this._monthsShort :
	            this._monthsShort['standalone'];
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i < 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'MMM') {
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'MMM') {
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }

	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        if (strict && !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }
	        if (!strict && !this._monthsParse[i]) {
	            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function setMonth (mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }

	    if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }

	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	    return mom;
	}

	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, 'Month');
	    }
	}

	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex && isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex && isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}

	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}

	function createDate (y, m, d, h, M, s, ms) {
	    // can't just apply() to create a date:
	    // https://stackoverflow.com/q/181348
	    var date = new Date(y, m, d, h, M, s, ms);

	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}

	function createUTCDate (y) {
	    var date = new Date(Date.UTC.apply(null, arguments));

	    // the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	    return -fwdlw + fwd - 1;
	}

	// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;

	    if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }

	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}

	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;

	    if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }

	    return {
	        week: resWeek,
	        year: resYear
	    };
	}

	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	// ALIASES

	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');

	// PRIORITIES

	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);

	// PARSING

	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);

	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};

	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}

	function localeFirstDayOfYear () {
	    return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	// FORMATTING

	addFormatToken('d', 0, 'do', 'day');

	addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});

	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');

	// ALIASES

	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');

	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);

	// PARSING

	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn't get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});

	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	        return input;
	    }

	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }

	    input = locale.weekdaysParse(input);
	    if (typeof input === 'number') {
	        return input;
	    }

	    return null;
	}

	function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}

	// LOCALES

	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
	    if (!m) {
	        return isArray(this._weekdays) ? this._weekdays :
	            this._weekdays['standalone'];
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	}

	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];

	        for (i = 0; i < 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'dddd') {
	            ii = indexOf.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'dddd') {
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }

	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already

	        mom = createUTC([2000, 1]).day(i);
	        if (strict && !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	    } else {
	        return day;
	    }
	}

	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	}

	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }

	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.

	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}

	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex && isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}

	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex && isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}

	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex && isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}


	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;

	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	function hFormat() {
	    return this.hours() % 12 || 12;
	}

	function kFormat() {
	    return this.hours() || 24;
	}

	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);

	addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}

	meridiem('a', true);
	meridiem('A', false);

	// ALIASES

	addUnitAlias('hour', 'h');

	// PRIORITY
	addUnitPriority('hour', 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}

	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('k',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);
	addRegexToken('kk', match1to2, match2);

	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);

	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['k', 'kk'], function (input, array, config) {
	    var kInput = toInt(input);
	    array[HOUR] = kInput === 24 ? 0 : kInput;
	});
	addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + '').toLowerCase().charAt(0) === 'p');
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	    } else {
	        return isLower ? 'am' : 'AM';
	    }
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);

	// months
	// week
	// weekdays
	// meridiem
	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	    relativeTime: defaultRelativeTime,

	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,

	    week: defaultLocaleWeek,

	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,

	    meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;

	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	}

	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;

	    while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;
	        while (j > 0) {
	            locale = loadLocale(split.slice(0, j).join('-'));
	            if (locale) {
	                return locale;
	            }
	            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return null;
	}

	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] && (typeof module !== 'undefined') &&
	            module && module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            var aliasedRequire = require;
	            __webpack_require__(207)("./" + name);
	            getSetGlobalLocale(oldLocale);
	        } catch (e) {}
	    }
	    return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }

	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	    }

	    return globalLocale._abbr;
	}

	function defineLocale (name, config) {
	    if (config !== null) {
	        var parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple('defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                    'an existing locale. moment.defineLocale(localeName, ' +
	                    'config) should only be used for creating a new locale ' +
	                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                if (!localeFamilies[config.parentLocale]) {
	                    localeFamilies[config.parentLocale] = [];
	                }
	                localeFamilies[config.parentLocale].push({
	                    name: name,
	                    config: config
	                });
	                return null;
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }

	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.
	        getSetGlobalLocale(name);


	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}

	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, parentConfig = baseConfig;
	        // MERGE
	        if (locales[name] != null) {
	            parentConfig = locales[name]._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;

	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}

	// returns locale data
	function getLocale (key) {
	    var locale;

	    if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	    }

	    if (!key) {
	        return globalLocale;
	    }

	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }

	    return chooseLocale(key);
	}

	function listLocales() {
	    return keys(locales);
	}

	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;

	    if (a && getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	            -1;

	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	            overflow = WEEKDAY;
	        }

	        getParsingFlags(m).overflow = overflow;
	    }

	    return m;
	}

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}

	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, yearToUse;

	    if (config._d) {
	        return;
	    }

	    currentDate = currentDateArray(config);

	    //compute day of the year from weeks and weekdays
	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }

	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear != null) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }

	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }

	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything
	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }

	    // Zero out whatever was not defaulted, including time
	    for (; i < 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }

	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }

	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }

	    // check for mismatching day of week
	    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
	        getParsingFlags(config).weekdayMismatch = true;
	    }
	}

	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;

	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday < 1 || weekday > 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;

	        var curWeek = weekOfYear(createLocal(), dow, doy);

	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	        // Default to current week.
	        week = defaults(w.w, curWeek.week);

	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday < 0 || weekday > 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from begining of week
	            weekday = w.e + dow;
	            if (w.e < 0 || w.e > 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to begining of week
	            weekday = dow;
	        }
	    }
	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
	    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	    ['YYYY-DDD', /\d{4}-\d{3}/],
	    ['YYYY-MM', /\d{4}-\d\d/, false],
	    ['YYYYYYMMDD', /[+-]\d{10}/],
	    ['YYYYMMDD', /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/],
	    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	    ['YYYYDDD', /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes = [
	    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	    ['HH:mm', /\d\d:\d\d/],
	    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	    ['HHmmss', /\d\d\d\d\d\d/],
	    ['HHmm', /\d\d\d\d/],
	    ['HH', /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;

	    if (match) {
	        getParsingFlags(config).iso = true;

	        for (i = 0, l = isoDates.length; i < l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be 'T' or space
	                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime && timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = 'Z';
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}

	// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	    var result = [
	        untruncateYear(yearStr),
	        defaultLocaleMonthsShort.indexOf(monthStr),
	        parseInt(dayStr, 10),
	        parseInt(hourStr, 10),
	        parseInt(minuteStr, 10)
	    ];

	    if (secondStr) {
	        result.push(parseInt(secondStr, 10));
	    }

	    return result;
	}

	function untruncateYear(yearStr) {
	    var year = parseInt(yearStr, 10);
	    if (year <= 49) {
	        return 2000 + year;
	    } else if (year <= 999) {
	        return 1900 + year;
	    }
	    return year;
	}

	function preprocessRFC2822(s) {
	    // Remove comments and folding whitespace and replace multiple-spaces with a single space
	    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
	}

	function checkWeekday(weekdayStr, parsedInput, config) {
	    if (weekdayStr) {
	        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
	        if (weekdayProvided !== weekdayActual) {
	            getParsingFlags(config).weekdayMismatch = true;
	            config._isValid = false;
	            return false;
	        }
	    }
	    return true;
	}

	var obsOffsets = {
	    UT: 0,
	    GMT: 0,
	    EDT: -4 * 60,
	    EST: -5 * 60,
	    CDT: -5 * 60,
	    CST: -6 * 60,
	    MDT: -6 * 60,
	    MST: -7 * 60,
	    PDT: -7 * 60,
	    PST: -8 * 60
	};

	function calculateOffset(obsOffset, militaryOffset, numOffset) {
	    if (obsOffset) {
	        return obsOffsets[obsOffset];
	    } else if (militaryOffset) {
	        // the only allowed military tz is Z
	        return 0;
	    } else {
	        var hm = parseInt(numOffset, 10);
	        var m = hm % 100, h = (hm - m) / 100;
	        return h * 60 + m;
	    }
	}

	// date and time from ref 2822 format
	function configFromRFC2822(config) {
	    var match = rfc2822.exec(preprocessRFC2822(config._i));
	    if (match) {
	        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
	        if (!checkWeekday(match[1], parsedArray, config)) {
	            return;
	        }

	        config._a = parsedArray;
	        config._tzm = calculateOffset(match[8], match[9], match[10]);

	        config._d = createUTCDate.apply(null, config._a);
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	        getParsingFlags(config).rfc2822 = true;
	    } else {
	        config._isValid = false;
	    }
	}

	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);

	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }

	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    configFromRFC2822(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    // Final attempt, use Input Fallback
	    hooks.createFromInputFallback(config);
	}

	hooks.createFromInputFallback = deprecate(
	    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
	    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
	    'discouraged and will be removed in an upcoming major release. Please refer to ' +
	    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }
	);

	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};

	// constant that refers to the RFC 2822 form
	hooks.RFC_2822 = function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	    if (config._f === hooks.RFC_2822) {
	        configFromRFC2822(config);
	        return;
	    }
	    config._a = [];
	    getParsingFlags(config).empty = true;

	    // This array is used to make a Date, either with `new Date` or `Date.UTC`
	    var string = '' + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;

	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length > 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don't parse if it's not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict && !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }

	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }

	    // clear _12h flag if hour is <= 12
	    if (config._a[HOUR] <= 12 &&
	        getParsingFlags(config).bigHour === true &&
	        config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }

	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	    configFromArray(config);
	    checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;

	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm && hour < 12) {
	            hour += 12;
	        }
	        if (!isPm && hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,

	        scoreToBeat,
	        i,
	        currentScore;

	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }

	    for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	            continue;
	        }

	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;

	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	        getParsingFlags(tempConfig).score = currentScore;

	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }

	    extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }

	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	    });

	    configFromArray(config);
	}

	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	    }

	    return res;
	}

	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;

	    config._locale = config._locale || getLocale(config._l);

	    if (input === null || (format === undefined && input === '')) {
	        return createInvalid({nullInput: true});
	    }

	    if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }

	    if (!isValid(config)) {
	        config._d = null;
	    }

	    return config;
	}

	function configFromInput(config) {
	    var input = config._i;
	    if (isUndefined(input)) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (isObject(input)) {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};

	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }

	    if ((isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;

	    return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
	    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other < this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	var prototypeMax = deprecate(
	    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other > this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}

	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isBefore', args);
	}

	function max () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isAfter', args);
	}

	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};

	var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	function isDurationValid(m) {
	    for (var key in m) {
	        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
	            return false;
	        }
	    }

	    var unitHasDecimal = false;
	    for (var i = 0; i < ordering.length; ++i) {
	        if (m[ordering[i]]) {
	            if (unitHasDecimal) {
	                return false; // only allow non-integers for smallest unit
	            }
	            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                unitHasDecimal = true;
	            }
	        }
	    }

	    return true;
	}

	function isValid$1() {
	    return this._isValid;
	}

	function createInvalid$1() {
	    return createDuration(NaN);
	}

	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;

	    this._isValid = isDurationValid(normalizedInput);

	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible to translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;

	    this._data = {};

	    this._locale = getLocale();

	    this._bubble();
	}

	function isDuration (obj) {
	    return obj instanceof Duration;
	}

	function absRound (number) {
	    if (number < 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}

	// FORMATTING

	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';
	        if (offset < 0) {
	            offset = -offset;
	            sign = '-';
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}

	offset('Z', ':');
	offset('ZZ', '');

	// PARSING

	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);

	    if (matches === null) {
	        return null;
	    }

	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);

	    return minutes === 0 ?
	      0 :
	      parts[0] === '+' ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}

	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};

	// MOMENTS

	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime, keepMinutes) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === 'string') {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) < 16 && !keepMinutes) {
	            input = input * 60;
	        }
	        if (!this._isUTC && keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, 'm');
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}

	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== 'string') {
	            input = -input;
	        }

	        this.utcOffset(input, keepLocalTime);

	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}

	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;

	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), 'm');
	        }
	    }
	    return this;
	}

	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm, false, true);
	    } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}

	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;

	    return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() > this.clone().month(0).utcOffset() ||
	        this.utcOffset() > this.clone().month(5).utcOffset()
	    );
	}

	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }

	    var c = {};

	    copyConfig(c, this);
	    c = prepareConfig(c);

	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &&
	            compareArrays(c._a, other.toArray()) > 0;
	    } else {
	        this._isDSTShifted = false;
	    }

	    return this._isDSTShifted;
	}

	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }

	    ret = new Duration(duration);

	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	    }

	    return ret;
	}

	createDuration.fn = Duration.prototype;
	createDuration.invalid = createInvalid$1;

	function parseIso (inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.'));
	    // apply sign while we're at it
	    return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
	    var res = {milliseconds: 0, months: 0};

	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	    }

	    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	    return res;
	}

	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() && other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }

	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }

	    return res;
	}

	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null && !isNaN(+period)) {
	            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	            tmp = val; val = period; period = tmp;
	        }

	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);

	    if (!mom.isValid()) {
	        // No op
	        return;
	    }

	    updateOffset = updateOffset == null ? true : updateOffset;

	    if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }
	    if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }
	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}

	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');

	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' :
	            diff < -1 ? 'lastWeek' :
	            diff < 0 ? 'lastDay' :
	            diff < 1 ? 'sameDay' :
	            diff < 2 ? 'nextDay' :
	            diff < 7 ? 'nextWeek' : 'sameElse';
	}

	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';

	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
	    return new Moment(this);
	}

	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	    } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	}

	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	}

	function isBetween (from, to, units, inclusivity) {
	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	}

	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units || 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	}

	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}

	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}

	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        delta, output;

	    if (!this.isValid()) {
	        return NaN;
	    }

	    that = cloneWithOffset(input, this);

	    if (!that.isValid()) {
	        return NaN;
	    }

	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	    units = normalizeUnits(units);

	    switch (units) {
	        case 'year': output = monthDiff(this, that) / 12; break;
	        case 'month': output = monthDiff(this, that); break;
	        case 'quarter': output = monthDiff(this, that) / 3; break;
	        case 'second': output = (this - that) / 1e3; break; // 1000
	        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
	        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
	        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
	        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
	        default: output = this - that;
	    }

	    return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2, adjust;

	    if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }

	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	function toString () {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}

	function toISOString() {
	    if (!this.isValid()) {
	        return null;
	    }
	    var m = this.clone().utc();
	    if (m.year() < 0 || m.year() > 9999) {
	        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	    }
	    if (isFunction(Date.prototype.toISOString)) {
	        // native implementation is ~50x faster, use it when we can
	        return this.toDate().toISOString();
	    }
	    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	    }
	    var func = 'moment';
	    var zone = '';
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	    }
	    var prefix = '[' + func + '("]';
	    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';

	    return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;

	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}

	var lang = deprecate(
	    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);

	function localeData () {
	    return this._locale;
	}

	function startOf (units) {
	    units = normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	        case 'date':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	    }

	    // weeks are a special case
	    if (units === 'week') {
	        this.weekday(0);
	    }
	    if (units === 'isoWeek') {
	        this.isoWeekday(1);
	    }

	    // quarters are also special
	    if (units === 'quarter') {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }

	    return this;
	}

	function endOf (units) {
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond') {
	        return this;
	    }

	    // 'date' is an alias for 'day', so it should be considered as such.
	    if (units === 'date') {
	        units = 'day';
	    }

	    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	}

	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
	    return new Date(this.valueOf());
	}

	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}

	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}

	function isValid$2 () {
	    return isValid(this);
	}

	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}

	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}

	// FORMATTING

	addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	});

	addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	// ALIASES

	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');

	// PRIORITY

	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);


	// PARSING

	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);

	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week > weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}

	// FORMATTING

	addFormatToken('Q', 0, 'Qo', 'quarter');

	// ALIASES

	addUnitAlias('quarter', 'Q');

	// PRIORITY

	addUnitPriority('quarter', 7);

	// PARSING

	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken('D', ['DD', 2], 'Do', 'date');

	// ALIASES

	addUnitAlias('date', 'D');

	// PRIOROITY
	addUnitPriority('date', 9);

	// PARSING

	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    return isStrict ?
	      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
	      locale._dayOfMonthOrdinalParseLenient;
	});

	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0], 10);
	});

	// MOMENTS

	var getSetDayOfMonth = makeGetSet('Date', true);

	// FORMATTING

	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	// ALIASES

	addUnitAlias('dayOfYear', 'DDD');

	// PRIORITY
	addUnitPriority('dayOfYear', 4);

	// PARSING

	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}

	// FORMATTING

	addFormatToken('m', ['mm', 2], 0, 'minute');

	// ALIASES

	addUnitAlias('minute', 'm');

	// PRIORITY

	addUnitPriority('minute', 14);

	// PARSING

	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);

	// MOMENTS

	var getSetMinute = makeGetSet('Minutes', false);

	// FORMATTING

	addFormatToken('s', ['ss', 2], 0, 'second');

	// ALIASES

	addUnitAlias('second', 's');

	// PRIORITY

	addUnitPriority('second', 15);

	// PARSING

	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);

	// MOMENTS

	var getSetSecond = makeGetSet('Seconds', false);

	// FORMATTING

	addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias('millisecond', 'ms');

	// PRIORITY

	addUnitPriority('millisecond', 16);

	// PARSING

	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);

	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}

	for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond = makeGetSet('Milliseconds', false);

	// FORMATTING

	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');

	// MOMENTS

	function getZoneAbbr () {
	    return this._isUTC ? 'UTC' : '';
	}

	function getZoneName () {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	}

	var proto = Moment.prototype;

	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$2;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;

	// Year
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;

	// Week Year
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;

	// Quarter
	proto.quarter = proto.quarters = getSetQuarter;

	// Month
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;

	// Week
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;

	// Day
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;

	// Hour
	proto.hour = proto.hours = getSetHour;

	// Minute
	proto.minute = proto.minutes = getSetMinute;

	// Second
	proto.second = proto.seconds = getSetSecond;

	// Millisecond
	proto.millisecond = proto.milliseconds = getSetMillisecond;

	// Offset
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;

	// Timezone
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;

	// Deprecations
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	function createUnix (input) {
	    return createLocal(input * 1000);
	}

	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
	    return string;
	}

	var proto$1 = Locale.prototype;

	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;

	// Month
	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;

	// Week
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	// Day of Week
	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;

	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	// Hours
	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;

	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }

	    format = format || '';

	    if (index != null) {
	        return get$1(format, index, field, 'month');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	    }
	    return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;

	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    }

	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;

	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }
	    return out;
	}

	function listMonths (format, index) {
	    return listMonthsImpl(format, index, 'months');
	}

	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	}

	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}

	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}

	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}

	getSetGlobalLocale('en', {
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	// Side effect imports
	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

	var mathAbs = Math.abs;

	function abs () {
	    var data           = this._data;

	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);

	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);

	    return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);

	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;

	    return duration._bubble();
	}

	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
	    if (number < 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}

	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;

	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	            (milliseconds <= 0 && days <= 0 && months <= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }

	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;

	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;

	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;

	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;

	    days += absFloor(hours / 24);

	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));

	    // 12 months -> 1 year
	    years = absFloor(months / 12);
	    months %= 12;

	    data.days   = days;
	    data.months = months;
	    data.years  = years;

	    return this;
	}

	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}

	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}

	function as (units) {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;

	    units = normalizeUnits(units);

	    if (units === 'month' || units === 'year') {
	        days   = this._days   + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        return units === 'month' ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case 'week'   : return days / 7     + milliseconds / 6048e5;
	            case 'day'    : return days         + milliseconds / 864e5;
	            case 'hour'   : return days * 24    + milliseconds / 36e5;
	            case 'minute' : return days * 1440  + milliseconds / 6e4;
	            case 'second' : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error('Unknown unit ' + units);
	        }
	    }
	}

	// TODO: Use this.as('ms')?
	function valueOf$1 () {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}

	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}

	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asYears        = makeAs('y');

	function clone$1 () {
	    return createDuration(this);
	}

	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this.isValid() ? this[units + 's']() : NaN;
	}

	function makeGetter(name) {
	    return function () {
	        return this.isValid() ? this._data[name] : NaN;
	    };
	}

	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');

	function weeks () {
	    return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
	    ss: 44,         // a few seconds to seconds
	    s : 45,         // seconds to minute
	    m : 45,         // minutes to hour
	    h : 22,         // hours to day
	    d : 26,         // days to month
	    M : 11          // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as('s'));
	    var minutes  = round(duration.as('m'));
	    var hours    = round(duration.as('h'));
	    var days     = round(duration.as('d'));
	    var months   = round(duration.as('M'));
	    var years    = round(duration.as('y'));

	    var a = seconds <= thresholds.ss && ['s', seconds]  ||
	            seconds < thresholds.s   && ['ss', seconds] ||
	            minutes <= 1             && ['m']           ||
	            minutes < thresholds.m   && ['mm', minutes] ||
	            hours   <= 1             && ['h']           ||
	            hours   < thresholds.h   && ['hh', hours]   ||
	            days    <= 1             && ['d']           ||
	            days    < thresholds.d   && ['dd', days]    ||
	            months  <= 1             && ['M']           ||
	            months  < thresholds.M   && ['MM', months]  ||
	            years   <= 1             && ['y']           || ['yy', years];

	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === 'function') {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    if (threshold === 's') {
	        thresholds.ss = limit - 1;
	    }
	    return true;
	}

	function humanize (withSuffix) {
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	}

	var abs$1 = Math.abs;

	function sign(x) {
	    return ((x > 0) - (x < 0)) || +x;
	}

	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;

	    // 3600 seconds -> 60 minutes -> 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;

	    // 12 months -> 1 year
	    years  = absFloor(months / 12);
	    months %= 12;


	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
	    var total = this.asSeconds();

	    if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	    }

	    var totalSign = total < 0 ? '-' : '';
	    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
	    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
	    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

	    return totalSign + 'P' +
	        (Y ? ymSign + Y + 'Y' : '') +
	        (M ? ymSign + M + 'M' : '') +
	        (D ? daysSign + D + 'D' : '') +
	        ((h || m || s) ? 'T' : '') +
	        (h ? hmsSign + h + 'H' : '') +
	        (m ? hmsSign + m + 'M' : '') +
	        (s ? hmsSign + s + 'S' : '');
	}

	var proto$2 = Duration.prototype;

	proto$2.isValid        = isValid$1;
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.clone          = clone$1;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;

	// Deprecations
	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang;

	// Side effect imports

	// FORMATTING

	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');

	// PARSING

	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	});

	// Side effect imports


	hooks.version = '2.19.1';

	setHookCallback(createLocal);

	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;

	return hooks;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(206)(module)))

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./af": 208,
		"./af.js": 208,
		"./ar": 209,
		"./ar-dz": 210,
		"./ar-dz.js": 210,
		"./ar-kw": 211,
		"./ar-kw.js": 211,
		"./ar-ly": 212,
		"./ar-ly.js": 212,
		"./ar-ma": 213,
		"./ar-ma.js": 213,
		"./ar-sa": 214,
		"./ar-sa.js": 214,
		"./ar-tn": 215,
		"./ar-tn.js": 215,
		"./ar.js": 209,
		"./az": 216,
		"./az.js": 216,
		"./be": 217,
		"./be.js": 217,
		"./bg": 218,
		"./bg.js": 218,
		"./bm": 219,
		"./bm.js": 219,
		"./bn": 220,
		"./bn.js": 220,
		"./bo": 221,
		"./bo.js": 221,
		"./br": 222,
		"./br.js": 222,
		"./bs": 223,
		"./bs.js": 223,
		"./ca": 224,
		"./ca.js": 224,
		"./cs": 225,
		"./cs.js": 225,
		"./cv": 226,
		"./cv.js": 226,
		"./cy": 227,
		"./cy.js": 227,
		"./da": 228,
		"./da.js": 228,
		"./de": 229,
		"./de-at": 230,
		"./de-at.js": 230,
		"./de-ch": 231,
		"./de-ch.js": 231,
		"./de.js": 229,
		"./dv": 232,
		"./dv.js": 232,
		"./el": 233,
		"./el.js": 233,
		"./en-au": 234,
		"./en-au.js": 234,
		"./en-ca": 235,
		"./en-ca.js": 235,
		"./en-gb": 236,
		"./en-gb.js": 236,
		"./en-ie": 237,
		"./en-ie.js": 237,
		"./en-nz": 238,
		"./en-nz.js": 238,
		"./eo": 239,
		"./eo.js": 239,
		"./es": 240,
		"./es-do": 241,
		"./es-do.js": 241,
		"./es-us": 242,
		"./es-us.js": 242,
		"./es.js": 240,
		"./et": 243,
		"./et.js": 243,
		"./eu": 244,
		"./eu.js": 244,
		"./fa": 245,
		"./fa.js": 245,
		"./fi": 246,
		"./fi.js": 246,
		"./fo": 247,
		"./fo.js": 247,
		"./fr": 248,
		"./fr-ca": 249,
		"./fr-ca.js": 249,
		"./fr-ch": 250,
		"./fr-ch.js": 250,
		"./fr.js": 248,
		"./fy": 251,
		"./fy.js": 251,
		"./gd": 252,
		"./gd.js": 252,
		"./gl": 253,
		"./gl.js": 253,
		"./gom-latn": 254,
		"./gom-latn.js": 254,
		"./gu": 255,
		"./gu.js": 255,
		"./he": 256,
		"./he.js": 256,
		"./hi": 257,
		"./hi.js": 257,
		"./hr": 258,
		"./hr.js": 258,
		"./hu": 259,
		"./hu.js": 259,
		"./hy-am": 260,
		"./hy-am.js": 260,
		"./id": 261,
		"./id.js": 261,
		"./is": 262,
		"./is.js": 262,
		"./it": 263,
		"./it.js": 263,
		"./ja": 264,
		"./ja.js": 264,
		"./jv": 265,
		"./jv.js": 265,
		"./ka": 266,
		"./ka.js": 266,
		"./kk": 267,
		"./kk.js": 267,
		"./km": 268,
		"./km.js": 268,
		"./kn": 269,
		"./kn.js": 269,
		"./ko": 270,
		"./ko.js": 270,
		"./ky": 271,
		"./ky.js": 271,
		"./lb": 272,
		"./lb.js": 272,
		"./lo": 273,
		"./lo.js": 273,
		"./lt": 274,
		"./lt.js": 274,
		"./lv": 275,
		"./lv.js": 275,
		"./me": 276,
		"./me.js": 276,
		"./mi": 277,
		"./mi.js": 277,
		"./mk": 278,
		"./mk.js": 278,
		"./ml": 279,
		"./ml.js": 279,
		"./mr": 280,
		"./mr.js": 280,
		"./ms": 281,
		"./ms-my": 282,
		"./ms-my.js": 282,
		"./ms.js": 281,
		"./my": 283,
		"./my.js": 283,
		"./nb": 284,
		"./nb.js": 284,
		"./ne": 285,
		"./ne.js": 285,
		"./nl": 286,
		"./nl-be": 287,
		"./nl-be.js": 287,
		"./nl.js": 286,
		"./nn": 288,
		"./nn.js": 288,
		"./pa-in": 289,
		"./pa-in.js": 289,
		"./pl": 290,
		"./pl.js": 290,
		"./pt": 291,
		"./pt-br": 292,
		"./pt-br.js": 292,
		"./pt.js": 291,
		"./ro": 293,
		"./ro.js": 293,
		"./ru": 294,
		"./ru.js": 294,
		"./sd": 295,
		"./sd.js": 295,
		"./se": 296,
		"./se.js": 296,
		"./si": 297,
		"./si.js": 297,
		"./sk": 298,
		"./sk.js": 298,
		"./sl": 299,
		"./sl.js": 299,
		"./sq": 300,
		"./sq.js": 300,
		"./sr": 301,
		"./sr-cyrl": 302,
		"./sr-cyrl.js": 302,
		"./sr.js": 301,
		"./ss": 303,
		"./ss.js": 303,
		"./sv": 304,
		"./sv.js": 304,
		"./sw": 305,
		"./sw.js": 305,
		"./ta": 306,
		"./ta.js": 306,
		"./te": 307,
		"./te.js": 307,
		"./tet": 308,
		"./tet.js": 308,
		"./th": 309,
		"./th.js": 309,
		"./tl-ph": 310,
		"./tl-ph.js": 310,
		"./tlh": 311,
		"./tlh.js": 311,
		"./tr": 312,
		"./tr.js": 312,
		"./tzl": 313,
		"./tzl.js": 313,
		"./tzm": 314,
		"./tzm-latn": 315,
		"./tzm-latn.js": 315,
		"./tzm.js": 314,
		"./uk": 316,
		"./uk.js": 316,
		"./ur": 317,
		"./ur.js": 317,
		"./uz": 318,
		"./uz-latn": 319,
		"./uz-latn.js": 319,
		"./uz.js": 318,
		"./vi": 320,
		"./vi.js": 320,
		"./x-pseudo": 321,
		"./x-pseudo.js": 321,
		"./yo": 322,
		"./yo.js": 322,
		"./zh-cn": 323,
		"./zh-cn.js": 323,
		"./zh-hk": 324,
		"./zh-hk.js": 324,
		"./zh-tw": 325,
		"./zh-tw.js": 325
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 207;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var af = moment.defineLocale('af', {
	    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'vm' : 'VM';
	        } else {
	            return isLower ? 'nm' : 'NM';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Vandag om] LT',
	        nextDay : '[Mre om] LT',
	        nextWeek : 'dddd [om] LT',
	        lastDay : '[Gister om] LT',
	        lastWeek : '[Laas] dddd [om] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'oor %s',
	        past : '%s gelede',
	        s : '\'n paar sekondes',
	        m : '\'n minuut',
	        mm : '%d minute',
	        h : '\'n uur',
	        hh : '%d ure',
	        d : '\'n dag',
	        dd : '%d dae',
	        M : '\'n maand',
	        MM : '%d maande',
	        y : '\'n jaar',
	        yy : '%d jaar'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});

	return af;

	})));


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    '  ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    '  ',
	    '  ',
	    '  '
	];

	var ar = moment.defineLocale('ar', {
	    months : months,
	    monthsShort : months,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ar;

	})));


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Algeria) [ar-dz]
	//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arDz = moment.defineLocale('ar-dz', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arDz;

	})));


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Kuwait) [ar-kw]
	//! author : Nusret Parlak: https://github.com/nusretparlak

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arKw = moment.defineLocale('ar-kw', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arKw;

	})));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '1',
	    '2': '2',
	    '3': '3',
	    '4': '4',
	    '5': '5',
	    '6': '6',
	    '7': '7',
	    '8': '8',
	    '9': '9',
	    '0': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];

	var arLy = moment.defineLocale('ar-ly', {
	    months : months,
	    monthsShort : months,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arLy;

	})));


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arMa = moment.defineLocale('ar-ma', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arMa;

	})));


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var arSa = moment.defineLocale('ar-sa', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arSa;

	})));


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arTn = moment.defineLocale('ar-tn', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: ' %s',
	        past: ' %s',
	        s: '',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return arTn;

	})));


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    1: '-inci',
	    5: '-inci',
	    8: '-inci',
	    70: '-inci',
	    80: '-inci',
	    2: '-nci',
	    7: '-nci',
	    20: '-nci',
	    50: '-nci',
	    3: '-nc',
	    4: '-nc',
	    100: '-nc',
	    6: '-nc',
	    9: '-uncu',
	    10: '-uncu',
	    30: '-uncu',
	    60: '-nc',
	    90: '-nc'
	};

	var az = moment.defineLocale('az', {
	    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	    weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
	    weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
	    weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugn saat] LT',
	        nextDay : '[sabah saat] LT',
	        nextWeek : '[gln hft] dddd [saat] LT',
	        lastDay : '[dnn] LT',
	        lastWeek : '[ken hft] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s vvl',
	        s : 'birne saniyy',
	        m : 'bir dqiq',
	        mm : '%d dqiq',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gn',
	        dd : '%d gn',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir il',
	        yy : '%d il'
	    },
	    meridiemParse: /gec|shr|gndz|axam/,
	    isPM : function (input) {
	        return /^(gndz|axam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'gec';
	        } else if (hour < 12) {
	            return 'shr';
	        } else if (hour < 17) {
	            return 'gndz';
	        } else {
	            return 'axam';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '-nc';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return az;

	})));


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': withoutSuffix ? '__' : '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}

	var be = moment.defineLocale('be', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : {
	        format: '______'.split('_'),
	        standalone: '______'.split('_'),
	        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        lastDay: '[ ] LT',
	        nextWeek: function () {
	            return '[] dddd [] LT';
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[ ] dddd [] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /|||/,
	    isPM : function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return be;

	})));


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var bg = moment.defineLocale('bg', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-';
	        } else if (last2Digits === 0) {
	            return number + '-';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-';
	        } else if (lastDigit === 1) {
	            return number + '-';
	        } else if (lastDigit === 2) {
	            return number + '-';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-';
	        } else {
	            return number + '-';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bg;

	})));


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bambara [bm]
	//! author : Estelle Comment : https://github.com/estellecomment

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';

	// Language contact person : Abdoufata Kane : https://github.com/abdoufata

	var bm = moment.defineLocale('bm', {
	    months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
	    monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
	    weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
	    weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
	    weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'MMMM [tile] D [san] YYYY',
	        LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',
	        LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
	    },
	    calendar : {
	        sameDay : '[Bi lr] LT',
	        nextDay : '[Sini lr] LT',
	        nextWeek : 'dddd [don lr] LT',
	        lastDay : '[Kunu lr] LT',
	        lastWeek : 'dddd [tmnen lr] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s kn',
	        past : 'a b %s b',
	        s : 'sanga dama dama',
	        m : 'miniti kelen',
	        mm : 'miniti %d',
	        h : 'lr kelen',
	        hh : 'lr %d',
	        d : 'tile kelen',
	        dd : 'tile %d',
	        M : 'kalo kelen',
	        MM : 'kalo %d',
	        y : 'san kelen',
	        yy : 'san %d'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return bm;

	})));


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var bn = moment.defineLocale('bn', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                (meridiem === '' && hour < 5) ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bn;

	})));


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var bo = moment.defineLocale('bo', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[], LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                (meridiem === '' && hour < 5) ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bo;

	})));


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format = {
	        'mm': 'munutenn',
	        'MM': 'miz',
	        'dd': 'devezh'
	    };
	    return number + ' ' + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	    }
	}
	function lastNumber(number) {
	    if (number > 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number === 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable = {
	        'm': 'v',
	        'b': 'v',
	        'd': 'z'
	    };
	    if (mutationTable[text.charAt(0)] === undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}

	var br = moment.defineLocale('br', {
	    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h[e]mm A',
	        LTS : 'h[e]mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [a viz] MMMM YYYY',
	        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	    },
	    calendar : {
	        sameDay : '[Hiziv da] LT',
	        nextDay : '[Warc\'hoazh da] LT',
	        nextWeek : 'dddd [da] LT',
	        lastDay : '[Dec\'h da] LT',
	        lastWeek : 'dddd [paset da] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'a-benn %s',
	        past : '%s \'zo',
	        s : 'un nebeud segondenno',
	        m : 'ur vunutenn',
	        mm : relativeTimeWithMutation,
	        h : 'un eur',
	        hh : '%d eur',
	        d : 'un devezh',
	        dd : relativeTimeWithMutation,
	        M : 'ur miz',
	        MM : relativeTimeWithMutation,
	        y : 'ur bloaz',
	        yy : specialMutationForYears
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
	    ordinal : function (number) {
	        var output = (number === 1) ? 'a' : 'vet';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return br;

	})));


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Markovi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}

	var bs = moment.defineLocale('bs', {
	    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bs;

	})));


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ca = moment.defineLocale('ca', {
	    months : {
	        standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
	        isFormat: /D[oD]?(\s)+MMMM/
	    },
	    monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	    weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM [de] YYYY',
	        ll : 'D MMM YYYY',
	        LLL : 'D MMMM [de] YYYY [a les] H:mm',
	        lll : 'D MMM YYYY, H:mm',
	        LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
	        llll : 'ddd D MMM YYYY, H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextDay : function () {
	            return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastDay : function () {
	            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'd\'aqu %s',
	        past : 'fa %s',
	        s : 'uns segons',
	        m : 'un minut',
	        mm : '%d minuts',
	        h : 'una hora',
	        hh : '%d hores',
	        d : 'un dia',
	        dd : '%d dies',
	        M : 'un mes',
	        MM : '%d mesos',
	        y : 'un any',
	        yy : '%d anys'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
	    ordinal : function (number, period) {
	        var output = (number === 1) ? 'r' :
	            (number === 2) ? 'n' :
	            (number === 3) ? 'r' :
	            (number === 4) ? 't' : '';
	        if (period === 'w' || period === 'W') {
	            output = 'a';
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ca;

	})));


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
	var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dn');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'msce' : 'msc');
	            } else {
	                return result + 'msci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	    }
	}

	var cs = moment.defineLocale('cs', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse = [];
	        for (i = 0; i < 12; i++) {
	            // use custom parser to solve problem with July (ervenec)
	            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
	    weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
	    weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm',
	        l : 'D. M. YYYY'
	    },
	    calendar : {
	        sameDay: '[dnes v] LT',
	        nextDay: '[ztra v] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve stedu v] LT';
	                case 4:
	                    return '[ve tvrtek v] LT';
	                case 5:
	                    return '[v ptek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	            }
	        },
	        lastDay: '[vera v] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulou nedli v] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [v] LT';
	                case 3:
	                    return '[minulou stedu v] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'ped %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cs;

	})));


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var cv = moment.defineLocale('cv', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'YYYY [] MMMM [] D[-]',
	        LLL : 'YYYY [] MMMM [] D[-], HH:mm',
	        LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
	    },
	    calendar : {
	        sameDay: '[] LT []',
	        nextDay: '[] LT []',
	        lastDay: '[] LT []',
	        nextWeek: '[] dddd LT []',
	        lastWeek: '[] dddd LT []',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
	            return output + affix;
	        },
	        past : '%s ',
	        s : '- ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-/,
	    ordinal : '%d-',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return cv;

	})));


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var cy = moment.defineLocale('cy', {
	    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[Heddiw am] LT',
	        nextDay: '[Yfory am] LT',
	        nextWeek: 'dddd [am] LT',
	        lastDay: '[Ddoe am] LT',
	        lastWeek: 'dddd [diwethaf am] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'mewn %s',
	        past: '%s yn l',
	        s: 'ychydig eiliadau',
	        m: 'munud',
	        mm: '%d munud',
	        h: 'awr',
	        hh: '%d awr',
	        d: 'diwrnod',
	        dd: '%d diwrnod',
	        M: 'mis',
	        MM: '%d mis',
	        y: 'blwyddyn',
	        yy: '%d flynedd'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b = number,
	            output = '',
	            lookup = [
	                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	            ];
	        if (b > 20) {
	            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                output = 'fed'; // not 30ain, 70ain or 90ain
	            } else {
	                output = 'ain';
	            }
	        } else if (b > 0) {
	            output = lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cy;

	})));


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var da = moment.defineLocale('da', {
	    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
	    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay : '[i dag kl.] LT',
	        nextDay : '[i morgen kl.] LT',
	        nextWeek : 'p dddd [kl.] LT',
	        lastDay : '[i gr kl.] LT',
	        lastWeek : '[i] dddd[s kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'f sekunder',
	        m : 'et minut',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dage',
	        M : 'en mned',
	        MM : '%d mneder',
	        y : 'et r',
	        yy : '%d r'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return da;

	})));


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var de = moment.defineLocale('de', {
	    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return de;

	})));


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deAt = moment.defineLocale('de-at', {
	    months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deAt;

	})));


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Switzerland) [de-ch]
	//! author : sschueller : https://github.com/sschueller

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	// based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deCh = moment.defineLocale('de-ch', {
	    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH.mm',
	        LTS: 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH.mm',
	        LLLL : 'dddd, D. MMMM YYYY HH.mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deCh;

	})));


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	var weekdays = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];

	var dv = moment.defineLocale('dv', {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {

	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/M/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : ' %d',
	        h : '',
	        hh : ' %d',
	        d : '',
	        dd : ' %d',
	        M : '',
	        MM : ' %d',
	        y : '',
	        yy : ' %d'
	    },
	    preparse: function (string) {
	        return string.replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '');
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return dv;

	})));


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}


	var el = moment.defineLocale('el', {
	    monthsNominativeEl : '___________'.split('_'),
	    monthsGenitiveEl : '___________'.split('_'),
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return this._monthsNominativeEl;
	        } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? '' : '';
	        } else {
	            return isLower ? '' : '';
	        }
	    },
	    isPM : function (input) {
	        return ((input + '').toLowerCase()[0] === '');
	    },
	    meridiemParse : /[]\.??\.?/i,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendarEl : {
	        sameDay : '[ {}] LT',
	        nextDay : '[ {}] LT',
	        nextWeek : 'dddd [{}] LT',
	        lastDay : '[ {}] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return '[ ] dddd [{}] LT';
	                default:
	                    return '[ ] dddd [{}] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    calendar : function (key, mom) {
	        var output = this._calendarEl[key],
	            hours = mom && mom.hours();
	        if (isFunction(output)) {
	            output = output.apply(mom);
	        }
	        return output.replace('{}', (hours % 12 === 1 ? '' : ''));
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});

	return el;

	})));


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enAu = moment.defineLocale('en-au', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enAu;

	})));


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enCa = moment.defineLocale('en-ca', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'YYYY-MM-DD',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	return enCa;

	})));


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enGb = moment.defineLocale('en-gb', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enGb;

	})));


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enIe = moment.defineLocale('en-ie', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enIe;

	})));


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enNz = moment.defineLocale('en-nz', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enNz;

	})));


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
	//! comment : miestasmia corrected the translation by colindean

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var eo = moment.defineLocale('eo', {
	    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
	    weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
	    weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
	    weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D[-a de] MMMM, YYYY',
	        LLL : 'D[-a de] MMMM, YYYY HH:mm',
	        LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() === 'p';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'p.t.m.' : 'P.T.M.';
	        } else {
	            return isLower ? 'a.t.m.' : 'A.T.M.';
	        }
	    },
	    calendar : {
	        sameDay : '[Hodia je] LT',
	        nextDay : '[Morga je] LT',
	        nextWeek : 'dddd [je] LT',
	        lastDay : '[Hiera je] LT',
	        lastWeek : '[pasinta] dddd [je] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'post %s',
	        past : 'anta %s',
	        s : 'sekundoj',
	        m : 'minuto',
	        mm : '%d minutoj',
	        h : 'horo',
	        hh : '%d horoj',
	        d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
	        dd : '%d tagoj',
	        M : 'monato',
	        MM : '%d monatoj',
	        y : 'jaro',
	        yy : '%d jaroj'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}a/,
	    ordinal : '%da',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eo;

	})));


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napur : https://github.com/julionc

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	var es = moment.defineLocale('es', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsRegex : monthsRegex,
	    monthsShortRegex : monthsRegex,
	    monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
	    monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return es;

	})));


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	var esDo = moment.defineLocale('es-do', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
	    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
	    monthsParse: monthsParse,
	    longMonthsParse: monthsParse,
	    shortMonthsParse: monthsParse,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY h:mm A',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return esDo;

	})));


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish(United State) [es-us]
	//! author : bustta : https://github.com/bustta

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var esUs = moment.defineLocale('es-us', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'MM/DD/YYYY',
	        LL : 'MMMM [de] D [de] YYYY',
	        LLL : 'MMMM [de] D [de] YYYY H:mm',
	        LLLL : 'dddd, MMMM [de] D [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return esUs;

	})));


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
	        'm' : ['he minuti', 'ks minut'],
	        'mm': [number + ' minuti', number + ' minutit'],
	        'h' : ['he tunni', 'tund aega', 'ks tund'],
	        'hh': [number + ' tunni', number + ' tundi'],
	        'd' : ['he peva', 'ks pev'],
	        'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
	        'MM': [number + ' kuu', number + ' kuud'],
	        'y' : ['he aasta', 'aasta', 'ks aasta'],
	        'yy': [number + ' aasta', number + ' aastat']
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}

	var et = moment.defineLocale('et', {
	    months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	    monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	    weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
	    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	    longDateFormat : {
	        LT   : 'H:mm',
	        LTS : 'H:mm:ss',
	        L    : 'DD.MM.YYYY',
	        LL   : 'D. MMMM YYYY',
	        LLL  : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[Tna,] LT',
	        nextDay  : '[Homme,] LT',
	        nextWeek : '[Jrgmine] dddd LT',
	        lastDay  : '[Eile,] LT',
	        lastWeek : '[Eelmine] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s prast',
	        past   : '%s tagasi',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : '%d peva',
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return et;

	})));


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var eu = moment.defineLocale('eu', {
	    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY[ko] MMMM[ren] D[a]',
	        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	        l : 'YYYY-M-D',
	        ll : 'YYYY[ko] MMM D[a]',
	        lll : 'YYYY[ko] MMM D[a] HH:mm',
	        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	    },
	    calendar : {
	        sameDay : '[gaur] LT[etan]',
	        nextDay : '[bihar] LT[etan]',
	        nextWeek : 'dddd LT[etan]',
	        lastDay : '[atzo] LT[etan]',
	        lastWeek : '[aurreko] dddd LT[etan]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s barru',
	        past : 'duela %s',
	        s : 'segundo batzuk',
	        m : 'minutu bat',
	        mm : '%d minutu',
	        h : 'ordu bat',
	        hh : '%d ordu',
	        d : 'egun bat',
	        dd : '%d egun',
	        M : 'hilabete bat',
	        MM : '%d hilabete',
	        y : 'urte bat',
	        yy : '%d urte'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eu;

	})));


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var fa = moment.defineLocale('fa', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '\u200c__\u200c__\u200c__'.split('_'),
	    weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /  |  /,
	    isPM: function (input) {
	        return /  /.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '  ';
	        } else {
	            return '  ';
	        }
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : 'dddd [] [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[-]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return fa;

	})));


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
	var numbersFuture = [
	        'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = '';
	    switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'pivn' : 'piv';
	        case 'dd':
	            result = isFuture ? 'pivn' : 'piv';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	    }
	    result = verbalNumber(number, isFuture) + ' ' + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}

	var fi = moment.defineLocale('fi', {
	    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	    monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
	    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'Do MMMM[ta] YYYY',
	        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	        l : 'D.M.YYYY',
	        ll : 'Do MMM YYYY',
	        lll : 'Do MMM YYYY, [klo] HH.mm',
	        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	    },
	    calendar : {
	        sameDay : '[tnn] [klo] LT',
	        nextDay : '[huomenna] [klo] LT',
	        nextWeek : 'dddd [klo] LT',
	        lastDay : '[eilen] [klo] LT',
	        lastWeek : '[viime] dddd[na] [klo] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s pst',
	        past : '%s sitten',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fi;

	})));


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var fo = moment.defineLocale('fo', {
	    months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
	    weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
	    weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D. MMMM, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ dag kl.] LT',
	        nextDay : '[ morgin kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[ gjr kl.] LT',
	        lastWeek : '[sstu] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'um %s',
	        past : '%s sani',
	        s : 'f sekund',
	        m : 'ein minutt',
	        mm : '%d minuttir',
	        h : 'ein tmi',
	        hh : '%d tmar',
	        d : 'ein dagur',
	        dd : '%d dagar',
	        M : 'ein mnai',
	        MM : '%d mnair',
	        y : 'eitt r',
	        yy : '%d r'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fo;

	})));


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var fr = moment.defineLocale('fr', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Aujourdhui ] LT',
	        nextDay : '[Demain ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[Hier ] LT',
	        lastWeek : 'dddd [dernier ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // TODO: Return 'e' when day of month > 1. Move this case inside
	            // block for masculine words below.
	            // See https://github.com/moment/moment/issues/3375
	            case 'D':
	                return number + (number === 1 ? 'er' : '');

	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case 'M':
	            case 'Q':
	            case 'DDD':
	            case 'd':
	                return number + (number === 1 ? 'er' : 'e');

	            // Words with feminine grammatical gender: semaine
	            case 'w':
	            case 'W':
	                return number + (number === 1 ? 're' : 'e');
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fr;

	})));


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var frCa = moment.defineLocale('fr-ca', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Aujourdhui ] LT',
	        nextDay : '[Demain ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[Hier ] LT',
	        lastWeek : 'dddd [dernier ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case 'M':
	            case 'Q':
	            case 'D':
	            case 'DDD':
	            case 'd':
	                return number + (number === 1 ? 'er' : 'e');

	            // Words with feminine grammatical gender: semaine
	            case 'w':
	            case 'W':
	                return number + (number === 1 ? 're' : 'e');
	        }
	    }
	});

	return frCa;

	})));


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var frCh = moment.defineLocale('fr-ch', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Aujourdhui ] LT',
	        nextDay : '[Demain ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[Hier ] LT',
	        lastWeek : 'dddd [dernier ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case 'M':
	            case 'Q':
	            case 'D':
	            case 'DDD':
	            case 'd':
	                return number + (number === 1 ? 'er' : 'e');

	            // Words with feminine grammatical gender: semaine
	            case 'w':
	            case 'W':
	                return number + (number === 1 ? 're' : 'e');
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return frCh;

	})));


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	var fy = moment.defineLocale('fy', {
	    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[hjoed om] LT',
	        nextDay: '[moarn om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[juster om] LT',
	        lastWeek: '[frne] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'oer %s',
	        past : '%s lyn',
	        s : 'in pear sekonden',
	        m : 'ien mint',
	        mm : '%d minuten',
	        h : 'ien oere',
	        hh : '%d oeren',
	        d : 'ien dei',
	        dd : '%d dagen',
	        M : 'ien moanne',
	        MM : '%d moannen',
	        y : 'ien jier',
	        yy : '%d jierren'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fy;

	})));


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
	];

	var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

	var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

	var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

	var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

	var gd = moment.defineLocale('gd', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[An-diugh aig] LT',
	        nextDay : '[A-mireach aig] LT',
	        nextWeek : 'dddd [aig] LT',
	        lastDay : '[An-d aig] LT',
	        lastWeek : 'dddd [seo chaidh] [aig] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ann an %s',
	        past : 'bho chionn %s',
	        s : 'beagan diogan',
	        m : 'mionaid',
	        mm : '%d mionaidean',
	        h : 'uair',
	        hh : '%d uairean',
	        d : 'latha',
	        dd : '%d latha',
	        M : 'mos',
	        MM : '%d mosan',
	        y : 'bliadhna',
	        yy : '%d bliadhna'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gd;

	})));


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var gl = moment.defineLocale('gl', {
	    months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	    monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	        },
	        lastDay : function () {
	            return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
	        },
	        lastWeek : function () {
	            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf('un') === 0) {
	                return 'n' + str;
	            }
	            return 'en ' + str;
	        },
	        past : 'hai %s',
	        s : 'uns segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'unha hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ano',
	        yy : '%d anos'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gl;

	})));


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Konkani Latin script [gom-latn]
	//! author : The Discoverer : https://github.com/WikiDiscoverer

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['thodde secondanim', 'thodde second'],
	        'm': ['eka mintan', 'ek minute'],
	        'mm': [number + ' mintanim', number + ' mintam'],
	        'h': ['eka horan', 'ek hor'],
	        'hh': [number + ' horanim', number + ' hor'],
	        'd': ['eka disan', 'ek dis'],
	        'dd': [number + ' disanim', number + ' dis'],
	        'M': ['eka mhoinean', 'ek mhoino'],
	        'MM': [number + ' mhoineanim', number + ' mhoine'],
	        'y': ['eka vorsan', 'ek voros'],
	        'yy': [number + ' vorsanim', number + ' vorsam']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var gomLatn = moment.defineLocale('gom-latn', {
	    months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
	    monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
	    weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
	    weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'A h:mm [vazta]',
	        LTS : 'A h:mm:ss [vazta]',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY A h:mm [vazta]',
	        LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
	        llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
	    },
	    calendar : {
	        sameDay: '[Aiz] LT',
	        nextDay: '[Faleam] LT',
	        nextWeek: '[Ieta to] dddd[,] LT',
	        lastDay: '[Kal] LT',
	        lastWeek: '[Fatlo] dddd[,] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s adim',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // the ordinal 'er' only applies to day of the month
	            case 'D':
	                return number + 'er';
	            default:
	            case 'M':
	            case 'Q':
	            case 'DDD':
	            case 'd':
	            case 'w':
	            case 'W':
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    },
	    meridiemParse: /rati|sokalli|donparam|sanje/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'rati') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'sokalli') {
	            return hour;
	        } else if (meridiem === 'donparam') {
	            return hour > 12 ? hour : hour + 12;
	        } else if (meridiem === 'sanje') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'rati';
	        } else if (hour < 12) {
	            return 'sokalli';
	        } else if (hour < 16) {
	            return 'donparam';
	        } else if (hour < 20) {
	            return 'sanje';
	        } else {
	            return 'rati';
	        }
	    }
	});

	return gomLatn;

	})));


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Gujarati [gu]
	//! author : Kaushik Thanki : https://github.com/Kaushik1987

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    };
	var numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	var gu = moment.defineLocale('gu', {
	    months: '___________'.split('_'),
	    monthsShort: '._.__.___._._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    longDateFormat: {
	        LT: 'A h:mm ',
	        LTS: 'A h:mm:ss ',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY, A h:mm ',
	        LLLL: 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar: {
	        sameDay: '[] LT',
	        nextDay: '[] LT',
	        nextWeek: 'dddd, LT',
	        lastDay: '[] LT',
	        lastWeek: '[] dddd, LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: '%s ',
	        past: '%s ',
	        s: ' ',
	        m: ' ',
	        mm: '%d ',
	        h: ' ',
	        hh: '%d ',
	        d: ' ',
	        dd: '%d ',
	        M: ' ',
	        MM: '%d ',
	        y: ' ',
	        yy: '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
	    meridiemParse: /|||/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week: {
	        dow: 0, // Sunday is the first day of the week.
	        doy: 6 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return gu;

	})));


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var he = moment.defineLocale('he', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D []MMMM YYYY',
	        LLL : 'D []MMMM YYYY HH:mm',
	        LLLL : 'dddd, D []MMMM YYYY HH:mm',
	        l : 'D/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ]LT',
	        nextDay : '[ ]LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ]LT',
	        lastWeek : '[] dddd [ ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        d : '',
	        dd : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        M : '',
	        MM : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        y : '',
	        yy : function (number) {
	            if (number === 2) {
	                return '';
	            } else if (number % 10 === 0 && number !== 10) {
	                return number + ' ';
	            }
	            return number + ' ';
	        }
	    },
	    meridiemParse: /"|"| | | ||/i,
	    isPM : function (input) {
	        return /^("| |)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 5) {
	            return ' ';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 12) {
	            return isLower ? '"' : ' ';
	        } else if (hour < 18) {
	            return isLower ? '"' : ' ';
	        } else {
	            return '';
	        }
	    }
	});

	return he;

	})));


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var hi = moment.defineLocale('hi', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.___._._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hi;

	})));


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Markovi : https://github.com/bmarkovic

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}

	var hr = moment.defineLocale('hr', {
	    months : {
	        format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	        standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	    },
	    monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hr;

	})));


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	function translate(number, withoutSuffix, key, isFuture) {
	    var num = number,
	        suffix;
	    switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
	    }
	    return '';
	}
	function week(isFuture) {
	    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	}

	var hu = moment.defineLocale('hu', {
	    months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
	    monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
	    weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
	    weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
	    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY.MM.DD.',
	        LL : 'YYYY. MMMM D.',
	        LLL : 'YYYY. MMMM D. H:mm',
	        LLLL : 'YYYY. MMMM D., dddd H:mm'
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() === 'u';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower === true ? 'de' : 'DE';
	        } else {
	            return isLower === true ? 'du' : 'DU';
	        }
	    },
	    calendar : {
	        sameDay : '[ma] LT[-kor]',
	        nextDay : '[holnap] LT[-kor]',
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : '[tegnap] LT[-kor]',
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s mlva',
	        past : '%s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return hu;

	})));


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var hyAm = moment.defineLocale('hy-am', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[] LT',
	        nextDay: '[] LT',
	        lastDay: '[] LT',
	        nextWeek: function () {
	            return 'dddd [ ] LT';
	        },
	        lastWeek: function () {
	            return '[] dddd [ ] LT';
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    meridiemParse: /|||/,
	    isPM: function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-';
	                }
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hyAm;

	})));


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var id = moment.defineLocale('id', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'siang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sore' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'siang';
	        } else if (hours < 19) {
	            return 'sore';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Besok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kemarin pukul] LT',
	        lastWeek : 'dddd [lalu pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lalu',
	        s : 'beberapa detik',
	        m : 'semenit',
	        mm : '%d menit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return id;

	})));


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik rn Sigursson : https://github.com/hinrik

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(n) {
	    if (n % 100 === 11) {
	        return true;
	    } else if (n % 10 === 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
	        case 'm':
	            return withoutSuffix ? 'mnta' : 'mntu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
	            } else if (withoutSuffix) {
	                return result + 'mnta';
	            }
	            return result + 'mntu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dgum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mnuur';
	            }
	            return isFuture ? 'mnu' : 'mnui';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mnuir';
	                }
	                return result + (isFuture ? 'mnui' : 'mnuum');
	            } else if (withoutSuffix) {
	                return result + 'mnuur';
	            }
	            return result + (isFuture ? 'mnu' : 'mnui');
	        case 'y':
	            return withoutSuffix || isFuture ? 'r' : 'ri';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
	            }
	            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
	    }
	}

	var is = moment.defineLocale('is', {
	    months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
	    weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
	    weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
	    weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	    },
	    calendar : {
	        sameDay : '[ dag kl.] LT',
	        nextDay : '[ morgun kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[ gr kl.] LT',
	        lastWeek : '[sasta] dddd [kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'eftir %s',
	        past : 'fyrir %s san',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : 'klukkustund',
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return is;

	})));


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var it = moment.defineLocale('it', {
	    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	    weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
	    weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
	    weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Oggi alle] LT',
	        nextDay: '[Domani alle] LT',
	        nextWeek: 'dddd [alle] LT',
	        lastDay: '[Ieri alle] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[la scorsa] dddd [alle] LT';
	                default:
	                    return '[lo scorso] dddd [alle] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	        },
	        past : '%s fa',
	        s : 'alcuni secondi',
	        m : 'un minuto',
	        mm : '%d minuti',
	        h : 'un\'ora',
	        hh : '%d ore',
	        d : 'un giorno',
	        dd : '%d giorni',
	        M : 'un mese',
	        MM : '%d mesi',
	        y : 'un anno',
	        yy : '%d anni'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return it;

	})));


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ja = moment.defineLocale('ja', {
	    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYYMD',
	        LLL : 'YYYYMD HH:mm',
	        LLLL : 'YYYYMD HH:mm dddd',
	        l : 'YYYY/MM/DD',
	        ll : 'YYYYMD',
	        lll : 'YYYYMD HH:mm',
	        llll : 'YYYYMD HH:mm dddd'
	    },
	    meridiemParse: /|/i,
	    isPM : function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[]dddd LT',
	        lastDay : '[] LT',
	        lastWeek : '[]dddd LT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1',
	        mm : '%d',
	        h : '1',
	        hh : '%d',
	        d : '1',
	        dd : '%d',
	        M : '1',
	        MM : '%d',
	        y : '1',
	        yy : '%d'
	    }
	});

	return ja;

	})));


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Javanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var jv = moment.defineLocale('jv', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'enjing') {
	            return hour;
	        } else if (meridiem === 'siyang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'enjing';
	        } else if (hours < 15) {
	            return 'siyang';
	        } else if (hours < 19) {
	            return 'sonten';
	        } else {
	            return 'ndalu';
	        }
	    },
	    calendar : {
	        sameDay : '[Dinten puniko pukul] LT',
	        nextDay : '[Mbenjang pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kala wingi pukul] LT',
	        lastWeek : 'dddd [kepengker pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'wonten ing %s',
	        past : '%s ingkang kepengker',
	        s : 'sawetawis detik',
	        m : 'setunggal menit',
	        mm : '%d menit',
	        h : 'setunggal jam',
	        hh : '%d jam',
	        d : 'sedinten',
	        dd : '%d dinten',
	        M : 'sewulan',
	        MM : '%d wulan',
	        y : 'setaun',
	        yy : '%d taun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return jv;

	})));


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ka = moment.defineLocale('ka', {
	    months : {
	        standalone: '___________'.split('_'),
	        format: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : {
	        standalone: '______'.split('_'),
	        format: '______'.split('_'),
	        isFormat: /(|)/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[] LT[-]',
	        nextDay : '[] LT[-]',
	        lastDay : '[] LT[-]',
	        nextWeek : '[] dddd LT[-]',
	        lastWeek : '[] dddd LT-',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(|||)/).test(s) ?
	                s.replace(/$/, '') :
	                s + '';
	        },
	        past : function (s) {
	            if ((/(||||)/).test(s)) {
	                return s.replace(/(|)$/, ' ');
	            }
	            if ((//).test(s)) {
	                return s.replace(/$/, ' ');
	            }
	        },
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
	    ordinal : function (number) {
	        if (number === 0) {
	            return number;
	        }
	        if (number === 1) {
	            return number + '-';
	        }
	        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	            return '-' + number;
	        }
	        return number + '-';
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});

	return ka;

	})));


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    0: '-',
	    1: '-',
	    2: '-',
	    3: '-',
	    4: '-',
	    5: '-',
	    6: '-',
	    7: '-',
	    8: '-',
	    9: '-',
	    10: '-',
	    20: '-',
	    30: '-',
	    40: '-',
	    50: '-',
	    60: '-',
	    70: '-',
	    80: '-',
	    90: '-',
	    100: '-'
	};

	var kk = moment.defineLocale('kk', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[ ] dddd [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kk;

	})));


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var km = moment.defineLocale('km', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[ ] LT',
	        lastWeek: 'dddd [] [] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: '%s',
	        past: '%s',
	        s: '',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return km;

	})));


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kannada [kn]
	//! author : Rajeev Naik : https://github.com/rajeevnaikte

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var kn = moment.defineLocale('kn', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}()/,
	    ordinal : function (number) {
	        return number + '';
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kn;

	})));


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ko = moment.defineLocale('ko', {
	    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'YYYY.MM.DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D A h:mm',
	        LLLL : 'YYYY MMMM D dddd A h:mm',
	        l : 'YYYY.MM.DD',
	        ll : 'YYYY MMMM D',
	        lll : 'YYYY MMMM D A h:mm',
	        llll : 'YYYY MMMM D dddd A h:mm'
	    },
	    calendar : {
	        sameDay : ' LT',
	        nextDay : ' LT',
	        nextWeek : 'dddd LT',
	        lastDay : ' LT',
	        lastWeek : ' dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        ss : '%d',
	        m : '1',
	        mm : '%d',
	        h : ' ',
	        hh : '%d',
	        d : '',
	        dd : '%d',
	        M : ' ',
	        MM : '%d',
	        y : ' ',
	        yy : '%d'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            case 'M':
	                return number + '';
	            case 'w':
	            case 'W':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    meridiemParse : /|/,
	    isPM : function (token) {
	        return token === '';
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour < 12 ? '' : '';
	    }
	});

	return ko;

	})));


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var suffixes = {
	    0: '-',
	    1: '-',
	    2: '-',
	    3: '-',
	    4: '-',
	    5: '-',
	    6: '-',
	    7: '-',
	    8: '-',
	    9: '-',
	    10: '-',
	    20: '-',
	    30: '-',
	    40: '-',
	    50: '-',
	    60: '-',
	    70: '-',
	    80: '-',
	    90: '-',
	    100: '-'
	};

	var ky = moment.defineLocale('ky', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[ ] dddd [] [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ky;

	})));


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eng Minutt', 'enger Minutt'],
	        'h': ['eng Stonn', 'enger Stonn'],
	        'd': ['een Dag', 'engem Dag'],
	        'M': ['ee Mount', 'engem Mount'],
	        'y': ['ee Joer', 'engem Joer']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'a ' + string;
	    }
	    return 'an ' + string;
	}
	function processPastTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'viru ' + string;
	    }
	    return 'virun ' + string;
	}
	/**
	 * Returns true if the word before the given number loses the '-n' ending.
	 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number = parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number < 0) {
	        // Negative Number --> always true
	        return true;
	    } else if (number < 10) {
	        // Only 1 digit
	        if (4 <= number && number <= 7) {
	            return true;
	        }
	        return false;
	    } else if (number < 100) {
	        // 2 digits
	        var lastDigit = number % 10, firstDigit = number / 10;
	        if (lastDigit === 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number < 10000) {
	        // 3 or 4 digits --> recursively check first digit
	        while (number >= 10) {
	            number = number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number = number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}

	var lb = moment.defineLocale('lb', {
	    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
	    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm [Auer]',
	        LTS: 'H:mm:ss [Auer]',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm [Auer]',
	        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	    },
	    calendar: {
	        sameDay: '[Haut um] LT',
	        sameElse: 'L',
	        nextDay: '[Muer um] LT',
	        nextWeek: 'dddd [um] LT',
	        lastDay: '[Gschter um] LT',
	        lastWeek: function () {
	            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return '[Leschten] dddd [um] LT';
	                default:
	                    return '[Leschte] dddd [um] LT';
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : 'e puer Sekonnen',
	        m : processRelativeTime,
	        mm : '%d Minutten',
	        h : processRelativeTime,
	        hh : '%d Stonnen',
	        d : processRelativeTime,
	        dd : '%d Deeg',
	        M : processRelativeTime,
	        MM : '%d Mint',
	        y : processRelativeTime,
	        yy : '%d Joer'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal: '%d.',
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lb;

	})));


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var lo = moment.defineLocale('lo', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM: function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[]dddd[] LT',
	        lastDay : '[] LT',
	        lastWeek : '[]dddd[] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /()\d{1,2}/,
	    ordinal : function (number) {
	        return '' + number;
	    }
	});

	return lo;

	})));


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozras : https://github.com/mmozuras

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var units = {
	    'm' : 'minut_minuts_minut',
	    'mm': 'minuts_minui_minutes',
	    'h' : 'valanda_valandos_valand',
	    'hh': 'valandos_valand_valandas',
	    'd' : 'diena_dienos_dien',
	    'dd': 'dienos_dien_dienas',
	    'M' : 'mnuo_mnesio_mnes',
	    'MM': 'mnesiai_mnesi_mnesius',
	    'y' : 'metai_met_metus',
	    'yy': 'metai_met_metus'
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return 'kelios sekunds';
	    } else {
	        return isFuture ? 'keli sekundi' : 'kelias sekundes';
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 === 0 || (number > 10 && number < 20);
	}
	function forms(key) {
	    return units[key].split('_');
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    if (number === 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt = moment.defineLocale('lt', {
	    months : {
	        format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
	        standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	    weekdays : {
	        format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
	        standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
	    weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY [m.] MMMM D [d.]',
	        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYY [m.] MMMM D [d.]',
	        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	    },
	    calendar : {
	        sameDay : '[iandien] LT',
	        nextDay : '[Rytoj] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[Vakar] LT',
	        lastWeek : '[Prajus] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'po %s',
	        past : 'prie %s',
	        s : translateSeconds,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + '-oji';
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lt;

	})));


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jnis Elmeris : https://github.com/JanisE

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var units = {
	    'm': 'mintes_mintm_minte_mintes'.split('_'),
	    'mm': 'mintes_mintm_minte_mintes'.split('_'),
	    'h': 'stundas_stundm_stunda_stundas'.split('_'),
	    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
	    'd': 'dienas_dienm_diena_dienas'.split('_'),
	    'dd': 'dienas_dienm_diena_dienas'.split('_'),
	    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
	    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
	    'y': 'gada_gadiem_gads_gadi'.split('_'),
	    'yy': 'gada_gadiem_gads_gadi'.split('_')
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. "21 minte", "3 mintes".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. "21 mintes" as in "pc 21 mintes".
	        // E.g. "3 mintm" as in "pc 3 mintm".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + ' ' + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
	}

	var lv = moment.defineLocale('lv', {
	    months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY.',
	        LL : 'YYYY. [gada] D. MMMM',
	        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	    },
	    calendar : {
	        sameDay : '[odien pulksten] LT',
	        nextDay : '[Rt pulksten] LT',
	        nextWeek : 'dddd [pulksten] LT',
	        lastDay : '[Vakar pulksten] LT',
	        lastWeek : '[Pagju] dddd [pulksten] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'pc %s',
	        past : 'pirms %s',
	        s : relativeSeconds,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lv;

	})));


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jednog minuta'],
	        mm: ['minut', 'minuta', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mjesec', 'mjeseca', 'mjeseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var me = moment.defineLocale('me', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sjutra u] LT',

	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jue u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prole] [nedjelje] [u] LT',
	                '[prolog] [ponedjeljka] [u] LT',
	                '[prolog] [utorka] [u] LT',
	                '[prole] [srijede] [u] LT',
	                '[prolog] [etvrtka] [u] LT',
	                '[prolog] [petka] [u] LT',
	                '[prole] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mjesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return me;

	})));


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var mi = moment.defineLocale('mi', {
	    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
	    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
	    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY [i] HH:mm',
	        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	    },
	    calendar: {
	        sameDay: '[i teie mahana, i] LT',
	        nextDay: '[apopo i] LT',
	        nextWeek: 'dddd [i] LT',
	        lastDay: '[inanahi i] LT',
	        lastWeek: 'dddd [whakamutunga i] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'i roto i %s',
	        past: '%s i mua',
	        s: 'te hkona ruarua',
	        m: 'he meneti',
	        mm: '%d meneti',
	        h: 'te haora',
	        hh: '%d haora',
	        d: 'he ra',
	        dd: '%d ra',
	        M: 'he marama',
	        MM: '%d marama',
	        y: 'he tau',
	        yy: '%d tau'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mi;

	})));


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var mk = moment.defineLocale('mk', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : 'e_o_____a'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : '[] dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-';
	        } else if (last2Digits === 0) {
	            return number + '-';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-';
	        } else if (lastDigit === 1) {
	            return number + '-';
	        } else if (lastDigit === 2) {
	            return number + '-';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-';
	        } else {
	            return number + '-';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mk;

	})));


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ml = moment.defineLocale('ml', {
	    months : '___________'.split('_'),
	    monthsShort : '._._._.___._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm -',
	        LTS : 'A h:mm:ss -',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm -',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm -'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    meridiemParse: /|| ||/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                meridiem === ' ' ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return ' ';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    }
	});

	return ml;

	})));


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output = '';
	    if (withoutSuffix) {
	        switch (string) {
	            case 's': output = ' '; break;
	            case 'm': output = ' '; break;
	            case 'mm': output = '%d '; break;
	            case 'h': output = ' '; break;
	            case 'hh': output = '%d '; break;
	            case 'd': output = ' '; break;
	            case 'dd': output = '%d '; break;
	            case 'M': output = ' '; break;
	            case 'MM': output = '%d '; break;
	            case 'y': output = ' '; break;
	            case 'yy': output = '%d '; break;
	        }
	    }
	    else {
	        switch (string) {
	            case 's': output = ' '; break;
	            case 'm': output = ' '; break;
	            case 'mm': output = '%d '; break;
	            case 'h': output = ' '; break;
	            case 'hh': output = '%d '; break;
	            case 'd': output = ' '; break;
	            case 'dd': output = '%d '; break;
	            case 'M': output = ' '; break;
	            case 'MM': output = '%d '; break;
	            case 'y': output = ' '; break;
	            case 'yy': output = '%d '; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}

	var mr = moment.defineLocale('mr', {
	    months : '___________'.split('_'),
	    monthsShort: '._._._._._._._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek: '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future: '%s',
	        past: '%s',
	        s: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mr;

	})));


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ms = moment.defineLocale('ms', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ms;

	})));


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var msMy = moment.defineLocale('ms-my', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return msMy;

	})));


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var my = moment.defineLocale('my', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),

	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[.] LT []',
	        nextDay: '[] LT []',
	        nextWeek: 'dddd LT []',
	        lastDay: '[.] LT []',
	        lastWeek: '[] dddd LT []',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: ' %s ',
	        past: ' %s ',
	        s: '.',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return my;

	})));


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokml [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var nb = moment.defineLocale('nb', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
	    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[i dag kl.] LT',
	        nextDay: '[i morgen kl.] LT',
	        nextWeek: 'dddd [kl.] LT',
	        lastDay: '[i gr kl.] LT',
	        lastWeek: '[forrige] dddd [kl.] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'noen sekunder',
	        m : 'ett minutt',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dager',
	        M : 'en mned',
	        MM : '%d mneder',
	        y : 'ett r',
	        yy : '%d r'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nb;

	})));


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var ne = moment.defineLocale('ne', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.___._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '._._._._._._.'.split('_'),
	    weekdaysMin : '._._._._._._.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 3) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 16) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[] dddd[,] LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd[,] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ne;

	})));


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nl = moment.defineLocale('nl', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'n minuut',
	        mm : '%d minuten',
	        h : 'n uur',
	        hh : '%d uur',
	        d : 'n dag',
	        dd : '%d dagen',
	        M : 'n maand',
	        MM : '%d maanden',
	        y : 'n jaar',
	        yy : '%d jaar'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nl;

	})));


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch (Belgium) [nl-be]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nlBe = moment.defineLocale('nl-be', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'n minuut',
	        mm : '%d minuten',
	        h : 'n uur',
	        hh : '%d uur',
	        d : 'n dag',
	        dd : '%d dagen',
	        M : 'n maand',
	        MM : '%d maanden',
	        y : 'n jaar',
	        yy : '%d jaar'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nlBe;

	})));


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var nn = moment.defineLocale('nn', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	    weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
	    weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[I dag klokka] LT',
	        nextDay: '[I morgon klokka] LT',
	        nextWeek: 'dddd [klokka] LT',
	        lastDay: '[I gr klokka] LT',
	        lastWeek: '[Fregande] dddd [klokka] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s sidan',
	        s : 'nokre sekund',
	        m : 'eit minutt',
	        mm : '%d minutt',
	        h : 'ein time',
	        hh : '%d timar',
	        d : 'ein dag',
	        dd : '%d dagar',
	        M : 'ein mnad',
	        MM : '%d mnader',
	        y : 'eit r',
	        yy : '%d r'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nn;

	})));


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var paIn = moment.defineLocale('pa-in', {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return paIn;

	})));


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
	var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	function plural(n) {
	    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minut';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzin';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesice' : 'miesicy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	    }
	}

	var pl = moment.defineLocale('pl', {
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return monthsNominative;
	        } else if (format === '') {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
	    weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
	    weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
	    weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Dzi o] LT',
	        nextDay: '[Jutro o] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[W niedziel o] LT';

	                case 2:
	                    return '[We wtorek o] LT';

	                case 3:
	                    return '[W rod o] LT';

	                case 6:
	                    return '[W sobot o] LT';

	                default:
	                    return '[W] dddd [o] LT';
	            }
	        },
	        lastDay: '[Wczoraj o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[W zesz niedziel o] LT';
	                case 3:
	                    return '[W zesz rod o] LT';
	                case 6:
	                    return '[W zesz sobot o] LT';
	                default:
	                    return '[W zeszy] dddd [o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : '%s temu',
	        s : 'kilka sekund',
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : '1 dzie',
	        dd : '%d dni',
	        M : 'miesic',
	        MM : translate,
	        y : 'rok',
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pl;

	})));


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var pt = moment.defineLocale('pt', {
	    months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
	    monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
	    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje s] LT',
	        nextDay: '[Amanh s] LT',
	        nextWeek: 'dddd [s] LT',
	        lastDay: '[Ontem s] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                '[ltima] dddd [s] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : 'h %s',
	        s : 'segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um ms',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pt;

	})));


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ptBr = moment.defineLocale('pt-br', {
	    months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
	    monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
	    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje s] LT',
	        nextDay: '[Amanh s] LT',
	        nextWeek: 'dddd [s] LT',
	        lastDay: '[Ontem s] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                '[ltima] dddd [s] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : '%s atrs',
	        s : 'poucos segundos',
	        ss : '%d segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um ms',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : '%d'
	});

	return ptBr;

	})));


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	            'mm': 'minute',
	            'hh': 'ore',
	            'dd': 'zile',
	            'MM': 'luni',
	            'yy': 'ani'
	        },
	        separator = ' ';
	    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	        separator = ' de ';
	    }
	    return number + separator + format[key];
	}

	var ro = moment.defineLocale('ro', {
	    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
	    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
	    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[azi la] LT',
	        nextDay: '[mine la] LT',
	        nextWeek: 'dddd [la] LT',
	        lastDay: '[ieri la] LT',
	        lastWeek: '[fosta] dddd [la] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'peste %s',
	        past : '%s n urm',
	        s : 'cteva secunde',
	        m : 'un minut',
	        mm : relativeTimeWithPlural,
	        h : 'o or',
	        hh : relativeTimeWithPlural,
	        d : 'o zi',
	        dd : relativeTimeWithPlural,
	        M : 'o lun',
	        MM : relativeTimeWithPlural,
	        y : 'un an',
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ro;

	})));


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensle : https://github.com/Oire
	//! author :   : https://github.com/socketpair

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

	// http://new.gramota.ru/spravka/rules/139-prop :  103
	//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru = moment.defineLocale('ru', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : {
	        //  CLDR  "."  ".",        ?
	        format: '._._._.____._._._._.'.split('_'),
	        standalone: '._.__.____._._._._.'.split('_')
	    },
	    weekdays : {
	        standalone: '______'.split('_'),
	        format: '______'.split('_'),
	        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    //    ,   ,  ,  4 ,      
	    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

	    //  
	    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

	    //    
	    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

	    // ,     
	    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        lastDay: '[ ] LT',
	        nextWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[] dddd [] LT';
	                } else {
	                    return '[] dddd [] LT';
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[] dddd [] LT';
	                } else {
	                    return '[] dddd [] LT';
	                }
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : '',
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /|||/i,
	    isPM : function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            case 'w':
	            case 'W':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ru;

	})));


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sindhi [sd]
	//! author : Narain Sagar : https://github.com/narainsagar

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	var days = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];

	var sd = moment.defineLocale('sd', {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        }
	        return '';
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd [  ] LT',
	        lastDay : '[] LT',
	        lastWeek : '[ ] dddd [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sd;

	})));


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Brd Rolstad Henriksen : https://github.com/karamell

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var se = moment.defineLocale('se', {
	    months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
	    monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
	    weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
	    weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
	    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'MMMM D. [b.] YYYY',
	        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[otne ti] LT',
	        nextDay: '[ihttin ti] LT',
	        nextWeek: 'dddd [ti] LT',
	        lastDay: '[ikte ti] LT',
	        lastWeek: '[ovddit] dddd [ti] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s geaes',
	        past : 'mait %s',
	        s : 'moadde sekunddat',
	        m : 'okta minuhta',
	        mm : '%d minuhtat',
	        h : 'okta diimmu',
	        hh : '%d diimmut',
	        d : 'okta beaivi',
	        dd : '%d beaivvit',
	        M : 'okta mnnu',
	        MM : '%d mnut',
	        y : 'okta jahki',
	        yy : '%d jagit'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return se;

	})));


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	/*jshint -W100*/
	var si = moment.defineLocale('si', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'a h:mm',
	        LTS : 'a h:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D, a h:mm',
	        LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
	    },
	    calendar : {
	        sameDay : '[] LT[]',
	        nextDay : '[] LT[]',
	        nextWeek : 'dddd LT[]',
	        lastDay : '[] LT[]',
	        lastWeek : '[] dddd LT[]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s ',
	        s : ' ',
	        m : '',
	        mm : ' %d',
	        h : '',
	        hh : ' %d',
	        d : '',
	        dd : ' %d',
	        M : '',
	        MM : ' %d',
	        y : '',
	        yy : ' %d'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2} /,
	    ordinal : function (number) {
	        return number + ' ';
	    },
	    meridiemParse : / | |.|../,
	    isPM : function (input) {
	        return input === '..' || input === ' ';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? '..' : ' ';
	        } else {
	            return isLower ? '..' : ' ';
	        }
	    }
	});

	return si;

	})));


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
	var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minty' : 'mint');
	            } else {
	                return result + 'mintami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodn');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'de' : 'dom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dn');
	            } else {
	                return result + 'dami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	    }
	}

	var sk = moment.defineLocale('sk', {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
	    weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
	    weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[dnes o] LT',
	        nextDay: '[zajtra o] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo tvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	            }
	        },
	        lastDay: '[vera o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minul nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [o] LT';
	                case 3:
	                    return '[minul stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [o] LT';
	                case 6:
	                    return '[minul sobotu o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'pred %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sk;

	})));


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovek : https://github.com/sedovsek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	    }
	}

	var sl = moment.defineLocale('sl', {
	    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
	    weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
	    weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danes ob] LT',
	        nextDay  : '[jutri ob] LT',

	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	            }
	        },
	        lastDay  : '[veraj ob] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[prejnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejnji] dddd [ob] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ez %s',
	        past   : 'pred %s',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sl;

	})));


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakrim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sq = moment.defineLocale('sq', {
	    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
	    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
	    weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
	    weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
	    weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) === 'M';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours < 12 ? 'PD' : 'MD';
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Sot n] LT',
	        nextDay : '[Nesr n] LT',
	        nextWeek : 'dddd [n] LT',
	        lastDay : '[Dje n] LT',
	        lastWeek : 'dddd [e kaluar n] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'n %s',
	        past : '%s m par',
	        s : 'disa sekonda',
	        m : 'nj minut',
	        mm : '%d minuta',
	        h : 'nj or',
	        hh : '%d or',
	        d : 'nj dit',
	        dd : '%d dit',
	        M : 'nj muaj',
	        MM : '%d muaj',
	        y : 'nj vit',
	        yy : '%d vite'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sq;

	})));


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jedne minute'],
	        mm: ['minut', 'minute', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mesec', 'meseca', 'meseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var sr = moment.defineLocale('sr', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sutra u] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jue u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prole] [nedelje] [u] LT',
	                '[prolog] [ponedeljka] [u] LT',
	                '[prolog] [utorka] [u] LT',
	                '[prole] [srede] [u] LT',
	                '[prolog] [etvrtka] [u] LT',
	                '[prolog] [petka] [u] LT',
	                '[prole] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'pre %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sr;

	})));


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: [' ', ' '],
	        mm: ['', '', ''],
	        h: [' ', ' '],
	        hh: ['', '', ''],
	        dd: ['', '', ''],
	        MM: ['', '', ''],
	        yy: ['', '', '']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var srCyrl = moment.defineLocale('sr-cyrl', {
	    months: '___________'.split('_'),
	    monthsShort: '._._._.____._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays: '______'.split('_'),
	    weekdaysShort: '._._._._._._.'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[] [] [] LT';
	                case 3:
	                    return '[] [] [] LT';
	                case 6:
	                    return '[] [] [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	            }
	        },
	        lastDay  : '[ ] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past   : ' %s',
	        s      : ' ',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : '',
	        dd     : translator.translate,
	        M      : '',
	        MM     : translator.translate,
	        y      : '',
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return srCyrl;

	})));


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var ss = moment.defineLocale('ss', {
	    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Namuhla nga] LT',
	        nextDay : '[Kusasa nga] LT',
	        nextWeek : 'dddd [nga] LT',
	        lastDay : '[Itolo nga] LT',
	        lastWeek : 'dddd [leliphelile] [nga] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'nga %s',
	        past : 'wenteka nga %s',
	        s : 'emizuzwana lomcane',
	        m : 'umzuzu',
	        mm : '%d emizuzu',
	        h : 'lihora',
	        hh : '%d emahora',
	        d : 'lilanga',
	        dd : '%d emalanga',
	        M : 'inyanga',
	        MM : '%d tinyanga',
	        y : 'umnyaka',
	        yy : '%d iminyaka'
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'ekuseni';
	        } else if (hours < 15) {
	            return 'emini';
	        } else if (hours < 19) {
	            return 'entsambama';
	        } else {
	            return 'ebusuku';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ekuseni') {
	            return hour;
	        } else if (meridiem === 'emini') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	            if (hour === 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ss;

	})));


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sv = moment.defineLocale('sv', {
	    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
	    weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Idag] LT',
	        nextDay: '[Imorgon] LT',
	        lastDay: '[Igr] LT',
	        nextWeek: '[P] dddd LT',
	        lastWeek: '[I] dddd[s] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : 'fr %s sedan',
	        s : 'ngra sekunder',
	        m : 'en minut',
	        mm : '%d minuter',
	        h : 'en timme',
	        hh : '%d timmar',
	        d : 'en dag',
	        dd : '%d dagar',
	        M : 'en mnad',
	        MM : '%d mnader',
	        y : 'ett r',
	        yy : '%d r'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'e' :
	            (b === 1) ? 'a' :
	            (b === 2) ? 'a' :
	            (b === 3) ? 'e' : 'e';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sv;

	})));


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sw = moment.defineLocale('sw', {
	    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[leo saa] LT',
	        nextDay : '[kesho saa] LT',
	        nextWeek : '[wiki ijayo] dddd [saat] LT',
	        lastDay : '[jana] LT',
	        lastWeek : '[wiki iliyopita] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s baadaye',
	        past : 'tokea %s',
	        s : 'hivi punde',
	        m : 'dakika moja',
	        mm : 'dakika %d',
	        h : 'saa limoja',
	        hh : 'masaa %d',
	        d : 'siku moja',
	        dd : 'masiku %d',
	        M : 'mwezi mmoja',
	        MM : 'miezi %d',
	        y : 'mwaka mmoja',
	        yy : 'miaka %d'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sw;

	})));


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};

	var ta = moment.defineLocale('ta', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, HH:mm',
	        LLLL : 'dddd, D MMMM YYYY, HH:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[ ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : ' ',
	        mm : '%d ',
	        h : '  ',
	        hh : '%d  ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number + '';
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /|||||/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 2) {
	            return ' ';
	        } else if (hour < 6) {
	            return ' ';  // 
	        } else if (hour < 10) {
	            return ' '; // 
	        } else if (hour < 14) {
	            return ' '; // 
	        } else if (hour < 18) {
	            return ' '; // 
	        } else if (hour < 22) {
	            return ' '; // 
	        } else {
	            return ' ';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 2 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ta;

	})));


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var te = moment.defineLocale('te', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.____._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return te;

	})));


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tetun Dili (East Timor) [tet]
	//! author : Joshua Brooks : https://github.com/joshbrooks
	//! author : Onorio De J. Afonso : https://github.com/marobo

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tet = moment.defineLocale('tet', {
	    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
	    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Ohin iha] LT',
	        nextDay: '[Aban iha] LT',
	        nextWeek: 'dddd [iha] LT',
	        lastDay: '[Horiseik iha] LT',
	        lastWeek: 'dddd [semana kotuk] [iha] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'iha %s',
	        past : '%s liuba',
	        s : 'minutu balun',
	        m : 'minutu ida',
	        mm : 'minutus %d',
	        h : 'horas ida',
	        hh : 'horas %d',
	        d : 'loron ida',
	        dd : 'loron %d',
	        M : 'fulan ida',
	        MM : 'fulan %d',
	        y : 'tinan ida',
	        yy : 'tinan %d'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tet;

	})));


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var th = moment.defineLocale('th', {
	    months : '___________'.split('_'),
	    monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'), // yes, three characters difference
	    weekdaysMin : '._._._._._._.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY  H:mm',
	        LLLL : 'dddd D MMMM YYYY  H:mm'
	    },
	    meridiemParse: /|/,
	    isPM: function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd[ ] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[]dddd[ ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});

	return th;

	})));


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tlPh = moment.defineLocale('tl-ph', {
	    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'MM/D/YYYY',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY HH:mm',
	        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: 'LT [ngayong araw]',
	        nextDay: '[Bukas ng] LT',
	        nextWeek: 'LT [sa susunod na] dddd',
	        lastDay: 'LT [kahapon]',
	        lastWeek: 'LT [noong nakaraang] dddd',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'sa loob ng %s',
	        past : '%s ang nakalipas',
	        s : 'ilang segundo',
	        m : 'isang minuto',
	        mm : '%d minuto',
	        h : 'isang oras',
	        hh : '%d oras',
	        d : 'isang araw',
	        dd : '%d araw',
	        M : 'isang buwan',
	        MM : '%d buwan',
	        y : 'isang taon',
	        yy : '%d taon'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlPh;

	})));


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

	function translateFuture(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'leS' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'waQ' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'nem' :
	    time + ' pIq';
	    return time;
	}

	function translatePast(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'Hu' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'wen' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'ben' :
	    time + ' ret';
	    return time;
	}

	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun = numberAsNoun(number);
	    switch (string) {
	        case 'mm':
	            return numberNoun + ' tup';
	        case 'hh':
	            return numberNoun + ' rep';
	        case 'dd':
	            return numberNoun + ' jaj';
	        case 'MM':
	            return numberNoun + ' jar';
	        case 'yy':
	            return numberNoun + ' DIS';
	    }
	}

	function numberAsNoun(number) {
	    var hundred = Math.floor((number % 1000) / 100),
	    ten = Math.floor((number % 100) / 10),
	    one = number % 10,
	    word = '';
	    if (hundred > 0) {
	        word += numbersNouns[hundred] + 'vatlh';
	    }
	    if (ten > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	    }
	    if (one > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	    }
	    return (word === '') ? 'pagh' : word;
	}

	var tlh = moment.defineLocale('tlh', {
	    months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
	    monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[DaHjaj] LT',
	        nextDay: '[waleS] LT',
	        nextWeek: 'LLL',
	        lastDay: '[waHu] LT',
	        lastWeek: 'LLL',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : 'puS lup',
	        m : 'wa tup',
	        mm : translate,
	        h : 'wa rep',
	        hh : translate,
	        d : 'wa jaj',
	        dd : translate,
	        M : 'wa jar',
	        MM : translate,
	        y : 'wa DIS',
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlh;

	})));


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiit Kaya: https://github.com/BYK

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    1: '\'inci',
	    5: '\'inci',
	    8: '\'inci',
	    70: '\'inci',
	    80: '\'inci',
	    2: '\'nci',
	    7: '\'nci',
	    20: '\'nci',
	    50: '\'nci',
	    3: '\'nc',
	    4: '\'nc',
	    100: '\'nc',
	    6: '\'nc',
	    9: '\'uncu',
	    10: '\'uncu',
	    30: '\'uncu',
	    60: '\'nc',
	    90: '\'nc'
	};

	var tr = moment.defineLocale('tr', {
	    months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
	    monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
	    weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
	    weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
	    weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugn saat] LT',
	        nextDay : '[yarn saat] LT',
	        nextWeek : '[gelecek] dddd [saat] LT',
	        lastDay : '[dn] LT',
	        lastWeek : '[geen] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s nce',
	        s : 'birka saniye',
	        m : 'bir dakika',
	        mm : '%d dakika',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gn',
	        dd : '%d gn',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir yl',
	        yy : '%d yl'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '\'nc';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tr;

	})));


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iust Canun

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl = moment.defineLocale('tzl', {
	    months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	    weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
	    weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
	    weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM [dallas] YYYY',
	        LLL : 'D. MMMM [dallas] YYYY HH.mm',
	        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	    },
	    meridiemParse: /d\'o|d\'a/i,
	    isPM : function (input) {
	        return 'd\'o' === input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'd\'o' : 'D\'O';
	        } else {
	            return isLower ? 'd\'a' : 'D\'A';
	        }
	    },
	    calendar : {
	        sameDay : '[oxhi ] LT',
	        nextDay : '[dem ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ieiri ] LT',
	        lastWeek : '[sr el] dddd [lasteu ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'osprei %s',
	        past : 'ja%s',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['viensas secunds', '\'iensas secunds'],
	        'm': ['\'n mut', '\'iens mut'],
	        'mm': [number + ' muts', '' + number + ' muts'],
	        'h': ['\'n ora', '\'iensa ora'],
	        'hh': [number + ' oras', '' + number + ' oras'],
	        'd': ['\'n ziua', '\'iensa ziua'],
	        'dd': [number + ' ziuas', '' + number + ' ziuas'],
	        'M': ['\'n mes', '\'iens mes'],
	        'MM': [number + ' mesen', '' + number + ' mesen'],
	        'y': ['\'n ar', '\'iens ar'],
	        'yy': [number + ' ars', '' + number + ' ars']
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}

	return tzl;

	})));


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tzm = moment.defineLocale('tzm', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[ ] LT',
	        lastWeek: 'dddd [] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '   %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d o',
	        M : 'o',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzm;

	})));


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tzmLatn = moment.defineLocale('tzm-latn', {
	    months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	    monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[asdkh g] LT',
	        nextDay: '[aska g] LT',
	        nextWeek: 'dddd [g] LT',
	        lastDay: '[assant g] LT',
	        lastWeek: 'dddd [g] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dadkh s yan %s',
	        past : 'yan %s',
	        s : 'imik',
	        m : 'minu',
	        mm : '%d minu',
	        h : 'saa',
	        hh : '%d tassain',
	        d : 'ass',
	        dd : '%d ossan',
	        M : 'ayowr',
	        MM : '%d iyyirn',
	        y : 'asgas',
	        yy : '%d isgasn'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzmLatn;

	})));


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': withoutSuffix ? '__' : '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays = {
	        'nominative': '______'.split('_'),
	        'accusative': '______'.split('_'),
	        'genitive': '______'.split('_')
	    };

	    if (!m) {
	        return weekdays['nominative'];
	    }

	    var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
	        'accusative' :
	        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
	            'genitive' :
	            'nominative');
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
	    };
	}

	var uk = moment.defineLocale('uk', {
	    months : {
	        'format': '___________'.split('_'),
	        'standalone': '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: processHoursFunction('[ '),
	        nextDay: processHoursFunction('[ '),
	        lastDay: processHoursFunction('[ '),
	        nextWeek: processHoursFunction('[] dddd ['),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[] dddd [').call(this);
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : '',
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /|||/,
	    isPM: function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uk;

	})));


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Urdu [ur]
	//! author : Sawood Alam : https://github.com/ibnesayeed
	//! author : Zack : https://github.com/ZackVision

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	var days = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];

	var ur = moment.defineLocale('ur', {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        }
	        return '';
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[  ] LT',
	        lastWeek : '[] dddd [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ur;

	})));


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var uz = moment.defineLocale('uz', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT []',
	        nextDay : '[] LT []',
	        nextWeek : 'dddd [ ] LT []',
	        lastDay : '[ ] LT []',
	        lastWeek : '[] dddd [ ] LT []',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s ',
	        past : '  %s ',
	        s : '',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return uz;

	})));


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek Latin [uz-latn]
	//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var uzLatn = moment.defineLocale('uz-latn', {
	    months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
	    monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
	    weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
	    weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
	    weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[Bugun soat] LT [da]',
	        nextDay : '[Ertaga] LT [da]',
	        nextWeek : 'dddd [kuni soat] LT [da]',
	        lastDay : '[Kecha soat] LT [da]',
	        lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'Yaqin %s ichida',
	        past : 'Bir necha %s oldin',
	        s : 'soniya',
	        m : 'bir daqiqa',
	        mm : '%d daqiqa',
	        h : 'bir soat',
	        hh : '%d soat',
	        d : 'bir kun',
	        dd : '%d kun',
	        M : 'bir oy',
	        MM : '%d oy',
	        y : 'bir yil',
	        yy : '%d yil'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uzLatn;

	})));


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var vi = moment.defineLocale('vi', {
	    months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
	    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
	    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'sa' : 'SA';
	        } else {
	            return isLower ? 'ch' : 'CH';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM [nm] YYYY',
	        LLL : 'D MMMM [nm] YYYY HH:mm',
	        LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
	        l : 'DD/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hm nay lc] LT',
	        nextDay: '[Ngy mai lc] LT',
	        nextWeek: 'dddd [tun ti lc] LT',
	        lastDay: '[Hm qua lc] LT',
	        lastWeek: 'dddd [tun ri lc] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s ti',
	        past : '%s trc',
	        s : 'vi giy',
	        m : 'mt pht',
	        mm : '%d pht',
	        h : 'mt gi',
	        hh : '%d gi',
	        d : 'mt ngy',
	        dd : '%d ngy',
	        M : 'mt thng',
	        MM : '%d thng',
	        y : 'mt nm',
	        yy : '%d nm'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return vi;

	})));


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var xPseudo = moment.defineLocale('x-pseudo', {
	    months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
	    monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
	    weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
	    weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[T~d~ t] LT',
	        nextDay : '[T~m~rr~w t] LT',
	        nextWeek : 'dddd [t] LT',
	        lastDay : '[~st~rd~ t] LT',
	        lastWeek : '[L~st] dddd [t] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '~ %s',
	        past : '%s ~g',
	        s : ' ~fw ~sc~ds',
	        m : ' ~m~t',
	        mm : '%d m~~ts',
	        h : '~ h~r',
	        hh : '%d h~rs',
	        d : ' ~d',
	        dd : '%d d~s',
	        M : ' ~m~th',
	        MM : '%d m~t~hs',
	        y : ' ~r',
	        yy : '%d ~rs'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return xPseudo;

	})));


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Yoruba Nigeria [yo]
	//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var yo = moment.defineLocale('yo', {
	    months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
	    monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
	    weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
	    weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
	    weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Oni ni] LT',
	        nextDay : '[la ni] LT',
	        nextWeek : 'dddd [s ton\'b] [ni] LT',
	        lastDay : '[Ana ni] LT',
	        lastWeek : 'dddd [s tol] [ni] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ni %s',
	        past : '%s kja',
	        s : 'isju aaya die',
	        m : 'isju kan',
	        mm : 'isju %d',
	        h : 'wakati kan',
	        hh : 'wakati %d',
	        d : 'j kan',
	        dd : 'j %d',
	        M : 'osu kan',
	        MM : 'osu %d',
	        y : 'dun kan',
	        yy : 'dun %d'
	    },
	    dayOfMonthOrdinalParse : /j\s\d{1,2}/,
	    ordinal : 'j %d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return yo;

	})));


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhCn = moment.defineLocale('zh-cn', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMD HH:mm',
	        llll : 'YYYYMMMDdddd HH:mm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' ||
	                meridiem === '') {
	            return hour;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        } else {
	            // ''
	            return hour >= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            case 'M':
	                return number + '';
	            case 'w':
	            case 'W':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    },
	    week : {
	        // GB/T 7408-1994ISO 8601:1988
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return zhCn;

	})));


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhHk = moment.defineLocale('zh-hk', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMD HH:mm',
	        LLLL : 'YYYYMMMDdddd HH:mm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMD HH:mm',
	        llll : 'YYYYMMMDdddd HH:mm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});

	return zhHk;

	})));


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(205)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhTw = moment.defineLocale('zh-tw', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMD HH:mm',
	        LLLL : 'YYYYMMMDdddd HH:mm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMD HH:mm',
	        llll : 'YYYYMMMDdddd HH:mm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});

	return zhTw;

	})));


/***/ }),
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable:no-unused-variable */
	// Subject imported before Observable to bypass circular dependency issue since
	// Subject extends Observable and Observable references Subject in it's
	// definition
	var Subject_1 = __webpack_require__(6);
	exports.Subject = Subject_1.Subject;
	exports.AnonymousSubject = Subject_1.AnonymousSubject;
	/* tslint:enable:no-unused-variable */
	var Observable_1 = __webpack_require__(7);
	exports.Observable = Observable_1.Observable;
	// statics
	/* tslint:disable:no-use-before-declare */
	__webpack_require__(702);
	__webpack_require__(706);
	__webpack_require__(709);
	__webpack_require__(712);
	__webpack_require__(715);
	__webpack_require__(718);
	__webpack_require__(720);
	__webpack_require__(723);
	__webpack_require__(724);
	__webpack_require__(727);
	__webpack_require__(730);
	__webpack_require__(731);
	__webpack_require__(733);
	__webpack_require__(736);
	__webpack_require__(740);
	__webpack_require__(743);
	__webpack_require__(745);
	__webpack_require__(27);
	__webpack_require__(749);
	__webpack_require__(751);
	__webpack_require__(754);
	__webpack_require__(757);
	__webpack_require__(33);
	__webpack_require__(760);
	__webpack_require__(764);
	//dom
	__webpack_require__(767);
	__webpack_require__(770);
	//operators
	__webpack_require__(778);
	__webpack_require__(780);
	__webpack_require__(782);
	__webpack_require__(784);
	__webpack_require__(786);
	__webpack_require__(36);
	__webpack_require__(788);
	__webpack_require__(790);
	__webpack_require__(791);
	__webpack_require__(792);
	__webpack_require__(793);
	__webpack_require__(794);
	__webpack_require__(797);
	__webpack_require__(799);
	__webpack_require__(801);
	__webpack_require__(43);
	__webpack_require__(803);
	__webpack_require__(805);
	__webpack_require__(807);
	__webpack_require__(809);
	__webpack_require__(50);
	__webpack_require__(812);
	__webpack_require__(52);
	__webpack_require__(814);
	__webpack_require__(816);
	__webpack_require__(818);
	__webpack_require__(820);
	__webpack_require__(54);
	__webpack_require__(823);
	__webpack_require__(825);
	__webpack_require__(827);
	__webpack_require__(829);
	__webpack_require__(830);
	__webpack_require__(835);
	__webpack_require__(837);
	__webpack_require__(839);
	__webpack_require__(841);
	__webpack_require__(843);
	__webpack_require__(844);
	__webpack_require__(846);
	__webpack_require__(56);
	__webpack_require__(847);
	__webpack_require__(849);
	__webpack_require__(851);
	__webpack_require__(853);
	__webpack_require__(854);
	__webpack_require__(855);
	__webpack_require__(856);
	__webpack_require__(857);
	__webpack_require__(859);
	__webpack_require__(861);
	__webpack_require__(864);
	__webpack_require__(865);
	__webpack_require__(866);
	__webpack_require__(868);
	__webpack_require__(871);
	__webpack_require__(873);
	__webpack_require__(875);
	__webpack_require__(877);
	__webpack_require__(879);
	__webpack_require__(881);
	__webpack_require__(882);
	__webpack_require__(883);
	__webpack_require__(885);
	__webpack_require__(887);
	__webpack_require__(889);
	__webpack_require__(891);
	__webpack_require__(893);
	__webpack_require__(895);
	__webpack_require__(897);
	__webpack_require__(899);
	__webpack_require__(901);
	__webpack_require__(903);
	__webpack_require__(905);
	__webpack_require__(907);
	__webpack_require__(909);
	__webpack_require__(911);
	__webpack_require__(920);
	__webpack_require__(58);
	__webpack_require__(922);
	__webpack_require__(924);
	__webpack_require__(926);
	__webpack_require__(928);
	__webpack_require__(930);
	__webpack_require__(932);
	__webpack_require__(934);
	__webpack_require__(936);
	__webpack_require__(938);
	__webpack_require__(941);
	__webpack_require__(943);
	__webpack_require__(945);
	__webpack_require__(60);
	__webpack_require__(947);
	__webpack_require__(949);
	__webpack_require__(951);
	__webpack_require__(953);
	__webpack_require__(955);
	__webpack_require__(957);
	__webpack_require__(959);
	__webpack_require__(960);
	/* tslint:disable:no-unused-variable */
	var Subscription_1 = __webpack_require__(11);
	exports.Subscription = Subscription_1.Subscription;
	var Subscriber_1 = __webpack_require__(9);
	exports.Subscriber = Subscriber_1.Subscriber;
	var AsyncSubject_1 = __webpack_require__(705);
	exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
	var ReplaySubject_1 = __webpack_require__(773);
	exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
	var BehaviorSubject_1 = __webpack_require__(92);
	exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
	var ConnectableObservable_1 = __webpack_require__(863);
	exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
	var Notification_1 = __webpack_require__(98);
	exports.Notification = Notification_1.Notification;
	var EmptyError_1 = __webpack_require__(103);
	exports.EmptyError = EmptyError_1.EmptyError;
	var ArgumentOutOfRangeError_1 = __webpack_require__(822);
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	var ObjectUnsubscribedError_1 = __webpack_require__(19);
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
	var TimeoutError_1 = __webpack_require__(940);
	exports.TimeoutError = TimeoutError_1.TimeoutError;
	var UnsubscriptionError_1 = __webpack_require__(16);
	exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
	var timeInterval_1 = __webpack_require__(937);
	exports.TimeInterval = timeInterval_1.TimeInterval;
	var timestamp_1 = __webpack_require__(944);
	exports.Timestamp = timestamp_1.Timestamp;
	var TestScheduler_1 = __webpack_require__(962);
	exports.TestScheduler = TestScheduler_1.TestScheduler;
	var VirtualTimeScheduler_1 = __webpack_require__(968);
	exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
	var AjaxObservable_1 = __webpack_require__(769);
	exports.AjaxResponse = AjaxObservable_1.AjaxResponse;
	exports.AjaxError = AjaxObservable_1.AjaxError;
	exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;
	var asap_1 = __webpack_require__(914);
	var async_1 = __webpack_require__(45);
	var queue_1 = __webpack_require__(774);
	var animationFrame_1 = __webpack_require__(969);
	var rxSubscriber_1 = __webpack_require__(18);
	var iterator_1 = __webpack_require__(41);
	var observable_1 = __webpack_require__(4);
	/* tslint:enable:no-unused-variable */
	/**
	 * @typedef {Object} Rx.Scheduler
	 * @property {Scheduler} queue Schedules on a queue in the current event frame
	 * (trampoline scheduler). Use this for iteration operations.
	 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
	 * fastest transport mechanism available, either Node.js' `process.nextTick()`
	 * or Web Worker MessageChannel or setTimeout or others. Use this for
	 * asynchronous conversions.
	 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
	 * time-based operations.
	 * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.
	 * Use this for synchronizing with the platform's painting
	 */
	var Scheduler = {
	    asap: asap_1.asap,
	    queue: queue_1.queue,
	    animationFrame: animationFrame_1.animationFrame,
	    async: async_1.async
	};
	exports.Scheduler = Scheduler;
	/**
	 * @typedef {Object} Rx.Symbol
	 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
	 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
	 * an object that has all of the traits of an Rx Subscriber, including the
	 * ability to add and remove subscriptions to the subscription chain and
	 * guarantees involving event triggering (can't "next" after unsubscription,
	 * etc).
	 * @property {Symbol|string} observable A symbol to use as a property name to
	 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
	 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
	 * to retrieve an iterator from an object.
	 */
	var Symbol = {
	    rxSubscriber: rxSubscriber_1.$$rxSubscriber,
	    observable: observable_1.$$observable,
	    iterator: iterator_1.$$iterator
	};
	exports.Symbol = Symbol;
	//# sourceMappingURL=Rx.js.map

/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var bindCallback_1 = __webpack_require__(703);
	Observable_1.Observable.bindCallback = bindCallback_1.bindCallback;
	//# sourceMappingURL=bindCallback.js.map

/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var BoundCallbackObservable_1 = __webpack_require__(704);
	exports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;
	//# sourceMappingURL=bindCallback.js.map

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var AsyncSubject_1 = __webpack_require__(705);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundCallbackObservable = (function (_super) {
	    __extends(BoundCallbackObservable, _super);
	    function BoundCallbackObservable(callbackFunc, selector, args, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a callback API to a function that returns an Observable.
	     *
	     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
	     * it will return a function `g` that when called as `g(x)` will output an
	     * Observable.</span>
	     *
	     * `bindCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done. The output of `bindCallback` is a function that takes the same
	     * parameters as `func`, except the last one (the callback). When the output
	     * function is called with arguments, it will return an Observable where the
	     * results will be delivered to.
	     *
	     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
	     * // Suppose we have jQuery.getJSON('/my/url', callback)
	     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
	     * var result = getJSONAsObservable('/my/url');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindNodeCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a callback as the last parameter.
	     * @param {function} [selector] A function which takes the arguments from the
	     * callback and maps those a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the callback would deliver.
	     * @static true
	     * @name bindCallback
	     * @owner Observable
	     */
	    BoundCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundCallbackObservable(func, selector, args, scheduler);
	        };
	    };
	    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    if (selector) {
	                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1.errorObject) {
	                            subject.error(errorObject_1.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	                if (result === errorObject_1.errorObject) {
	                    subject.error(errorObject_1.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber });
	        }
	    };
	    BoundCallbackObservable.dispatch = function (state) {
	        var self = this;
	        var source = state.source, subscriber = state.subscriber;
	        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
	        var subject = source.subject;
	        if (!subject) {
	            subject = source.subject = new AsyncSubject_1.AsyncSubject();
	            var handler = function handlerFn() {
	                var innerArgs = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    innerArgs[_i - 0] = arguments[_i];
	                }
	                var source = handlerFn.source;
	                var selector = source.selector, subject = source.subject;
	                if (selector) {
	                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                    if (result_2 === errorObject_1.errorObject) {
	                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	                    }
	                    else {
	                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                    }
	                }
	                else {
	                    var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	                }
	            };
	            // use named function to pass values in without closure
	            handler.source = source;
	            var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	            if (result === errorObject_1.errorObject) {
	                subject.error(errorObject_1.errorObject.e);
	            }
	        }
	        self.add(subject.subscribe(subscriber));
	    };
	    return BoundCallbackObservable;
	}(Observable_1.Observable));
	exports.BoundCallbackObservable = BoundCallbackObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}
	//# sourceMappingURL=BoundCallbackObservable.js.map

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscription_1 = __webpack_require__(11);
	/**
	 * @class AsyncSubject<T>
	 */
	var AsyncSubject = (function (_super) {
	    __extends(AsyncSubject, _super);
	    function AsyncSubject() {
	        _super.apply(this, arguments);
	        this.value = null;
	        this.hasNext = false;
	        this.hasCompleted = false;
	    }
	    AsyncSubject.prototype._subscribe = function (subscriber) {
	        if (this.hasCompleted && this.hasNext) {
	            subscriber.next(this.value);
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.hasCompleted) {
	            this.value = value;
	            this.hasNext = true;
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        this.hasCompleted = true;
	        if (this.hasNext) {
	            _super.prototype.next.call(this, this.value);
	        }
	        _super.prototype.complete.call(this);
	    };
	    return AsyncSubject;
	}(Subject_1.Subject));
	exports.AsyncSubject = AsyncSubject;
	//# sourceMappingURL=AsyncSubject.js.map

/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var bindNodeCallback_1 = __webpack_require__(707);
	Observable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
	//# sourceMappingURL=bindNodeCallback.js.map

/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var BoundNodeCallbackObservable_1 = __webpack_require__(708);
	exports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;
	//# sourceMappingURL=bindNodeCallback.js.map

/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var AsyncSubject_1 = __webpack_require__(705);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundNodeCallbackObservable = (function (_super) {
	    __extends(BoundNodeCallbackObservable, _super);
	    function BoundNodeCallbackObservable(callbackFunc, selector, args, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a Node.js-style callback API to a function that returns an
	     * Observable.
	     *
	     * <span class="informal">It's just like {@link bindCallback}, but the
	     * callback is expected to be of type `callback(error, result)`.</span>
	     *
	     * `bindNodeCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done. The callback function is expected to follow Node.js conventions,
	     * where the first argument to the callback is an error, while remaining
	     * arguments are the callback result. The output of `bindNodeCallback` is a
	     * function that takes the same parameters as `func`, except the last one (the
	     * callback). When the output function is called with arguments, it will
	     * return an Observable where the results will be delivered to.
	     *
	     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
	     * import * as fs from 'fs';
	     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
	     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a callback as the last parameter.
	     * @param {function} [selector] A function which takes the arguments from the
	     * callback and maps those a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the Node.js callback would
	     * deliver.
	     * @static true
	     * @name bindNodeCallback
	     * @owner Observable
	     */
	    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundNodeCallbackObservable(func, selector, args, scheduler);
	        };
	    };
	    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    var err = innerArgs.shift();
	                    if (err) {
	                        subject.error(err);
	                    }
	                    else if (selector) {
	                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1.errorObject) {
	                            subject.error(errorObject_1.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	                if (result === errorObject_1.errorObject) {
	                    subject.error(errorObject_1.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber });
	        }
	    };
	    return BoundNodeCallbackObservable;
	}(Observable_1.Observable));
	exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;
	function dispatch(state) {
	    var self = this;
	    var source = state.source, subscriber = state.subscriber;
	    // XXX: cast to `any` to access to the private field in `source`.
	    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;
	    var subject = source.subject;
	    if (!subject) {
	        subject = source.subject = new AsyncSubject_1.AsyncSubject();
	        var handler = function handlerFn() {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i - 0] = arguments[_i];
	            }
	            var source = handlerFn.source;
	            var selector = source.selector, subject = source.subject;
	            var err = innerArgs.shift();
	            if (err) {
	                subject.error(err);
	            }
	            else if (selector) {
	                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                if (result_2 === errorObject_1.errorObject) {
	                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	                }
	                else {
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                }
	            }
	            else {
	                var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
	                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	            }
	        };
	        // use named function to pass values in without closure
	        handler.source = source;
	        var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	        if (result === errorObject_1.errorObject) {
	            subject.error(errorObject_1.errorObject.e);
	        }
	    }
	    self.add(subject.subscribe(subscriber));
	}
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}
	//# sourceMappingURL=BoundNodeCallbackObservable.js.map

/***/ }),
/* 709 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var combineLatest_1 = __webpack_require__(710);
	Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;
	//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(32);
	var isArray_1 = __webpack_require__(12);
	var ArrayObservable_1 = __webpack_require__(29);
	var combineLatest_1 = __webpack_require__(711);
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from all the Observables passed as
	 * arguments. This is done by subscribing to each Observable, in order, and
	 * collecting an array of each of the most recent values any time any of the
	 * input Observables emits, then either taking that array and passing it as
	 * arguments to an optional `project` function and emitting the return value of
	 * that, or just emitting the array of recent values directly if there is no
	 * `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * // With output to console:
	 * // BMI is 24.212293388429753
	 * // BMI is 23.93948099205209
	 * // BMI is 23.671253629592222
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} observable1 An input Observable to combine with the
	 * source Observable.
	 * @param {Observable} observable2 An input Observable to combine with the
	 * source Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
	 * each input Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @static true
	 * @name combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    var scheduler = null;
	    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;
	//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(29);
	var isArray_1 = __webpack_require__(12);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	var none = {};
	/* tslint:disable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from this Observable with values from
	 * Observables passed as arguments. This is done by subscribing to each
	 * Observable, in order, and collecting an array of each of the most recent
	 * values any time any of the input Observables emits, then either taking that
	 * array and passing it as arguments to an optional `project` function and
	 * emitting the return value of that, or just emitting the array of recent
	 * values directly if there is no `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * // With output to console:
	 * // BMI is 24.212293388429753
	 * // BMI is 23.93948099205209
	 * // BMI is 23.671253629592222
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    observables.unshift(this);
	    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;
	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        this.project = project;
	    }
	    CombineLatestOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
	    };
	    return CombineLatestOperator;
	}());
	exports.CombineLatestOperator = CombineLatestOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CombineLatestSubscriber = (function (_super) {
	    __extends(CombineLatestSubscriber, _super);
	    function CombineLatestSubscriber(destination, project) {
	        _super.call(this, destination);
	        this.project = project;
	        this.active = 0;
	        this.values = [];
	        this.observables = [];
	    }
	    CombineLatestSubscriber.prototype._next = function (observable) {
	        this.values.push(none);
	        this.observables.push(observable);
	    };
	    CombineLatestSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            this.active = len;
	            this.toRespond = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var values = this.values;
	        var oldVal = values[outerIndex];
	        var toRespond = !this.toRespond
	            ? 0
	            : oldVal === none ? --this.toRespond : this.toRespond;
	        values[outerIndex] = innerValue;
	        if (toRespond === 0) {
	            if (this.project) {
	                this._tryProject(values);
	            }
	            else {
	                this.destination.next(values.slice());
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype._tryProject = function (values) {
	        var result;
	        try {
	            result = this.project.apply(this, values);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return CombineLatestSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.CombineLatestSubscriber = CombineLatestSubscriber;
	//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var concat_1 = __webpack_require__(713);
	Observable_1.Observable.concat = concat_1.concat;
	//# sourceMappingURL=concat.js.map

/***/ }),
/* 713 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var concat_1 = __webpack_require__(714);
	exports.concat = concat_1.concatStatic;
	//# sourceMappingURL=concat.js.map

/***/ }),
/* 714 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(32);
	var ArrayObservable_1 = __webpack_require__(29);
	var mergeAll_1 = __webpack_require__(106);
	/* tslint:disable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins this Observable with multiple other Observables by subscribing to them
	 * one at a time, starting with the source, and merging their results into the
	 * output Observable. Will wait for each Observable to complete before moving
	 * on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = timer.concat(sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in:
	 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = timer1.concat(timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in the following:
	 * // (Prints to console sequentially)
	 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
	 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
	 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} other An input Observable to concatenate after the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @method concat
	 * @owner Observable
	 */
	function concat() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
	}
	exports.concat = concat;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins multiple Observables together by subscribing to them one at a time and
	 * merging their results into the output Observable. Will wait for each
	 * Observable to complete before moving on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = Rx.Observable.concat(timer, sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in:
	 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = Rx.Observable.concat(timer1, timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in the following:
	 * // (Prints to console sequentially)
	 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
	 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
	 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} input1 An input Observable to concatenate with others.
	 * @param {Observable} input2 An input Observable to concatenate with others.
	 * More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @static true
	 * @name concat
	 * @owner Observable
	 */
	function concatStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var scheduler = null;
	    var args = observables;
	    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
	        scheduler = args.pop();
	    }
	    if (scheduler === null && observables.length === 1) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatStatic = concatStatic;
	//# sourceMappingURL=concat.js.map

/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var defer_1 = __webpack_require__(716);
	Observable_1.Observable.defer = defer_1.defer;
	//# sourceMappingURL=defer.js.map

/***/ }),
/* 716 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var DeferObservable_1 = __webpack_require__(717);
	exports.defer = DeferObservable_1.DeferObservable.create;
	//# sourceMappingURL=defer.js.map

/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var DeferObservable = (function (_super) {
	    __extends(DeferObservable, _super);
	    function DeferObservable(observableFactory) {
	        _super.call(this);
	        this.observableFactory = observableFactory;
	    }
	    /**
	     * Creates an Observable that, on subscribe, calls an Observable factory to
	     * make an Observable for each new Observer.
	     *
	     * <span class="informal">Creates the Observable lazily, that is, only when it
	     * is subscribed.
	     * </span>
	     *
	     * <img src="./img/defer.png" width="100%">
	     *
	     * `defer` allows you to create the Observable only when the Observer
	     * subscribes, and create a fresh Observable for each Observer. It waits until
	     * an Observer subscribes to it, and then it generates an Observable,
	     * typically with an Observable factory function. It does this afresh for each
	     * subscriber, so although each subscriber may think it is subscribing to the
	     * same Observable, in fact each subscriber gets its own individual
	     * Observable.
	     *
	     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
	     * var clicksOrInterval = Rx.Observable.defer(function () {
	     *   if (Math.random() > 0.5) {
	     *     return Rx.Observable.fromEvent(document, 'click');
	     *   } else {
	     *     return Rx.Observable.interval(1000);
	     *   }
	     * });
	     * clicksOrInterval.subscribe(x => console.log(x));
	     *
	     * // Results in the following behavior:
	     * // If the result of Math.random() is greater than 0.5 it will listen
	     * // for clicks anywhere on the "document"; when document is clicked it
	     * // will log a MouseEvent object to the console. If the result is less
	     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
	     *
	     * @see {@link create}
	     *
	     * @param {function(): Observable|Promise} observableFactory The Observable
	     * factory function to invoke for each Observer that subscribes to the output
	     * Observable. May also return a Promise, which will be converted on the fly
	     * to an Observable.
	     * @return {Observable} An Observable whose Observers' subscriptions trigger
	     * an invocation of the given Observable factory function.
	     * @static true
	     * @name defer
	     * @owner Observable
	     */
	    DeferObservable.create = function (observableFactory) {
	        return new DeferObservable(observableFactory);
	    };
	    DeferObservable.prototype._subscribe = function (subscriber) {
	        return new DeferSubscriber(subscriber, this.observableFactory);
	    };
	    return DeferObservable;
	}(Observable_1.Observable));
	exports.DeferObservable = DeferObservable;
	var DeferSubscriber = (function (_super) {
	    __extends(DeferSubscriber, _super);
	    function DeferSubscriber(destination, factory) {
	        _super.call(this, destination);
	        this.factory = factory;
	        this.tryDefer();
	    }
	    DeferSubscriber.prototype.tryDefer = function () {
	        try {
	            this._callFactory();
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    DeferSubscriber.prototype._callFactory = function () {
	        var result = this.factory();
	        if (result) {
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return DeferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=DeferObservable.js.map

/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var empty_1 = __webpack_require__(719);
	Observable_1.Observable.empty = empty_1.empty;
	//# sourceMappingURL=empty.js.map

/***/ }),
/* 719 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var EmptyObservable_1 = __webpack_require__(31);
	exports.empty = EmptyObservable_1.EmptyObservable.create;
	//# sourceMappingURL=empty.js.map

/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var forkJoin_1 = __webpack_require__(721);
	Observable_1.Observable.forkJoin = forkJoin_1.forkJoin;
	//# sourceMappingURL=forkJoin.js.map

/***/ }),
/* 721 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ForkJoinObservable_1 = __webpack_require__(722);
	exports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;
	//# sourceMappingURL=forkJoin.js.map

/***/ }),
/* 722 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var EmptyObservable_1 = __webpack_require__(31);
	var isArray_1 = __webpack_require__(12);
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ForkJoinObservable = (function (_super) {
	    __extends(ForkJoinObservable, _super);
	    function ForkJoinObservable(sources, resultSelector) {
	        _super.call(this);
	        this.sources = sources;
	        this.resultSelector = resultSelector;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * @param sources
	     * @return {any}
	     * @static true
	     * @name forkJoin
	     * @owner Observable
	     */
	    ForkJoinObservable.create = function () {
	        var sources = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            sources[_i - 0] = arguments[_i];
	        }
	        if (sources === null || arguments.length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        var resultSelector = null;
	        if (typeof sources[sources.length - 1] === 'function') {
	            resultSelector = sources.pop();
	        }
	        // if the first and only other argument besides the resultSelector is an array
	        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
	        if (sources.length === 1 && isArray_1.isArray(sources[0])) {
	            sources = sources[0];
	        }
	        if (sources.length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        return new ForkJoinObservable(sources, resultSelector);
	    };
	    ForkJoinObservable.prototype._subscribe = function (subscriber) {
	        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);
	    };
	    return ForkJoinObservable;
	}(Observable_1.Observable));
	exports.ForkJoinObservable = ForkJoinObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ForkJoinSubscriber = (function (_super) {
	    __extends(ForkJoinSubscriber, _super);
	    function ForkJoinSubscriber(destination, sources, resultSelector) {
	        _super.call(this, destination);
	        this.sources = sources;
	        this.resultSelector = resultSelector;
	        this.completed = 0;
	        this.haveValues = 0;
	        var len = sources.length;
	        this.total = len;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            var source = sources[i];
	            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);
	            if (innerSubscription) {
	                innerSubscription.outerIndex = i;
	                this.add(innerSubscription);
	            }
	        }
	    }
	    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        if (!innerSub._hasValue) {
	            innerSub._hasValue = true;
	            this.haveValues++;
	        }
	    };
	    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
	        var destination = this.destination;
	        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;
	        var len = values.length;
	        if (!innerSub._hasValue) {
	            destination.complete();
	            return;
	        }
	        this.completed++;
	        if (this.completed !== len) {
	            return;
	        }
	        if (haveValues === len) {
	            var value = resultSelector ? resultSelector.apply(this, values) : values;
	            destination.next(value);
	        }
	        destination.complete();
	    };
	    return ForkJoinSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=ForkJoinObservable.js.map

/***/ }),
/* 723 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var from_1 = __webpack_require__(93);
	Observable_1.Observable.from = from_1.from;
	//# sourceMappingURL=from.js.map

/***/ }),
/* 724 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var fromEvent_1 = __webpack_require__(725);
	Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
	//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 725 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventObservable_1 = __webpack_require__(726);
	exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
	//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 726 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var tryCatch_1 = __webpack_require__(14);
	var isFunction_1 = __webpack_require__(10);
	var errorObject_1 = __webpack_require__(15);
	var Subscription_1 = __webpack_require__(11);
	var toString = Object.prototype.toString;
	function isNodeStyleEventEmmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isNodeList(sourceObj) {
	    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
	}
	function isHTMLCollection(sourceObj) {
	    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
	}
	function isEventTarget(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventObservable = (function (_super) {
	    __extends(FromEventObservable, _super);
	    function FromEventObservable(sourceObj, eventName, selector, options) {
	        _super.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	        this.options = options;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Creates an Observable that emits events of a specific type coming from the
	     * given event target.
	     *
	     * <span class="informal">Creates an Observable from DOM events, or Node
	     * EventEmitter events or others.</span>
	     *
	     * <img src="./img/fromEvent.png" width="100%">
	     *
	     * Creates an Observable by attaching an event listener to an "event target",
	     * which may be an object with `addEventListener` and `removeEventListener`,
	     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
	     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
	     * the output Observable is subscribed, and removed when the Subscription is
	     * unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * var clicks = Rx.Observable.fromEvent(document, 'click');
	     * clicks.subscribe(x => console.log(x));
	     *
	     * // Results in:
	     * // MouseEvent object logged to console everytime a click
	     * // occurs on the document.
	     *
	     * @see {@link from}
	     * @see {@link fromEventPattern}
	     *
	     * @param {EventTargetLike} target The DOMElement, event target, Node.js
	     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
	     * @param {string} eventName The event name of interest, being emitted by the
	     * `target`.
	     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
	     * @param {SelectorMethodSignature<T>} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEvent
	     * @owner Observable
	     */
	    FromEventObservable.create = function (target, eventName, options, selector) {
	        if (isFunction_1.isFunction(options)) {
	            selector = options;
	            options = undefined;
	        }
	        return new FromEventObservable(target, eventName, selector, options);
	    };
	    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
	        var unsubscribe;
	        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
	            }
	        }
	        else if (isEventTarget(sourceObj)) {
	            var source_1 = sourceObj;
	            sourceObj.addEventListener(eventName, handler, options);
	            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
	        }
	        else if (isJQueryStyleEventEmitter(sourceObj)) {
	            var source_2 = sourceObj;
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () { return source_2.off(eventName, handler); };
	        }
	        else if (isNodeStyleEventEmmitter(sourceObj)) {
	            var source_3 = sourceObj;
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
	        }
	        else {
	            throw new TypeError('Invalid event target');
	        }
	        subscriber.add(new Subscription_1.Subscription(unsubscribe));
	    };
	    FromEventObservable.prototype._subscribe = function (subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var options = this.options;
	        var selector = this.selector;
	        var handler = selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
	            if (result === errorObject_1.errorObject) {
	                subscriber.error(errorObject_1.errorObject.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { return subscriber.next(e); };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
	    };
	    return FromEventObservable;
	}(Observable_1.Observable));
	exports.FromEventObservable = FromEventObservable;
	//# sourceMappingURL=FromEventObservable.js.map

/***/ }),
/* 727 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var fromEventPattern_1 = __webpack_require__(728);
	Observable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;
	//# sourceMappingURL=fromEventPattern.js.map

/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventPatternObservable_1 = __webpack_require__(729);
	exports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;
	//# sourceMappingURL=fromEventPattern.js.map

/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var Subscription_1 = __webpack_require__(11);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventPatternObservable = (function (_super) {
	    __extends(FromEventPatternObservable, _super);
	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _super.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }
	    /**
	     * Creates an Observable from an API based on addHandler/removeHandler
	     * functions.
	     *
	     * <span class="informal">Converts any addHandler/removeHandler API to an
	     * Observable.</span>
	     *
	     * <img src="./img/fromEventPattern.png" width="100%">
	     *
	     * Creates an Observable by using the `addHandler` and `removeHandler`
	     * functions to add and remove the handlers, with an optional selector
	     * function to project the event arguments to a result. The `addHandler` is
	     * called when the output Observable is subscribed, and `removeHandler` is
	     * called when the Subscription is unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * function addClickHandler(handler) {
	     *   document.addEventListener('click', handler);
	     * }
	     *
	     * function removeClickHandler(handler) {
	     *   document.removeEventListener('click', handler);
	     * }
	     *
	     * var clicks = Rx.Observable.fromEventPattern(
	     *   addClickHandler,
	     *   removeClickHandler
	     * );
	     * clicks.subscribe(x => console.log(x));
	     *
	     * @see {@link from}
	     * @see {@link fromEvent}
	     *
	     * @param {function(handler: Function): any} addHandler A function that takes
	     * a `handler` function as argument and attaches it somehow to the actual
	     * source of events.
	     * @param {function(handler: Function): void} removeHandler A function that
	     * takes a `handler` function as argument and removes it in case it was
	     * previously attached using `addHandler`.
	     * @param {function(...args: any): T} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEventPattern
	     * @owner Observable
	     */
	    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	    };
	    FromEventPatternObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var removeHandler = this.removeHandler;
	        var handler = !!this.selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            _this._callSelector(subscriber, args);
	        } : function (e) { subscriber.next(e); };
	        this._callAddHandler(handler, subscriber);
	        subscriber.add(new Subscription_1.Subscription(function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler);
	        }));
	    };
	    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {
	        try {
	            var result = this.selector.apply(this, args);
	            subscriber.next(result);
	        }
	        catch (e) {
	            subscriber.error(e);
	        }
	    };
	    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {
	        try {
	            this.addHandler(handler);
	        }
	        catch (e) {
	            errorSubscriber.error(e);
	        }
	    };
	    return FromEventPatternObservable;
	}(Observable_1.Observable));
	exports.FromEventPatternObservable = FromEventPatternObservable;
	//# sourceMappingURL=FromEventPatternObservable.js.map

/***/ }),
/* 730 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var fromPromise_1 = __webpack_require__(63);
	Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
	//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var GenerateObservable_1 = __webpack_require__(732);
	Observable_1.Observable.generate = GenerateObservable_1.GenerateObservable.create;
	//# sourceMappingURL=generate.js.map

/***/ }),
/* 732 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var isScheduler_1 = __webpack_require__(32);
	var selfSelector = function (value) { return value; };
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var GenerateObservable = (function (_super) {
	    __extends(GenerateObservable, _super);
	    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
	        _super.call(this);
	        this.initialState = initialState;
	        this.condition = condition;
	        this.iterate = iterate;
	        this.resultSelector = resultSelector;
	        this.scheduler = scheduler;
	    }
	    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
	        if (arguments.length == 1) {
	            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
	        }
	        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
	            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
	        }
	        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
	    };
	    GenerateObservable.prototype._subscribe = function (subscriber) {
	        var state = this.initialState;
	        if (this.scheduler) {
	            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
	                subscriber: subscriber,
	                iterate: this.iterate,
	                condition: this.condition,
	                resultSelector: this.resultSelector,
	                state: state });
	        }
	        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;
	        do {
	            if (condition) {
	                var conditionResult = void 0;
	                try {
	                    conditionResult = condition(state);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (!conditionResult) {
	                    subscriber.complete();
	                    break;
	                }
	            }
	            var value = void 0;
	            try {
	                value = resultSelector(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            subscriber.next(value);
	            if (subscriber.closed) {
	                break;
	            }
	            try {
	                state = iterate(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        } while (true);
	    };
	    GenerateObservable.dispatch = function (state) {
	        var subscriber = state.subscriber, condition = state.condition;
	        if (subscriber.closed) {
	            return;
	        }
	        if (state.needIterate) {
	            try {
	                state.state = state.iterate(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        }
	        else {
	            state.needIterate = true;
	        }
	        if (condition) {
	            var conditionResult = void 0;
	            try {
	                conditionResult = condition(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            if (!conditionResult) {
	                subscriber.complete();
	                return;
	            }
	            if (subscriber.closed) {
	                return;
	            }
	        }
	        var value;
	        try {
	            value = state.resultSelector(state.state);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return;
	        }
	        if (subscriber.closed) {
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        return this.schedule(state);
	    };
	    return GenerateObservable;
	}(Observable_1.Observable));
	exports.GenerateObservable = GenerateObservable;
	//# sourceMappingURL=GenerateObservable.js.map

/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var if_1 = __webpack_require__(734);
	Observable_1.Observable.if = if_1._if;
	//# sourceMappingURL=if.js.map

/***/ }),
/* 734 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var IfObservable_1 = __webpack_require__(735);
	exports._if = IfObservable_1.IfObservable.create;
	//# sourceMappingURL=if.js.map

/***/ }),
/* 735 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IfObservable = (function (_super) {
	    __extends(IfObservable, _super);
	    function IfObservable(condition, thenSource, elseSource) {
	        _super.call(this);
	        this.condition = condition;
	        this.thenSource = thenSource;
	        this.elseSource = elseSource;
	    }
	    IfObservable.create = function (condition, thenSource, elseSource) {
	        return new IfObservable(condition, thenSource, elseSource);
	    };
	    IfObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
	        return new IfSubscriber(subscriber, condition, thenSource, elseSource);
	    };
	    return IfObservable;
	}(Observable_1.Observable));
	exports.IfObservable = IfObservable;
	var IfSubscriber = (function (_super) {
	    __extends(IfSubscriber, _super);
	    function IfSubscriber(destination, condition, thenSource, elseSource) {
	        _super.call(this, destination);
	        this.condition = condition;
	        this.thenSource = thenSource;
	        this.elseSource = elseSource;
	        this.tryIf();
	    }
	    IfSubscriber.prototype.tryIf = function () {
	        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
	        var result;
	        try {
	            result = condition();
	            var source = result ? thenSource : elseSource;
	            if (source) {
	                this.add(subscribeToResult_1.subscribeToResult(this, source));
	            }
	            else {
	                this._complete();
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    return IfSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=IfObservable.js.map

/***/ }),
/* 736 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var interval_1 = __webpack_require__(737);
	Observable_1.Observable.interval = interval_1.interval;
	//# sourceMappingURL=interval.js.map

/***/ }),
/* 737 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var IntervalObservable_1 = __webpack_require__(738);
	exports.interval = IntervalObservable_1.IntervalObservable.create;
	//# sourceMappingURL=interval.js.map

/***/ }),
/* 738 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = __webpack_require__(739);
	var Observable_1 = __webpack_require__(7);
	var async_1 = __webpack_require__(45);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IntervalObservable = (function (_super) {
	    __extends(IntervalObservable, _super);
	    function IntervalObservable(period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1.async; }
	        _super.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = async_1.async;
	        }
	    }
	    /**
	     * Creates an Observable that emits sequential numbers every specified
	     * interval of time, on a specified IScheduler.
	     *
	     * <span class="informal">Emits incremental numbers periodically in time.
	     * </span>
	     *
	     * <img src="./img/interval.png" width="100%">
	     *
	     * `interval` returns an Observable that emits an infinite sequence of
	     * ascending integers, with a constant interval of time of your choosing
	     * between those emissions. The first emission is not sent immediately, but
	     * only after the first period has passed. By default, this operator uses the
	     * `async` IScheduler to provide a notion of time, but you may pass any
	     * IScheduler to it.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
	     * var numbers = Rx.Observable.interval(1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link delay}
	     *
	     * @param {number} [period=0] The interval size in milliseconds (by default)
	     * or the time unit determined by the scheduler's clock.
	     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a sequential number each time
	     * interval.
	     * @static true
	     * @name interval
	     * @owner Observable
	     */
	    IntervalObservable.create = function (period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1.async; }
	        return new IntervalObservable(period, scheduler);
	    };
	    IntervalObservable.dispatch = function (state) {
	        var index = state.index, subscriber = state.subscriber, period = state.period;
	        subscriber.next(index);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };
	    IntervalObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };
	    return IntervalObservable;
	}(Observable_1.Observable));
	exports.IntervalObservable = IntervalObservable;
	//# sourceMappingURL=IntervalObservable.js.map

/***/ }),
/* 739 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(12);
	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}
	exports.isNumeric = isNumeric;
	;
	//# sourceMappingURL=isNumeric.js.map

/***/ }),
/* 740 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var merge_1 = __webpack_require__(741);
	Observable_1.Observable.merge = merge_1.merge;
	//# sourceMappingURL=merge.js.map

/***/ }),
/* 741 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var merge_1 = __webpack_require__(742);
	exports.merge = merge_1.mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ }),
/* 742 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(29);
	var mergeAll_1 = __webpack_require__(106);
	var isScheduler_1 = __webpack_require__(32);
	/* tslint:disable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {Observable} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
	}
	exports.merge = merge;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // timer will emit ascending values, one every second(1000ms) to console
	 * // clicks logs MouseEvents to console everytime the "document" is clicked
	 * // Since the two streams are merged you see these happening
	 * // as they occur.
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - First timer1 and timer2 will run concurrently
	 * // - timer1 will emit a value every 1000ms for 10 iterations
	 * // - timer2 will emit a value every 2000ms for 6 iterations
	 * // - after timer1 hits it's max iteration, timer2 will
	 * //   continue, and timer3 will start to run concurrently with timer2
	 * // - when timer2 hits it's max iteration it terminates, and
	 * //   timer3 will continue to emit a value every 500ms until it is complete
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {...Observable} observables Input Observables to merge together.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (scheduler === null && observables.length === 1) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
	}
	exports.mergeStatic = mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ }),
/* 743 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var race_1 = __webpack_require__(744);
	Observable_1.Observable.race = race_1.raceStatic;
	//# sourceMappingURL=race.js.map

/***/ }),
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(12);
	var ArrayObservable_1 = __webpack_require__(29);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Returns an Observable that mirrors the first source Observable to emit an item
	 * from the combination of this Observable and supplied Observables
	 * @param {...Observables} ...observables sources used to race for which Observable emits first.
	 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
	 * @method race
	 * @owner Observable
	 */
	function race() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
	}
	exports.race = race;
	function raceStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1) {
	        if (isArray_1.isArray(observables[0])) {
	            observables = observables[0];
	        }
	        else {
	            return observables[0];
	        }
	    }
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
	}
	exports.raceStatic = raceStatic;
	var RaceOperator = (function () {
	    function RaceOperator() {
	    }
	    RaceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RaceSubscriber(subscriber));
	    };
	    return RaceOperator;
	}());
	exports.RaceOperator = RaceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RaceSubscriber = (function (_super) {
	    __extends(RaceSubscriber, _super);
	    function RaceSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasFirst = false;
	        this.observables = [];
	        this.subscriptions = [];
	    }
	    RaceSubscriber.prototype._next = function (observable) {
	        this.observables.push(observable);
	    };
	    RaceSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            for (var i = 0; i < len && !this.hasFirst; i++) {
	                var observable = observables[i];
	                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
	                if (this.subscriptions) {
	                    this.subscriptions.push(subscription);
	                }
	                this.add(subscription);
	            }
	            this.observables = null;
	        }
	    };
	    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (!this.hasFirst) {
	            this.hasFirst = true;
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                if (i !== outerIndex) {
	                    var subscription = this.subscriptions[i];
	                    subscription.unsubscribe();
	                    this.remove(subscription);
	                }
	            }
	            this.subscriptions = null;
	        }
	        this.destination.next(innerValue);
	    };
	    return RaceSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.RaceSubscriber = RaceSubscriber;
	//# sourceMappingURL=race.js.map

/***/ }),
/* 745 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var never_1 = __webpack_require__(746);
	Observable_1.Observable.never = never_1.never;
	//# sourceMappingURL=never.js.map

/***/ }),
/* 746 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var NeverObservable_1 = __webpack_require__(747);
	exports.never = NeverObservable_1.NeverObservable.create;
	//# sourceMappingURL=never.js.map

/***/ }),
/* 747 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var noop_1 = __webpack_require__(748);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var NeverObservable = (function (_super) {
	    __extends(NeverObservable, _super);
	    function NeverObservable() {
	        _super.call(this);
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer.
	     *
	     * <span class="informal">An Observable that never emits anything.</span>
	     *
	     * <img src="./img/never.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that emits
	     * neither values nor errors nor the completion notification. It can be used
	     * for testing purposes or for composing with other Observables. Please not
	     * that by never emitting a complete notification, this Observable keeps the
	     * subscription from being disposed automatically. Subscriptions need to be
	     * manually disposed.
	     *
	     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
	     * function info() {
	     *   console.log('Will not be called');
	     * }
	     * var result = Rx.Observable.never().startWith(7);
	     * result.subscribe(x => console.log(x), info, info);
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @return {Observable} A "never" Observable: never emits anything.
	     * @static true
	     * @name never
	     * @owner Observable
	     */
	    NeverObservable.create = function () {
	        return new NeverObservable();
	    };
	    NeverObservable.prototype._subscribe = function (subscriber) {
	        noop_1.noop();
	    };
	    return NeverObservable;
	}(Observable_1.Observable));
	exports.NeverObservable = NeverObservable;
	//# sourceMappingURL=NeverObservable.js.map

/***/ }),
/* 748 */
/***/ (function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;
	//# sourceMappingURL=noop.js.map

/***/ }),
/* 749 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var onErrorResumeNext_1 = __webpack_require__(750);
	Observable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;
	//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 750 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FromObservable_1 = __webpack_require__(94);
	var isArray_1 = __webpack_require__(12);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	function onErrorResumeNext() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i - 0] = arguments[_i];
	    }
	    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    return this.lift(new OnErrorResumeNextOperator(nextSources));
	}
	exports.onErrorResumeNext = onErrorResumeNext;
	/* tslint:enable:max-line-length */
	function onErrorResumeNextStatic() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i - 0] = arguments[_i];
	    }
	    var source = null;
	    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    source = nextSources.shift();
	    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
	}
	exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
	var OnErrorResumeNextOperator = (function () {
	    function OnErrorResumeNextOperator(nextSources) {
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
	    };
	    return OnErrorResumeNextOperator;
	}());
	var OnErrorResumeNextSubscriber = (function (_super) {
	    __extends(OnErrorResumeNextSubscriber, _super);
	    function OnErrorResumeNextSubscriber(destination, nextSources) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._error = function (err) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._complete = function () {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
	        var next = this.nextSources.shift();
	        if (next) {
	            this.add(subscribeToResult_1.subscribeToResult(this, next));
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return OnErrorResumeNextSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var pairs_1 = __webpack_require__(752);
	Observable_1.Observable.pairs = pairs_1.pairs;
	//# sourceMappingURL=pairs.js.map

/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var PairsObservable_1 = __webpack_require__(753);
	exports.pairs = PairsObservable_1.PairsObservable.create;
	//# sourceMappingURL=pairs.js.map

/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	function dispatch(state) {
	    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;
	    if (index === length) {
	        subscriber.complete();
	        return;
	    }
	    var key = keys[index];
	    subscriber.next([key, obj[key]]);
	    state.index = index + 1;
	    this.schedule(state);
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PairsObservable = (function (_super) {
	    __extends(PairsObservable, _super);
	    function PairsObservable(obj, scheduler) {
	        _super.call(this);
	        this.obj = obj;
	        this.scheduler = scheduler;
	        this.keys = Object.keys(obj);
	    }
	    /**
	     * Convert an object into an observable sequence of [key, value] pairs
	     * using an optional IScheduler to enumerate the object.
	     *
	     * @example <caption>Converts a javascript object to an Observable</caption>
	     * var obj = {
	     *   foo: 42,
	     *   bar: 56,
	     *   baz: 78
	     * };
	     *
	     * var source = Rx.Observable.pairs(obj);
	     *
	     * var subscription = source.subscribe(
	     *   function (x) {
	     *     console.log('Next: %s', x);
	     *   },
	     *   function (err) {
	     *     console.log('Error: %s', err);
	     *   },
	     *   function () {
	     *     console.log('Completed');
	     *   });
	     *
	     * @param {Object} obj The object to inspect and turn into an
	     * Observable sequence.
	     * @param {Scheduler} [scheduler] An optional IScheduler to run the
	     * enumeration of the input sequence on.
	     * @returns {(Observable<Array<string | T>>)} An observable sequence of
	     * [key, value] pairs from the object.
	     */
	    PairsObservable.create = function (obj, scheduler) {
	        return new PairsObservable(obj, scheduler);
	    };
	    PairsObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, keys = _a.keys, scheduler = _a.scheduler;
	        var length = keys.length;
	        if (scheduler) {
	            return scheduler.schedule(dispatch, 0, {
	                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber
	            });
	        }
	        else {
	            for (var idx = 0; idx < length; idx++) {
	                var key = keys[idx];
	                subscriber.next([key, this.obj[key]]);
	            }
	            subscriber.complete();
	        }
	    };
	    return PairsObservable;
	}(Observable_1.Observable));
	exports.PairsObservable = PairsObservable;
	//# sourceMappingURL=PairsObservable.js.map

/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var range_1 = __webpack_require__(755);
	Observable_1.Observable.range = range_1.range;
	//# sourceMappingURL=range.js.map

/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var RangeObservable_1 = __webpack_require__(756);
	exports.range = RangeObservable_1.RangeObservable.create;
	//# sourceMappingURL=range.js.map

/***/ }),
/* 756 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var RangeObservable = (function (_super) {
	    __extends(RangeObservable, _super);
	    function RangeObservable(start, count, scheduler) {
	        _super.call(this);
	        this.start = start;
	        this._count = count;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits a sequence of numbers within a specified
	     * range.
	     *
	     * <span class="informal">Emits a sequence of numbers in a range.</span>
	     *
	     * <img src="./img/range.png" width="100%">
	     *
	     * `range` operator emits a range of sequential integers, in order, where you
	     * select the `start` of the range and its `length`. By default, uses no
	     * IScheduler and just delivers the notifications synchronously, but may use
	     * an optional IScheduler to regulate those deliveries.
	     *
	     * @example <caption>Emits the numbers 1 to 10</caption>
	     * var numbers = Rx.Observable.range(1, 10);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link interval}
	     *
	     * @param {number} [start=0] The value of the first integer in the sequence.
	     * @param {number} [count=0] The number of sequential integers to generate.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the notifications.
	     * @return {Observable} An Observable of numbers that emits a finite range of
	     * sequential integers.
	     * @static true
	     * @name range
	     * @owner Observable
	     */
	    RangeObservable.create = function (start, count, scheduler) {
	        if (start === void 0) { start = 0; }
	        if (count === void 0) { count = 0; }
	        return new RangeObservable(start, count, scheduler);
	    };
	    RangeObservable.dispatch = function (state) {
	        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };
	    RangeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var start = this.start;
	        var count = this._count;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, count: count, start: start, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                if (index++ >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.closed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return RangeObservable;
	}(Observable_1.Observable));
	exports.RangeObservable = RangeObservable;
	//# sourceMappingURL=RangeObservable.js.map

/***/ }),
/* 757 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var using_1 = __webpack_require__(758);
	Observable_1.Observable.using = using_1.using;
	//# sourceMappingURL=using.js.map

/***/ }),
/* 758 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var UsingObservable_1 = __webpack_require__(759);
	exports.using = UsingObservable_1.UsingObservable.create;
	//# sourceMappingURL=using.js.map

/***/ }),
/* 759 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var UsingObservable = (function (_super) {
	    __extends(UsingObservable, _super);
	    function UsingObservable(resourceFactory, observableFactory) {
	        _super.call(this);
	        this.resourceFactory = resourceFactory;
	        this.observableFactory = observableFactory;
	    }
	    UsingObservable.create = function (resourceFactory, observableFactory) {
	        return new UsingObservable(resourceFactory, observableFactory);
	    };
	    UsingObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;
	        var resource;
	        try {
	            resource = resourceFactory();
	            return new UsingSubscriber(subscriber, resource, observableFactory);
	        }
	        catch (err) {
	            subscriber.error(err);
	        }
	    };
	    return UsingObservable;
	}(Observable_1.Observable));
	exports.UsingObservable = UsingObservable;
	var UsingSubscriber = (function (_super) {
	    __extends(UsingSubscriber, _super);
	    function UsingSubscriber(destination, resource, observableFactory) {
	        _super.call(this, destination);
	        this.resource = resource;
	        this.observableFactory = observableFactory;
	        destination.add(resource);
	        this.tryUse();
	    }
	    UsingSubscriber.prototype.tryUse = function () {
	        try {
	            var source = this.observableFactory.call(this, this.resource);
	            if (source) {
	                this.add(subscribeToResult_1.subscribeToResult(this, source));
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    return UsingSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=UsingObservable.js.map

/***/ }),
/* 760 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var timer_1 = __webpack_require__(761);
	Observable_1.Observable.timer = timer_1.timer;
	//# sourceMappingURL=timer.js.map

/***/ }),
/* 761 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var TimerObservable_1 = __webpack_require__(762);
	exports.timer = TimerObservable_1.TimerObservable.create;
	//# sourceMappingURL=timer.js.map

/***/ }),
/* 762 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = __webpack_require__(739);
	var Observable_1 = __webpack_require__(7);
	var async_1 = __webpack_require__(45);
	var isScheduler_1 = __webpack_require__(32);
	var isDate_1 = __webpack_require__(763);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var TimerObservable = (function (_super) {
	    __extends(TimerObservable, _super);
	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === void 0) { dueTime = 0; }
	        _super.call(this);
	        this.period = -1;
	        this.dueTime = 0;
	        if (isNumeric_1.isNumeric(period)) {
	            this.period = Number(period) < 1 && 1 || Number(period);
	        }
	        else if (isScheduler_1.isScheduler(period)) {
	            scheduler = period;
	        }
	        if (!isScheduler_1.isScheduler(scheduler)) {
	            scheduler = async_1.async;
	        }
	        this.scheduler = scheduler;
	        this.dueTime = isDate_1.isDate(dueTime) ?
	            (+dueTime - this.scheduler.now()) :
	            dueTime;
	    }
	    /**
	     * Creates an Observable that starts emitting after an `initialDelay` and
	     * emits ever increasing numbers after each `period` of time thereafter.
	     *
	     * <span class="informal">Its like {@link interval}, but you can specify when
	     * should the emissions start.</span>
	     *
	     * <img src="./img/timer.png" width="100%">
	     *
	     * `timer` returns an Observable that emits an infinite sequence of ascending
	     * integers, with a constant interval of time, `period` of your choosing
	     * between those emissions. The first emission happens after the specified
	     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
	     * operator uses the `async` IScheduler to provide a notion of time, but you
	     * may pass any IScheduler to it. If `period` is not specified, the output
	     * Observable emits only one value, `0`. Otherwise, it emits an infinite
	     * sequence.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
	     * var numbers = Rx.Observable.timer(3000, 1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @example <caption>Emits one number after five seconds</caption>
	     * var numbers = Rx.Observable.timer(5000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link interval}
	     * @see {@link delay}
	     *
	     * @param {number|Date} initialDelay The initial delay time to wait before
	     * emitting the first value of `0`.
	     * @param {number} [period] The period of time between emissions of the
	     * subsequent numbers.
	     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a `0` after the
	     * `initialDelay` and ever increasing numbers after each `period` of time
	     * thereafter.
	     * @static true
	     * @name timer
	     * @owner Observable
	     */
	    TimerObservable.create = function (initialDelay, period, scheduler) {
	        if (initialDelay === void 0) { initialDelay = 0; }
	        return new TimerObservable(initialDelay, period, scheduler);
	    };
	    TimerObservable.dispatch = function (state) {
	        var index = state.index, period = state.period, subscriber = state.subscriber;
	        var action = this;
	        subscriber.next(index);
	        if (subscriber.closed) {
	            return;
	        }
	        else if (period === -1) {
	            return subscriber.complete();
	        }
	        state.index = index + 1;
	        action.schedule(state, period);
	    };
	    TimerObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
	        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
	            index: index, period: period, subscriber: subscriber
	        });
	    };
	    return TimerObservable;
	}(Observable_1.Observable));
	exports.TimerObservable = TimerObservable;
	//# sourceMappingURL=TimerObservable.js.map

/***/ }),
/* 763 */
/***/ (function(module, exports) {

	"use strict";
	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}
	exports.isDate = isDate;
	//# sourceMappingURL=isDate.js.map

/***/ }),
/* 764 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var zip_1 = __webpack_require__(765);
	Observable_1.Observable.zip = zip_1.zip;
	//# sourceMappingURL=zip.js.map

/***/ }),
/* 765 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var zip_1 = __webpack_require__(766);
	exports.zip = zip_1.zipStatic;
	//# sourceMappingURL=zip.js.map

/***/ }),
/* 766 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(29);
	var isArray_1 = __webpack_require__(12);
	var Subscriber_1 = __webpack_require__(9);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	var iterator_1 = __webpack_require__(41);
	/* tslint:disable:max-line-length */
	/**
	 * @param observables
	 * @return {Observable<R>}
	 * @method zip
	 * @owner Observable
	 */
	function zipProto() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
	}
	exports.zipProto = zipProto;
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
	 * of its input Observables.
	 *
	 * If the latest parameter is a function, this function is used to compute the created value from the input values.
	 * Otherwise, an array of the input values is returned.
	 *
	 * @example <caption>Combine age and name from different sources</caption>
	 *
	 * let age$ = Observable.of<number>(27, 25, 29);
	 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
	 * let isDev$ = Observable.of<boolean>(true, true, false);
	 *
	 * Observable
	 *     .zip(age$,
	 *          name$,
	 *          isDev$,
	 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
	 *     .subscribe(x => console.log(x));
	 *
	 * // outputs
	 * // { age: 7, name: 'Foo', isDev: true }
	 * // { age: 5, name: 'Bar', isDev: true }
	 * // { age: 9, name: 'Beer', isDev: false }
	 *
	 * @param observables
	 * @return {Observable<R>}
	 * @static true
	 * @name zip
	 * @owner Observable
	 */
	function zipStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = observables[observables.length - 1];
	    if (typeof project === 'function') {
	        observables.pop();
	    }
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
	}
	exports.zipStatic = zipStatic;
	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        this.project = project;
	    }
	    ZipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ZipSubscriber(subscriber, this.project));
	    };
	    return ZipOperator;
	}());
	exports.ZipOperator = ZipOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipSubscriber = (function (_super) {
	    __extends(ZipSubscriber, _super);
	    function ZipSubscriber(destination, project, values) {
	        if (values === void 0) { values = Object.create(null); }
	        _super.call(this, destination);
	        this.iterators = [];
	        this.active = 0;
	        this.project = (typeof project === 'function') ? project : null;
	        this.values = values;
	    }
	    ZipSubscriber.prototype._next = function (value) {
	        var iterators = this.iterators;
	        if (isArray_1.isArray(value)) {
	            iterators.push(new StaticArrayIterator(value));
	        }
	        else if (typeof value[iterator_1.$$iterator] === 'function') {
	            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
	        }
	        else {
	            iterators.push(new ZipBufferIterator(this.destination, this, value));
	        }
	    };
	    ZipSubscriber.prototype._complete = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        this.active = len;
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (iterator.stillUnsubscribed) {
	                this.add(iterator.subscribe(iterator, i));
	            }
	            else {
	                this.active--; // not an observable
	            }
	        }
	    };
	    ZipSubscriber.prototype.notifyInactive = function () {
	        this.active--;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ZipSubscriber.prototype.checkIterators = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        var destination = this.destination;
	        // abort if not all of them have values
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
	                return;
	            }
	        }
	        var shouldComplete = false;
	        var args = [];
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            var result = iterator.next();
	            // check to see if it's completed now that you've gotten
	            // the next value.
	            if (iterator.hasCompleted()) {
	                shouldComplete = true;
	            }
	            if (result.done) {
	                destination.complete();
	                return;
	            }
	            args.push(result.value);
	        }
	        if (this.project) {
	            this._tryProject(args);
	        }
	        else {
	            destination.next(args);
	        }
	        if (shouldComplete) {
	            destination.complete();
	        }
	    };
	    ZipSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return ZipSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ZipSubscriber = ZipSubscriber;
	var StaticIterator = (function () {
	    function StaticIterator(iterator) {
	        this.iterator = iterator;
	        this.nextResult = iterator.next();
	    }
	    StaticIterator.prototype.hasValue = function () {
	        return true;
	    };
	    StaticIterator.prototype.next = function () {
	        var result = this.nextResult;
	        this.nextResult = this.iterator.next();
	        return result;
	    };
	    StaticIterator.prototype.hasCompleted = function () {
	        var nextResult = this.nextResult;
	        return nextResult && nextResult.done;
	    };
	    return StaticIterator;
	}());
	var StaticArrayIterator = (function () {
	    function StaticArrayIterator(array) {
	        this.array = array;
	        this.index = 0;
	        this.length = 0;
	        this.length = array.length;
	    }
	    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
	        return this;
	    };
	    StaticArrayIterator.prototype.next = function (value) {
	        var i = this.index++;
	        var array = this.array;
	        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
	    };
	    StaticArrayIterator.prototype.hasValue = function () {
	        return this.array.length > this.index;
	    };
	    StaticArrayIterator.prototype.hasCompleted = function () {
	        return this.array.length === this.index;
	    };
	    return StaticArrayIterator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipBufferIterator = (function (_super) {
	    __extends(ZipBufferIterator, _super);
	    function ZipBufferIterator(destination, parent, observable) {
	        _super.call(this, destination);
	        this.parent = parent;
	        this.observable = observable;
	        this.stillUnsubscribed = true;
	        this.buffer = [];
	        this.isComplete = false;
	    }
	    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
	        return this;
	    };
	    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
	    //    this is legit because `next()` will never be called by a subscription in this case.
	    ZipBufferIterator.prototype.next = function () {
	        var buffer = this.buffer;
	        if (buffer.length === 0 && this.isComplete) {
	            return { value: null, done: true };
	        }
	        else {
	            return { value: buffer.shift(), done: false };
	        }
	    };
	    ZipBufferIterator.prototype.hasValue = function () {
	        return this.buffer.length > 0;
	    };
	    ZipBufferIterator.prototype.hasCompleted = function () {
	        return this.buffer.length === 0 && this.isComplete;
	    };
	    ZipBufferIterator.prototype.notifyComplete = function () {
	        if (this.buffer.length > 0) {
	            this.isComplete = true;
	            this.parent.notifyInactive();
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.buffer.push(innerValue);
	        this.parent.checkIterators();
	    };
	    ZipBufferIterator.prototype.subscribe = function (value, index) {
	        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
	    };
	    return ZipBufferIterator;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=zip.js.map

/***/ }),
/* 767 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var ajax_1 = __webpack_require__(768);
	Observable_1.Observable.ajax = ajax_1.ajax;
	//# sourceMappingURL=ajax.js.map

/***/ }),
/* 768 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var AjaxObservable_1 = __webpack_require__(769);
	exports.ajax = AjaxObservable_1.AjaxObservable.create;
	//# sourceMappingURL=ajax.js.map

/***/ }),
/* 769 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(5);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var Observable_1 = __webpack_require__(7);
	var Subscriber_1 = __webpack_require__(9);
	var map_1 = __webpack_require__(57);
	function getCORSRequest() {
	    if (root_1.root.XMLHttpRequest) {
	        var xhr = new root_1.root.XMLHttpRequest();
	        if ('withCredentials' in xhr) {
	            xhr.withCredentials = !!this.withCredentials;
	        }
	        return xhr;
	    }
	    else if (!!root_1.root.XDomainRequest) {
	        return new root_1.root.XDomainRequest();
	    }
	    else {
	        throw new Error('CORS is not supported by your browser');
	    }
	}
	function getXMLHttpRequest() {
	    if (root_1.root.XMLHttpRequest) {
	        return new root_1.root.XMLHttpRequest();
	    }
	    else {
	        var progId = void 0;
	        try {
	            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
	            for (var i = 0; i < 3; i++) {
	                try {
	                    progId = progIds[i];
	                    if (new root_1.root.ActiveXObject(progId)) {
	                        break;
	                    }
	                }
	                catch (e) {
	                }
	            }
	            return new root_1.root.ActiveXObject(progId);
	        }
	        catch (e) {
	            throw new Error('XMLHttpRequest is not supported by your browser');
	        }
	    }
	}
	function ajaxGet(url, headers) {
	    if (headers === void 0) { headers = null; }
	    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
	}
	exports.ajaxGet = ajaxGet;
	;
	function ajaxPost(url, body, headers) {
	    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
	}
	exports.ajaxPost = ajaxPost;
	;
	function ajaxDelete(url, headers) {
	    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
	}
	exports.ajaxDelete = ajaxDelete;
	;
	function ajaxPut(url, body, headers) {
	    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
	}
	exports.ajaxPut = ajaxPut;
	;
	function ajaxGetJSON(url, headers) {
	    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })
	        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));
	}
	exports.ajaxGetJSON = ajaxGetJSON;
	;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var AjaxObservable = (function (_super) {
	    __extends(AjaxObservable, _super);
	    function AjaxObservable(urlOrRequest) {
	        _super.call(this);
	        var request = {
	            async: true,
	            createXHR: function () {
	                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
	            },
	            crossDomain: false,
	            withCredentials: false,
	            headers: {},
	            method: 'GET',
	            responseType: 'json',
	            timeout: 0
	        };
	        if (typeof urlOrRequest === 'string') {
	            request.url = urlOrRequest;
	        }
	        else {
	            for (var prop in urlOrRequest) {
	                if (urlOrRequest.hasOwnProperty(prop)) {
	                    request[prop] = urlOrRequest[prop];
	                }
	            }
	        }
	        this.request = request;
	    }
	    AjaxObservable.prototype._subscribe = function (subscriber) {
	        return new AjaxSubscriber(subscriber, this.request);
	    };
	    /**
	     * Creates an observable for an Ajax request with either a request object with
	     * url, headers, etc or a string for a URL.
	     *
	     * @example
	     * source = Rx.Observable.ajax('/products');
	     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
	     *
	     * @param {string|Object} request Can be one of the following:
	     *   A string of the URL to make the Ajax call.
	     *   An object with the following properties
	     *   - url: URL of the request
	     *   - body: The body of the request
	     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
	     *   - async: Whether the request is async
	     *   - headers: Optional headers
	     *   - crossDomain: true if a cross domain request, else false
	     *   - createXHR: a function to override if you need to use an alternate
	     *   XMLHttpRequest implementation.
	     *   - resultSelector: a function to use to alter the output value type of
	     *   the Observable. Gets {@link AjaxResponse} as an argument.
	     * @return {Observable} An observable sequence containing the XMLHttpRequest.
	     * @static true
	     * @name ajax
	     * @owner Observable
	    */
	    AjaxObservable.create = (function () {
	        var create = function (urlOrRequest) {
	            return new AjaxObservable(urlOrRequest);
	        };
	        create.get = ajaxGet;
	        create.post = ajaxPost;
	        create.delete = ajaxDelete;
	        create.put = ajaxPut;
	        create.getJSON = ajaxGetJSON;
	        return create;
	    })();
	    return AjaxObservable;
	}(Observable_1.Observable));
	exports.AjaxObservable = AjaxObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AjaxSubscriber = (function (_super) {
	    __extends(AjaxSubscriber, _super);
	    function AjaxSubscriber(destination, request) {
	        _super.call(this, destination);
	        this.request = request;
	        this.done = false;
	        var headers = request.headers = request.headers || {};
	        // force CORS if requested
	        if (!request.crossDomain && !headers['X-Requested-With']) {
	            headers['X-Requested-With'] = 'XMLHttpRequest';
	        }
	        // ensure content type is set
	        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
	            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
	        }
	        // properly serialize body
	        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
	        this.send();
	    }
	    AjaxSubscriber.prototype.next = function (e) {
	        this.done = true;
	        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;
	        var response = new AjaxResponse(e, xhr, request);
	        destination.next(response);
	    };
	    AjaxSubscriber.prototype.send = function () {
	        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;
	        var createXHR = request.createXHR;
	        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
	        if (xhr === errorObject_1.errorObject) {
	            this.error(errorObject_1.errorObject.e);
	        }
	        else {
	            this.xhr = xhr;
	            // set up the events before open XHR
	            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
	            // You need to add the event listeners before calling open() on the request.
	            // Otherwise the progress events will not fire.
	            this.setupEvents(xhr, request);
	            // open XHR
	            var result = void 0;
	            if (user) {
	                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
	            }
	            else {
	                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
	            }
	            if (result === errorObject_1.errorObject) {
	                this.error(errorObject_1.errorObject.e);
	                return null;
	            }
	            // timeout and responseType can be set once the XHR is open
	            xhr.timeout = request.timeout;
	            xhr.responseType = request.responseType;
	            // set headers
	            this.setHeaders(xhr, headers);
	            // finally send the request
	            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
	            if (result === errorObject_1.errorObject) {
	                this.error(errorObject_1.errorObject.e);
	                return null;
	            }
	        }
	        return xhr;
	    };
	    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
	        if (!body || typeof body === 'string') {
	            return body;
	        }
	        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
	            return body;
	        }
	        if (contentType) {
	            var splitIndex = contentType.indexOf(';');
	            if (splitIndex !== -1) {
	                contentType = contentType.substring(0, splitIndex);
	            }
	        }
	        switch (contentType) {
	            case 'application/x-www-form-urlencoded':
	                return Object.keys(body).map(function (key) { return (encodeURI(key) + "=" + encodeURI(body[key])); }).join('&');
	            case 'application/json':
	                return JSON.stringify(body);
	            default:
	                return body;
	        }
	    };
	    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
	        for (var key in headers) {
	            if (headers.hasOwnProperty(key)) {
	                xhr.setRequestHeader(key, headers[key]);
	            }
	        }
	    };
	    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
	        var progressSubscriber = request.progressSubscriber;
	        function xhrTimeout(e) {
	            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
	            if (progressSubscriber) {
	                progressSubscriber.error(e);
	            }
	            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
	        }
	        ;
	        xhr.ontimeout = xhrTimeout;
	        xhrTimeout.request = request;
	        xhrTimeout.subscriber = this;
	        xhrTimeout.progressSubscriber = progressSubscriber;
	        if (xhr.upload && 'withCredentials' in xhr) {
	            if (progressSubscriber) {
	                var xhrProgress_1;
	                xhrProgress_1 = function (e) {
	                    var progressSubscriber = xhrProgress_1.progressSubscriber;
	                    progressSubscriber.next(e);
	                };
	                if (root_1.root.XDomainRequest) {
	                    xhr.onprogress = xhrProgress_1;
	                }
	                else {
	                    xhr.upload.onprogress = xhrProgress_1;
	                }
	                xhrProgress_1.progressSubscriber = progressSubscriber;
	            }
	            var xhrError_1;
	            xhrError_1 = function (e) {
	                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;
	                if (progressSubscriber) {
	                    progressSubscriber.error(e);
	                }
	                subscriber.error(new AjaxError('ajax error', this, request));
	            };
	            xhr.onerror = xhrError_1;
	            xhrError_1.request = request;
	            xhrError_1.subscriber = this;
	            xhrError_1.progressSubscriber = progressSubscriber;
	        }
	        function xhrReadyStateChange(e) {
	            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
	            if (this.readyState === 4) {
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status_1 = this.status === 1223 ? 204 : this.status;
	                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status_1 === 0) {
	                    status_1 = response ? 200 : 0;
	                }
	                if (200 <= status_1 && status_1 < 300) {
	                    if (progressSubscriber) {
	                        progressSubscriber.complete();
	                    }
	                    subscriber.next(e);
	                    subscriber.complete();
	                }
	                else {
	                    if (progressSubscriber) {
	                        progressSubscriber.error(e);
	                    }
	                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
	                }
	            }
	        }
	        ;
	        xhr.onreadystatechange = xhrReadyStateChange;
	        xhrReadyStateChange.subscriber = this;
	        xhrReadyStateChange.progressSubscriber = progressSubscriber;
	        xhrReadyStateChange.request = request;
	    };
	    AjaxSubscriber.prototype.unsubscribe = function () {
	        var _a = this, done = _a.done, xhr = _a.xhr;
	        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
	            xhr.abort();
	        }
	        _super.prototype.unsubscribe.call(this);
	    };
	    return AjaxSubscriber;
	}(Subscriber_1.Subscriber));
	exports.AjaxSubscriber = AjaxSubscriber;
	/**
	 * A normalized AJAX response.
	 *
	 * @see {@link ajax}
	 *
	 * @class AjaxResponse
	 */
	var AjaxResponse = (function () {
	    function AjaxResponse(originalEvent, xhr, request) {
	        this.originalEvent = originalEvent;
	        this.xhr = xhr;
	        this.request = request;
	        this.status = xhr.status;
	        this.responseType = xhr.responseType || request.responseType;
	        switch (this.responseType) {
	            case 'json':
	                if ('response' in xhr) {
	                    //IE does not support json as responseType, parse it internally
	                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
	                }
	                else {
	                    this.response = JSON.parse(xhr.responseText || 'null');
	                }
	                break;
	            case 'xml':
	                this.response = xhr.responseXML;
	                break;
	            case 'text':
	            default:
	                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;
	                break;
	        }
	    }
	    return AjaxResponse;
	}());
	exports.AjaxResponse = AjaxResponse;
	/**
	 * A normalized AJAX error.
	 *
	 * @see {@link ajax}
	 *
	 * @class AjaxError
	 */
	var AjaxError = (function (_super) {
	    __extends(AjaxError, _super);
	    function AjaxError(message, xhr, request) {
	        _super.call(this, message);
	        this.message = message;
	        this.xhr = xhr;
	        this.request = request;
	        this.status = xhr.status;
	    }
	    return AjaxError;
	}(Error));
	exports.AjaxError = AjaxError;
	/**
	 * @see {@link ajax}
	 *
	 * @class AjaxTimeoutError
	 */
	var AjaxTimeoutError = (function (_super) {
	    __extends(AjaxTimeoutError, _super);
	    function AjaxTimeoutError(xhr, request) {
	        _super.call(this, 'ajax timeout', xhr, request);
	    }
	    return AjaxTimeoutError;
	}(AjaxError));
	exports.AjaxTimeoutError = AjaxTimeoutError;
	//# sourceMappingURL=AjaxObservable.js.map

/***/ }),
/* 770 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var webSocket_1 = __webpack_require__(771);
	Observable_1.Observable.webSocket = webSocket_1.webSocket;
	//# sourceMappingURL=webSocket.js.map

/***/ }),
/* 771 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var WebSocketSubject_1 = __webpack_require__(772);
	exports.webSocket = WebSocketSubject_1.WebSocketSubject.create;
	//# sourceMappingURL=webSocket.js.map

/***/ }),
/* 772 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscriber_1 = __webpack_require__(9);
	var Observable_1 = __webpack_require__(7);
	var Subscription_1 = __webpack_require__(11);
	var root_1 = __webpack_require__(5);
	var ReplaySubject_1 = __webpack_require__(773);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var assign_1 = __webpack_require__(777);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var WebSocketSubject = (function (_super) {
	    __extends(WebSocketSubject, _super);
	    function WebSocketSubject(urlConfigOrSource, destination) {
	        if (urlConfigOrSource instanceof Observable_1.Observable) {
	            _super.call(this, destination, urlConfigOrSource);
	        }
	        else {
	            _super.call(this);
	            this.WebSocketCtor = root_1.root.WebSocket;
	            this._output = new Subject_1.Subject();
	            if (typeof urlConfigOrSource === 'string') {
	                this.url = urlConfigOrSource;
	            }
	            else {
	                // WARNING: config object could override important members here.
	                assign_1.assign(this, urlConfigOrSource);
	            }
	            if (!this.WebSocketCtor) {
	                throw new Error('no WebSocket constructor can be found');
	            }
	            this.destination = new ReplaySubject_1.ReplaySubject();
	        }
	    }
	    WebSocketSubject.prototype.resultSelector = function (e) {
	        return JSON.parse(e.data);
	    };
	    /**
	     * @param urlConfigOrSource
	     * @return {WebSocketSubject}
	     * @static true
	     * @name webSocket
	     * @owner Observable
	     */
	    WebSocketSubject.create = function (urlConfigOrSource) {
	        return new WebSocketSubject(urlConfigOrSource);
	    };
	    WebSocketSubject.prototype.lift = function (operator) {
	        var sock = new WebSocketSubject(this, this.destination);
	        sock.operator = operator;
	        return sock;
	    };
	    WebSocketSubject.prototype._resetState = function () {
	        this.socket = null;
	        if (!this.source) {
	            this.destination = new ReplaySubject_1.ReplaySubject();
	        }
	        this._output = new Subject_1.Subject();
	    };
	    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
	    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
	        var self = this;
	        return new Observable_1.Observable(function (observer) {
	            var result = tryCatch_1.tryCatch(subMsg)();
	            if (result === errorObject_1.errorObject) {
	                observer.error(errorObject_1.errorObject.e);
	            }
	            else {
	                self.next(result);
	            }
	            var subscription = self.subscribe(function (x) {
	                var result = tryCatch_1.tryCatch(messageFilter)(x);
	                if (result === errorObject_1.errorObject) {
	                    observer.error(errorObject_1.errorObject.e);
	                }
	                else if (result) {
	                    observer.next(x);
	                }
	            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
	            return function () {
	                var result = tryCatch_1.tryCatch(unsubMsg)();
	                if (result === errorObject_1.errorObject) {
	                    observer.error(errorObject_1.errorObject.e);
	                }
	                else {
	                    self.next(result);
	                }
	                subscription.unsubscribe();
	            };
	        });
	    };
	    WebSocketSubject.prototype._connectSocket = function () {
	        var _this = this;
	        var WebSocketCtor = this.WebSocketCtor;
	        var observer = this._output;
	        var socket = null;
	        try {
	            socket = this.protocol ?
	                new WebSocketCtor(this.url, this.protocol) :
	                new WebSocketCtor(this.url);
	            this.socket = socket;
	        }
	        catch (e) {
	            observer.error(e);
	            return;
	        }
	        var subscription = new Subscription_1.Subscription(function () {
	            _this.socket = null;
	            if (socket && socket.readyState === 1) {
	                socket.close();
	            }
	        });
	        socket.onopen = function (e) {
	            var openObserver = _this.openObserver;
	            if (openObserver) {
	                openObserver.next(e);
	            }
	            var queue = _this.destination;
	            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {
	                var closingObserver = _this.closingObserver;
	                if (closingObserver) {
	                    closingObserver.next(undefined);
	                }
	                if (e && e.code) {
	                    socket.close(e.code, e.reason);
	                }
	                else {
	                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +
	                        'and an optional reason: { code: number, reason: string }'));
	                }
	                _this._resetState();
	            }, function () {
	                var closingObserver = _this.closingObserver;
	                if (closingObserver) {
	                    closingObserver.next(undefined);
	                }
	                socket.close();
	                _this._resetState();
	            });
	            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {
	                subscription.add(queue.subscribe(_this.destination));
	            }
	        };
	        socket.onerror = function (e) {
	            _this._resetState();
	            observer.error(e);
	        };
	        socket.onclose = function (e) {
	            _this._resetState();
	            var closeObserver = _this.closeObserver;
	            if (closeObserver) {
	                closeObserver.next(e);
	            }
	            if (e.wasClean) {
	                observer.complete();
	            }
	            else {
	                observer.error(e);
	            }
	        };
	        socket.onmessage = function (e) {
	            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);
	            if (result === errorObject_1.errorObject) {
	                observer.error(errorObject_1.errorObject.e);
	            }
	            else {
	                observer.next(result);
	            }
	        };
	    };
	    WebSocketSubject.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var source = this.source;
	        if (source) {
	            return source.subscribe(subscriber);
	        }
	        if (!this.socket) {
	            this._connectSocket();
	        }
	        var subscription = new Subscription_1.Subscription();
	        subscription.add(this._output.subscribe(subscriber));
	        subscription.add(function () {
	            var socket = _this.socket;
	            if (_this._output.observers.length === 0) {
	                if (socket && socket.readyState === 1) {
	                    socket.close();
	                }
	                _this._resetState();
	            }
	        });
	        return subscription;
	    };
	    WebSocketSubject.prototype.unsubscribe = function () {
	        var _a = this, source = _a.source, socket = _a.socket;
	        if (socket && socket.readyState === 1) {
	            socket.close();
	            this._resetState();
	        }
	        _super.prototype.unsubscribe.call(this);
	        if (!source) {
	            this.destination = new ReplaySubject_1.ReplaySubject();
	        }
	    };
	    return WebSocketSubject;
	}(Subject_1.AnonymousSubject));
	exports.WebSocketSubject = WebSocketSubject;
	//# sourceMappingURL=WebSocketSubject.js.map

/***/ }),
/* 773 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var queue_1 = __webpack_require__(774);
	var Subscription_1 = __webpack_require__(11);
	var observeOn_1 = __webpack_require__(97);
	var ObjectUnsubscribedError_1 = __webpack_require__(19);
	var SubjectSubscription_1 = __webpack_require__(20);
	/**
	 * @class ReplaySubject<T>
	 */
	var ReplaySubject = (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(bufferSize, windowTime, scheduler) {
	        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	        _super.call(this);
	        this.scheduler = scheduler;
	        this._events = [];
	        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = windowTime < 1 ? 1 : windowTime;
	    }
	    ReplaySubject.prototype.next = function (value) {
	        var now = this._getNow();
	        this._events.push(new ReplayEvent(now, value));
	        this._trimBufferThenGetEvents();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        var _events = this._trimBufferThenGetEvents();
	        var scheduler = this.scheduler;
	        var subscription;
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscription = Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscription = Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	        if (scheduler) {
	            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
	        }
	        var len = _events.length;
	        for (var i = 0; i < len && !subscriber.closed; i++) {
	            subscriber.next(_events[i].value);
	        }
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	        }
	        return subscription;
	    };
	    ReplaySubject.prototype._getNow = function () {
	        return (this.scheduler || queue_1.queue).now();
	    };
	    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
	        var now = this._getNow();
	        var _bufferSize = this._bufferSize;
	        var _windowTime = this._windowTime;
	        var _events = this._events;
	        var eventsCount = _events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if ((now - _events[spliceCount].time) < _windowTime) {
	                break;
	            }
	            spliceCount++;
	        }
	        if (eventsCount > _bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
	        }
	        if (spliceCount > 0) {
	            _events.splice(0, spliceCount);
	        }
	        return _events;
	    };
	    return ReplaySubject;
	}(Subject_1.Subject));
	exports.ReplaySubject = ReplaySubject;
	var ReplayEvent = (function () {
	    function ReplayEvent(time, value) {
	        this.time = time;
	        this.value = value;
	    }
	    return ReplayEvent;
	}());
	//# sourceMappingURL=ReplaySubject.js.map

/***/ }),
/* 774 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var QueueAction_1 = __webpack_require__(775);
	var QueueScheduler_1 = __webpack_require__(776);
	exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
	//# sourceMappingURL=queue.js.map

/***/ }),
/* 775 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1 = __webpack_require__(46);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var QueueAction = (function (_super) {
	    __extends(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return (delay > 0 || this.closed) ?
	            _super.prototype.execute.call(this, state, delay) :
	            this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Otherwise flush the scheduler starting with this action.
	        return scheduler.flush(this);
	    };
	    return QueueAction;
	}(AsyncAction_1.AsyncAction));
	exports.QueueAction = QueueAction;
	//# sourceMappingURL=QueueAction.js.map

/***/ }),
/* 776 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1 = __webpack_require__(48);
	var QueueScheduler = (function (_super) {
	    __extends(QueueScheduler, _super);
	    function QueueScheduler() {
	        _super.apply(this, arguments);
	    }
	    return QueueScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.QueueScheduler = QueueScheduler;
	//# sourceMappingURL=QueueScheduler.js.map

/***/ }),
/* 777 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	function assignImpl(target) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    var len = sources.length;
	    for (var i = 0; i < len; i++) {
	        var source = sources[i];
	        for (var k in source) {
	            if (source.hasOwnProperty(k)) {
	                target[k] = source[k];
	            }
	        }
	    }
	    return target;
	}
	exports.assignImpl = assignImpl;
	;
	function getAssign(root) {
	    return root.Object.assign || assignImpl;
	}
	exports.getAssign = getAssign;
	exports.assign = getAssign(root_1.root);
	//# sourceMappingURL=assign.js.map

/***/ }),
/* 778 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var buffer_1 = __webpack_require__(779);
	Observable_1.Observable.prototype.buffer = buffer_1.buffer;
	//# sourceMappingURL=buffer.js.map

/***/ }),
/* 779 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Buffers the source Observable values until `closingNotifier` emits.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when another Observable emits.</span>
	 *
	 * <img src="./img/buffer.png" width="100%">
	 *
	 * Buffers the incoming Observable values until the given `closingNotifier`
	 * Observable emits a value, at which point it emits the buffer on the output
	 * Observable and starts a new buffer internally, awaiting the next time
	 * `closingNotifier` emits.
	 *
	 * @example <caption>On every click, emit array of most recent interval events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var buffered = interval.buffer(clicks);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link window}
	 *
	 * @param {Observable<any>} closingNotifier An Observable that signals the
	 * buffer to be emitted on the output Observable.
	 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
	 * values.
	 * @method buffer
	 * @owner Observable
	 */
	function buffer(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}
	exports.buffer = buffer;
	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        this.closingNotifier = closingNotifier;
	    }
	    BufferOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
	    };
	    return BufferOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferSubscriber = (function (_super) {
	    __extends(BufferSubscriber, _super);
	    function BufferSubscriber(destination, closingNotifier) {
	        _super.call(this, destination);
	        this.buffer = [];
	        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
	    }
	    BufferSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };
	    return BufferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=buffer.js.map

/***/ }),
/* 780 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var bufferCount_1 = __webpack_require__(781);
	Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;
	//# sourceMappingURL=bufferCount.js.map

/***/ }),
/* 781 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Buffers the source Observable values until the size hits the maximum
	 * `bufferSize` given.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when its size reaches `bufferSize`.</span>
	 *
	 * <img src="./img/bufferCount.png" width="100%">
	 *
	 * Buffers a number of values from the source Observable by `bufferSize` then
	 * emits the buffer and clears it, and starts a new buffer each
	 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
	 * `null`, then new buffers are started immediately at the start of the source
	 * and when each buffer closes and is emitted.
	 *
	 * @example <caption>Emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>On every click, emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2, 1);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link pairwise}
	 * @see {@link windowCount}
	 *
	 * @param {number} bufferSize The maximum size of the buffer emitted.
	 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
	 * For example if `startBufferEvery` is `2`, then a new buffer will be started
	 * on every other value from the source. A new buffer is started at the
	 * beginning of the source by default.
	 * @return {Observable<T[]>} An Observable of arrays of buffered values.
	 * @method bufferCount
	 * @owner Observable
	 */
	function bufferCount(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}
	exports.bufferCount = bufferCount;
	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	    }
	    BufferCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery));
	    };
	    return BufferCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferCountSubscriber = (function (_super) {
	    __extends(BufferCountSubscriber, _super);
	    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _super.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [];
	        this.count = 0;
	    }
	    BufferCountSubscriber.prototype._next = function (value) {
	        var count = this.count++;
	        var _a = this, destination = _a.destination, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers;
	        var startOn = (startBufferEvery == null) ? bufferSize : startBufferEvery;
	        if (count % startOn === 0) {
	            buffers.push([]);
	        }
	        for (var i = buffers.length; i--;) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                buffers.splice(i, 1);
	                destination.next(buffer);
	            }
	        }
	    };
	    BufferCountSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=bufferCount.js.map

/***/ }),
/* 782 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var bufferTime_1 = __webpack_require__(783);
	Observable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;
	//# sourceMappingURL=bufferTime.js.map

/***/ }),
/* 783 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(45);
	var Subscriber_1 = __webpack_require__(9);
	var isScheduler_1 = __webpack_require__(32);
	/* tslint:disable:max-line-length */
	/**
	 * Buffers the source Observable values for a specific time period.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * those arrays periodically in time.</span>
	 *
	 * <img src="./img/bufferTime.png" width="100%">
	 *
	 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
	 * Unless the optional argument `bufferCreationInterval` is given, it emits and
	 * resets the buffer every `bufferTimeSpan` milliseconds. If
	 * `bufferCreationInterval` is given, this operator opens the buffer every
	 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
	 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
	 * `maxBufferSize` is specified, the buffer will be closed either after
	 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
	 *
	 * @example <caption>Every second, emit an array of the recent click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(1000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(2000, 5000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link windowTime}
	 *
	 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
	 * @param {number} [bufferCreationInterval] The interval at which to start new
	 * buffers.
	 * @param {number} [maxBufferSize] The maximum buffer size.
	 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
	 * intervals that determine buffer boundaries.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferTime
	 * @owner Observable
	 */
	function bufferTime(bufferTimeSpan) {
	    var length = arguments.length;
	    var scheduler = async_1.async;
	    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
	        scheduler = arguments[arguments.length - 1];
	        length--;
	    }
	    var bufferCreationInterval = null;
	    if (length >= 2) {
	        bufferCreationInterval = arguments[1];
	    }
	    var maxBufferSize = Number.POSITIVE_INFINITY;
	    if (length >= 3) {
	        maxBufferSize = arguments[2];
	    }
	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
	}
	exports.bufferTime = bufferTime;
	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	    }
	    BufferTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
	    };
	    return BufferTimeOperator;
	}());
	var Context = (function () {
	    function Context() {
	        this.buffer = [];
	    }
	    return Context;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferTimeSubscriber = (function (_super) {
	    __extends(BufferTimeSubscriber, _super);
	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        _super.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	        this.contexts = [];
	        var context = this.openContext();
	        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
	        if (this.timespanOnly) {
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	        else {
	            var closeState = { subscriber: this, context: context };
	            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	        }
	    }
	    BufferTimeSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        var filledBufferContext;
	        for (var i = 0; i < len; i++) {
	            var context = contexts[i];
	            var buffer = context.buffer;
	            buffer.push(value);
	            if (buffer.length == this.maxBufferSize) {
	                filledBufferContext = context;
	            }
	        }
	        if (filledBufferContext) {
	            this.onBufferFull(filledBufferContext);
	        }
	    };
	    BufferTimeSubscriber.prototype._error = function (err) {
	        this.contexts.length = 0;
	        _super.prototype._error.call(this, err);
	    };
	    BufferTimeSubscriber.prototype._complete = function () {
	        var _a = this, contexts = _a.contexts, destination = _a.destination;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            destination.next(context.buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferTimeSubscriber.prototype._unsubscribe = function () {
	        this.contexts = null;
	    };
	    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
	        this.closeContext(context);
	        var closeAction = context.closeAction;
	        closeAction.unsubscribe();
	        this.remove(closeAction);
	        if (!this.closed && this.timespanOnly) {
	            context = this.openContext();
	            var bufferTimeSpan = this.bufferTimeSpan;
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	    };
	    BufferTimeSubscriber.prototype.openContext = function () {
	        var context = new Context();
	        this.contexts.push(context);
	        return context;
	    };
	    BufferTimeSubscriber.prototype.closeContext = function (context) {
	        this.destination.next(context.buffer);
	        var contexts = this.contexts;
	        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
	        if (spliceIndex >= 0) {
	            contexts.splice(contexts.indexOf(context), 1);
	        }
	    };
	    return BufferTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevContext = state.context;
	    if (prevContext) {
	        subscriber.closeContext(prevContext);
	    }
	    if (!subscriber.closed) {
	        state.context = subscriber.openContext();
	        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
	    }
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
	    var context = subscriber.openContext();
	    var action = this;
	    if (!subscriber.closed) {
	        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
	        action.schedule(state, bufferCreationInterval);
	    }
	}
	function dispatchBufferClose(arg) {
	    var subscriber = arg.subscriber, context = arg.context;
	    subscriber.closeContext(context);
	}
	//# sourceMappingURL=bufferTime.js.map

/***/ }),
/* 784 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var bufferToggle_1 = __webpack_require__(785);
	Observable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;
	//# sourceMappingURL=bufferToggle.js.map

/***/ }),
/* 785 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(11);
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/**
	 * Buffers the source Observable values starting from an emission from
	 * `openings` and ending when the output of `closingSelector` emits.
	 *
	 * <span class="informal">Collects values from the past as an array. Starts
	 * collecting only when `opening` emits, and calls the `closingSelector`
	 * function to get an Observable that tells when to close the buffer.</span>
	 *
	 * <img src="./img/bufferToggle.png" width="100%">
	 *
	 * Buffers values from the source by opening the buffer via signals from an
	 * Observable provided to `openings`, and closing and sending the buffers when
	 * a Subscribable or Promise returned by the `closingSelector` function emits.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var buffered = clicks.bufferToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferWhen}
	 * @see {@link windowToggle}
	 *
	 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
	 * buffers.
	 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
	 * which, when it emits, signals that the associated buffer should be emitted
	 * and cleared.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferToggle
	 * @owner Observable
	 */
	function bufferToggle(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}
	exports.bufferToggle = bufferToggle;
	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    BufferToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return BufferToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferToggleSubscriber = (function (_super) {
	    __extends(BufferToggleSubscriber, _super);
	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(subscribeToResult_1.subscribeToResult(this, openings));
	    }
	    BufferToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        for (var i = 0; i < len; i++) {
	            contexts[i].buffer.push(value);
	        }
	    };
	    BufferToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._error.call(this, err);
	    };
	    BufferToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            this.destination.next(context.buffer);
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._complete.call(this);
	    };
	    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
	    };
	    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.closeBuffer(innerSub.context);
	    };
	    BufferToggleSubscriber.prototype.openBuffer = function (value) {
	        try {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = closingSelector.call(this, value);
	            if (closingNotifier) {
	                this.trySubscribe(closingNotifier);
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
	        var contexts = this.contexts;
	        if (contexts && context) {
	            var buffer = context.buffer, subscription = context.subscription;
	            this.destination.next(buffer);
	            contexts.splice(contexts.indexOf(context), 1);
	            this.remove(subscription);
	            subscription.unsubscribe();
	        }
	    };
	    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
	        var contexts = this.contexts;
	        var buffer = [];
	        var subscription = new Subscription_1.Subscription();
	        var context = { buffer: buffer, subscription: subscription };
	        contexts.push(context);
	        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
	        if (!innerSubscription || innerSubscription.closed) {
	            this.closeBuffer(context);
	        }
	        else {
	            innerSubscription.context = context;
	            this.add(innerSubscription);
	            subscription.add(innerSubscription);
	        }
	    };
	    return BufferToggleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=bufferToggle.js.map

/***/ }),
/* 786 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var bufferWhen_1 = __webpack_require__(787);
	Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;
	//# sourceMappingURL=bufferWhen.js.map

/***/ }),
/* 787 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(11);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Buffers the source Observable values, using a factory function of closing
	 * Observables to determine when to close, emit, and reset the buffer.
	 *
	 * <span class="informal">Collects values from the past as an array. When it
	 * starts collecting values, it calls a function that returns an Observable that
	 * tells when to close the buffer and restart collecting.</span>
	 *
	 * <img src="./img/bufferWhen.png" width="100%">
	 *
	 * Opens a buffer immediately, then closes the buffer when the observable
	 * returned by calling `closingSelector` function emits a value. When it closes
	 * the buffer, it immediately opens a new buffer and repeats the process.
	 *
	 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferWhen(() =>
	 *   Rx.Observable.interval(1000 + Math.random() * 4000)
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link windowWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals buffer closure.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferWhen
	 * @owner Observable
	 */
	function bufferWhen(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}
	exports.bufferWhen = bufferWhen;
	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    BufferWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
	    };
	    return BufferWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferWhenSubscriber = (function (_super) {
	    __extends(BufferWhenSubscriber, _super);
	    function BufferWhenSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.subscribing = false;
	        this.openBuffer();
	    }
	    BufferWhenSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferWhenSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferWhenSubscriber.prototype._unsubscribe = function () {
	        this.buffer = null;
	        this.subscribing = false;
	    };
	    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openBuffer();
	    };
	    BufferWhenSubscriber.prototype.notifyComplete = function () {
	        if (this.subscribing) {
	            this.complete();
	        }
	        else {
	            this.openBuffer();
	        }
	    };
	    BufferWhenSubscriber.prototype.openBuffer = function () {
	        var closingSubscription = this.closingSubscription;
	        if (closingSubscription) {
	            this.remove(closingSubscription);
	            closingSubscription.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (this.buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1.errorObject) {
	            this.error(errorObject_1.errorObject.e);
	        }
	        else {
	            closingSubscription = new Subscription_1.Subscription();
	            this.closingSubscription = closingSubscription;
	            this.add(closingSubscription);
	            this.subscribing = true;
	            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
	            this.subscribing = false;
	        }
	    };
	    return BufferWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=bufferWhen.js.map

/***/ }),
/* 788 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var combineAll_1 = __webpack_require__(789);
	Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;
	//# sourceMappingURL=combineAll.js.map

/***/ }),
/* 789 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var combineLatest_1 = __webpack_require__(711);
	/**
	 * Converts a higher-order Observable into a first-order Observable by waiting
	 * for the outer Observable to complete, then applying {@link combineLatest}.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by applying
	 * {@link combineLatest} when the Observable-of-Observables completes.</span>
	 *
	 * <img src="./img/combineAll.png" width="100%">
	 *
	 * Takes an Observable of Observables, and collects all Observables from it.
	 * Once the outer Observable completes, it subscribes to all collected
	 * Observables and combines their values using the {@link combineLatest}
	 * strategy, such that:
	 * - Every time an inner Observable emits, the output Observable emits.
	 * - When the returned observable emits, it emits all of the latest values by:
	 *   - If a `project` function is provided, it is called with each recent value
	 *     from each inner Observable in whatever order they arrived, and the result
	 *     of the `project` function is what is emitted by the output Observable.
	 *   - If there is no `project` function, an array of all of the most recent
	 *     values is emitted by the output Observable.
	 *
	 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev =>
	 *   Rx.Observable.interval(Math.random()*2000).take(3)
	 * ).take(2);
	 * var result = higherOrder.combineAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 * @see {@link mergeAll}
	 *
	 * @param {function} [project] An optional function to map the most recent
	 * values from each inner Observable into a new result. Takes each of the most
	 * recent values from each collected inner Observable as arguments, in order.
	 * @return {Observable} An Observable of projected results or arrays of recent
	 * values.
	 * @method combineAll
	 * @owner Observable
	 */
	function combineAll(project) {
	    return this.lift(new combineLatest_1.CombineLatestOperator(project));
	}
	exports.combineAll = combineAll;
	//# sourceMappingURL=combineAll.js.map

/***/ }),
/* 790 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var combineLatest_1 = __webpack_require__(711);
	Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;
	//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 791 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var concat_1 = __webpack_require__(714);
	Observable_1.Observable.prototype.concat = concat_1.concat;
	//# sourceMappingURL=concat.js.map

/***/ }),
/* 792 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var concatAll_1 = __webpack_require__(105);
	Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;
	//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 793 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var concatMap_1 = __webpack_require__(99);
	Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 794 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var concatMapTo_1 = __webpack_require__(795);
	Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;
	//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 795 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMapTo_1 = __webpack_require__(796);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in a serialized fashion on the output Observable.
	 *
	 * <span class="informal">It's like {@link concatMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/concatMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. Each new `innerObservable`
	 * instance emitted on the output Observable is concatenated with the previous
	 * `innerObservable` instance.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
	 * set to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link mergeMapTo}
	 * @see {@link switchMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An observable of values merged together by joining the
	 * passed observable with itself, one after the other, for each value emitted
	 * from the source.
	 * @method concatMapTo
	 * @owner Observable
	 */
	function concatMapTo(innerObservable, resultSelector) {
	    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
	}
	exports.concatMapTo = concatMapTo;
	//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 796 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in the output Observable.
	 *
	 * <span class="informal">It's like {@link mergeMap}, but maps each value always
	 * to the same inner Observable.</span>
	 *
	 * <img src="./img/mergeMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then merges those resulting Observables into one
	 * single Observable, which is the output Observable.
	 *
	 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 * @see {@link switchMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable.
	 * @method mergeMapTo
	 * @owner Observable
	 */
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
	}
	exports.mergeMapTo = mergeMapTo;
	// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
	//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
	var MergeMapToOperator = (function () {
	    function MergeMapToOperator(ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapToOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
	    };
	    return MergeMapToOperator;
	}());
	exports.MergeMapToOperator = MergeMapToOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapToSubscriber = (function (_super) {
	    __extends(MergeMapToSubscriber, _super);
	    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapToSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = this.ish;
	            var destination = this.destination;
	            this.active++;
	            this._innerSub(ish, destination, resultSelector, value, index);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapToSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    MergeMapToSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapToSubscriber = MergeMapToSubscriber;
	//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 797 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var count_1 = __webpack_require__(798);
	Observable_1.Observable.prototype.count = count_1.count;
	//# sourceMappingURL=count.js.map

/***/ }),
/* 798 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Counts the number of emissions on the source and emits that number when the
	 * source completes.
	 *
	 * <span class="informal">Tells how many values were emitted, when the source
	 * completes.</span>
	 *
	 * <img src="./img/count.png" width="100%">
	 *
	 * `count` transforms an Observable that emits values into an Observable that
	 * emits a single value that represents the number of values emitted by the
	 * source Observable. If the source Observable terminates with an error, `count`
	 * will pass this error notification along without emitting an value first. If
	 * the source Observable does not terminate at all, `count` will neither emit
	 * a value nor terminate. This operator takes an optional `predicate` function
	 * as argument, in which case the output emission will represent the number of
	 * source values that matched `true` with the `predicate`.
	 *
	 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var secondsBeforeClick = seconds.takeUntil(clicks);
	 * var result = secondsBeforeClick.count();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
	 * var numbers = Rx.Observable.range(1, 7);
	 * var result = numbers.count(i => i % 2 === 1);
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // 4
	 *
	 * @see {@link max}
	 * @see {@link min}
	 * @see {@link reduce}
	 *
	 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
	 * boolean function to select what values are to be counted. It is provided with
	 * arguments of:
	 * - `value`: the value from the source Observable.
	 * - `index`: the (zero-based) "index" of the value from the source Observable.
	 * - `source`: the source Observable instance itself.
	 * @return {Observable} An Observable of one number that represents the count as
	 * described above.
	 * @method count
	 * @owner Observable
	 */
	function count(predicate) {
	    return this.lift(new CountOperator(predicate, this));
	}
	exports.count = count;
	var CountOperator = (function () {
	    function CountOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    CountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
	    };
	    return CountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CountSubscriber = (function (_super) {
	    __extends(CountSubscriber, _super);
	    function CountSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.count = 0;
	        this.index = 0;
	    }
	    CountSubscriber.prototype._next = function (value) {
	        if (this.predicate) {
	            this._tryPredicate(value);
	        }
	        else {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._tryPredicate = function (value) {
	        var result;
	        try {
	            result = this.predicate(value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._complete = function () {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };
	    return CountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=count.js.map

/***/ }),
/* 799 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var dematerialize_1 = __webpack_require__(800);
	Observable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;
	//# sourceMappingURL=dematerialize.js.map

/***/ }),
/* 800 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Converts an Observable of {@link Notification} objects into the emissions
	 * that they represent.
	 *
	 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
	 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
	 *
	 * <img src="./img/dematerialize.png" width="100%">
	 *
	 * `dematerialize` is assumed to operate an Observable that only emits
	 * {@link Notification} objects as `next` emissions, and does not emit any
	 * `error`. Such Observable is the output of a `materialize` operation. Those
	 * notifications are then unwrapped using the metadata they contain, and emitted
	 * as `next`, `error`, and `complete` on the output Observable.
	 *
	 * Use this operator in conjunction with {@link materialize}.
	 *
	 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
	 * var notifA = new Rx.Notification('N', 'A');
	 * var notifB = new Rx.Notification('N', 'B');
	 * var notifE = new Rx.Notification('E', void 0,
	 *   new TypeError('x.toUpperCase is not a function')
	 * );
	 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
	 * var upperCase = materialized.dematerialize();
	 * upperCase.subscribe(x => console.log(x), e => console.error(e));
	 *
	 * // Results in:
	 * // A
	 * // B
	 * // TypeError: x.toUpperCase is not a function
	 *
	 * @see {@link Notification}
	 * @see {@link materialize}
	 *
	 * @return {Observable} An Observable that emits items and notifications
	 * embedded in Notification objects emitted by the source Observable.
	 * @method dematerialize
	 * @owner Observable
	 */
	function dematerialize() {
	    return this.lift(new DeMaterializeOperator());
	}
	exports.dematerialize = dematerialize;
	var DeMaterializeOperator = (function () {
	    function DeMaterializeOperator() {
	    }
	    DeMaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DeMaterializeSubscriber(subscriber));
	    };
	    return DeMaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DeMaterializeSubscriber = (function (_super) {
	    __extends(DeMaterializeSubscriber, _super);
	    function DeMaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    DeMaterializeSubscriber.prototype._next = function (value) {
	        value.observe(this.destination);
	    };
	    return DeMaterializeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=dematerialize.js.map

/***/ }),
/* 801 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var debounce_1 = __webpack_require__(802);
	Observable_1.Observable.prototype.debounce = debounce_1.debounce;
	//# sourceMappingURL=debounce.js.map

/***/ }),
/* 802 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * determined by another Observable has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link debounceTime}, but the time span of
	 * emission silence is determined by a second Observable.</span>
	 *
	 * <img src="./img/debounce.png" width="100%">
	 *
	 * `debounce` delays values emitted by the source Observable, but drops previous
	 * pending delayed emissions if a new value arrives on the source Observable.
	 * This operator keeps track of the most recent value from the source
	 * Observable, and spawns a duration Observable by calling the
	 * `durationSelector` function. The value is emitted only when the duration
	 * Observable emits a value or completes, and if no other value was emitted on
	 * the source Observable since the duration Observable was spawned. If a new
	 * value appears before the duration Observable emits, the previous value will
	 * be dropped and will not be emitted on the output Observable.
	 *
	 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
	 * delay-like operator since output emissions do not necessarily occur at the
	 * same time as they did on the source Observable.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): Observable|Promise} durationSelector A function
	 * that receives a value from the source Observable, for computing the timeout
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified duration Observable returned by
	 * `durationSelector`, and may drop some values if they occur too frequently.
	 * @method debounce
	 * @owner Observable
	 */
	function debounce(durationSelector) {
	    return this.lift(new DebounceOperator(durationSelector));
	}
	exports.debounce = debounce;
	var DebounceOperator = (function () {
	    function DebounceOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    DebounceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
	    };
	    return DebounceOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceSubscriber = (function (_super) {
	    __extends(DebounceSubscriber, _super);
	    function DebounceSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	        this.durationSubscription = null;
	    }
	    DebounceSubscriber.prototype._next = function (value) {
	        try {
	            var result = this.durationSelector.call(this, value);
	            if (result) {
	                this._tryNext(value, result);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DebounceSubscriber.prototype._complete = function () {
	        this.emitValue();
	        this.destination.complete();
	    };
	    DebounceSubscriber.prototype._tryNext = function (value, duration) {
	        var subscription = this.durationSubscription;
	        this.value = value;
	        this.hasValue = true;
	        if (subscription) {
	            subscription.unsubscribe();
	            this.remove(subscription);
	        }
	        subscription = subscribeToResult_1.subscribeToResult(this, duration);
	        if (!subscription.closed) {
	            this.add(this.durationSubscription = subscription);
	        }
	    };
	    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            var value = this.value;
	            var subscription = this.durationSubscription;
	            if (subscription) {
	                this.durationSubscription = null;
	                subscription.unsubscribe();
	                this.remove(subscription);
	            }
	            this.value = null;
	            this.hasValue = false;
	            _super.prototype._next.call(this, value);
	        }
	    };
	    return DebounceSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=debounce.js.map

/***/ }),
/* 803 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var defaultIfEmpty_1 = __webpack_require__(804);
	Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
	//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),
/* 804 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/* tslint:disable:max-line-length */
	/**
	 * Emits a given value if the source Observable completes without emitting any
	 * `next` value, otherwise mirrors the source Observable.
	 *
	 * <span class="informal">If the source Observable turns out to be empty, then
	 * this operator will emit a default value.</span>
	 *
	 * <img src="./img/defaultIfEmpty.png" width="100%">
	 *
	 * `defaultIfEmpty` emits the values emitted by the source Observable or a
	 * specified default value if the source Observable is empty (completes without
	 * having emitted any `next` value).
	 *
	 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
	 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link empty}
	 * @see {@link last}
	 *
	 * @param {any} [defaultValue=null] The default value used if the source
	 * Observable is empty.
	 * @return {Observable} An Observable that emits either the specified
	 * `defaultValue` if the source Observable emits no items, or the values emitted
	 * by the source Observable.
	 * @method defaultIfEmpty
	 * @owner Observable
	 */
	function defaultIfEmpty(defaultValue) {
	    if (defaultValue === void 0) { defaultValue = null; }
	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}
	exports.defaultIfEmpty = defaultIfEmpty;
	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        this.defaultValue = defaultValue;
	    }
	    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
	    };
	    return DefaultIfEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DefaultIfEmptySubscriber = (function (_super) {
	    __extends(DefaultIfEmptySubscriber, _super);
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _super.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }
	    DefaultIfEmptySubscriber.prototype._next = function (value) {
	        this.isEmpty = false;
	        this.destination.next(value);
	    };
	    DefaultIfEmptySubscriber.prototype._complete = function () {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	    return DefaultIfEmptySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),
/* 805 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var delay_1 = __webpack_require__(806);
	Observable_1.Observable.prototype.delay = delay_1.delay;
	//# sourceMappingURL=delay.js.map

/***/ }),
/* 806 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(45);
	var isDate_1 = __webpack_require__(763);
	var Subscriber_1 = __webpack_require__(9);
	var Notification_1 = __webpack_require__(98);
	/**
	 * Delays the emission of items from the source Observable by a given timeout or
	 * until a given Date.
	 *
	 * <span class="informal">Time shifts each item by some specified amount of
	 * milliseconds.</span>
	 *
	 * <img src="./img/delay.png" width="100%">
	 *
	 * If the delay argument is a Number, this operator time shifts the source
	 * Observable by that amount of time expressed in milliseconds. The relative
	 * time intervals between the values are preserved.
	 *
	 * If the delay argument is a Date, this operator time shifts the start of the
	 * Observable execution until the given date occurs.
	 *
	 * @example <caption>Delay each click by one second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @example <caption>Delay all clicks until a future date happens</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var date = new Date('March 15, 2050 12:00:00'); // in the future
	 * var delayedClicks = clicks.delay(date); // click emitted only after that date
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 *
	 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
	 * a `Date` until which the emission of the source items is delayed.
	 * @param {Scheduler} [scheduler=async] The IScheduler to use for
	 * managing the timers that handle the time-shift for each item.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified timeout or Date.
	 * @method delay
	 * @owner Observable
	 */
	function delay(delay, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteDelay = isDate_1.isDate(delay);
	    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
	    return this.lift(new DelayOperator(delayFor, scheduler));
	}
	exports.delay = delay;
	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	    DelayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
	    };
	    return DelayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelaySubscriber = (function (_super) {
	    __extends(DelaySubscriber, _super);
	    function DelaySubscriber(destination, delay, scheduler) {
	        _super.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	    }
	    DelaySubscriber.dispatch = function (state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, delay_1);
	        }
	        else {
	            source.active = false;
	        }
	    };
	    DelaySubscriber.prototype._schedule = function (scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };
	    DelaySubscriber.prototype.scheduleNotification = function (notification) {
	        if (this.errored === true) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        var message = new DelayMessage(scheduler.now() + this.delay, notification);
	        this.queue.push(message);
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	    DelaySubscriber.prototype._next = function (value) {
	        this.scheduleNotification(Notification_1.Notification.createNext(value));
	    };
	    DelaySubscriber.prototype._error = function (err) {
	        this.errored = true;
	        this.queue = [];
	        this.destination.error(err);
	    };
	    DelaySubscriber.prototype._complete = function () {
	        this.scheduleNotification(Notification_1.Notification.createComplete());
	    };
	    return DelaySubscriber;
	}(Subscriber_1.Subscriber));
	var DelayMessage = (function () {
	    function DelayMessage(time, notification) {
	        this.time = time;
	        this.notification = notification;
	    }
	    return DelayMessage;
	}());
	//# sourceMappingURL=delay.js.map

/***/ }),
/* 807 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var delayWhen_1 = __webpack_require__(808);
	Observable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;
	//# sourceMappingURL=delayWhen.js.map

/***/ }),
/* 808 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var Observable_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Delays the emission of items from the source Observable by a given time span
	 * determined by the emissions of another Observable.
	 *
	 * <span class="informal">It's like {@link delay}, but the time span of the
	 * delay duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/delayWhen.png" width="100%">
	 *
	 * `delayWhen` time shifts each emitted value from the source Observable by a
	 * time span determined by another Observable. When the source emits a value,
	 * the `delayDurationSelector` function is called with the source value as
	 * argument, and should return an Observable, called the "duration" Observable.
	 * The source value is emitted on the output Observable only when the duration
	 * Observable emits a value or completes.
	 *
	 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
	 * is an Observable. When `subscriptionDelay` emits its first value or
	 * completes, the source Observable is subscribed to and starts behaving like
	 * described in the previous paragraph. If `subscriptionDelay` is not provided,
	 * `delayWhen` will subscribe to the source Observable as soon as the output
	 * Observable is subscribed.
	 *
	 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delayWhen(event =>
	 *   Rx.Observable.interval(Math.random() * 5000)
	 * );
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounce}
	 * @see {@link delay}
	 *
	 * @param {function(value: T): Observable} delayDurationSelector A function that
	 * returns an Observable for each value emitted by the source Observable, which
	 * is then used to delay the emission of that item on the output Observable
	 * until the Observable returned from this function emits a value.
	 * @param {Observable} subscriptionDelay An Observable that triggers the
	 * subscription to the source Observable once it emits any value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by an amount of time specified by the Observable returned by
	 * `delayDurationSelector`.
	 * @method delayWhen
	 * @owner Observable
	 */
	function delayWhen(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return new SubscriptionDelayObservable(this, subscriptionDelay)
	            .lift(new DelayWhenOperator(delayDurationSelector));
	    }
	    return this.lift(new DelayWhenOperator(delayDurationSelector));
	}
	exports.delayWhen = delayWhen;
	var DelayWhenOperator = (function () {
	    function DelayWhenOperator(delayDurationSelector) {
	        this.delayDurationSelector = delayDurationSelector;
	    }
	    DelayWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
	    };
	    return DelayWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelayWhenSubscriber = (function (_super) {
	    __extends(DelayWhenSubscriber, _super);
	    function DelayWhenSubscriber(destination, delayDurationSelector) {
	        _super.call(this, destination);
	        this.delayDurationSelector = delayDurationSelector;
	        this.completed = false;
	        this.delayNotifierSubscriptions = [];
	        this.values = [];
	    }
	    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(outerValue);
	        this.removeSubscription(innerSub);
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        var value = this.removeSubscription(innerSub);
	        if (value) {
	            this.destination.next(value);
	        }
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype._next = function (value) {
	        try {
	            var delayNotifier = this.delayDurationSelector(value);
	            if (delayNotifier) {
	                this.tryDelay(delayNotifier, value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DelayWhenSubscriber.prototype._complete = function () {
	        this.completed = true;
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
	        subscription.unsubscribe();
	        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
	        var value = null;
	        if (subscriptionIdx !== -1) {
	            value = this.values[subscriptionIdx];
	            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
	            this.values.splice(subscriptionIdx, 1);
	        }
	        return value;
	    };
	    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
	        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
	        this.add(notifierSubscription);
	        this.delayNotifierSubscriptions.push(notifierSubscription);
	        this.values.push(value);
	    };
	    DelayWhenSubscriber.prototype.tryComplete = function () {
	        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
	            this.destination.complete();
	        }
	    };
	    return DelayWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelayObservable = (function (_super) {
	    __extends(SubscriptionDelayObservable, _super);
	    function SubscriptionDelayObservable(source, subscriptionDelay) {
	        _super.call(this);
	        this.source = source;
	        this.subscriptionDelay = subscriptionDelay;
	    }
	    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
	        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
	    };
	    return SubscriptionDelayObservable;
	}(Observable_1.Observable));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelaySubscriber = (function (_super) {
	    __extends(SubscriptionDelaySubscriber, _super);
	    function SubscriptionDelaySubscriber(parent, source) {
	        _super.call(this);
	        this.parent = parent;
	        this.source = source;
	        this.sourceSubscribed = false;
	    }
	    SubscriptionDelaySubscriber.prototype._next = function (unused) {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype._error = function (err) {
	        this.unsubscribe();
	        this.parent.error(err);
	    };
	    SubscriptionDelaySubscriber.prototype._complete = function () {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
	        if (!this.sourceSubscribed) {
	            this.sourceSubscribed = true;
	            this.unsubscribe();
	            this.source.subscribe(this.parent);
	        }
	    };
	    return SubscriptionDelaySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=delayWhen.js.map

/***/ }),
/* 809 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var distinct_1 = __webpack_require__(810);
	Observable_1.Observable.prototype.distinct = distinct_1.distinct;
	//# sourceMappingURL=distinct.js.map

/***/ }),
/* 810 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	var Set_1 = __webpack_require__(811);
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
	 *
	 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
	 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
	 * source observable directly with an equality check against previous values.
	 *
	 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
	 *
	 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
	 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
	 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
	 * that the internal `Set` can be "flushed", basically clearing it of values.
	 *
	 * @example <caption>A simple example with numbers</caption>
	 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
	 *   .distinct()
	 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
	 *
	 * @example <caption>An example using a keySelector function</caption>
	 * interface Person {
	 *    age: number,
	 *    name: string
	 * }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'})
	 *     .distinct((p: Person) => p.name)
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 *
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 *
	 * @param {function} [keySelector] optional function to select which value you want to check as distinct.
	 * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.
	 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
	 * @method distinct
	 * @owner Observable
	 */
	function distinct(keySelector, flushes) {
	    return this.lift(new DistinctOperator(keySelector, flushes));
	}
	exports.distinct = distinct;
	var DistinctOperator = (function () {
	    function DistinctOperator(keySelector, flushes) {
	        this.keySelector = keySelector;
	        this.flushes = flushes;
	    }
	    DistinctOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
	    };
	    return DistinctOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctSubscriber = (function (_super) {
	    __extends(DistinctSubscriber, _super);
	    function DistinctSubscriber(destination, keySelector, flushes) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.values = new Set_1.Set();
	        if (flushes) {
	            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
	        }
	    }
	    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values.clear();
	    };
	    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DistinctSubscriber.prototype._next = function (value) {
	        if (this.keySelector) {
	            this._useKeySelector(value);
	        }
	        else {
	            this._finalizeNext(value, value);
	        }
	    };
	    DistinctSubscriber.prototype._useKeySelector = function (value) {
	        var key;
	        var destination = this.destination;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this._finalizeNext(key, value);
	    };
	    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
	        var values = this.values;
	        if (!values.has(key)) {
	            values.add(key);
	            this.destination.next(value);
	        }
	    };
	    return DistinctSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.DistinctSubscriber = DistinctSubscriber;
	//# sourceMappingURL=distinct.js.map

/***/ }),
/* 811 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	function minimalSetImpl() {
	    // THIS IS NOT a full impl of Set, this is just the minimum
	    // bits of functionality we need for this library.
	    return (function () {
	        function MinimalSet() {
	            this._values = [];
	        }
	        MinimalSet.prototype.add = function (value) {
	            if (!this.has(value)) {
	                this._values.push(value);
	            }
	        };
	        MinimalSet.prototype.has = function (value) {
	            return this._values.indexOf(value) !== -1;
	        };
	        Object.defineProperty(MinimalSet.prototype, "size", {
	            get: function () {
	                return this._values.length;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        MinimalSet.prototype.clear = function () {
	            this._values.length = 0;
	        };
	        return MinimalSet;
	    }());
	}
	exports.minimalSetImpl = minimalSetImpl;
	exports.Set = root_1.root.Set || minimalSetImpl();
	//# sourceMappingURL=Set.js.map

/***/ }),
/* 812 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var distinctUntilKeyChanged_1 = __webpack_require__(813);
	Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
	//# sourceMappingURL=distinctUntilKeyChanged.js.map

/***/ }),
/* 813 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var distinctUntilChanged_1 = __webpack_require__(51);
	/* tslint:disable:max-line-length */
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
	 * using a property accessed by using the key provided to check if the two items are distinct.
	 *
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 *
	 * If a comparator function is not provided, an equality check is used by default.
	 *
	 * @example <caption>An example comparing the name of persons</caption>
	 *
	 *  interface Person {
	 *     age: number,
	 *     name: string
	 *  }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'},
	 *     { age: 6, name: 'Foo'})
	 *     .distinctUntilKeyChanged('name')
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo' }
	 *
	 * @example <caption>An example comparing the first letters of the name</caption>
	 *
	 * interface Person {
	 *     age: number,
	 *     name: string
	 *  }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo1'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo2'},
	 *     { age: 6, name: 'Foo3'})
	 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo1' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo2' }
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 *
	 * @param {string} key string key for object property lookup on each item.
	 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} an Observable that emits items from the source Observable with distinct values based on the key specified.
	 * @method distinctUntilKeyChanged
	 * @owner Observable
	 */
	function distinctUntilKeyChanged(key, compare) {
	    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
	        if (compare) {
	            return compare(x[key], y[key]);
	        }
	        return x[key] === y[key];
	    });
	}
	exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
	//# sourceMappingURL=distinctUntilKeyChanged.js.map

/***/ }),
/* 814 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var exhaust_1 = __webpack_require__(815);
	Observable_1.Observable.prototype.exhaust = exhaust_1.exhaust;
	//# sourceMappingURL=exhaust.js.map

/***/ }),
/* 815 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Converts a higher-order Observable into a first-order Observable by dropping
	 * inner Observables while the previous inner Observable has not yet completed.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * next inner Observables while the current inner is still executing.</span>
	 *
	 * <img src="./img/exhaust.png" width="100%">
	 *
	 * `exhaust` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable begins emitting the items emitted by that
	 * inner Observable. So far, it behaves like {@link mergeAll}. However,
	 * `exhaust` ignores every new inner Observable if the previous Observable has
	 * not yet completed. Once that one completes, it will accept and flatten the
	 * next inner Observable and repeat this process.
	 *
	 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var result = higherOrder.exhaust();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link switch}
	 * @see {@link mergeAll}
	 * @see {@link exhaustMap}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} Returns an Observable that takes a source of Observables
	 * and propagates the first observable exclusively until it completes before
	 * subscribing to the next.
	 * @method exhaust
	 * @owner Observable
	 */
	function exhaust() {
	    return this.lift(new SwitchFirstOperator());
	}
	exports.exhaust = exhaust;
	var SwitchFirstOperator = (function () {
	    function SwitchFirstOperator() {
	    }
	    SwitchFirstOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstSubscriber(subscriber));
	    };
	    return SwitchFirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchFirstSubscriber = (function (_super) {
	    __extends(SwitchFirstSubscriber, _super);
	    function SwitchFirstSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasCompleted = false;
	        this.hasSubscription = false;
	    }
	    SwitchFirstSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.hasSubscription = true;
	            this.add(subscribeToResult_1.subscribeToResult(this, value));
	        }
	    };
	    SwitchFirstSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=exhaust.js.map

/***/ }),
/* 816 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var exhaustMap_1 = __webpack_require__(817);
	Observable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;
	//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 817 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable only if the previous projected Observable has completed.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link exhaust}.</span>
	 *
	 * <img src="./img/exhaustMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. When it projects a source value to
	 * an Observable, the output Observable begins emitting the items emitted by
	 * that projected Observable. However, `exhaustMap` ignores every new projected
	 * Observable if the previous projected Observable has not yet completed. Once
	 * that one completes, it will accept and flatten the next projected Observable
	 * and repeat this process.
	 *
	 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaust}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable containing projected Observables
	 * of each item of the source, ignoring projected Observables that start before
	 * their preceding Observable has completed.
	 * @method exhaustMap
	 * @owner Observable
	 */
	function exhaustMap(project, resultSelector) {
	    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
	}
	exports.exhaustMap = exhaustMap;
	var SwitchFirstMapOperator = (function () {
	    function SwitchFirstMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchFirstMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchFirstMapSubscriber = (function (_super) {
	    __extends(SwitchFirstMapSubscriber, _super);
	    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.hasSubscription = false;
	        this.hasCompleted = false;
	        this.index = 0;
	    }
	    SwitchFirstMapSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.tryNext(value);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
	        var index = this.index++;
	        var destination = this.destination;
	        try {
	            var result = this.project(value, index);
	            this.hasSubscription = true;
	            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
	        }
	        catch (err) {
	            destination.error(err);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        try {
	            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	            destination.next(result);
	        }
	        catch (err) {
	            destination.error(err);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 818 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var expand_1 = __webpack_require__(819);
	Observable_1.Observable.prototype.expand = expand_1.expand;
	//# sourceMappingURL=expand.js.map

/***/ }),
/* 819 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Recursively projects each source value to an Observable which is merged in
	 * the output Observable.
	 *
	 * <span class="informal">It's similar to {@link mergeMap}, but applies the
	 * projection function to every source value as well as every output value.
	 * It's recursive.</span>
	 *
	 * <img src="./img/expand.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger. *Expand* will re-emit on the output
	 * Observable every source value. Then, each output value is given to the
	 * `project` function which returns an inner Observable to be merged on the
	 * output Observable. Those output values resulting from the projection are also
	 * given to the `project` function to produce new output values. This is how
	 * *expand* behaves recursively.
	 *
	 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var powersOfTwo = clicks
	 *   .mapTo(1)
	 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
	 *   .take(10);
	 * powersOfTwo.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 *
	 * @param {function(value: T, index: number) => Observable} project A function
	 * that, when applied to an item emitted by the source or the output Observable,
	 * returns an Observable.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
	 * each projected inner Observable.
	 * @return {Observable} An Observable that emits the source values and also
	 * result of applying the projection function to each value emitted on the
	 * output Observable and and merging the results of the Observables obtained
	 * from this transformation.
	 * @method expand
	 * @owner Observable
	 */
	function expand(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (scheduler === void 0) { scheduler = undefined; }
	    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
	    return this.lift(new ExpandOperator(project, concurrent, scheduler));
	}
	exports.expand = expand;
	var ExpandOperator = (function () {
	    function ExpandOperator(project, concurrent, scheduler) {
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	    }
	    ExpandOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
	    };
	    return ExpandOperator;
	}());
	exports.ExpandOperator = ExpandOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ExpandSubscriber = (function (_super) {
	    __extends(ExpandSubscriber, _super);
	    function ExpandSubscriber(destination, project, concurrent, scheduler) {
	        _super.call(this, destination);
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this.active = 0;
	        this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            this.buffer = [];
	        }
	    }
	    ExpandSubscriber.dispatch = function (arg) {
	        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
	        subscriber.subscribeToProjection(result, value, index);
	    };
	    ExpandSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (destination.closed) {
	            this._complete();
	            return;
	        }
	        var index = this.index++;
	        if (this.active < this.concurrent) {
	            destination.next(value);
	            var result = tryCatch_1.tryCatch(this.project)(value, index);
	            if (result === errorObject_1.errorObject) {
	                destination.error(errorObject_1.errorObject.e);
	            }
	            else if (!this.scheduler) {
	                this.subscribeToProjection(result, value, index);
	            }
	            else {
	                var state = { subscriber: this, result: result, value: value, index: index };
	                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	        this.active++;
	        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    ExpandSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._next(innerValue);
	    };
	    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return ExpandSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.ExpandSubscriber = ExpandSubscriber;
	//# sourceMappingURL=expand.js.map

/***/ }),
/* 820 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var elementAt_1 = __webpack_require__(821);
	Observable_1.Observable.prototype.elementAt = elementAt_1.elementAt;
	//# sourceMappingURL=elementAt.js.map

/***/ }),
/* 821 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var ArgumentOutOfRangeError_1 = __webpack_require__(822);
	/**
	 * Emits the single value at the specified `index` in a sequence of emissions
	 * from the source Observable.
	 *
	 * <span class="informal">Emits only the i-th value, then completes.</span>
	 *
	 * <img src="./img/elementAt.png" width="100%">
	 *
	 * `elementAt` returns an Observable that emits the item at the specified
	 * `index` in the source Observable, or a default value if that `index` is out
	 * of range and the `default` argument is provided. If the `default` argument is
	 * not given and the `index` is out of range, the output Observable will emit an
	 * `ArgumentOutOfRangeError` error.
	 *
	 * @example <caption>Emit only the third click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.elementAt(2);
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // click 1 = nothing
	 * // click 2 = nothing
	 * // click 3 = MouseEvent object logged to console
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link skip}
	 * @see {@link single}
	 * @see {@link take}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
	 * Observable has completed before emitting the i-th `next` notification.
	 *
	 * @param {number} index Is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {T} [defaultValue] The default value returned for missing indices.
	 * @return {Observable} An Observable that emits a single item, if it is found.
	 * Otherwise, will emit the default value if given. If not, then emits an error.
	 * @method elementAt
	 * @owner Observable
	 */
	function elementAt(index, defaultValue) {
	    return this.lift(new ElementAtOperator(index, defaultValue));
	}
	exports.elementAt = elementAt;
	var ElementAtOperator = (function () {
	    function ElementAtOperator(index, defaultValue) {
	        this.index = index;
	        this.defaultValue = defaultValue;
	        if (index < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    ElementAtOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
	    };
	    return ElementAtOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ElementAtSubscriber = (function (_super) {
	    __extends(ElementAtSubscriber, _super);
	    function ElementAtSubscriber(destination, index, defaultValue) {
	        _super.call(this, destination);
	        this.index = index;
	        this.defaultValue = defaultValue;
	    }
	    ElementAtSubscriber.prototype._next = function (x) {
	        if (this.index-- === 0) {
	            this.destination.next(x);
	            this.destination.complete();
	        }
	    };
	    ElementAtSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index >= 0) {
	            if (typeof this.defaultValue !== 'undefined') {
	                destination.next(this.defaultValue);
	            }
	            else {
	                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
	            }
	        }
	        destination.complete();
	    };
	    return ElementAtSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=elementAt.js.map

/***/ }),
/* 822 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an element was queried at a certain index of an
	 * Observable, but no such index or position exists in that sequence.
	 *
	 * @see {@link elementAt}
	 * @see {@link take}
	 * @see {@link takeLast}
	 *
	 * @class ArgumentOutOfRangeError
	 */
	var ArgumentOutOfRangeError = (function (_super) {
	    __extends(ArgumentOutOfRangeError, _super);
	    function ArgumentOutOfRangeError() {
	        var err = _super.call(this, 'argument out of range');
	        this.name = err.name = 'ArgumentOutOfRangeError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ArgumentOutOfRangeError;
	}(Error));
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
	//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),
/* 823 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var finally_1 = __webpack_require__(824);
	Observable_1.Observable.prototype.finally = finally_1._finally;
	Observable_1.Observable.prototype._finally = finally_1._finally;
	//# sourceMappingURL=finally.js.map

/***/ }),
/* 824 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var Subscription_1 = __webpack_require__(11);
	/**
	 * Returns an Observable that mirrors the source Observable, but will call a specified function when
	 * the source terminates on complete or error.
	 * @param {function} callback function to be called when source terminates.
	 * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.
	 * @method finally
	 * @owner Observable
	 */
	function _finally(callback) {
	    return this.lift(new FinallyOperator(callback));
	}
	exports._finally = _finally;
	var FinallyOperator = (function () {
	    function FinallyOperator(callback) {
	        this.callback = callback;
	    }
	    FinallyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
	    };
	    return FinallyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FinallySubscriber = (function (_super) {
	    __extends(FinallySubscriber, _super);
	    function FinallySubscriber(destination, callback) {
	        _super.call(this, destination);
	        this.add(new Subscription_1.Subscription(callback));
	    }
	    return FinallySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=finally.js.map

/***/ }),
/* 825 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var find_1 = __webpack_require__(826);
	Observable_1.Observable.prototype.find = find_1.find;
	//# sourceMappingURL=find.js.map

/***/ }),
/* 826 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/* tslint:disable:max-line-length */
	/**
	 * Emits only the first value emitted by the source Observable that meets some
	 * condition.
	 *
	 * <span class="informal">Finds the first value that passes some test and emits
	 * that.</span>
	 *
	 * <img src="./img/find.png" width="100%">
	 *
	 * `find` searches for the first item in the source Observable that matches the
	 * specified condition embodied by the `predicate`, and returns the first
	 * occurrence in the source. Unlike {@link first}, the `predicate` is required
	 * in `find`, and does not emit an error if a valid value is not found.
	 *
	 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link first}
	 * @see {@link findIndex}
	 * @see {@link take}
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
	 * A function called with each item to test for condition matching.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable<T>} An Observable of the first item that matches the
	 * condition.
	 * @method find
	 * @owner Observable
	 */
	function find(predicate, thisArg) {
	    if (typeof predicate !== 'function') {
	        throw new TypeError('predicate is not a function');
	    }
	    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
	}
	exports.find = find;
	var FindValueOperator = (function () {
	    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	    }
	    FindValueOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
	    };
	    return FindValueOperator;
	}());
	exports.FindValueOperator = FindValueOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FindValueSubscriber = (function (_super) {
	    __extends(FindValueSubscriber, _super);
	    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	        this.index = 0;
	    }
	    FindValueSubscriber.prototype.notifyComplete = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    FindValueSubscriber.prototype._next = function (value) {
	        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
	        var index = this.index++;
	        try {
	            var result = predicate.call(thisArg || this, value, index, this.source);
	            if (result) {
	                this.notifyComplete(this.yieldIndex ? index : value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    FindValueSubscriber.prototype._complete = function () {
	        this.notifyComplete(this.yieldIndex ? -1 : undefined);
	    };
	    return FindValueSubscriber;
	}(Subscriber_1.Subscriber));
	exports.FindValueSubscriber = FindValueSubscriber;
	//# sourceMappingURL=find.js.map

/***/ }),
/* 827 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var findIndex_1 = __webpack_require__(828);
	Observable_1.Observable.prototype.findIndex = findIndex_1.findIndex;
	//# sourceMappingURL=findIndex.js.map

/***/ }),
/* 828 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var find_1 = __webpack_require__(826);
	/**
	 * Emits only the index of the first value emitted by the source Observable that
	 * meets some condition.
	 *
	 * <span class="informal">It's like {@link find}, but emits the index of the
	 * found value, not the value itself.</span>
	 *
	 * <img src="./img/findIndex.png" width="100%">
	 *
	 * `findIndex` searches for the first item in the source Observable that matches
	 * the specified condition embodied by the `predicate`, and returns the
	 * (zero-based) index of the first occurrence in the source. Unlike
	 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
	 * an error if a valid value is not found.
	 *
	 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link first}
	 * @see {@link take}
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
	 * A function called with each item to test for condition matching.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of the index of the first item that
	 * matches the condition.
	 * @method find
	 * @owner Observable
	 */
	function findIndex(predicate, thisArg) {
	    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));
	}
	exports.findIndex = findIndex;
	//# sourceMappingURL=findIndex.js.map

/***/ }),
/* 829 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var first_1 = __webpack_require__(102);
	Observable_1.Observable.prototype.first = first_1.first;
	//# sourceMappingURL=first.js.map

/***/ }),
/* 830 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var groupBy_1 = __webpack_require__(831);
	Observable_1.Observable.prototype.groupBy = groupBy_1.groupBy;
	//# sourceMappingURL=groupBy.js.map

/***/ }),
/* 831 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var Subscription_1 = __webpack_require__(11);
	var Observable_1 = __webpack_require__(7);
	var Subject_1 = __webpack_require__(6);
	var Map_1 = __webpack_require__(832);
	var FastMap_1 = __webpack_require__(834);
	/* tslint:disable:max-line-length */
	/**
	 * Groups the items emitted by an Observable according to a specified criterion,
	 * and emits these grouped items as `GroupedObservables`, one
	 * {@link GroupedObservable} per group.
	 *
	 * <img src="./img/groupBy.png" width="100%">
	 *
	 * @param {function(value: T): K} keySelector a function that extracts the key
	 * for each item.
	 * @param {function(value: T): R} [elementSelector] a function that extracts the
	 * return element for each item.
	 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
	 * a function that returns an Observable to determine how long each group should
	 * exist.
	 * @return {Observable<GroupedObservable<K,R>>} an Observable that emits
	 * GroupedObservables, each of which corresponds to a unique key value and each
	 * of which emits those items from the source Observable that share that key
	 * value.
	 * @method groupBy
	 * @owner Observable
	 */
	function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
	    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
	}
	exports.groupBy = groupBy;
	var GroupByOperator = (function () {
	    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	    }
	    GroupByOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
	    };
	    return GroupByOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupBySubscriber = (function (_super) {
	    __extends(GroupBySubscriber, _super);
	    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	        this.groups = null;
	        this.attemptedToUnsubscribe = false;
	        this.count = 0;
	    }
	    GroupBySubscriber.prototype._next = function (value) {
	        var key;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this._group(value, key);
	    };
	    GroupBySubscriber.prototype._group = function (value, key) {
	        var groups = this.groups;
	        if (!groups) {
	            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
	        }
	        var group = groups.get(key);
	        var element;
	        if (this.elementSelector) {
	            try {
	                element = this.elementSelector(value);
	            }
	            catch (err) {
	                this.error(err);
	            }
	        }
	        else {
	            element = value;
	        }
	        if (!group) {
	            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
	            groups.set(key, group);
	            var groupedObservable = new GroupedObservable(key, group, this);
	            this.destination.next(groupedObservable);
	            if (this.durationSelector) {
	                var duration = void 0;
	                try {
	                    duration = this.durationSelector(new GroupedObservable(key, group));
	                }
	                catch (err) {
	                    this.error(err);
	                    return;
	                }
	                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
	            }
	        }
	        if (!group.closed) {
	            group.next(element);
	        }
	    };
	    GroupBySubscriber.prototype._error = function (err) {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	            });
	            groups.clear();
	        }
	        this.destination.error(err);
	    };
	    GroupBySubscriber.prototype._complete = function () {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	            });
	            groups.clear();
	        }
	        this.destination.complete();
	    };
	    GroupBySubscriber.prototype.removeGroup = function (key) {
	        this.groups.delete(key);
	    };
	    GroupBySubscriber.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            this.attemptedToUnsubscribe = true;
	            if (this.count === 0) {
	                _super.prototype.unsubscribe.call(this);
	            }
	        }
	    };
	    return GroupBySubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupDurationSubscriber = (function (_super) {
	    __extends(GroupDurationSubscriber, _super);
	    function GroupDurationSubscriber(key, group, parent) {
	        _super.call(this);
	        this.key = key;
	        this.group = group;
	        this.parent = parent;
	    }
	    GroupDurationSubscriber.prototype._next = function (value) {
	        this._complete();
	    };
	    GroupDurationSubscriber.prototype._error = function (err) {
	        var group = this.group;
	        if (!group.closed) {
	            group.error(err);
	        }
	        this.parent.removeGroup(this.key);
	    };
	    GroupDurationSubscriber.prototype._complete = function () {
	        var group = this.group;
	        if (!group.closed) {
	            group.complete();
	        }
	        this.parent.removeGroup(this.key);
	    };
	    return GroupDurationSubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * An Observable representing values belonging to the same group represented by
	 * a common key. The values emitted by a GroupedObservable come from the source
	 * Observable. The common key is available as the field `key` on a
	 * GroupedObservable instance.
	 *
	 * @class GroupedObservable<K, T>
	 */
	var GroupedObservable = (function (_super) {
	    __extends(GroupedObservable, _super);
	    function GroupedObservable(key, groupSubject, refCountSubscription) {
	        _super.call(this);
	        this.key = key;
	        this.groupSubject = groupSubject;
	        this.refCountSubscription = refCountSubscription;
	    }
	    GroupedObservable.prototype._subscribe = function (subscriber) {
	        var subscription = new Subscription_1.Subscription();
	        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
	        if (refCountSubscription && !refCountSubscription.closed) {
	            subscription.add(new InnerRefCountSubscription(refCountSubscription));
	        }
	        subscription.add(groupSubject.subscribe(subscriber));
	        return subscription;
	    };
	    return GroupedObservable;
	}(Observable_1.Observable));
	exports.GroupedObservable = GroupedObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerRefCountSubscription = (function (_super) {
	    __extends(InnerRefCountSubscription, _super);
	    function InnerRefCountSubscription(parent) {
	        _super.call(this);
	        this.parent = parent;
	        parent.count++;
	    }
	    InnerRefCountSubscription.prototype.unsubscribe = function () {
	        var parent = this.parent;
	        if (!parent.closed && !this.closed) {
	            _super.prototype.unsubscribe.call(this);
	            parent.count -= 1;
	            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
	                parent.unsubscribe();
	            }
	        }
	    };
	    return InnerRefCountSubscription;
	}(Subscription_1.Subscription));
	//# sourceMappingURL=groupBy.js.map

/***/ }),
/* 832 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	var MapPolyfill_1 = __webpack_require__(833);
	exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();
	//# sourceMappingURL=Map.js.map

/***/ }),
/* 833 */
/***/ (function(module, exports) {

	"use strict";
	var MapPolyfill = (function () {
	    function MapPolyfill() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    MapPolyfill.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    MapPolyfill.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        }
	        else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    MapPolyfill.prototype.delete = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    MapPolyfill.prototype.clear = function () {
	        this._keys.length = 0;
	        this._values.length = 0;
	        this.size = 0;
	    };
	    MapPolyfill.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return MapPolyfill;
	}());
	exports.MapPolyfill = MapPolyfill;
	//# sourceMappingURL=MapPolyfill.js.map

/***/ }),
/* 834 */
/***/ (function(module, exports) {

	"use strict";
	var FastMap = (function () {
	    function FastMap() {
	        this.values = {};
	    }
	    FastMap.prototype.delete = function (key) {
	        this.values[key] = null;
	        return true;
	    };
	    FastMap.prototype.set = function (key, value) {
	        this.values[key] = value;
	        return this;
	    };
	    FastMap.prototype.get = function (key) {
	        return this.values[key];
	    };
	    FastMap.prototype.forEach = function (cb, thisArg) {
	        var values = this.values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key) && values[key] !== null) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };
	    FastMap.prototype.clear = function () {
	        this.values = {};
	    };
	    return FastMap;
	}());
	exports.FastMap = FastMap;
	//# sourceMappingURL=FastMap.js.map

/***/ }),
/* 835 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var ignoreElements_1 = __webpack_require__(836);
	Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;
	//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 836 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var noop_1 = __webpack_require__(748);
	/**
	 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
	 *
	 * <img src="./img/ignoreElements.png" width="100%">
	 *
	 * @return {Observable} an empty Observable that only calls `complete`
	 * or `error`, based on which one is called by the source Observable.
	 * @method ignoreElements
	 * @owner Observable
	 */
	function ignoreElements() {
	    return this.lift(new IgnoreElementsOperator());
	}
	exports.ignoreElements = ignoreElements;
	;
	var IgnoreElementsOperator = (function () {
	    function IgnoreElementsOperator() {
	    }
	    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
	    };
	    return IgnoreElementsOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IgnoreElementsSubscriber = (function (_super) {
	    __extends(IgnoreElementsSubscriber, _super);
	    function IgnoreElementsSubscriber() {
	        _super.apply(this, arguments);
	    }
	    IgnoreElementsSubscriber.prototype._next = function (unused) {
	        noop_1.noop();
	    };
	    return IgnoreElementsSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 837 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var isEmpty_1 = __webpack_require__(838);
	Observable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;
	//# sourceMappingURL=isEmpty.js.map

/***/ }),
/* 838 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
	 *
	 * <img src="./img/isEmpty.png" width="100%">
	 *
	 * @return {Observable} an Observable that emits a Boolean.
	 * @method isEmpty
	 * @owner Observable
	 */
	function isEmpty() {
	    return this.lift(new IsEmptyOperator());
	}
	exports.isEmpty = isEmpty;
	var IsEmptyOperator = (function () {
	    function IsEmptyOperator() {
	    }
	    IsEmptyOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new IsEmptySubscriber(observer));
	    };
	    return IsEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IsEmptySubscriber = (function (_super) {
	    __extends(IsEmptySubscriber, _super);
	    function IsEmptySubscriber(destination) {
	        _super.call(this, destination);
	    }
	    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
	        var destination = this.destination;
	        destination.next(isEmpty);
	        destination.complete();
	    };
	    IsEmptySubscriber.prototype._next = function (value) {
	        this.notifyComplete(false);
	    };
	    IsEmptySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return IsEmptySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=isEmpty.js.map

/***/ }),
/* 839 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var audit_1 = __webpack_require__(840);
	Observable_1.Observable.prototype.audit = audit_1.audit;
	//# sourceMappingURL=audit.js.map

/***/ }),
/* 840 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Ignores source values for a duration determined by another Observable, then
	 * emits the most recent value from the source Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link auditTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/audit.png" width="100%">
	 *
	 * `audit` is similar to `throttle`, but emits the last value from the silenced
	 * time window, instead of the first value. `audit` emits the most recent value
	 * from the source Observable on the output Observable as soon as its internal
	 * timer becomes disabled, and ignores source values while the timer is enabled.
	 * Initially, the timer is disabled. As soon as the first source value arrives,
	 * the timer is enabled by calling the `durationSelector` function with the
	 * source value, which returns the "duration" Observable. When the duration
	 * Observable emits a value or completes, the timer is disabled, then the most
	 * recent source value is emitted on the output Observable, and this process
	 * repeats for the next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): Observable|Promise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method audit
	 * @owner Observable
	 */
	function audit(durationSelector) {
	    return this.lift(new AuditOperator(durationSelector));
	}
	exports.audit = audit;
	var AuditOperator = (function () {
	    function AuditOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    AuditOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
	    };
	    return AuditOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditSubscriber = (function (_super) {
	    __extends(AuditSubscriber, _super);
	    function AuditSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	    }
	    AuditSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
	            if (duration === errorObject_1.errorObject) {
	                this.destination.error(errorObject_1.errorObject.e);
	            }
	            else {
	                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	            }
	        }
	    };
	    AuditSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        this.clearThrottle();
	    };
	    AuditSubscriber.prototype.notifyComplete = function () {
	        this.clearThrottle();
	    };
	    return AuditSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=audit.js.map

/***/ }),
/* 841 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var auditTime_1 = __webpack_require__(842);
	Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;
	//# sourceMappingURL=auditTime.js.map

/***/ }),
/* 842 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(45);
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Ignores source values for `duration` milliseconds, then emits the most recent
	 * value from the source Observable, then repeats this process.
	 *
	 * <span class="informal">When it sees a source values, it ignores that plus
	 * the next ones for `duration` milliseconds, and then it emits the most recent
	 * value from the source.</span>
	 *
	 * <img src="./img/auditTime.png" width="100%">
	 *
	 * `auditTime` is similar to `throttleTime`, but emits the last value from the
	 * silenced time window, instead of the first value. `auditTime` emits the most
	 * recent value from the source Observable on the output Observable as soon as
	 * its internal timer becomes disabled, and ignores source values while the
	 * timer is enabled. Initially, the timer is disabled. As soon as the first
	 * source value arrives, the timer is enabled. After `duration` milliseconds (or
	 * the time unit determined internally by the optional `scheduler`) has passed,
	 * the timer is disabled, then the most recent source value is emitted on the
	 * output Observable, and this process repeats for the next source value.
	 * Optionally takes a {@link IScheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.auditTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} duration Time to wait before emitting the most recent source
	 * value, measured in milliseconds or the time unit determined internally
	 * by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the rate-limiting behavior.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method auditTime
	 * @owner Observable
	 */
	function auditTime(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new AuditTimeOperator(duration, scheduler));
	}
	exports.auditTime = auditTime;
	var AuditTimeOperator = (function () {
	    function AuditTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    AuditTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return AuditTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditTimeSubscriber = (function (_super) {
	    __extends(AuditTimeSubscriber, _super);
	    function AuditTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	    }
	    AuditTimeSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));
	        }
	    };
	    AuditTimeSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    return AuditTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.clearThrottle();
	}
	//# sourceMappingURL=auditTime.js.map

/***/ }),
/* 843 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var last_1 = __webpack_require__(107);
	Observable_1.Observable.prototype.last = last_1.last;
	//# sourceMappingURL=last.js.map

/***/ }),
/* 844 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var let_1 = __webpack_require__(845);
	Observable_1.Observable.prototype.let = let_1.letProto;
	Observable_1.Observable.prototype.letBind = let_1.letProto;
	//# sourceMappingURL=let.js.map

/***/ }),
/* 845 */
/***/ (function(module, exports) {

	"use strict";
	/**
	 * @param func
	 * @return {Observable<R>}
	 * @method let
	 * @owner Observable
	 */
	function letProto(func) {
	    return func(this);
	}
	exports.letProto = letProto;
	//# sourceMappingURL=let.js.map

/***/ }),
/* 846 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var every_1 = __webpack_require__(101);
	Observable_1.Observable.prototype.every = every_1.every;
	//# sourceMappingURL=every.js.map

/***/ }),
/* 847 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var mapTo_1 = __webpack_require__(848);
	Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;
	//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 848 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Emits the given constant value on the output Observable every time the source
	 * Observable emits a value.
	 *
	 * <span class="informal">Like {@link map}, but it maps every source value to
	 * the same output value every time.</span>
	 *
	 * <img src="./img/mapTo.png" width="100%">
	 *
	 * Takes a constant `value` as argument, and emits that whenever the source
	 * Observable emits a value. In other words, ignores the actual source value,
	 * and simply uses the emission moment to know when to emit the given `value`.
	 *
	 * @example <caption>Map every every click to the string 'Hi'</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var greetings = clicks.mapTo('Hi');
	 * greetings.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {any} value The value to map each source value to.
	 * @return {Observable} An Observable that emits the given `value` every time
	 * the source Observable emits something.
	 * @method mapTo
	 * @owner Observable
	 */
	function mapTo(value) {
	    return this.lift(new MapToOperator(value));
	}
	exports.mapTo = mapTo;
	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        this.value = value;
	    }
	    MapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapToSubscriber(subscriber, this.value));
	    };
	    return MapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapToSubscriber = (function (_super) {
	    __extends(MapToSubscriber, _super);
	    function MapToSubscriber(destination, value) {
	        _super.call(this, destination);
	        this.value = value;
	    }
	    MapToSubscriber.prototype._next = function (x) {
	        this.destination.next(this.value);
	    };
	    return MapToSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 849 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var materialize_1 = __webpack_require__(850);
	Observable_1.Observable.prototype.materialize = materialize_1.materialize;
	//# sourceMappingURL=materialize.js.map

/***/ }),
/* 850 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var Notification_1 = __webpack_require__(98);
	/**
	 * Represents all of the notifications from the source Observable as `next`
	 * emissions marked with their original types within {@link Notification}
	 * objects.
	 *
	 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
	 * {@link Notification} objects, emitted as `next` on the output Observable.
	 * </span>
	 *
	 * <img src="./img/materialize.png" width="100%">
	 *
	 * `materialize` returns an Observable that emits a `next` notification for each
	 * `next`, `error`, or `complete` emission of the source Observable. When the
	 * source Observable emits `complete`, the output Observable will emit `next` as
	 * a Notification of type "complete", and then it will emit `complete` as well.
	 * When the source Observable emits `error`, the output will emit `next` as a
	 * Notification of type "error", and then `complete`.
	 *
	 * This operator is useful for producing metadata of the source Observable, to
	 * be consumed as `next` emissions. Use it in conjunction with
	 * {@link dematerialize}.
	 *
	 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
	 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
	 * var upperCase = letters.map(x => x.toUpperCase());
	 * var materialized = upperCase.materialize();
	 * materialized.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
	 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
	 * // - Notification {kind: "E", value: undefined, error: TypeError:
	 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
	 * //   [as project] (http://1, hasValue: false}
	 *
	 * @see {@link Notification}
	 * @see {@link dematerialize}
	 *
	 * @return {Observable<Notification<T>>} An Observable that emits
	 * {@link Notification} objects that wrap the original emissions from the source
	 * Observable with metadata.
	 * @method materialize
	 * @owner Observable
	 */
	function materialize() {
	    return this.lift(new MaterializeOperator());
	}
	exports.materialize = materialize;
	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	    }
	    MaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MaterializeSubscriber(subscriber));
	    };
	    return MaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MaterializeSubscriber = (function (_super) {
	    __extends(MaterializeSubscriber, _super);
	    function MaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    MaterializeSubscriber.prototype._next = function (value) {
	        this.destination.next(Notification_1.Notification.createNext(value));
	    };
	    MaterializeSubscriber.prototype._error = function (err) {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createError(err));
	        destination.complete();
	    };
	    MaterializeSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createComplete());
	        destination.complete();
	    };
	    return MaterializeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=materialize.js.map

/***/ }),
/* 851 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var max_1 = __webpack_require__(852);
	Observable_1.Observable.prototype.max = max_1.max;
	//# sourceMappingURL=max.js.map

/***/ }),
/* 852 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var reduce_1 = __webpack_require__(104);
	/**
	 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
	 * and when source Observable completes it emits a single item: the item with the largest value.
	 *
	 * <img src="./img/max.png" width="100%">
	 *
	 * @example <caption>Get the maximal value of a series of numbers</caption>
	 * Rx.Observable.of(5, 4, 7, 2, 8)
	 *   .max()
	 *   .subscribe(x => console.log(x)); // -> 8
	 *
	 * @example <caption>Use a comparer function to get the maximal item</caption>
	 * interface Person {
	 *   age: number,
	 *   name: string
	 * }
	 * Observable.of<Person>({age: 7, name: 'Foo'},
	 *                       {age: 5, name: 'Bar'},
	 *                       {age: 9, name: 'Beer'})
	 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
	 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
	 * }
	 *
	 * @see {@link min}
	 *
	 * @param {Function} optional comparer function that it will use instead of its default to compare the value of two
	 * items.
	 * @return {Observable} an Observable that emits item with the largest value.
	 * @method max
	 * @owner Observable
	 */
	function max(comparer) {
	    var max = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
	        : function (x, y) { return x > y ? x : y; };
	    return this.lift(new reduce_1.ReduceOperator(max));
	}
	exports.max = max;
	//# sourceMappingURL=max.js.map

/***/ }),
/* 853 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var merge_1 = __webpack_require__(742);
	Observable_1.Observable.prototype.merge = merge_1.merge;
	//# sourceMappingURL=merge.js.map

/***/ }),
/* 854 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var mergeAll_1 = __webpack_require__(106);
	Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;
	//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 855 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var mergeMap_1 = __webpack_require__(100);
	Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
	Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
	//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 856 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var mergeMapTo_1 = __webpack_require__(796);
	Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
	Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;
	//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 857 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var mergeScan_1 = __webpack_require__(858);
	Observable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;
	//# sourceMappingURL=mergeScan.js.map

/***/ }),
/* 858 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var subscribeToResult_1 = __webpack_require__(39);
	var OuterSubscriber_1 = __webpack_require__(38);
	/**
	 * @param project
	 * @param seed
	 * @param concurrent
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method mergeScan
	 * @owner Observable
	 */
	function mergeScan(project, seed, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeScanOperator(project, seed, concurrent));
	}
	exports.mergeScan = mergeScan;
	var MergeScanOperator = (function () {
	    function MergeScanOperator(project, seed, concurrent) {
	        this.project = project;
	        this.seed = seed;
	        this.concurrent = concurrent;
	    }
	    MergeScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MergeScanSubscriber(subscriber, this.project, this.seed, this.concurrent));
	    };
	    return MergeScanOperator;
	}());
	exports.MergeScanOperator = MergeScanOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeScanSubscriber = (function (_super) {
	    __extends(MergeScanSubscriber, _super);
	    function MergeScanSubscriber(destination, project, acc, concurrent) {
	        _super.call(this, destination);
	        this.project = project;
	        this.acc = acc;
	        this.concurrent = concurrent;
	        this.hasValue = false;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeScanSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var index = this.index++;
	            var ish = tryCatch_1.tryCatch(this.project)(this.acc, value);
	            var destination = this.destination;
	            if (ish === errorObject_1.errorObject) {
	                destination.error(errorObject_1.errorObject.e);
	            }
	            else {
	                this.active++;
	                this._innerSub(ish, value, index);
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeScanSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var destination = this.destination;
	        this.acc = innerValue;
	        this.hasValue = true;
	        destination.next(innerValue);
	    };
	    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    return MergeScanSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeScanSubscriber = MergeScanSubscriber;
	//# sourceMappingURL=mergeScan.js.map

/***/ }),
/* 859 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var min_1 = __webpack_require__(860);
	Observable_1.Observable.prototype.min = min_1.min;
	//# sourceMappingURL=min.js.map

/***/ }),
/* 860 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var reduce_1 = __webpack_require__(104);
	/**
	 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
	 * and when source Observable completes it emits a single item: the item with the smallest value.
	 *
	 * <img src="./img/min.png" width="100%">
	 *
	 * @example <caption>Get the minimal value of a series of numbers</caption>
	 * Rx.Observable.of(5, 4, 7, 2, 8)
	 *   .min()
	 *   .subscribe(x => console.log(x)); // -> 2
	 *
	 * @example <caption>Use a comparer function to get the minimal item</caption>
	 * interface Person {
	 *   age: number,
	 *   name: string
	 * }
	 * Observable.of<Person>({age: 7, name: 'Foo'},
	 *                       {age: 5, name: 'Bar'},
	 *                       {age: 9, name: 'Beer'})
	 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
	 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
	 * }
	 *
	 * @see {@link max}
	 *
	 * @param {Function} optional comparer function that it will use instead of its default to compare the value of two items.
	 * @return {Observable<R>} an Observable that emits item with the smallest value.
	 * @method min
	 * @owner Observable
	 */
	function min(comparer) {
	    var min = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
	        : function (x, y) { return x < y ? x : y; };
	    return this.lift(new reduce_1.ReduceOperator(min));
	}
	exports.min = min;
	//# sourceMappingURL=min.js.map

/***/ }),
/* 861 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var multicast_1 = __webpack_require__(862);
	Observable_1.Observable.prototype.multicast = multicast_1.multicast;
	//# sourceMappingURL=multicast.js.map

/***/ }),
/* 862 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ConnectableObservable_1 = __webpack_require__(863);
	/* tslint:disable:max-line-length */
	/**
	 * Returns an Observable that emits the results of invoking a specified selector on items
	 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
	 *
	 * <img src="./img/multicast.png" width="100%">
	 *
	 * @param {Function|Subject} Factory function to create an intermediate subject through
	 * which the source sequence's elements will be multicast to the selector function
	 * or Subject to push source elements into.
	 * @param {Function} Optional selector function that can use the multicasted source stream
	 * as many times as needed, without causing multiple subscriptions to the source stream.
	 * Subscribers to the given source will receive all notifications of the source from the
	 * time of the subscription forward.
	 * @return {Observable} an Observable that emits the results of invoking the selector
	 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
	 * the underlying stream.
	 * @method multicast
	 * @owner Observable
	 */
	function multicast(subjectOrSubjectFactory, selector) {
	    var subjectFactory;
	    if (typeof subjectOrSubjectFactory === 'function') {
	        subjectFactory = subjectOrSubjectFactory;
	    }
	    else {
	        subjectFactory = function subjectFactory() {
	            return subjectOrSubjectFactory;
	        };
	    }
	    if (typeof selector === 'function') {
	        return this.lift(new MulticastOperator(subjectFactory, selector));
	    }
	    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
	    connectable.source = this;
	    connectable.subjectFactory = subjectFactory;
	    return connectable;
	}
	exports.multicast = multicast;
	var MulticastOperator = (function () {
	    function MulticastOperator(subjectFactory, selector) {
	        this.subjectFactory = subjectFactory;
	        this.selector = selector;
	    }
	    MulticastOperator.prototype.call = function (subscriber, source) {
	        var selector = this.selector;
	        var subject = this.subjectFactory();
	        var subscription = selector(subject).subscribe(subscriber);
	        subscription.add(source.subscribe(subject));
	        return subscription;
	    };
	    return MulticastOperator;
	}());
	exports.MulticastOperator = MulticastOperator;
	//# sourceMappingURL=multicast.js.map

/***/ }),
/* 863 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Observable_1 = __webpack_require__(7);
	var Subscriber_1 = __webpack_require__(9);
	var Subscription_1 = __webpack_require__(11);
	/**
	 * @class ConnectableObservable<T>
	 */
	var ConnectableObservable = (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        _super.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	        this._refCount = 0;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var connection = this._connection;
	        if (!connection) {
	            connection = this._connection = new Subscription_1.Subscription();
	            connection.add(this.source
	                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1.Subscription.EMPTY;
	            }
	            else {
	                this._connection = connection;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return this.lift(new RefCountOperator(this));
	    };
	    return ConnectableObservable;
	}(Observable_1.Observable));
	exports.ConnectableObservable = ConnectableObservable;
	exports.connectableObservableDescriptor = {
	    operator: { value: null },
	    _refCount: { value: 0, writable: true },
	    _subscribe: { value: ConnectableObservable.prototype._subscribe },
	    getSubject: { value: ConnectableObservable.prototype.getSubject },
	    connect: { value: ConnectableObservable.prototype.connect },
	    refCount: { value: ConnectableObservable.prototype.refCount }
	};
	var ConnectableSubscriber = (function (_super) {
	    __extends(ConnectableSubscriber, _super);
	    function ConnectableSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    ConnectableSubscriber.prototype._error = function (err) {
	        this._unsubscribe();
	        _super.prototype._error.call(this, err);
	    };
	    ConnectableSubscriber.prototype._complete = function () {
	        this._unsubscribe();
	        _super.prototype._complete.call(this);
	    };
	    ConnectableSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (connectable) {
	            this.connectable = null;
	            var connection = connectable._connection;
	            connectable._refCount = 0;
	            connectable._subject = null;
	            connectable._connection = null;
	            if (connection) {
	                connection.unsubscribe();
	            }
	        }
	    };
	    return ConnectableSubscriber;
	}(Subject_1.SubjectSubscriber));
	var RefCountOperator = (function () {
	    function RefCountOperator(connectable) {
	        this.connectable = connectable;
	    }
	    RefCountOperator.prototype.call = function (subscriber, source) {
	        var connectable = this.connectable;
	        connectable._refCount++;
	        var refCounter = new RefCountSubscriber(subscriber, connectable);
	        var subscription = source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            refCounter.connection = connectable.connect();
	        }
	        return subscription;
	    };
	    return RefCountOperator;
	}());
	var RefCountSubscriber = (function (_super) {
	    __extends(RefCountSubscriber, _super);
	    function RefCountSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    RefCountSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (!connectable) {
	            this.connection = null;
	            return;
	        }
	        this.connectable = null;
	        var refCount = connectable._refCount;
	        if (refCount <= 0) {
	            this.connection = null;
	            return;
	        }
	        connectable._refCount = refCount - 1;
	        if (refCount > 1) {
	            this.connection = null;
	            return;
	        }
	        ///
	        // Compare the local RefCountSubscriber's connection Subscription to the
	        // connection Subscription on the shared ConnectableObservable. In cases
	        // where the ConnectableObservable source synchronously emits values, and
	        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
	        // execution continues to here before the RefCountOperator has a chance to
	        // supply the RefCountSubscriber with the shared connection Subscription.
	        // For example:
	        // ```
	        // Observable.range(0, 10)
	        //   .publish()
	        //   .refCount()
	        //   .take(5)
	        //   .subscribe();
	        // ```
	        // In order to account for this case, RefCountSubscriber should only dispose
	        // the ConnectableObservable's shared connection Subscription if the
	        // connection Subscription exists, *and* either:
	        //   a. RefCountSubscriber doesn't have a reference to the shared connection
	        //      Subscription yet, or,
	        //   b. RefCountSubscriber's connection Subscription reference is identical
	        //      to the shared connection Subscription
	        ///
	        var connection = this.connection;
	        var sharedConnection = connectable._connection;
	        this.connection = null;
	        if (sharedConnection && (!connection || sharedConnection === connection)) {
	            sharedConnection.unsubscribe();
	        }
	    };
	    return RefCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),
/* 864 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var observeOn_1 = __webpack_require__(97);
	Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;
	//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 865 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var onErrorResumeNext_1 = __webpack_require__(750);
	Observable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
	//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),
/* 866 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var pairwise_1 = __webpack_require__(867);
	Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;
	//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 867 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Groups pairs of consecutive emissions together and emits them as an array of
	 * two values.
	 *
	 * <span class="informal">Puts the current value and previous value together as
	 * an array, and emits that.</span>
	 *
	 * <img src="./img/pairwise.png" width="100%">
	 *
	 * The Nth emission from the source Observable will cause the output Observable
	 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
	 * pair. For this reason, `pairwise` emits on the second and subsequent
	 * emissions from the source Observable, but not on the first emission, because
	 * there is no previous value in that case.
	 *
	 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var pairs = clicks.pairwise();
	 * var distance = pairs.map(pair => {
	 *   var x0 = pair[0].clientX;
	 *   var y0 = pair[0].clientY;
	 *   var x1 = pair[1].clientX;
	 *   var y1 = pair[1].clientY;
	 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
	 * });
	 * distance.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 *
	 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
	 * consecutive values from the source Observable.
	 * @method pairwise
	 * @owner Observable
	 */
	function pairwise() {
	    return this.lift(new PairwiseOperator());
	}
	exports.pairwise = pairwise;
	var PairwiseOperator = (function () {
	    function PairwiseOperator() {
	    }
	    PairwiseOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new PairwiseSubscriber(subscriber));
	    };
	    return PairwiseOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var PairwiseSubscriber = (function (_super) {
	    __extends(PairwiseSubscriber, _super);
	    function PairwiseSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasPrev = false;
	    }
	    PairwiseSubscriber.prototype._next = function (value) {
	        if (this.hasPrev) {
	            this.destination.next([this.prev, value]);
	        }
	        else {
	            this.hasPrev = true;
	        }
	        this.prev = value;
	    };
	    return PairwiseSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 868 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var partition_1 = __webpack_require__(869);
	Observable_1.Observable.prototype.partition = partition_1.partition;
	//# sourceMappingURL=partition.js.map

/***/ }),
/* 869 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var not_1 = __webpack_require__(870);
	var filter_1 = __webpack_require__(55);
	/**
	 * Splits the source Observable into two, one with values that satisfy a
	 * predicate, and another with values that don't satisfy the predicate.
	 *
	 * <span class="informal">It's like {@link filter}, but returns two Observables:
	 * one like the output of {@link filter}, and the other with values that did not
	 * pass the condition.</span>
	 *
	 * <img src="./img/partition.png" width="100%">
	 *
	 * `partition` outputs an array with two Observables that partition the values
	 * from the source Observable through the given `predicate` function. The first
	 * Observable in that array emits source values for which the predicate argument
	 * returns true. The second Observable emits source values for which the
	 * predicate returns false. The first behaves like {@link filter} and the second
	 * behaves like {@link filter} with the predicate negated.
	 *
	 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
	 * var clicksOnDivs = parts[0];
	 * var clicksElsewhere = parts[1];
	 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
	 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
	 *
	 * @see {@link filter}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted on the first Observable in the returned array, if
	 * `false` the value is emitted on the second Observable in the array. The
	 * `index` parameter is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
	 * with values that passed the predicate, and another with values that did not
	 * pass the predicate.
	 * @method partition
	 * @owner Observable
	 */
	function partition(predicate, thisArg) {
	    return [
	        filter_1.filter.call(this, predicate, thisArg),
	        filter_1.filter.call(this, not_1.not(predicate, thisArg))
	    ];
	}
	exports.partition = partition;
	//# sourceMappingURL=partition.js.map

/***/ }),
/* 870 */
/***/ (function(module, exports) {

	"use strict";
	function not(pred, thisArg) {
	    function notPred() {
	        return !(notPred.pred.apply(notPred.thisArg, arguments));
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}
	exports.not = not;
	//# sourceMappingURL=not.js.map

/***/ }),
/* 871 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var pluck_1 = __webpack_require__(872);
	Observable_1.Observable.prototype.pluck = pluck_1.pluck;
	//# sourceMappingURL=pluck.js.map

/***/ }),
/* 872 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var map_1 = __webpack_require__(57);
	/**
	 * Maps each source value (an object) to its specified nested property.
	 *
	 * <span class="informal">Like {@link map}, but meant only for picking one of
	 * the nested properties of every emitted object.</span>
	 *
	 * <img src="./img/pluck.png" width="100%">
	 *
	 * Given a list of strings describing a path to an object property, retrieves
	 * the value of a specified nested property from all values in the source
	 * Observable. If a property can't be resolved, it will return `undefined` for
	 * that value.
	 *
	 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var tagNames = clicks.pluck('target', 'tagName');
	 * tagNames.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {...string} properties The nested properties to pluck from each source
	 * value (an object).
	 * @return {Observable} Returns a new Observable of property values from the
	 * source values.
	 * @method pluck
	 * @owner Observable
	 */
	function pluck() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i - 0] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return map_1.map.call(this, plucker(properties, length));
	}
	exports.pluck = pluck;
	function plucker(props, length) {
	    var mapper = function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp[props[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    };
	    return mapper;
	}
	//# sourceMappingURL=pluck.js.map

/***/ }),
/* 873 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var publish_1 = __webpack_require__(874);
	Observable_1.Observable.prototype.publish = publish_1.publish;
	//# sourceMappingURL=publish.js.map

/***/ }),
/* 874 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Subject_1 = __webpack_require__(6);
	var multicast_1 = __webpack_require__(862);
	/* tslint:disable:max-line-length */
	/**
	 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
	 * before it begins emitting items to those Observers that have subscribed to it.
	 *
	 * <img src="./img/publish.png" width="100%">
	 *
	 * @param {Function} Optional selector function which can use the multicasted source sequence as many times as needed,
	 * without causing multiple subscriptions to the source sequence.
	 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
	 * @return a ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
	 * @method publish
	 * @owner Observable
	 */
	function publish(selector) {
	    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :
	        multicast_1.multicast.call(this, new Subject_1.Subject());
	}
	exports.publish = publish;
	//# sourceMappingURL=publish.js.map

/***/ }),
/* 875 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var publishBehavior_1 = __webpack_require__(876);
	Observable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;
	//# sourceMappingURL=publishBehavior.js.map

/***/ }),
/* 876 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var BehaviorSubject_1 = __webpack_require__(92);
	var multicast_1 = __webpack_require__(862);
	/**
	 * @param value
	 * @return {ConnectableObservable<T>}
	 * @method publishBehavior
	 * @owner Observable
	 */
	function publishBehavior(value) {
	    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));
	}
	exports.publishBehavior = publishBehavior;
	//# sourceMappingURL=publishBehavior.js.map

/***/ }),
/* 877 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var publishReplay_1 = __webpack_require__(878);
	Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;
	//# sourceMappingURL=publishReplay.js.map

/***/ }),
/* 878 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ReplaySubject_1 = __webpack_require__(773);
	var multicast_1 = __webpack_require__(862);
	/**
	 * @param bufferSize
	 * @param windowTime
	 * @param scheduler
	 * @return {ConnectableObservable<T>}
	 * @method publishReplay
	 * @owner Observable
	 */
	function publishReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));
	}
	exports.publishReplay = publishReplay;
	//# sourceMappingURL=publishReplay.js.map

/***/ }),
/* 879 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var publishLast_1 = __webpack_require__(880);
	Observable_1.Observable.prototype.publishLast = publishLast_1.publishLast;
	//# sourceMappingURL=publishLast.js.map

/***/ }),
/* 880 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncSubject_1 = __webpack_require__(705);
	var multicast_1 = __webpack_require__(862);
	/**
	 * @return {ConnectableObservable<T>}
	 * @method publishLast
	 * @owner Observable
	 */
	function publishLast() {
	    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());
	}
	exports.publishLast = publishLast;
	//# sourceMappingURL=publishLast.js.map

/***/ }),
/* 881 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var race_1 = __webpack_require__(744);
	Observable_1.Observable.prototype.race = race_1.race;
	//# sourceMappingURL=race.js.map

/***/ }),
/* 882 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var reduce_1 = __webpack_require__(104);
	Observable_1.Observable.prototype.reduce = reduce_1.reduce;
	//# sourceMappingURL=reduce.js.map

/***/ }),
/* 883 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var repeat_1 = __webpack_require__(884);
	Observable_1.Observable.prototype.repeat = repeat_1.repeat;
	//# sourceMappingURL=repeat.js.map

/***/ }),
/* 884 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var EmptyObservable_1 = __webpack_require__(31);
	/**
	 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times,
	 * on a particular IScheduler.
	 *
	 * <img src="./img/repeat.png" width="100%">
	 *
	 * @param {Scheduler} [scheduler] the IScheduler to emit the items on.
	 * @param {number} [count] the number of times the source Observable items are repeated, a count of 0 will yield
	 * an empty Observable.
	 * @return {Observable} an Observable that repeats the stream of items emitted by the source Observable at most
	 * count times.
	 * @method repeat
	 * @owner Observable
	 */
	function repeat(count) {
	    if (count === void 0) { count = -1; }
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else if (count < 0) {
	        return this.lift(new RepeatOperator(-1, this));
	    }
	    else {
	        return this.lift(new RepeatOperator(count - 1, this));
	    }
	}
	exports.repeat = repeat;
	var RepeatOperator = (function () {
	    function RepeatOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RepeatOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
	    };
	    return RepeatOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatSubscriber = (function (_super) {
	    __extends(RepeatSubscriber, _super);
	    function RepeatSubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RepeatSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.complete.call(this);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            this.unsubscribe();
	            this.isStopped = false;
	            this.closed = false;
	            source.subscribe(this);
	        }
	    };
	    return RepeatSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=repeat.js.map

/***/ }),
/* 885 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var repeatWhen_1 = __webpack_require__(886);
	Observable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;
	//# sourceMappingURL=repeatWhen.js.map

/***/ }),
/* 886 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Returns an Observable that emits the same values as the source observable with the exception of a `complete`.
	 * A `complete` will cause the emission of the Throwable that cause the complete to the Observable returned from
	 * notificationHandler. If that Observable calls onComplete or `complete` then retry will call `complete` or `error`
	 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
	 * IScheduler.
	 *
	 * <img src="./img/repeatWhen.png" width="100%">
	 *
	 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
	 * aborting the retry.
	 * @param {scheduler} the IScheduler on which to subscribe to the source Observable.
	 * @return {Observable} the source Observable modified with retry logic.
	 * @method repeatWhen
	 * @owner Observable
	 */
	function repeatWhen(notifier) {
	    return this.lift(new RepeatWhenOperator(notifier, this));
	}
	exports.repeatWhen = repeatWhen;
	var RepeatWhenOperator = (function () {
	    function RepeatWhenOperator(notifier, source) {
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RepeatWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, this.source));
	    };
	    return RepeatWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatWhenSubscriber = (function (_super) {
	    __extends(RepeatWhenSubscriber, _super);
	    function RepeatWhenSubscriber(destination, notifier, source) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RepeatWhenSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var notifications = this.notifications;
	            var retries = this.retries;
	            var retriesSubscription = this.retriesSubscription;
	            if (!retries) {
	                notifications = new Subject_1.Subject();
	                retries = tryCatch_1.tryCatch(this.notifier)(notifications);
	                if (retries === errorObject_1.errorObject) {
	                    return _super.prototype.complete.call(this);
	                }
	                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
	            }
	            else {
	                this.notifications = null;
	                this.retriesSubscription = null;
	            }
	            this.unsubscribe();
	            this.closed = false;
	            this.notifications = notifications;
	            this.retries = retries;
	            this.retriesSubscription = retriesSubscription;
	            notifications.next();
	        }
	    };
	    RepeatWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
	        if (notifications) {
	            notifications.unsubscribe();
	            this.notifications = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
	        this.notifications = null;
	        this.retries = null;
	        this.retriesSubscription = null;
	        this.unsubscribe();
	        this.isStopped = false;
	        this.closed = false;
	        this.notifications = notifications;
	        this.retries = retries;
	        this.retriesSubscription = retriesSubscription;
	        this.source.subscribe(this);
	    };
	    return RepeatWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=repeatWhen.js.map

/***/ }),
/* 887 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var retry_1 = __webpack_require__(888);
	Observable_1.Observable.prototype.retry = retry_1.retry;
	//# sourceMappingURL=retry.js.map

/***/ }),
/* 888 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls `error` and the
	 * predicate returns true for that specific exception and retry count.
	 * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of
	 * count resubscriptions (given as a number parameter) rather than propagating the `error` call.
	 *
	 * <img src="./img/retry.png" width="100%">
	 *
	 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
	 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
	 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
	 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
	 * @param {number} number of retry attempts before failing.
	 * @return {Observable} the source Observable modified with the retry logic.
	 * @method retry
	 * @owner Observable
	 */
	function retry(count) {
	    if (count === void 0) { count = -1; }
	    return this.lift(new RetryOperator(count, this));
	}
	exports.retry = retry;
	var RetryOperator = (function () {
	    function RetryOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RetryOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
	    };
	    return RetryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetrySubscriber = (function (_super) {
	    __extends(RetrySubscriber, _super);
	    function RetrySubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RetrySubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.error.call(this, err);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            this.unsubscribe();
	            this.isStopped = false;
	            this.closed = false;
	            source.subscribe(this);
	        }
	    };
	    return RetrySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=retry.js.map

/***/ }),
/* 889 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var retryWhen_1 = __webpack_require__(890);
	Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;
	//# sourceMappingURL=retryWhen.js.map

/***/ }),
/* 890 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Returns an Observable that emits the same values as the source observable with the exception of an `error`.
	 * An `error` will cause the emission of the Throwable that cause the error to the Observable returned from
	 * notificationHandler. If that Observable calls onComplete or `error` then retry will call `complete` or `error`
	 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
	 * IScheduler.
	 *
	 * <img src="./img/retryWhen.png" width="100%">
	 *
	 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
	 * aborting the retry.
	 * @param {scheduler} the IScheduler on which to subscribe to the source Observable.
	 * @return {Observable} the source Observable modified with retry logic.
	 * @method retryWhen
	 * @owner Observable
	 */
	function retryWhen(notifier) {
	    return this.lift(new RetryWhenOperator(notifier, this));
	}
	exports.retryWhen = retryWhen;
	var RetryWhenOperator = (function () {
	    function RetryWhenOperator(notifier, source) {
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
	    };
	    return RetryWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetryWhenSubscriber = (function (_super) {
	    __extends(RetryWhenSubscriber, _super);
	    function RetryWhenSubscriber(destination, notifier, source) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var errors = this.errors;
	            var retries = this.retries;
	            var retriesSubscription = this.retriesSubscription;
	            if (!retries) {
	                errors = new Subject_1.Subject();
	                retries = tryCatch_1.tryCatch(this.notifier)(errors);
	                if (retries === errorObject_1.errorObject) {
	                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
	                }
	                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
	            }
	            else {
	                this.errors = null;
	                this.retriesSubscription = null;
	            }
	            this.unsubscribe();
	            this.closed = false;
	            this.errors = errors;
	            this.retries = retries;
	            this.retriesSubscription = retriesSubscription;
	            errors.next(err);
	        }
	    };
	    RetryWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
	        if (errors) {
	            errors.unsubscribe();
	            this.errors = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
	        this.errors = null;
	        this.retries = null;
	        this.retriesSubscription = null;
	        this.unsubscribe();
	        this.isStopped = false;
	        this.closed = false;
	        this.errors = errors;
	        this.retries = retries;
	        this.retriesSubscription = retriesSubscription;
	        this.source.subscribe(this);
	    };
	    return RetryWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=retryWhen.js.map

/***/ }),
/* 891 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var sample_1 = __webpack_require__(892);
	Observable_1.Observable.prototype.sample = sample_1.sample;
	//# sourceMappingURL=sample.js.map

/***/ }),
/* 892 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Emits the most recently emitted value from the source Observable whenever
	 * another Observable, the `notifier`, emits.
	 *
	 * <span class="informal">It's like {@link sampleTime}, but samples whenever
	 * the `notifier` Observable emits something.</span>
	 *
	 * <img src="./img/sample.png" width="100%">
	 *
	 * Whenever the `notifier` Observable emits a value or completes, `sample`
	 * looks at the source Observable and emits whichever value it has most recently
	 * emitted since the previous sampling, unless the source has not emitted
	 * anything since the previous sampling. The `notifier` is subscribed to as soon
	 * as the output Observable is subscribed.
	 *
	 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = seconds.sample(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {Observable<any>} notifier The Observable to use for sampling the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable whenever the notifier Observable
	 * emits value or completes.
	 * @method sample
	 * @owner Observable
	 */
	function sample(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}
	exports.sample = sample;
	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SampleOperator.prototype.call = function (subscriber, source) {
	        var sampleSubscriber = new SampleSubscriber(subscriber);
	        var subscription = source.subscribe(sampleSubscriber);
	        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
	        return subscription;
	    };
	    return SampleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleSubscriber = (function (_super) {
	    __extends(SampleSubscriber, _super);
	    function SampleSubscriber() {
	        _super.apply(this, arguments);
	        this.hasValue = false;
	    }
	    SampleSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	    };
	    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.value);
	        }
	    };
	    return SampleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=sample.js.map

/***/ }),
/* 893 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var sampleTime_1 = __webpack_require__(894);
	Observable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;
	//# sourceMappingURL=sampleTime.js.map

/***/ }),
/* 894 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var async_1 = __webpack_require__(45);
	/**
	 * Emits the most recently emitted value from the source Observable within
	 * periodic time intervals.
	 *
	 * <span class="informal">Samples the source Observable at periodic time
	 * intervals, emitting what it samples.</span>
	 *
	 * <img src="./img/sampleTime.png" width="100%">
	 *
	 * `sampleTime` periodically looks at the source Observable and emits whichever
	 * value it has most recently emitted since the previous sampling, unless the
	 * source has not emitted anything since the previous sampling. The sampling
	 * happens periodically in time every `period` milliseconds (or the time unit
	 * defined by the optional `scheduler` argument). The sampling starts as soon as
	 * the output Observable is subscribed.
	 *
	 * @example <caption>Every second, emit the most recent click at most once</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.sampleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {number} period The sampling period expressed in milliseconds or the
	 * time unit determined internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable at the specified time interval.
	 * @method sampleTime
	 * @owner Observable
	 */
	function sampleTime(period, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new SampleTimeOperator(period, scheduler));
	}
	exports.sampleTime = sampleTime;
	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(period, scheduler) {
	        this.period = period;
	        this.scheduler = scheduler;
	    }
	    SampleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
	    };
	    return SampleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleTimeSubscriber = (function (_super) {
	    __extends(SampleTimeSubscriber, _super);
	    function SampleTimeSubscriber(destination, period, scheduler) {
	        _super.call(this, destination);
	        this.period = period;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
	    }
	    SampleTimeSubscriber.prototype._next = function (value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	    SampleTimeSubscriber.prototype.notifyNext = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.lastValue);
	        }
	    };
	    return SampleTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNotification(state) {
	    var subscriber = state.subscriber, period = state.period;
	    subscriber.notifyNext();
	    this.schedule(state, period);
	}
	//# sourceMappingURL=sampleTime.js.map

/***/ }),
/* 895 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var scan_1 = __webpack_require__(896);
	Observable_1.Observable.prototype.scan = scan_1.scan;
	//# sourceMappingURL=scan.js.map

/***/ }),
/* 896 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/* tslint:disable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns each
	 * intermediate result, with an optional seed value.
	 *
	 * <span class="informal">It's like {@link reduce}, but emits the current
	 * accumulation whenever the source emits a value.</span>
	 *
	 * <img src="./img/scan.png" width="100%">
	 *
	 * Combines together all values emitted on the source, using an accumulator
	 * function that knows how to join a new source value into the accumulation from
	 * the past. Is similar to {@link reduce}, but emits the intermediate
	 * accumulations.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var ones = clicks.mapTo(1);
	 * var seed = 0;
	 * var count = ones.scan((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link reduce}
	 *
	 * @param {function(acc: R, value: T, index: number): R} accumulator
	 * The accumulator function called on each source value.
	 * @param {T|R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @method scan
	 * @owner Observable
	 */
	function scan(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
	}
	exports.scan = scan;
	var ScanOperator = (function () {
	    function ScanOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ScanOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ScanSubscriber = (function (_super) {
	    __extends(ScanSubscriber, _super);
	    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this._seed = _seed;
	        this.hasSeed = hasSeed;
	        this.index = 0;
	    }
	    Object.defineProperty(ScanSubscriber.prototype, "seed", {
	        get: function () {
	            return this._seed;
	        },
	        set: function (value) {
	            this.hasSeed = true;
	            this._seed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ScanSubscriber.prototype._next = function (value) {
	        if (!this.hasSeed) {
	            this.seed = value;
	            this.destination.next(value);
	        }
	        else {
	            return this._tryNext(value);
	        }
	    };
	    ScanSubscriber.prototype._tryNext = function (value) {
	        var index = this.index++;
	        var result;
	        try {
	            result = this.accumulator(this.seed, value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	        this.seed = result;
	        this.destination.next(result);
	    };
	    return ScanSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=scan.js.map

/***/ }),
/* 897 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var sequenceEqual_1 = __webpack_require__(898);
	Observable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;
	//# sourceMappingURL=sequenceEqual.js.map

/***/ }),
/* 898 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	/**
	 * Compares all values of two observables in sequence using an optional comparor function
	 * and returns an observable of a single boolean value representing whether or not the two sequences
	 * are equal.
	 *
	 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
	 *
	 * <img src="./img/sequenceEqual.png" width="100%">
	 *
	 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
	 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
	 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
	 * observables completes, the operator will wait for the other observable to complete; If the other
	 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
	 * completes or emits after the other complets, the returned observable will never complete.
	 *
	 * @example <caption>figure out if the Konami code matches</caption>
	 * var code = Rx.Observable.from([
	 *  "ArrowUp",
	 *  "ArrowUp",
	 *  "ArrowDown",
	 *  "ArrowDown",
	 *  "ArrowLeft",
	 *  "ArrowRight",
	 *  "ArrowLeft",
	 *  "ArrowRight",
	 *  "KeyB",
	 *  "KeyA",
	 *  "Enter" // no start key, clearly.
	 * ]);
	 *
	 * var keys = Rx.Observable.fromEvent(document, 'keyup')
	 *  .map(e => e.code);
	 * var matches = keys.bufferCount(11, 1)
	 *  .mergeMap(
	 *    last11 =>
	 *      Rx.Observable.from(last11)
	 *        .sequenceEqual(code)
	 *   );
	 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
	 *
	 * @see {@link combineLatest}
	 * @see {@link zip}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} compareTo the observable sequence to compare the source sequence to.
	 * @param {function} [comparor] An optional function to compare each value pair
	 * @return {Observable} An Observable of a single boolean value representing whether or not
	 * the values emitted by both observables were equal in sequence
	 * @method sequenceEqual
	 * @owner Observable
	 */
	function sequenceEqual(compareTo, comparor) {
	    return this.lift(new SequenceEqualOperator(compareTo, comparor));
	}
	exports.sequenceEqual = sequenceEqual;
	var SequenceEqualOperator = (function () {
	    function SequenceEqualOperator(compareTo, comparor) {
	        this.compareTo = compareTo;
	        this.comparor = comparor;
	    }
	    SequenceEqualOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
	    };
	    return SequenceEqualOperator;
	}());
	exports.SequenceEqualOperator = SequenceEqualOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SequenceEqualSubscriber = (function (_super) {
	    __extends(SequenceEqualSubscriber, _super);
	    function SequenceEqualSubscriber(destination, compareTo, comparor) {
	        _super.call(this, destination);
	        this.compareTo = compareTo;
	        this.comparor = comparor;
	        this._a = [];
	        this._b = [];
	        this._oneComplete = false;
	        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
	    }
	    SequenceEqualSubscriber.prototype._next = function (value) {
	        if (this._oneComplete && this._b.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._a.push(value);
	            this.checkValues();
	        }
	    };
	    SequenceEqualSubscriber.prototype._complete = function () {
	        if (this._oneComplete) {
	            this.emit(this._a.length === 0 && this._b.length === 0);
	        }
	        else {
	            this._oneComplete = true;
	        }
	    };
	    SequenceEqualSubscriber.prototype.checkValues = function () {
	        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
	        while (_a.length > 0 && _b.length > 0) {
	            var a = _a.shift();
	            var b = _b.shift();
	            var areEqual = false;
	            if (comparor) {
	                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
	                if (areEqual === errorObject_1.errorObject) {
	                    this.destination.error(errorObject_1.errorObject.e);
	                }
	            }
	            else {
	                areEqual = a === b;
	            }
	            if (!areEqual) {
	                this.emit(false);
	            }
	        }
	    };
	    SequenceEqualSubscriber.prototype.emit = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    SequenceEqualSubscriber.prototype.nextB = function (value) {
	        if (this._oneComplete && this._a.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._b.push(value);
	            this.checkValues();
	        }
	    };
	    return SequenceEqualSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
	var SequenceEqualCompareToSubscriber = (function (_super) {
	    __extends(SequenceEqualCompareToSubscriber, _super);
	    function SequenceEqualCompareToSubscriber(destination, parent) {
	        _super.call(this, destination);
	        this.parent = parent;
	    }
	    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
	        this.parent.nextB(value);
	    };
	    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
	        this.parent.error(err);
	    };
	    SequenceEqualCompareToSubscriber.prototype._complete = function () {
	        this.parent._complete();
	    };
	    return SequenceEqualCompareToSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=sequenceEqual.js.map

/***/ }),
/* 899 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var share_1 = __webpack_require__(900);
	Observable_1.Observable.prototype.share = share_1.share;
	//# sourceMappingURL=share.js.map

/***/ }),
/* 900 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var multicast_1 = __webpack_require__(862);
	var Subject_1 = __webpack_require__(6);
	function shareSubjectFactory() {
	    return new Subject_1.Subject();
	}
	/**
	 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
	 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
	 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
	 * This is an alias for .publish().refCount().
	 *
	 * <img src="./img/share.png" width="100%">
	 *
	 * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers
	 * @method share
	 * @owner Observable
	 */
	function share() {
	    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
	}
	exports.share = share;
	;
	//# sourceMappingURL=share.js.map

/***/ }),
/* 901 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var single_1 = __webpack_require__(902);
	Observable_1.Observable.prototype.single = single_1.single;
	//# sourceMappingURL=single.js.map

/***/ }),
/* 902 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var EmptyError_1 = __webpack_require__(103);
	/**
	 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
	 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
	 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
	 *
	 * <img src="./img/single.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {Function} a predicate function to evaluate items emitted by the source Observable.
	 * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches
	 * the predicate.
	 .
	 * @method single
	 * @owner Observable
	 */
	function single(predicate) {
	    return this.lift(new SingleOperator(predicate, this));
	}
	exports.single = single;
	var SingleOperator = (function () {
	    function SingleOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    SingleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
	    };
	    return SingleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SingleSubscriber = (function (_super) {
	    __extends(SingleSubscriber, _super);
	    function SingleSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.seenValue = false;
	        this.index = 0;
	    }
	    SingleSubscriber.prototype.applySingleValue = function (value) {
	        if (this.seenValue) {
	            this.destination.error('Sequence contains more than one element');
	        }
	        else {
	            this.seenValue = true;
	            this.singleValue = value;
	        }
	    };
	    SingleSubscriber.prototype._next = function (value) {
	        var predicate = this.predicate;
	        this.index++;
	        if (predicate) {
	            this.tryNext(value);
	        }
	        else {
	            this.applySingleValue(value);
	        }
	    };
	    SingleSubscriber.prototype.tryNext = function (value) {
	        try {
	            var result = this.predicate(value, this.index, this.source);
	            if (result) {
	                this.applySingleValue(value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    SingleSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index > 0) {
	            destination.next(this.seenValue ? this.singleValue : undefined);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return SingleSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=single.js.map

/***/ }),
/* 903 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var skip_1 = __webpack_require__(904);
	Observable_1.Observable.prototype.skip = skip_1.skip;
	//# sourceMappingURL=skip.js.map

/***/ }),
/* 904 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Returns an Observable that skips `n` items emitted by an Observable.
	 *
	 * <img src="./img/skip.png" width="100%">
	 *
	 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
	 * @return {Observable} an Observable that skips values emitted by the source Observable.
	 *
	 * @method skip
	 * @owner Observable
	 */
	function skip(total) {
	    return this.lift(new SkipOperator(total));
	}
	exports.skip = skip;
	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        this.total = total;
	    }
	    SkipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipSubscriber(subscriber, this.total));
	    };
	    return SkipOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipSubscriber = (function (_super) {
	    __extends(SkipSubscriber, _super);
	    function SkipSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    SkipSubscriber.prototype._next = function (x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	    return SkipSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=skip.js.map

/***/ }),
/* 905 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var skipUntil_1 = __webpack_require__(906);
	Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;
	//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 906 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
	 *
	 * <img src="./img/skipUntil.png" width="100%">
	 *
	 * @param {Observable} the second Observable that has to emit an item before the source Observable's elements begin to
	 * be mirrored by the resulting Observable.
	 * @return {Observable<T>} an Observable that skips items from the source Observable until the second Observable emits
	 * an item, then emits the remaining items.
	 * @method skipUntil
	 * @owner Observable
	 */
	function skipUntil(notifier) {
	    return this.lift(new SkipUntilOperator(notifier));
	}
	exports.skipUntil = skipUntil;
	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SkipUntilOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
	    };
	    return SkipUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipUntilSubscriber = (function (_super) {
	    __extends(SkipUntilSubscriber, _super);
	    function SkipUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.isInnerStopped = false;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    SkipUntilSubscriber.prototype._next = function (value) {
	        if (this.hasValue) {
	            _super.prototype._next.call(this, value);
	        }
	    };
	    SkipUntilSubscriber.prototype._complete = function () {
	        if (this.isInnerStopped) {
	            _super.prototype._complete.call(this);
	        }
	        else {
	            this.unsubscribe();
	        }
	    };
	    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.hasValue = true;
	    };
	    SkipUntilSubscriber.prototype.notifyComplete = function () {
	        this.isInnerStopped = true;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    return SkipUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 907 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var skipWhile_1 = __webpack_require__(908);
	Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;
	//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 908 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
	 * true, but emits all further source items as soon as the condition becomes false.
	 *
	 * <img src="./img/skipWhile.png" width="100%">
	 *
	 * @param {Function} predicate - a function to test each item emitted from the source Observable.
	 * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the
	 * specified predicate becomes false.
	 * @method skipWhile
	 * @owner Observable
	 */
	function skipWhile(predicate) {
	    return this.lift(new SkipWhileOperator(predicate));
	}
	exports.skipWhile = skipWhile;
	var SkipWhileOperator = (function () {
	    function SkipWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    SkipWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
	    };
	    return SkipWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipWhileSubscriber = (function (_super) {
	    __extends(SkipWhileSubscriber, _super);
	    function SkipWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.skipping = true;
	        this.index = 0;
	    }
	    SkipWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (this.skipping) {
	            this.tryCallPredicate(value);
	        }
	        if (!this.skipping) {
	            destination.next(value);
	        }
	    };
	    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
	        try {
	            var result = this.predicate(value, this.index++);
	            this.skipping = Boolean(result);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    return SkipWhileSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 909 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var startWith_1 = __webpack_require__(910);
	Observable_1.Observable.prototype.startWith = startWith_1.startWith;
	//# sourceMappingURL=startWith.js.map

/***/ }),
/* 910 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(29);
	var ScalarObservable_1 = __webpack_require__(30);
	var EmptyObservable_1 = __webpack_require__(31);
	var concat_1 = __webpack_require__(714);
	var isScheduler_1 = __webpack_require__(32);
	/* tslint:disable:max-line-length */
	/**
	 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
	 * source Observable.
	 *
	 * <img src="./img/startWith.png" width="100%">
	 *
	 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
	 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
	 * emitted by the source Observable.
	 * @method startWith
	 * @owner Observable
	 */
	function startWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i - 0] = arguments[_i];
	    }
	    var scheduler = array[array.length - 1];
	    if (isScheduler_1.isScheduler(scheduler)) {
	        array.pop();
	    }
	    else {
	        scheduler = null;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
	    }
	    else if (len > 1) {
	        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
	    }
	    else {
	        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
	    }
	}
	exports.startWith = startWith;
	//# sourceMappingURL=startWith.js.map

/***/ }),
/* 911 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var subscribeOn_1 = __webpack_require__(912);
	Observable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;
	//# sourceMappingURL=subscribeOn.js.map

/***/ }),
/* 912 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var SubscribeOnObservable_1 = __webpack_require__(913);
	/**
	 * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
	 *
	 * <img src="./img/subscribeOn.png" width="100%">
	 *
	 * @param {Scheduler} the IScheduler to perform subscription actions on.
	 * @return {Observable<T>} the source Observable modified so that its subscriptions happen on the specified IScheduler
	 .
	 * @method subscribeOn
	 * @owner Observable
	 */
	function subscribeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new SubscribeOnOperator(scheduler, delay));
	}
	exports.subscribeOn = subscribeOn;
	var SubscribeOnOperator = (function () {
	    function SubscribeOnOperator(scheduler, delay) {
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    SubscribeOnOperator.prototype.call = function (subscriber, source) {
	        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
	    };
	    return SubscribeOnOperator;
	}());
	//# sourceMappingURL=subscribeOn.js.map

/***/ }),
/* 913 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var asap_1 = __webpack_require__(914);
	var isNumeric_1 = __webpack_require__(739);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var SubscribeOnObservable = (function (_super) {
	    __extends(SubscribeOnObservable, _super);
	    function SubscribeOnObservable(source, delayTime, scheduler) {
	        if (delayTime === void 0) { delayTime = 0; }
	        if (scheduler === void 0) { scheduler = asap_1.asap; }
	        _super.call(this);
	        this.source = source;
	        this.delayTime = delayTime;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
	            this.delayTime = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = asap_1.asap;
	        }
	    }
	    SubscribeOnObservable.create = function (source, delay, scheduler) {
	        if (delay === void 0) { delay = 0; }
	        if (scheduler === void 0) { scheduler = asap_1.asap; }
	        return new SubscribeOnObservable(source, delay, scheduler);
	    };
	    SubscribeOnObservable.dispatch = function (arg) {
	        var source = arg.source, subscriber = arg.subscriber;
	        return this.add(source.subscribe(subscriber));
	    };
	    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        });
	    };
	    return SubscribeOnObservable;
	}(Observable_1.Observable));
	exports.SubscribeOnObservable = SubscribeOnObservable;
	//# sourceMappingURL=SubscribeOnObservable.js.map

/***/ }),
/* 914 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var AsapAction_1 = __webpack_require__(915);
	var AsapScheduler_1 = __webpack_require__(919);
	exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
	//# sourceMappingURL=asap.js.map

/***/ }),
/* 915 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Immediate_1 = __webpack_require__(916);
	var AsyncAction_1 = __webpack_require__(46);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsapAction = (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay is greater than 0, request as an async action.
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Push the action to the end of the scheduler queue.
	        scheduler.actions.push(this);
	        // If a microtask has already been scheduled, don't schedule another
	        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
	        // the current scheduled microtask id.
	        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        // If the scheduler queue is empty, cancel the requested microtask and
	        // set the scheduled flag to undefined so the next AsapAction will schedule
	        // its own.
	        if (scheduler.actions.length === 0) {
	            Immediate_1.Immediate.clearImmediate(id);
	            scheduler.scheduled = undefined;
	        }
	        // Return undefined so the action knows to request a new async id if it's rescheduled.
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction_1.AsyncAction));
	exports.AsapAction = AsapAction;
	//# sourceMappingURL=AsapAction.js.map

/***/ }),
/* 916 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**
	Some credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	"use strict";
	var root_1 = __webpack_require__(5);
	var ImmediateDefinition = (function () {
	    function ImmediateDefinition(root) {
	        this.root = root;
	        if (root.setImmediate && typeof root.setImmediate === 'function') {
	            this.setImmediate = root.setImmediate.bind(root);
	            this.clearImmediate = root.clearImmediate.bind(root);
	        }
	        else {
	            this.nextHandle = 1;
	            this.tasksByHandle = {};
	            this.currentlyRunningATask = false;
	            // Don't get fooled by e.g. browserify environments.
	            if (this.canUseProcessNextTick()) {
	                // For Node.js before 0.9
	                this.setImmediate = this.createProcessNextTickSetImmediate();
	            }
	            else if (this.canUsePostMessage()) {
	                // For non-IE10 modern browsers
	                this.setImmediate = this.createPostMessageSetImmediate();
	            }
	            else if (this.canUseMessageChannel()) {
	                // For web workers, where supported
	                this.setImmediate = this.createMessageChannelSetImmediate();
	            }
	            else if (this.canUseReadyStateChange()) {
	                // For IE 68
	                this.setImmediate = this.createReadyStateChangeSetImmediate();
	            }
	            else {
	                // For older browsers
	                this.setImmediate = this.createSetTimeoutSetImmediate();
	            }
	            var ci = function clearImmediate(handle) {
	                delete clearImmediate.instance.tasksByHandle[handle];
	            };
	            ci.instance = this;
	            this.clearImmediate = ci;
	        }
	    }
	    ImmediateDefinition.prototype.identify = function (o) {
	        return this.root.Object.prototype.toString.call(o);
	    };
	    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
	        return this.identify(this.root.process) === '[object process]';
	    };
	    ImmediateDefinition.prototype.canUseMessageChannel = function () {
	        return Boolean(this.root.MessageChannel);
	    };
	    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
	        var document = this.root.document;
	        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
	    };
	    ImmediateDefinition.prototype.canUsePostMessage = function () {
	        var root = this.root;
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `root.postMessage` means something completely different and can't be used for this purpose.
	        if (root.postMessage && !root.importScripts) {
	            var postMessageIsAsynchronous_1 = true;
	            var oldOnMessage = root.onmessage;
	            root.onmessage = function () {
	                postMessageIsAsynchronous_1 = false;
	            };
	            root.postMessage('', '*');
	            root.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous_1;
	        }
	        return false;
	    };
	    // This function accepts the same arguments as setImmediate, but
	    // returns a function that requires no arguments.
	    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var fn = function result() {
	            var _a = result, handler = _a.handler, args = _a.args;
	            if (typeof handler === 'function') {
	                handler.apply(undefined, args);
	            }
	            else {
	                (new Function('' + handler))();
	            }
	        };
	        fn.handler = handler;
	        fn.args = args;
	        return fn;
	    };
	    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
	        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
	        return this.nextHandle++;
	    };
	    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	        var root = this.root;
	        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
	        var onGlobalMessage = function globalMessageHandler(event) {
	            var instance = globalMessageHandler.instance;
	            if (event.source === root &&
	                typeof event.data === 'string' &&
	                event.data.indexOf(messagePrefix) === 0) {
	                instance.runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	        onGlobalMessage.instance = this;
	        root.addEventListener('message', onGlobalMessage, false);
	        var fn = function setImmediate() {
	            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.postMessage(messagePrefix + handle, '*');
	            return handle;
	        };
	        fn.instance = this;
	        fn.messagePrefix = messagePrefix;
	        return fn;
	    };
	    ImmediateDefinition.prototype.runIfPresent = function (handle) {
	        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (this.currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // 'too much recursion' error.
	            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
	        }
	        else {
	            var task = this.tasksByHandle[handle];
	            if (task) {
	                this.currentlyRunningATask = true;
	                try {
	                    task();
	                }
	                finally {
	                    this.clearImmediate(handle);
	                    this.currentlyRunningATask = false;
	                }
	            }
	        }
	    };
	    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
	        var _this = this;
	        var channel = new this.root.MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            _this.runIfPresent(handle);
	        };
	        var fn = function setImmediate() {
	            var _a = setImmediate, channel = _a.channel, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            channel.port2.postMessage(handle);
	            return handle;
	        };
	        fn.channel = channel;
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var root = instance.root;
	            var doc = root.document;
	            var html = doc.documentElement;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement('script');
	            script.onreadystatechange = function () {
	                instance.runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    return ImmediateDefinition;
	}());
	exports.ImmediateDefinition = ImmediateDefinition;
	exports.Immediate = new ImmediateDefinition(root_1.root);
	//# sourceMappingURL=Immediate.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(917).clearImmediate, __webpack_require__(917).setImmediate))

/***/ }),
/* 917 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// setimmediate attaches itself to the global object
	__webpack_require__(918);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ }),
/* 918 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";

	    if (global.setImmediate) {
	        return;
	    }

	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;

	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }

	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }

	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }

	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }

	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }

	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }

	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };

	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }

	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }

	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };

	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }

	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }

	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }

	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();

	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();

	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();

	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 68
	        installReadyStateChangeImplementation();

	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }

	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(699)))

/***/ }),
/* 919 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1 = __webpack_require__(48);
	var AsapScheduler = (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        _super.apply(this, arguments);
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.AsapScheduler = AsapScheduler;
	//# sourceMappingURL=AsapScheduler.js.map

/***/ }),
/* 920 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var switch_1 = __webpack_require__(921);
	Observable_1.Observable.prototype.switch = switch_1._switch;
	Observable_1.Observable.prototype._switch = switch_1._switch;
	//# sourceMappingURL=switch.js.map

/***/ }),
/* 921 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * subscribing to only the most recently emitted of those inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * previous inner Observable once a new one appears.</span>
	 *
	 * <img src="./img/switch.png" width="100%">
	 *
	 * `switch` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable subscribes to the inner Observable and
	 * begins emitting the items emitted by that. So far, it behaves
	 * like {@link mergeAll}. However, when a new inner Observable is emitted,
	 * `switch` unsubscribes from the earlier-emitted inner Observable and
	 * subscribes to the new inner Observable and begins emitting items from it. It
	 * continues to behave like this for subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * // Each click event is mapped to an Observable that ticks every second
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var switched = higherOrder.switch();
	 * // The outcome is that `switched` is essentially a timer that restarts
	 * // on every click. The interval Observables from older clicks do not merge
	 * // with the current interval Observable.
	 * switched.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switchMap}
	 * @see {@link switchMapTo}
	 * @see {@link zipAll}
	 *
	 * @return {Observable<T>} An Observable that emits the items emitted by the
	 * Observable most recently emitted by the source Observable.
	 * @method switch
	 * @name switch
	 * @owner Observable
	 */
	function _switch() {
	    return this.lift(new SwitchOperator());
	}
	exports._switch = _switch;
	var SwitchOperator = (function () {
	    function SwitchOperator() {
	    }
	    SwitchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchSubscriber(subscriber));
	    };
	    return SwitchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchSubscriber = (function (_super) {
	    __extends(SwitchSubscriber, _super);
	    function SwitchSubscriber(destination) {
	        _super.call(this, destination);
	        this.active = 0;
	        this.hasCompleted = false;
	    }
	    SwitchSubscriber.prototype._next = function (value) {
	        this.unsubscribeInner();
	        this.active++;
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
	    };
	    SwitchSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    SwitchSubscriber.prototype.unsubscribeInner = function () {
	        this.active = this.active > 0 ? this.active - 1 : 0;
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	            this.remove(innerSubscription);
	        }
	    };
	    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    SwitchSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchSubscriber.prototype.notifyComplete = function () {
	        this.unsubscribeInner();
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return SwitchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switch.js.map

/***/ }),
/* 922 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var switchMapTo_1 = __webpack_require__(923);
	Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
	//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 923 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is flattened multiple
	 * times with {@link switch} in the output Observable.
	 *
	 * <span class="informal">It's like {@link switchMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/switchMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. The output Observables
	 * emits values only from the most recently emitted instance of
	 * `innerObservable`.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link switch}
	 * @see {@link switchMap}
	 * @see {@link mergeMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` every time a value is emitted on the source Observable.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable, and taking only the values
	 * from the most recently projected inner Observable.
	 * @method switchMapTo
	 * @owner Observable
	 */
	function switchMapTo(innerObservable, resultSelector) {
	    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
	}
	exports.switchMapTo = switchMapTo;
	var SwitchMapToOperator = (function () {
	    function SwitchMapToOperator(observable, resultSelector) {
	        this.observable = observable;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
	    };
	    return SwitchMapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapToSubscriber = (function (_super) {
	    __extends(SwitchMapToSubscriber, _super);
	    function SwitchMapToSubscriber(destination, inner, resultSelector) {
	        _super.call(this, destination);
	        this.inner = inner;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapToSubscriber.prototype._next = function (value) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
	    };
	    SwitchMapToSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    return SwitchMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 924 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var take_1 = __webpack_require__(925);
	Observable_1.Observable.prototype.take = take_1.take;
	//# sourceMappingURL=take.js.map

/***/ }),
/* 925 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var ArgumentOutOfRangeError_1 = __webpack_require__(822);
	var EmptyObservable_1 = __webpack_require__(31);
	/**
	 * Emits only the first `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Takes the first `count` values from the source, then
	 * completes.</span>
	 *
	 * <img src="./img/take.png" width="100%">
	 *
	 * `take` returns an Observable that emits only the first `count` values emitted
	 * by the source Observable. If the source emits fewer than `count` values then
	 * all of its values are emitted. After that, it completes, regardless if the
	 * source completes.
	 *
	 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var five = interval.take(5);
	 * five.subscribe(x => console.log(x));
	 *
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of `next` values to emit.
	 * @return {Observable<T>} An Observable that emits only the first `count`
	 * values emitted by the source Observable, or all of the values from the source
	 * if the source emits fewer than `count` values.
	 * @method take
	 * @owner Observable
	 */
	function take(count) {
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeOperator(count));
	    }
	}
	exports.take = take;
	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeSubscriber(subscriber, this.total));
	    };
	    return TakeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeSubscriber = (function (_super) {
	    __extends(TakeSubscriber, _super);
	    function TakeSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    TakeSubscriber.prototype._next = function (value) {
	        var total = this.total;
	        var count = ++this.count;
	        if (count <= total) {
	            this.destination.next(value);
	            if (count === total) {
	                this.destination.complete();
	                this.unsubscribe();
	            }
	        }
	    };
	    return TakeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=take.js.map

/***/ }),
/* 926 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var takeLast_1 = __webpack_require__(927);
	Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;
	//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 927 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var ArgumentOutOfRangeError_1 = __webpack_require__(822);
	var EmptyObservable_1 = __webpack_require__(31);
	/**
	 * Emits only the last `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Remembers the latest `count` values, then emits those
	 * only when the source completes.</span>
	 *
	 * <img src="./img/takeLast.png" width="100%">
	 *
	 * `takeLast` returns an Observable that emits at most the last `count` values
	 * emitted by the source Observable. If the source emits fewer than `count`
	 * values then all of its values are emitted. This operator must wait until the
	 * `complete` notification emission from the source in order to emit the `next`
	 * values on the output Observable, because otherwise it is impossible to know
	 * whether or not more values will be emitted on the source. For this reason,
	 * all values are emitted synchronously, followed by the complete notification.
	 *
	 * @example <caption>Take the last 3 values of an Observable with many values</caption>
	 * var many = Rx.Observable.range(1, 100);
	 * var lastThree = many.takeLast(3);
	 * lastThree.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of values to emit from the end of
	 * the sequence of values emitted by the source Observable.
	 * @return {Observable<T>} An Observable that emits at most the last count
	 * values emitted by the source Observable.
	 * @method takeLast
	 * @owner Observable
	 */
	function takeLast(count) {
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeLastOperator(count));
	    }
	}
	exports.takeLast = takeLast;
	var TakeLastOperator = (function () {
	    function TakeLastOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeLastOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
	    };
	    return TakeLastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeLastSubscriber = (function (_super) {
	    __extends(TakeLastSubscriber, _super);
	    function TakeLastSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.ring = new Array();
	        this.count = 0;
	    }
	    TakeLastSubscriber.prototype._next = function (value) {
	        var ring = this.ring;
	        var total = this.total;
	        var count = this.count++;
	        if (ring.length < total) {
	            ring.push(value);
	        }
	        else {
	            var index = count % total;
	            ring[index] = value;
	        }
	    };
	    TakeLastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var count = this.count;
	        if (count > 0) {
	            var total = this.count >= this.total ? this.total : this.count;
	            var ring = this.ring;
	            for (var i = 0; i < total; i++) {
	                var idx = (count++) % total;
	                destination.next(ring[idx]);
	            }
	        }
	        destination.complete();
	    };
	    return TakeLastSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 928 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var takeUntil_1 = __webpack_require__(929);
	Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
	//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 929 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Emits the values emitted by the source Observable until a `notifier`
	 * Observable emits a value.
	 *
	 * <span class="informal">Lets values pass until a second Observable,
	 * `notifier`, emits something. Then, it completes.</span>
	 *
	 * <img src="./img/takeUntil.png" width="100%">
	 *
	 * `takeUntil` subscribes and begins mirroring the source Observable. It also
	 * monitors a second Observable, `notifier` that you provide. If the `notifier`
	 * emits a value or a complete notification, the output Observable stops
	 * mirroring the source Observable and completes.
	 *
	 * @example <caption>Tick every second until the first click happens</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = interval.takeUntil(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @param {Observable} notifier The Observable whose first emitted value will
	 * cause the output Observable of `takeUntil` to stop emitting values from the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable until such time as `notifier` emits its first value.
	 * @method takeUntil
	 * @owner Observable
	 */
	function takeUntil(notifier) {
	    return this.lift(new TakeUntilOperator(notifier));
	}
	exports.takeUntil = takeUntil;
	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    TakeUntilOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
	    };
	    return TakeUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeUntilSubscriber = (function (_super) {
	    __extends(TakeUntilSubscriber, _super);
	    function TakeUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.complete();
	    };
	    TakeUntilSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    return TakeUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 930 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var takeWhile_1 = __webpack_require__(931);
	Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;
	//# sourceMappingURL=takeWhile.js.map

/***/ }),
/* 931 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Emits values emitted by the source Observable so long as each value satisfies
	 * the given `predicate`, and then completes as soon as this `predicate` is not
	 * satisfied.
	 *
	 * <span class="informal">Takes values from the source only while they pass the
	 * condition given. When the first value does not satisfy, it completes.</span>
	 *
	 * <img src="./img/takeWhile.png" width="100%">
	 *
	 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
	 * emitted on the source is given to the `predicate` function which returns a
	 * boolean, representing a condition to be satisfied by the source values. The
	 * output Observable emits the source values until such time as the `predicate`
	 * returns false, at which point `takeWhile` stops mirroring the source
	 * Observable and completes the output Observable.
	 *
	 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.takeWhile(ev => ev.clientX > 200);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates a value emitted by the source Observable and returns a boolean.
	 * Also takes the (zero-based) index as the second argument.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable so long as each value satisfies the condition defined by the
	 * `predicate`, then completes.
	 * @method takeWhile
	 * @owner Observable
	 */
	function takeWhile(predicate) {
	    return this.lift(new TakeWhileOperator(predicate));
	}
	exports.takeWhile = takeWhile;
	var TakeWhileOperator = (function () {
	    function TakeWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    TakeWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
	    };
	    return TakeWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeWhileSubscriber = (function (_super) {
	    __extends(TakeWhileSubscriber, _super);
	    function TakeWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.index = 0;
	    }
	    TakeWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        var result;
	        try {
	            result = this.predicate(value, this.index++);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this.nextOrComplete(value, result);
	    };
	    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
	        var destination = this.destination;
	        if (Boolean(predicateResult)) {
	            destination.next(value);
	        }
	        else {
	            destination.complete();
	        }
	    };
	    return TakeWhileSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=takeWhile.js.map

/***/ }),
/* 932 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var throttle_1 = __webpack_require__(933);
	Observable_1.Observable.prototype.throttle = throttle_1.throttle;
	//# sourceMappingURL=throttle.js.map

/***/ }),
/* 933 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for a duration determined by another Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link throttleTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/throttle.png" width="100%">
	 *
	 * `throttle` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled by calling the `durationSelector` function with the source value,
	 * which returns the "duration" Observable. When the duration Observable emits a
	 * value or completes, the timer is disabled, and this process repeats for the
	 * next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {function(value: T): Observable|Promise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttle
	 * @owner Observable
	 */
	function throttle(durationSelector) {
	    return this.lift(new ThrottleOperator(durationSelector));
	}
	exports.throttle = throttle;
	var ThrottleOperator = (function () {
	    function ThrottleOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    ThrottleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector));
	    };
	    return ThrottleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleSubscriber = (function (_super) {
	    __extends(ThrottleSubscriber, _super);
	    function ThrottleSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.durationSelector = durationSelector;
	    }
	    ThrottleSubscriber.prototype._next = function (value) {
	        if (!this.throttled) {
	            this.tryDurationSelector(value);
	        }
	    };
	    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
	        var duration = null;
	        try {
	            duration = this.durationSelector(value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.emitAndThrottle(value, duration);
	    };
	    ThrottleSubscriber.prototype.emitAndThrottle = function (value, duration) {
	        this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	        this.destination.next(value);
	    };
	    ThrottleSubscriber.prototype._unsubscribe = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	    };
	    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._unsubscribe();
	    };
	    ThrottleSubscriber.prototype.notifyComplete = function () {
	        this._unsubscribe();
	    };
	    return ThrottleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=throttle.js.map

/***/ }),
/* 934 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var throttleTime_1 = __webpack_require__(935);
	Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;
	//# sourceMappingURL=throttleTime.js.map

/***/ }),
/* 935 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var async_1 = __webpack_require__(45);
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for `duration` milliseconds, then repeats this process.
	 *
	 * <span class="informal">Lets a value pass, then ignores source values for the
	 * next `duration` milliseconds.</span>
	 *
	 * <img src="./img/throttleTime.png" width="100%">
	 *
	 * `throttleTime` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled. After `duration` milliseconds (or the time unit determined
	 * internally by the optional `scheduler`) has passed, the timer is disabled,
	 * and this process repeats for the next source value. Optionally takes a
	 * {@link IScheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {number} duration Time to wait before emitting another value after
	 * emitting the last value, measured in milliseconds or the time unit determined
	 * internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttleTime
	 * @owner Observable
	 */
	function throttleTime(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new ThrottleTimeOperator(duration, scheduler));
	}
	exports.throttleTime = throttleTime;
	var ThrottleTimeOperator = (function () {
	    function ThrottleTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return ThrottleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleTimeSubscriber = (function (_super) {
	    __extends(ThrottleTimeSubscriber, _super);
	    function ThrottleTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    ThrottleTimeSubscriber.prototype._next = function (value) {
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
	            this.destination.next(value);
	        }
	    };
	    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            throttled.unsubscribe();
	            this.remove(throttled);
	            this.throttled = null;
	        }
	    };
	    return ThrottleTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(arg) {
	    var subscriber = arg.subscriber;
	    subscriber.clearThrottle();
	}
	//# sourceMappingURL=throttleTime.js.map

/***/ }),
/* 936 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var timeInterval_1 = __webpack_require__(937);
	Observable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;
	//# sourceMappingURL=timeInterval.js.map

/***/ }),
/* 937 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var async_1 = __webpack_require__(45);
	/**
	 * @param scheduler
	 * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
	 * @method timeInterval
	 * @owner Observable
	 */
	function timeInterval(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new TimeIntervalOperator(scheduler));
	}
	exports.timeInterval = timeInterval;
	var TimeInterval = (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());
	exports.TimeInterval = TimeInterval;
	;
	var TimeIntervalOperator = (function () {
	    function TimeIntervalOperator(scheduler) {
	        this.scheduler = scheduler;
	    }
	    TimeIntervalOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
	    };
	    return TimeIntervalOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeIntervalSubscriber = (function (_super) {
	    __extends(TimeIntervalSubscriber, _super);
	    function TimeIntervalSubscriber(destination, scheduler) {
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.lastTime = 0;
	        this.lastTime = scheduler.now();
	    }
	    TimeIntervalSubscriber.prototype._next = function (value) {
	        var now = this.scheduler.now();
	        var span = now - this.lastTime;
	        this.lastTime = now;
	        this.destination.next(new TimeInterval(value, span));
	    };
	    return TimeIntervalSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=timeInterval.js.map

/***/ }),
/* 938 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var timeout_1 = __webpack_require__(939);
	Observable_1.Observable.prototype.timeout = timeout_1.timeout;
	//# sourceMappingURL=timeout.js.map

/***/ }),
/* 939 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(45);
	var isDate_1 = __webpack_require__(763);
	var Subscriber_1 = __webpack_require__(9);
	var TimeoutError_1 = __webpack_require__(940);
	/**
	 * @param {number} due
	 * @param {Scheduler} [scheduler]
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeout
	 * @owner Observable
	 */
	function timeout(due, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteTimeout = isDate_1.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));
	}
	exports.timeout = timeout;
	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.scheduler = scheduler;
	        this.errorInstance = errorInstance;
	    }
	    TimeoutOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
	    };
	    return TimeoutOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutSubscriber = (function (_super) {
	    __extends(TimeoutSubscriber, _super);
	    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
	        _super.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.scheduler = scheduler;
	        this.errorInstance = errorInstance;
	        this.index = 0;
	        this._previousIndex = 0;
	        this._hasCompleted = false;
	        this.scheduleTimeout();
	    }
	    Object.defineProperty(TimeoutSubscriber.prototype, "previousIndex", {
	        get: function () {
	            return this._previousIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TimeoutSubscriber.prototype, "hasCompleted", {
	        get: function () {
	            return this._hasCompleted;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TimeoutSubscriber.dispatchTimeout = function (state) {
	        var source = state.subscriber;
	        var currentIndex = state.index;
	        if (!source.hasCompleted && source.previousIndex === currentIndex) {
	            source.notifyTimeout();
	        }
	    };
	    TimeoutSubscriber.prototype.scheduleTimeout = function () {
	        var currentIndex = this.index;
	        this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, { subscriber: this, index: currentIndex });
	        this.index++;
	        this._previousIndex = currentIndex;
	    };
	    TimeoutSubscriber.prototype._next = function (value) {
	        this.destination.next(value);
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	    };
	    TimeoutSubscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this._hasCompleted = true;
	    };
	    TimeoutSubscriber.prototype._complete = function () {
	        this.destination.complete();
	        this._hasCompleted = true;
	    };
	    TimeoutSubscriber.prototype.notifyTimeout = function () {
	        this.error(this.errorInstance);
	    };
	    return TimeoutSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=timeout.js.map

/***/ }),
/* 940 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when duetime elapses.
	 *
	 * @see {@link timeout}
	 *
	 * @class TimeoutError
	 */
	var TimeoutError = (function (_super) {
	    __extends(TimeoutError, _super);
	    function TimeoutError() {
	        var err = _super.call(this, 'Timeout has occurred');
	        this.name = err.name = 'TimeoutError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return TimeoutError;
	}(Error));
	exports.TimeoutError = TimeoutError;
	//# sourceMappingURL=TimeoutError.js.map

/***/ }),
/* 941 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var timeoutWith_1 = __webpack_require__(942);
	Observable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;
	//# sourceMappingURL=timeoutWith.js.map

/***/ }),
/* 942 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(45);
	var isDate_1 = __webpack_require__(763);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * @param due
	 * @param withObservable
	 * @param scheduler
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeoutWith
	 * @owner Observable
	 */
	function timeoutWith(due, withObservable, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteTimeout = isDate_1.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
	}
	exports.timeoutWith = timeoutWith;
	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }
	    TimeoutWithOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
	    };
	    return TimeoutWithOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutWithSubscriber = (function (_super) {
	    __extends(TimeoutWithSubscriber, _super);
	    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	        _super.call(this);
	        this.destination = destination;
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        this.timeoutSubscription = undefined;
	        this.index = 0;
	        this._previousIndex = 0;
	        this._hasCompleted = false;
	        destination.add(this);
	        this.scheduleTimeout();
	    }
	    Object.defineProperty(TimeoutWithSubscriber.prototype, "previousIndex", {
	        get: function () {
	            return this._previousIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TimeoutWithSubscriber.prototype, "hasCompleted", {
	        get: function () {
	            return this._hasCompleted;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TimeoutWithSubscriber.dispatchTimeout = function (state) {
	        var source = state.subscriber;
	        var currentIndex = state.index;
	        if (!source.hasCompleted && source.previousIndex === currentIndex) {
	            source.handleTimeout();
	        }
	    };
	    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
	        var currentIndex = this.index;
	        var timeoutState = { subscriber: this, index: currentIndex };
	        this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, timeoutState);
	        this.index++;
	        this._previousIndex = currentIndex;
	    };
	    TimeoutWithSubscriber.prototype._next = function (value) {
	        this.destination.next(value);
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	    };
	    TimeoutWithSubscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this._hasCompleted = true;
	    };
	    TimeoutWithSubscriber.prototype._complete = function () {
	        this.destination.complete();
	        this._hasCompleted = true;
	    };
	    TimeoutWithSubscriber.prototype.handleTimeout = function () {
	        if (!this.closed) {
	            var withObservable = this.withObservable;
	            this.unsubscribe();
	            this.destination.add(this.timeoutSubscription = subscribeToResult_1.subscribeToResult(this, withObservable));
	        }
	    };
	    return TimeoutWithSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=timeoutWith.js.map

/***/ }),
/* 943 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var timestamp_1 = __webpack_require__(944);
	Observable_1.Observable.prototype.timestamp = timestamp_1.timestamp;
	//# sourceMappingURL=timestamp.js.map

/***/ }),
/* 944 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var async_1 = __webpack_require__(45);
	/**
	 * @param scheduler
	 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
	 * @method timestamp
	 * @owner Observable
	 */
	function timestamp(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new TimestampOperator(scheduler));
	}
	exports.timestamp = timestamp;
	var Timestamp = (function () {
	    function Timestamp(value, timestamp) {
	        this.value = value;
	        this.timestamp = timestamp;
	    }
	    return Timestamp;
	}());
	exports.Timestamp = Timestamp;
	;
	var TimestampOperator = (function () {
	    function TimestampOperator(scheduler) {
	        this.scheduler = scheduler;
	    }
	    TimestampOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));
	    };
	    return TimestampOperator;
	}());
	var TimestampSubscriber = (function (_super) {
	    __extends(TimestampSubscriber, _super);
	    function TimestampSubscriber(destination, scheduler) {
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	    }
	    TimestampSubscriber.prototype._next = function (value) {
	        var now = this.scheduler.now();
	        this.destination.next(new Timestamp(value, now));
	    };
	    return TimestampSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=timestamp.js.map

/***/ }),
/* 945 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var toArray_1 = __webpack_require__(946);
	Observable_1.Observable.prototype.toArray = toArray_1.toArray;
	//# sourceMappingURL=toArray.js.map

/***/ }),
/* 946 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
	 * @method toArray
	 * @owner Observable
	 */
	function toArray() {
	    return this.lift(new ToArrayOperator());
	}
	exports.toArray = toArray;
	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	    }
	    ToArrayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ToArraySubscriber(subscriber));
	    };
	    return ToArrayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ToArraySubscriber = (function (_super) {
	    __extends(ToArraySubscriber, _super);
	    function ToArraySubscriber(destination) {
	        _super.call(this, destination);
	        this.array = [];
	    }
	    ToArraySubscriber.prototype._next = function (x) {
	        this.array.push(x);
	    };
	    ToArraySubscriber.prototype._complete = function () {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };
	    return ToArraySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=toArray.js.map

/***/ }),
/* 947 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var window_1 = __webpack_require__(948);
	Observable_1.Observable.prototype.window = window_1.window;
	//# sourceMappingURL=window.js.map

/***/ }),
/* 948 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Branch out the source Observable values as a nested Observable whenever
	 * `windowBoundaries` emits.
	 *
	 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
	 * instead of an array.</span>
	 *
	 * <img src="./img/window.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping
	 * windows. It emits the current window and opens a new one whenever the
	 * Observable `windowBoundaries` emits an item. Because each window is an
	 * Observable, the output is a higher-order Observable.
	 *
	 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var result = clicks.window(interval)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link buffer}
	 *
	 * @param {Observable<any>} windowBoundaries An Observable that completes the
	 * previous window and starts a new window.
	 * @return {Observable<Observable<T>>} An Observable of windows, which are
	 * Observables emitting values of the source Observable.
	 * @method window
	 * @owner Observable
	 */
	function window(windowBoundaries) {
	    return this.lift(new WindowOperator(windowBoundaries));
	}
	exports.window = window;
	var WindowOperator = (function () {
	    function WindowOperator(windowBoundaries) {
	        this.windowBoundaries = windowBoundaries;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        var windowSubscriber = new WindowSubscriber(subscriber);
	        var sourceSubscription = source.subscribe(windowSubscriber);
	        if (!sourceSubscription.closed) {
	            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
	        }
	        return sourceSubscription;
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination) {
	        _super.call(this, destination);
	        this.window = new Subject_1.Subject();
	        destination.next(this.window);
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow();
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this._complete();
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	    };
	    WindowSubscriber.prototype._unsubscribe = function () {
	        this.window = null;
	    };
	    WindowSubscriber.prototype.openWindow = function () {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var destination = this.destination;
	        var newWindow = this.window = new Subject_1.Subject();
	        destination.next(newWindow);
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=window.js.map

/***/ }),
/* 949 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var windowCount_1 = __webpack_require__(950);
	Observable_1.Observable.prototype.windowCount = windowCount_1.windowCount;
	//# sourceMappingURL=windowCount.js.map

/***/ }),
/* 950 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(9);
	var Subject_1 = __webpack_require__(6);
	/**
	 * Branch out the source Observable values as a nested Observable with each
	 * nested Observable emitting at most `windowSize` values.
	 *
	 * <span class="informal">It's like {@link bufferCount}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowCount.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows every `startWindowEvery`
	 * items, each containing no more than `windowSize` items. When the source
	 * Observable completes or encounters an error, the output Observable emits
	 * the current window and propagates the notification from the source
	 * Observable. If `startWindowEvery` is not provided, then new windows are
	 * started immediately at the start of the source and when each window completes
	 * with size `windowSize`.
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(3)
	 *   .map(win => win.skip(1)) // skip first of every 3 clicks
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(2, 3)
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link bufferCount}
	 *
	 * @param {number} windowSize The maximum number of values emitted by each
	 * window.
	 * @param {number} [startWindowEvery] Interval at which to start a new window.
	 * For example if `startWindowEvery` is `2`, then a new window will be started
	 * on every other value from the source. A new window is started at the
	 * beginning of the source by default.
	 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
	 * are Observable of values.
	 * @method windowCount
	 * @owner Observable
	 */
	function windowCount(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}
	exports.windowCount = windowCount;
	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }
	    WindowCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
	    };
	    return WindowCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowCountSubscriber = (function (_super) {
	    __extends(WindowCountSubscriber, _super);
	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [new Subject_1.Subject()];
	        this.count = 0;
	        destination.next(this.windows[0]);
	    }
	    WindowCountSubscriber.prototype._next = function (value) {
	        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
	        var destination = this.destination;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len && !this.closed; i++) {
	            windows[i].next(value);
	        }
	        var c = this.count - windowSize + 1;
	        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
	            windows.shift().complete();
	        }
	        if (++this.count % startWindowEvery === 0 && !this.closed) {
	            var window_1 = new Subject_1.Subject();
	            windows.push(window_1);
	            destination.next(window_1);
	        }
	    };
	    WindowCountSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().error(err);
	            }
	        }
	        this.destination.error(err);
	    };
	    WindowCountSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowCountSubscriber.prototype._unsubscribe = function () {
	        this.count = 0;
	        this.windows = null;
	    };
	    return WindowCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=windowCount.js.map

/***/ }),
/* 951 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var windowTime_1 = __webpack_require__(952);
	Observable_1.Observable.prototype.windowTime = windowTime_1.windowTime;
	//# sourceMappingURL=windowTime.js.map

/***/ }),
/* 952 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var async_1 = __webpack_require__(45);
	var Subscriber_1 = __webpack_require__(9);
	/**
	 * Branch out the source Observable values as a nested Observable periodically
	 * in time.
	 *
	 * <span class="informal">It's like {@link bufferTime}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowTime.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable starts a new window periodically, as
	 * determined by the `windowCreationInterval` argument. It emits each window
	 * after a fixed timespan, specified by the `windowTimeSpan` argument. When the
	 * source Observable completes or encounters an error, the output Observable
	 * emits the current window and propagates the notification from the source
	 * Observable. If `windowCreationInterval` is not provided, the output
	 * Observable starts a new window when the previous window of duration
	 * `windowTimeSpan` completes.
	 *
	 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowTime(1000)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowTime(1000, 5000)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link bufferTime}
	 *
	 * @param {number} windowTimeSpan The amount of time to fill each window.
	 * @param {number} [windowCreationInterval] The interval at which to start new
	 * windows.
	 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
	 * intervals that determine window boundaries.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowTime
	 * @owner Observable
	 */
	function windowTime(windowTimeSpan, windowCreationInterval, scheduler) {
	    if (windowCreationInterval === void 0) { windowCreationInterval = null; }
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
	}
	exports.windowTime = windowTime;
	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	    }
	    WindowTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler));
	    };
	    return WindowTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowTimeSubscriber = (function (_super) {
	    __extends(WindowTimeSubscriber, _super);
	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	        this.windows = [];
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var window_1 = this.openWindow();
	            var closeState = { subscriber: this, window: window_1, context: null };
	            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	        }
	        else {
	            var window_2 = this.openWindow();
	            var timeSpanOnlyState = { subscriber: this, window: window_2, windowTimeSpan: windowTimeSpan };
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	        }
	    }
	    WindowTimeSubscriber.prototype._next = function (value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            var window_3 = windows[i];
	            if (!window_3.closed) {
	                window_3.next(value);
	            }
	        }
	    };
	    WindowTimeSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	    WindowTimeSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            var window_4 = windows.shift();
	            if (!window_4.closed) {
	                window_4.complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowTimeSubscriber.prototype.openWindow = function () {
	        var window = new Subject_1.Subject();
	        this.windows.push(window);
	        var destination = this.destination;
	        destination.next(window);
	        return window;
	    };
	    WindowTimeSubscriber.prototype.closeWindow = function (window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };
	    return WindowTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
	    if (window) {
	        window.complete();
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    var timeSpanState = { subscriber: subscriber, window: window, context: context };
	    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	    action.add(context.subscription);
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(arg) {
	    var subscriber = arg.subscriber, window = arg.window, context = arg.context;
	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}
	//# sourceMappingURL=windowTime.js.map

/***/ }),
/* 953 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var windowToggle_1 = __webpack_require__(954);
	Observable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;
	//# sourceMappingURL=windowToggle.js.map

/***/ }),
/* 954 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscription_1 = __webpack_require__(11);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Branch out the source Observable values as a nested Observable starting from
	 * an emission from `openings` and ending when the output of `closingSelector`
	 * emits.
	 *
	 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowToggle.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows that contain those items
	 * emitted by the source Observable between the time when the `openings`
	 * Observable emits an item and when the Observable returned by
	 * `closingSelector` emits an item.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var result = clicks.windowToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * ).mergeAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowWhen}
	 * @see {@link bufferToggle}
	 *
	 * @param {Observable<O>} openings An observable of notifications to start new
	 * windows.
	 * @param {function(value: O): Observable} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns an Observable,
	 * which, when it emits (either `next` or `complete`), signals that the
	 * associated window should complete.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowToggle
	 * @owner Observable
	 */
	function windowToggle(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}
	exports.windowToggle = windowToggle;
	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    WindowToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return WindowToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowToggleSubscriber = (function (_super) {
	    __extends(WindowToggleSubscriber, _super);
	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
	    }
	    WindowToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        if (contexts) {
	            var len = contexts.length;
	            for (var i = 0; i < len; i++) {
	                contexts[i].window.next(value);
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.error(err);
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._error.call(this, err);
	    };
	    WindowToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.complete();
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    WindowToggleSubscriber.prototype._unsubscribe = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.unsubscribe();
	                context.subscription.unsubscribe();
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (outerValue === this.openings) {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
	            if (closingNotifier === errorObject_1.errorObject) {
	                return this.error(errorObject_1.errorObject.e);
	            }
	            else {
	                var window_1 = new Subject_1.Subject();
	                var subscription = new Subscription_1.Subscription();
	                var context = { window: window_1, subscription: subscription };
	                this.contexts.push(context);
	                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
	                if (innerSubscription.closed) {
	                    this.closeWindow(this.contexts.length - 1);
	                }
	                else {
	                    innerSubscription.context = context;
	                    subscription.add(innerSubscription);
	                }
	                this.destination.next(window_1);
	            }
	        }
	        else {
	            this.closeWindow(this.contexts.indexOf(outerValue));
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyError = function (err) {
	        this.error(err);
	    };
	    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
	        if (inner !== this.openSubscription) {
	            this.closeWindow(this.contexts.indexOf(inner.context));
	        }
	    };
	    WindowToggleSubscriber.prototype.closeWindow = function (index) {
	        if (index === -1) {
	            return;
	        }
	        var contexts = this.contexts;
	        var context = contexts[index];
	        var window = context.window, subscription = context.subscription;
	        contexts.splice(index, 1);
	        window.complete();
	        subscription.unsubscribe();
	    };
	    return WindowToggleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=windowToggle.js.map

/***/ }),
/* 955 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var windowWhen_1 = __webpack_require__(956);
	Observable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;
	//# sourceMappingURL=windowWhen.js.map

/***/ }),
/* 956 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var tryCatch_1 = __webpack_require__(14);
	var errorObject_1 = __webpack_require__(15);
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/**
	 * Branch out the source Observable values as a nested Observable using a
	 * factory function of closing Observables to determine when to start a new
	 * window.
	 *
	 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowWhen.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping windows.
	 * It emits the current window and opens a new one whenever the Observable
	 * produced by the specified `closingSelector` function emits an item. The first
	 * window is opened immediately when subscribing to the output Observable.
	 *
	 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks
	 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link bufferWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals (on either `next` or
	 * `complete`) when to close the previous window and start a new one.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowWhen
	 * @owner Observable
	 */
	function windowWhen(closingSelector) {
	    return this.lift(new WindowOperator(closingSelector));
	}
	exports.windowWhen = windowWhen;
	var WindowOperator = (function () {
	    function WindowOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.closingSelector = closingSelector;
	        this.openWindow();
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
	        if (this.closingNotification) {
	            this.closingNotification.unsubscribe();
	        }
	    };
	    WindowSubscriber.prototype.openWindow = function (innerSub) {
	        if (innerSub === void 0) { innerSub = null; }
	        if (innerSub) {
	            this.remove(innerSub);
	            innerSub.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var window = this.window = new Subject_1.Subject();
	        this.destination.next(window);
	        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1.errorObject) {
	            var err = errorObject_1.errorObject.e;
	            this.destination.error(err);
	            this.window.error(err);
	        }
	        else {
	            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
	        }
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=windowWhen.js.map

/***/ }),
/* 957 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var withLatestFrom_1 = __webpack_require__(958);
	Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;
	//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 958 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(39);
	/* tslint:disable:max-line-length */
	/**
	 * Combines the source Observable with other Observables to create an Observable
	 * whose values are calculated from the latest values of each, only when the
	 * source emits.
	 *
	 * <span class="informal">Whenever the source Observable emits a value, it
	 * computes a formula using that value plus the latest values from other input
	 * Observables, then emits the output of that formula.</span>
	 *
	 * <img src="./img/withLatestFrom.png" width="100%">
	 *
	 * `withLatestFrom` combines each value from the source Observable (the
	 * instance) with the latest values from the other input Observables only when
	 * the source emits a value, optionally using a `project` function to determine
	 * the value to be emitted on the output Observable. All input Observables must
	 * emit at least one value before the output Observable will emit a value.
	 *
	 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var result = clicks.withLatestFrom(timer);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 *
	 * @param {Observable} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Function} [project] Projection function for combining values
	 * together. Receives all values in order of the Observables passed, where the
	 * first parameter is a value from the source Observable. (e.g.
	 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
	 * passed, arrays will be emitted on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method withLatestFrom
	 * @owner Observable
	 */
	function withLatestFrom() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i - 0] = arguments[_i];
	    }
	    var project;
	    if (typeof args[args.length - 1] === 'function') {
	        project = args.pop();
	    }
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}
	exports.withLatestFrom = withLatestFrom;
	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        this.observables = observables;
	        this.project = project;
	    }
	    WithLatestFromOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
	    };
	    return WithLatestFromOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WithLatestFromSubscriber = (function (_super) {
	    __extends(WithLatestFromSubscriber, _super);
	    function WithLatestFromSubscriber(destination, observables, project) {
	        _super.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        this.toRespond = [];
	        var len = observables.length;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.toRespond.push(i);
	        }
	        for (var i = 0; i < len; i++) {
	            var observable = observables[i];
	            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	        }
	    }
	    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    WithLatestFromSubscriber.prototype._next = function (value) {
	        if (this.toRespond.length === 0) {
	            var args = [value].concat(this.values);
	            if (this.project) {
	                this._tryProject(args);
	            }
	            else {
	                this.destination.next(args);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return WithLatestFromSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 959 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var zip_1 = __webpack_require__(766);
	Observable_1.Observable.prototype.zip = zip_1.zipProto;
	//# sourceMappingURL=zip.js.map

/***/ }),
/* 960 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(7);
	var zipAll_1 = __webpack_require__(961);
	Observable_1.Observable.prototype.zipAll = zipAll_1.zipAll;
	//# sourceMappingURL=zipAll.js.map

/***/ }),
/* 961 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var zip_1 = __webpack_require__(766);
	/**
	 * @param project
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method zipAll
	 * @owner Observable
	 */
	function zipAll(project) {
	    return this.lift(new zip_1.ZipOperator(project));
	}
	exports.zipAll = zipAll;
	//# sourceMappingURL=zipAll.js.map

/***/ }),
/* 962 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var Notification_1 = __webpack_require__(98);
	var ColdObservable_1 = __webpack_require__(963);
	var HotObservable_1 = __webpack_require__(967);
	var SubscriptionLog_1 = __webpack_require__(965);
	var VirtualTimeScheduler_1 = __webpack_require__(968);
	var defaultMaxFrame = 750;
	var TestScheduler = (function (_super) {
	    __extends(TestScheduler, _super);
	    function TestScheduler(assertDeepEqual) {
	        _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
	        this.assertDeepEqual = assertDeepEqual;
	        this.hotObservables = [];
	        this.coldObservables = [];
	        this.flushTests = [];
	    }
	    TestScheduler.prototype.createTime = function (marbles) {
	        var indexOf = marbles.indexOf('|');
	        if (indexOf === -1) {
	            throw new Error('marble diagram for time should have a completion marker "|"');
	        }
	        return indexOf * TestScheduler.frameTimeFactor;
	    };
	    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
	        if (marbles.indexOf('^') !== -1) {
	            throw new Error('cold observable cannot have subscription offset "^"');
	        }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('cold observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var cold = new ColdObservable_1.ColdObservable(messages, this);
	        this.coldObservables.push(cold);
	        return cold;
	    };
	    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('hot observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var subject = new HotObservable_1.HotObservable(messages, this);
	        this.hotObservables.push(subject);
	        return subject;
	    };
	    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
	        var _this = this;
	        var messages = [];
	        observable.subscribe(function (value) {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });
	        }, function (err) {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });
	        }, function () {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });
	        });
	        return messages;
	    };
	    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
	        var _this = this;
	        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
	        var actual = [];
	        var flushTest = { actual: actual, ready: false };
	        var unsubscriptionFrame = TestScheduler
	            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
	        var subscription;
	        this.schedule(function () {
	            subscription = observable.subscribe(function (x) {
	                var value = x;
	                // Support Observable-of-Observables
	                if (x instanceof Observable_1.Observable) {
	                    value = _this.materializeInnerObservable(value, _this.frame);
	                }
	                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
	            }, function (err) {
	                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });
	            }, function () {
	                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
	            });
	        }, 0);
	        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
	        }
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function (marbles, values, errorValue) {
	                flushTest.ready = true;
	                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
	            }
	        };
	    };
	    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
	        var flushTest = { actual: actualSubscriptionLogs, ready: false };
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function (marbles) {
	                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
	                flushTest.ready = true;
	                flushTest.expected = marblesArray.map(function (marbles) {
	                    return TestScheduler.parseMarblesAsSubscriptions(marbles);
	                });
	            }
	        };
	    };
	    TestScheduler.prototype.flush = function () {
	        var hotObservables = this.hotObservables;
	        while (hotObservables.length > 0) {
	            hotObservables.shift().setup();
	        }
	        _super.prototype.flush.call(this);
	        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });
	        while (readyFlushTests.length > 0) {
	            var test = readyFlushTests.shift();
	            this.assertDeepEqual(test.actual, test.expected);
	        }
	    };
	    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {
	        if (typeof marbles !== 'string') {
	            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
	        }
	        var len = marbles.length;
	        var groupStart = -1;
	        var subscriptionFrame = Number.POSITIVE_INFINITY;
	        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '^':
	                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('found a second subscription point \'^\' in a ' +
	                            'subscription marble diagram. There can only be one.');
	                    }
	                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                case '!':
	                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('found a second subscription point \'^\' in a ' +
	                            'subscription marble diagram. There can only be one.');
	                    }
	                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                default:
	                    throw new Error('there can only be \'^\' and \'!\' markers in a ' +
	                        'subscription marble diagram. Found instead \'' + c + '\'.');
	            }
	        }
	        if (unsubscriptionFrame < 0) {
	            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
	        }
	        else {
	            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
	        }
	    };
	    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
	        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('conventional marble diagrams cannot have the ' +
	                'unsubscription marker "!"');
	        }
	        var len = marbles.length;
	        var testMessages = [];
	        var subIndex = marbles.indexOf('^');
	        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
	        var getValue = typeof values !== 'object' ?
	            function (x) { return x; } :
	            function (x) {
	                // Support Observable-of-Observables
	                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {
	                    return values[x].messages;
	                }
	                return values[x];
	            };
	        var groupStart = -1;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor + frameOffset;
	            var notification = void 0;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '|':
	                    notification = Notification_1.Notification.createComplete();
	                    break;
	                case '^':
	                    break;
	                case '#':
	                    notification = Notification_1.Notification.createError(errorValue || 'error');
	                    break;
	                default:
	                    notification = Notification_1.Notification.createNext(getValue(c));
	                    break;
	            }
	            if (notification) {
	                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
	            }
	        }
	        return testMessages;
	    };
	    return TestScheduler;
	}(VirtualTimeScheduler_1.VirtualTimeScheduler));
	exports.TestScheduler = TestScheduler;
	//# sourceMappingURL=TestScheduler.js.map

/***/ }),
/* 963 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(7);
	var Subscription_1 = __webpack_require__(11);
	var SubscriptionLoggable_1 = __webpack_require__(964);
	var applyMixins_1 = __webpack_require__(966);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ColdObservable = (function (_super) {
	    __extends(ColdObservable, _super);
	    function ColdObservable(messages, scheduler) {
	        _super.call(this, function (subscriber) {
	            var observable = this;
	            var index = observable.logSubscribedFrame();
	            subscriber.add(new Subscription_1.Subscription(function () {
	                observable.logUnsubscribedFrame(index);
	            }));
	            observable.scheduleMessages(subscriber);
	            return subscriber;
	        });
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	    ColdObservable.prototype.scheduleMessages = function (subscriber) {
	        var messagesLength = this.messages.length;
	        for (var i = 0; i < messagesLength; i++) {
	            var message = this.messages[i];
	            subscriber.add(this.scheduler.schedule(function (_a) {
	                var message = _a.message, subscriber = _a.subscriber;
	                message.notification.observe(subscriber);
	            }, message.frame, { message: message, subscriber: subscriber }));
	        }
	    };
	    return ColdObservable;
	}(Observable_1.Observable));
	exports.ColdObservable = ColdObservable;
	applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);
	//# sourceMappingURL=ColdObservable.js.map

/***/ }),
/* 964 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var SubscriptionLog_1 = __webpack_require__(965);
	var SubscriptionLoggable = (function () {
	    function SubscriptionLoggable() {
	        this.subscriptions = [];
	    }
	    SubscriptionLoggable.prototype.logSubscribedFrame = function () {
	        this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));
	        return this.subscriptions.length - 1;
	    };
	    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
	        var subscriptionLogs = this.subscriptions;
	        var oldSubscriptionLog = subscriptionLogs[index];
	        subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
	    };
	    return SubscriptionLoggable;
	}());
	exports.SubscriptionLoggable = SubscriptionLoggable;
	//# sourceMappingURL=SubscriptionLoggable.js.map

/***/ }),
/* 965 */
/***/ (function(module, exports) {

	"use strict";
	var SubscriptionLog = (function () {
	    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
	        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
	        this.subscribedFrame = subscribedFrame;
	        this.unsubscribedFrame = unsubscribedFrame;
	    }
	    return SubscriptionLog;
	}());
	exports.SubscriptionLog = SubscriptionLog;
	//# sourceMappingURL=SubscriptionLog.js.map

/***/ }),
/* 966 */
/***/ (function(module, exports) {

	"use strict";
	function applyMixins(derivedCtor, baseCtors) {
	    for (var i = 0, len = baseCtors.length; i < len; i++) {
	        var baseCtor = baseCtors[i];
	        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
	        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
	            var name_1 = propertyKeys[j];
	            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
	        }
	    }
	}
	exports.applyMixins = applyMixins;
	//# sourceMappingURL=applyMixins.js.map

/***/ }),
/* 967 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscription_1 = __webpack_require__(11);
	var SubscriptionLoggable_1 = __webpack_require__(964);
	var applyMixins_1 = __webpack_require__(966);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var HotObservable = (function (_super) {
	    __extends(HotObservable, _super);
	    function HotObservable(messages, scheduler) {
	        _super.call(this);
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	    HotObservable.prototype._subscribe = function (subscriber) {
	        var subject = this;
	        var index = subject.logSubscribedFrame();
	        subscriber.add(new Subscription_1.Subscription(function () {
	            subject.logUnsubscribedFrame(index);
	        }));
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    HotObservable.prototype.setup = function () {
	        var subject = this;
	        var messagesLength = subject.messages.length;
	        /* tslint:disable:no-var-keyword */
	        for (var i = 0; i < messagesLength; i++) {
	            (function () {
	                var message = subject.messages[i];
	                /* tslint:enable */
	                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);
	            })();
	        }
	    };
	    return HotObservable;
	}(Subject_1.Subject));
	exports.HotObservable = HotObservable;
	applyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);
	//# sourceMappingURL=HotObservable.js.map

/***/ }),
/* 968 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1 = __webpack_require__(46);
	var AsyncScheduler_1 = __webpack_require__(48);
	var VirtualTimeScheduler = (function (_super) {
	    __extends(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
	        var _this = this;
	        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
	        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
	        _super.call(this, SchedulerAction, function () { return _this.frame; });
	        this.maxFrames = maxFrames;
	        this.frame = 0;
	        this.index = -1;
	    }
	    /**
	     * Prompt the Scheduler to execute all of its queued actions, therefore
	     * clearing its queue.
	     * @return {void}
	     */
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error, action;
	        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        }
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.VirtualTimeScheduler = VirtualTimeScheduler;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var VirtualAction = (function (_super) {
	    __extends(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) { index = scheduler.index += 1; }
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.index = index;
	        this.index = scheduler.index = index;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (!this.id) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        // If an action is rescheduled, we save allocations by mutating its state,
	        // pushing it to the end of the scheduler queue, and recycling the action.
	        // But since the VirtualTimeScheduler is used for testing, VirtualActions
	        // must be immutable so they can be inspected later.
	        var action = new VirtualAction(this.scheduler, this.work);
	        this.add(action);
	        return action.schedule(state, delay);
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return true;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return undefined;
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction_1.AsyncAction));
	exports.VirtualAction = VirtualAction;
	//# sourceMappingURL=VirtualTimeScheduler.js.map

/***/ }),
/* 969 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var AnimationFrameAction_1 = __webpack_require__(970);
	var AnimationFrameScheduler_1 = __webpack_require__(972);
	exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
	//# sourceMappingURL=animationFrame.js.map

/***/ }),
/* 970 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1 = __webpack_require__(46);
	var AnimationFrame_1 = __webpack_require__(971);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AnimationFrameAction = (function (_super) {
	    __extends(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay is greater than 0, request as an async action.
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Push the action to the end of the scheduler queue.
	        scheduler.actions.push(this);
	        // If an animation frame has already been requested, don't request another
	        // one. If an animation frame hasn't been requested yet, request one. Return
	        // the current animation frame request id.
	        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        // If the scheduler queue is empty, cancel the requested animation frame and
	        // set the scheduled flag to undefined so the next AnimationFrameAction will
	        // request its own.
	        if (scheduler.actions.length === 0) {
	            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);
	            scheduler.scheduled = undefined;
	        }
	        // Return undefined so the action knows to request a new async id if it's rescheduled.
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction_1.AsyncAction));
	exports.AnimationFrameAction = AnimationFrameAction;
	//# sourceMappingURL=AnimationFrameAction.js.map

/***/ }),
/* 971 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(5);
	var RequestAnimationFrameDefinition = (function () {
	    function RequestAnimationFrameDefinition(root) {
	        if (root.requestAnimationFrame) {
	            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
	        }
	        else if (root.mozRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
	        }
	        else if (root.webkitRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
	        }
	        else if (root.msRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
	        }
	        else if (root.oRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
	        }
	        else {
	            this.cancelAnimationFrame = root.clearTimeout.bind(root);
	            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };
	        }
	    }
	    return RequestAnimationFrameDefinition;
	}());
	exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;
	exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);
	//# sourceMappingURL=AnimationFrame.js.map

/***/ }),
/* 972 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1 = __webpack_require__(48);
	var AnimationFrameScheduler = (function (_super) {
	    __extends(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        _super.apply(this, arguments);
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.AnimationFrameScheduler = AnimationFrameScheduler;
	//# sourceMappingURL=AnimationFrameScheduler.js.map

/***/ }),
/* 973 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ })
]);